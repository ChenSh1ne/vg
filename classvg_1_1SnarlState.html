<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>vg: vg::SnarlState Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1SnarlState.html">SnarlState</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classvg_1_1SnarlState-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::SnarlState Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;genome_state.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a14db6ed9f20936f71de90d0d12f92468"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlState.html#a14db6ed9f20936f71de90d0d12f92468">SnarlState</a> (const <a class="el" href="classvg_1_1NetGraph.html">NetGraph</a> *<a class="el" href="classvg_1_1SnarlState.html#a62e2fb69d55ee9cf1e2653dc4c9c8ead">graph</a>)</td></tr>
<tr class="memdesc:a14db6ed9f20936f71de90d0d12f92468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classvg_1_1SnarlState.html">SnarlState</a> that uses the given net graph.  <a href="#a14db6ed9f20936f71de90d0d12f92468">More...</a><br/></td></tr>
<tr class="separator:a14db6ed9f20936f71de90d0d12f92468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67cfa52583343bc2899a8ee7fbe05f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlState.html#ae67cfa52583343bc2899a8ee7fbe05f3">dump</a> () const </td></tr>
<tr class="memdesc:ae67cfa52583343bc2899a8ee7fbe05f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump internal state to cerr.  <a href="#ae67cfa52583343bc2899a8ee7fbe05f3">More...</a><br/></td></tr>
<tr class="separator:ae67cfa52583343bc2899a8ee7fbe05f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502b3fe50eb937e293f704bae5d06175"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlState.html#a502b3fe50eb937e293f704bae5d06175">size</a> () const </td></tr>
<tr class="memdesc:a502b3fe50eb937e293f704bae5d06175"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many haplotypes traverse this snarl?  <a href="#a502b3fe50eb937e293f704bae5d06175">More...</a><br/></td></tr>
<tr class="separator:a502b3fe50eb937e293f704bae5d06175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0035e60db21d7b025e667ec240921bb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlState.html#a0035e60db21d7b025e667ec240921bb8">trace</a> (size_t overall_lane, bool backward, const function&lt; void(const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;, size_t)&gt; &amp;iteratee) const </td></tr>
<tr class="separator:a0035e60db21d7b025e667ec240921bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428e616c3ef0bab94325edbd728819e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlState.html#a428e616c3ef0bab94325edbd728819e3">insert</a> (const vector&lt; pair&lt; <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a>, size_t &gt;&gt; &amp;haplotype)</td></tr>
<tr class="separator:a428e616c3ef0bab94325edbd728819e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f40f3779030f0e665d3cdc77bbaeafd"><td class="memItemLeft" align="right" valign="top">const vector&lt; pair&lt; <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a>, <br class="typebreak"/>
size_t &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlState.html#a6f40f3779030f0e665d3cdc77bbaeafd">append</a> (const vector&lt; <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &gt; &amp;haplotype, bool backward=false)</td></tr>
<tr class="separator:a6f40f3779030f0e665d3cdc77bbaeafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8489b6496d77d037d0ee2f0367119a3a"><td class="memItemLeft" align="right" valign="top">const vector&lt; pair&lt; <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a>, <br class="typebreak"/>
size_t &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlState.html#a8489b6496d77d037d0ee2f0367119a3a">insert</a> (size_t overall_lane, const vector&lt; <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &gt; &amp;haplotype, bool backward=false)</td></tr>
<tr class="separator:a8489b6496d77d037d0ee2f0367119a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e53694dd3b0169ad55103076997660"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a>, size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlState.html#a92e53694dd3b0169ad55103076997660">erase</a> (size_t overall_lane)</td></tr>
<tr class="separator:a92e53694dd3b0169ad55103076997660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3f0d0c720ea665b3db9542d07f7ec1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlState.html#a4e3f0d0c720ea665b3db9542d07f7ec1">swap</a> (size_t lane1, size_t lane2)</td></tr>
<tr class="separator:a4e3f0d0c720ea665b3db9542d07f7ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a98f04166481311709d9a8d3b05b0245e"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; pair&lt; <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a>, <br class="typebreak"/>
size_t &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlState.html#a98f04166481311709d9a8d3b05b0245e">haplotypes</a></td></tr>
<tr class="separator:a98f04166481311709d9a8d3b05b0245e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d595bd630d0d550176cade6897b491"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a>, <br class="typebreak"/>
vector&lt; decltype(<a class="el" href="classvg_1_1SnarlState.html#a98f04166481311709d9a8d3b05b0245e">haplotypes</a>)::value_type::iterator &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlState.html#a01d595bd630d0d550176cade6897b491">net_node_lanes</a></td></tr>
<tr class="separator:a01d595bd630d0d550176cade6897b491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e2fb69d55ee9cf1e2653dc4c9c8ead"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1NetGraph.html">NetGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlState.html#a62e2fb69d55ee9cf1e2653dc4c9c8ead">graph</a></td></tr>
<tr class="separator:a62e2fb69d55ee9cf1e2653dc4c9c8ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents the state of a snarl: zero or more haplotypes traversing its <a class="el" href="classvg_1_1NetGraph.html">NetGraph</a>.</p>
<p>Only admits full-length traversals of a snarl from start to end.</p>
<p>Every traversing haplotype is assigned a "lane" number at which it traverses the snarl. Lane is the same looking backward or forward through the snarl. Within each child snarl or child node, the traversal is also assigned a lane. The lane assignments at the start and end nodes are the same, and define the lane assignments for the overall snarl. Traversals can be inserted at any lane number in any internal node. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a14db6ed9f20936f71de90d0d12f92468"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::SnarlState::SnarlState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NetGraph.html">NetGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classvg_1_1SnarlState.html">SnarlState</a> that uses the given net graph. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6f40f3779030f0e665d3cdc77bbaeafd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt; pair&lt; <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a>, size_t &gt; &gt; &amp; vg::SnarlState::append </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>haplotype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>backward</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert the given traversal of this snarl from start to end or end to start (as determined by the backward flag), assigning each visit to a handle to the next available lane. Returns the haplotype annotated with lane assignments. If handles to the same node or child snarl appear more than once, their lane numbers will be strictly increasing. </p>

</div>
</div>
<a class="anchor" id="ae67cfa52583343bc2899a8ee7fbe05f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SnarlState::dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump internal state to cerr. </p>

</div>
</div>
<a class="anchor" id="a92e53694dd3b0169ad55103076997660"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a>, size_t &gt; &gt; vg::SnarlState::erase </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>overall_lane</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Erase the traversal of this haplotype in the given overall lane. Shifts everything in a higher lane 1 rank down. Returns the erased haplotype and its old lane assignments. </p>

</div>
</div>
<a class="anchor" id="a428e616c3ef0bab94325edbd728819e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SnarlState::insert </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; pair&lt; <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a>, size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>haplotype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert the given traversal of this snarl from start to end, with the given lane assignments for each oriented handle. If handles to the same node or child snarl appear more than once, their lane numbers must be strictly increasing. </p>

</div>
</div>
<a class="anchor" id="a8489b6496d77d037d0ee2f0367119a3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt; pair&lt; <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a>, size_t &gt; &gt; &amp; vg::SnarlState::insert </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>overall_lane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>haplotype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>backward</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert the given traversal of this snarl from start to end or end to start (as determined by the backward flag), assigning it to the given overall lane. Returns the haplotype annotated with lane assignments for all the internal handles. If the internal handles represent child snarls, this can be used to recurse down and insert traversals of them at the right lanes. If handles to the same node or child snarl appear more than once, their assigned lane numbers will be strictly increasing. Returns the haplotype annotated with lane assignments. </p>

</div>
</div>
<a class="anchor" id="a502b3fe50eb937e293f704bae5d06175"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::SnarlState::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How many haplotypes traverse this snarl? </p>

</div>
</div>
<a class="anchor" id="a4e3f0d0c720ea665b3db9542d07f7ec1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SnarlState::swap </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lane1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lane2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swap the traversals of this haplotype in the two given overall lanes. Internal lane assignments (as are used by child snarls) are not affected. </p>

</div>
</div>
<a class="anchor" id="a0035e60db21d7b025e667ec240921bb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SnarlState::trace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>overall_lane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>backward</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Trace the haplotype int eh given overall lane in the given orientation. Yields the oriented handles visited and the per-forward-handle lane assignments. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a62e2fb69d55ee9cf1e2653dc4c9c8ead"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvg_1_1NetGraph.html">NetGraph</a>* vg::SnarlState::graph</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>We need to keep track of the net graph, because we may need to traverse haplotypes forward or reverse and we need to flip things. </p>

</div>
</div>
<a class="anchor" id="a98f04166481311709d9a8d3b05b0245e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;vector&lt;pair&lt;<a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a>, size_t&gt; &gt; &gt; vg::SnarlState::haplotypes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a01d595bd630d0d550176cade6897b491"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt;<a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a>, vector&lt;decltype(<a class="el" href="classvg_1_1SnarlState.html#a98f04166481311709d9a8d3b05b0245e">haplotypes</a>)::value_type::iterator&gt; &gt; vg::SnarlState::net_node_lanes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="genome__state_8hpp.html">genome_state.hpp</a></li>
<li>src/<a class="el" href="genome__state_8cpp.html">genome_state.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
