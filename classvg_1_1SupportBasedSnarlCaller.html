<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::SupportBasedSnarlCaller Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html">SupportBasedSnarlCaller</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classvg_1_1SupportBasedSnarlCaller-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::SupportBasedSnarlCaller Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;snarl_caller.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vg::SupportBasedSnarlCaller:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvg_1_1SupportBasedSnarlCaller.png" usemap="#vg::SupportBasedSnarlCaller_map" alt=""/>
  <map id="vg::SupportBasedSnarlCaller_map" name="vg::SupportBasedSnarlCaller_map">
<area href="classvg_1_1SnarlCaller.html" alt="vg::SnarlCaller" shape="rect" coords="0,0,182,24"/>
<area href="classvg_1_1PackedSupportSnarlCaller.html" alt="vg::PackedSupportSnarlCaller" shape="rect" coords="0,112,182,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae6c35a2438dac057d7fd50152a004e49"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#ae6c35a2438dac057d7fd50152a004e49">SupportBasedSnarlCaller</a> (const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;<a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#ab0f5bd05d950be25e87a9f5fbc345a5c">graph</a>, <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;<a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a86c40f2d62950d1f484aa6dd84abf60d">snarl_manager</a>)</td></tr>
<tr class="separator:ae6c35a2438dac057d7fd50152a004e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc8a2019ce7e220dbee5b26c4b27211"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a1bc8a2019ce7e220dbee5b26c4b27211">~SupportBasedSnarlCaller</a> ()</td></tr>
<tr class="separator:a1bc8a2019ce7e220dbee5b26c4b27211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59bcdab863b9de0ecafe7fb72707fddc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a59bcdab863b9de0ecafe7fb72707fddc">set_het_bias</a> (double het_bias)</td></tr>
<tr class="memdesc:a59bcdab863b9de0ecafe7fb72707fddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set some of the parameters.  <a href="#a59bcdab863b9de0ecafe7fb72707fddc">More...</a><br /></td></tr>
<tr class="separator:a59bcdab863b9de0ecafe7fb72707fddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afbd8d1bc78b6716c587b93424db8cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a3afbd8d1bc78b6716c587b93424db8cb">set_min_supports</a> (double min_mad_for_call, double min_support_for_call, double min_site_support)</td></tr>
<tr class="separator:a3afbd8d1bc78b6716c587b93424db8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabdec54f27e4c971f33e660d697b1380"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structvg_1_1Support.html">Support</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#aabdec54f27e4c971f33e660d697b1380">get_edge_support</a> (const <a class="el" href="namespacevg.html#a3de8fe5f38b1730a36af4ad9c4258963">edge_t</a> &amp;edge) const =0</td></tr>
<tr class="memdesc:aabdec54f27e4c971f33e660d697b1380"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele. ">Support</a> of an edge.  <a href="#aabdec54f27e4c971f33e660d697b1380">More...</a><br /></td></tr>
<tr class="separator:aabdec54f27e4c971f33e660d697b1380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2682959038a70c7c95f617eafbdd9e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structvg_1_1Support.html">Support</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a7a2682959038a70c7c95f617eafbdd9e">get_edge_support</a> (<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> from, bool from_reverse, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> to, bool to_reverse) const =0</td></tr>
<tr class="separator:a7a2682959038a70c7c95f617eafbdd9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6be34cbf8b8f0a8ef16cc65170d9999"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#ac6be34cbf8b8f0a8ef16cc65170d9999">get_edge_length</a> (const <a class="el" href="namespacevg.html#a3de8fe5f38b1730a36af4ad9c4258963">edge_t</a> &amp;edge, const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, size_t &gt; &amp;ref_offsets) const</td></tr>
<tr class="memdesc:ac6be34cbf8b8f0a8ef16cc65170d9999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Effective length of an edge.  <a href="#ac6be34cbf8b8f0a8ef16cc65170d9999">More...</a><br /></td></tr>
<tr class="separator:ac6be34cbf8b8f0a8ef16cc65170d9999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf35e340cb6709d3f8ff3308f9f9bea"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structvg_1_1Support.html">Support</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#afaf35e340cb6709d3f8ff3308f9f9bea">get_min_node_support</a> (<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> node) const =0</td></tr>
<tr class="memdesc:afaf35e340cb6709d3f8ff3308f9f9bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum support of a node.  <a href="#afaf35e340cb6709d3f8ff3308f9f9bea">More...</a><br /></td></tr>
<tr class="separator:afaf35e340cb6709d3f8ff3308f9f9bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc085bf1fe3a372ff6fa4a39f38931e2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structvg_1_1Support.html">Support</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#acc085bf1fe3a372ff6fa4a39f38931e2">get_avg_node_support</a> (<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> node) const =0</td></tr>
<tr class="memdesc:acc085bf1fe3a372ff6fa4a39f38931e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average support of a node.  <a href="#acc085bf1fe3a372ff6fa4a39f38931e2">More...</a><br /></td></tr>
<tr class="separator:acc085bf1fe3a372ff6fa4a39f38931e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227a274c77e013d1ae00249e290b6bd9"><td class="memItemLeft" align="right" valign="top">virtual tuple&lt; <a class="el" href="structvg_1_1Support.html">Support</a>, <a class="el" href="structvg_1_1Support.html">Support</a>, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a227a274c77e013d1ae00249e290b6bd9">get_child_support</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;snarl) const</td></tr>
<tr class="memdesc:a227a274c77e013d1ae00249e290b6bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use node or edge support as proxy for child support (as was done in original calling code)  <a href="#a227a274c77e013d1ae00249e290b6bd9">More...</a><br /></td></tr>
<tr class="separator:a227a274c77e013d1ae00249e290b6bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9597fd0336a6bb227133939eeda7a8"><td class="memItemLeft" align="right" valign="top">virtual vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#adc9597fd0336a6bb227133939eeda7a8">genotype</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;snarl, const vector&lt; <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt; &amp;traversals, int ref_trav_idx, int ploidy)</td></tr>
<tr class="memdesc:adc9597fd0336a6bb227133939eeda7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the genotype of a site.  <a href="#adc9597fd0336a6bb227133939eeda7a8">More...</a><br /></td></tr>
<tr class="separator:adc9597fd0336a6bb227133939eeda7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1e45e1eff5208d489115539d621384"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a0a1e45e1eff5208d489115539d621384">update_vcf_info</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;snarl, const vector&lt; <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt; &amp;traversals, const vector&lt; int &gt; &amp;<a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#adc9597fd0336a6bb227133939eeda7a8">genotype</a>, const string &amp;sample_name, vcflib::Variant &amp;variant)</td></tr>
<tr class="memdesc:a0a1e45e1eff5208d489115539d621384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update INFO and FORMAT fields of the called variant.  <a href="#a0a1e45e1eff5208d489115539d621384">More...</a><br /></td></tr>
<tr class="separator:a0a1e45e1eff5208d489115539d621384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc68060df93ea4a91d7cce0ac5ec19a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a4fc68060df93ea4a91d7cce0ac5ec19a">update_vcf_header</a> (string &amp;header) const</td></tr>
<tr class="memdesc:a4fc68060df93ea4a91d7cce0ac5ec19a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define any header fields needed by the above.  <a href="#a4fc68060df93ea4a91d7cce0ac5ec19a">More...</a><br /></td></tr>
<tr class="separator:a4fc68060df93ea4a91d7cce0ac5ec19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c1b0c9ff28087add5e4c8b169bad9e"><td class="memItemLeft" align="right" valign="top">virtual function&lt; bool(const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a61c1b0c9ff28087add5e4c8b169bad9e">get_skip_allele_fn</a> () const</td></tr>
<tr class="memdesc:a61c1b0c9ff28087add5e4c8b169bad9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use min_alt_path_support threshold as cutoff.  <a href="#a61c1b0c9ff28087add5e4c8b169bad9e">More...</a><br /></td></tr>
<tr class="separator:a61c1b0c9ff28087add5e4c8b169bad9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435d0401a38ceaaf916ecd191b602d8f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structvg_1_1Support.html">Support</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a435d0401a38ceaaf916ecd191b602d8f">get_traversal_support</a> (const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;traversal) const</td></tr>
<tr class="separator:a435d0401a38ceaaf916ecd191b602d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26fdca89320adfc6f1866a5a89e2e0f"><td class="memItemLeft" align="right" valign="top">virtual vector&lt; <a class="el" href="structvg_1_1Support.html">Support</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#ac26fdca89320adfc6f1866a5a89e2e0f">get_traversal_set_support</a> (const vector&lt; <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt; &amp;traversals, const vector&lt; int &gt; &amp;shared_travs, bool exclusive_only, bool exclusive_count, int ref_trav_idx=-1) const</td></tr>
<tr class="separator:ac26fdca89320adfc6f1866a5a89e2e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61f74e84cfc2f249ab88b85d54d3e76"><td class="memItemLeft" align="right" valign="top">virtual vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#ad61f74e84cfc2f249ab88b85d54d3e76">get_traversal_sizes</a> (const vector&lt; <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt; &amp;traversals) const</td></tr>
<tr class="memdesc:ad61f74e84cfc2f249ab88b85d54d3e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total length of all nodes in the traversal.  <a href="#ad61f74e84cfc2f249ab88b85d54d3e76">More...</a><br /></td></tr>
<tr class="separator:ad61f74e84cfc2f249ab88b85d54d3e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f3117542a1994dcc54044fafebfd9c"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a12f3117542a1994dcc54044fafebfd9c">get_average_traversal_support_switch_threshold</a> () const</td></tr>
<tr class="memdesc:a12f3117542a1994dcc54044fafebfd9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the average traversal support thresholdek.  <a href="#a12f3117542a1994dcc54044fafebfd9c">More...</a><br /></td></tr>
<tr class="separator:a12f3117542a1994dcc54044fafebfd9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e36771ace6cf84d9f4f732cdbc692f"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#ac7e36771ace6cf84d9f4f732cdbc692f">get_min_total_support_for_call</a> () const</td></tr>
<tr class="memdesc:ac7e36771ace6cf84d9f4f732cdbc692f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum total support for call.  <a href="#ac7e36771ace6cf84d9f4f732cdbc692f">More...</a><br /></td></tr>
<tr class="separator:ac7e36771ace6cf84d9f4f732cdbc692f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvg_1_1SnarlCaller"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classvg_1_1SnarlCaller')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvg_1_1SnarlCaller.html">vg::SnarlCaller</a></td></tr>
<tr class="memitem:abda61a55c21f1473db0443293144c96d inherit pub_methods_classvg_1_1SnarlCaller"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlCaller.html#abda61a55c21f1473db0443293144c96d">~SnarlCaller</a> ()</td></tr>
<tr class="separator:abda61a55c21f1473db0443293144c96d inherit pub_methods_classvg_1_1SnarlCaller"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5bfeb4b6d8e5995aa3955b4aeb877252"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a5bfeb4b6d8e5995aa3955b4aeb877252">get_bias</a> (const vector&lt; int &gt; &amp;traversal_sizes, int best_trav, int second_best_trav, int ref_trav_idx) const</td></tr>
<tr class="separator:a5bfeb4b6d8e5995aa3955b4aeb877252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb1cab3eba7c1535fabba693d430ce2"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a7fb1cab3eba7c1535fabba693d430ce2">get_ref_offsets</a> (const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;ref_trav) const</td></tr>
<tr class="separator:a7fb1cab3eba7c1535fabba693d430ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a1b5a50373729771229ada685b12627df"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a1b5a50373729771229ada685b12627df">get_best_support</a> (const vector&lt; <a class="el" href="structvg_1_1Support.html">Support</a> &gt; &amp;supports, const vector&lt; int &gt; &amp;skips)</td></tr>
<tr class="memdesc:a1b5a50373729771229ada685b12627df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the best support out of a list of supports, ignoring skips.  <a href="#a1b5a50373729771229ada685b12627df">More...</a><br /></td></tr>
<tr class="separator:a1b5a50373729771229ada685b12627df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84da98787b002a2ed9c8c1da6661cebd"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a84da98787b002a2ed9c8c1da6661cebd">support_val</a> (const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;support)</td></tr>
<tr class="memdesc:a84da98787b002a2ed9c8c1da6661cebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relic from old code.  <a href="#a84da98787b002a2ed9c8c1da6661cebd">More...</a><br /></td></tr>
<tr class="separator:a84da98787b002a2ed9c8c1da6661cebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a559c8afa8e4f1f73768d7d90ff6a6db0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a559c8afa8e4f1f73768d7d90ff6a6db0">min_total_support_for_call</a> = 1</td></tr>
<tr class="memdesc:a559c8afa8e4f1f73768d7d90ff6a6db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuning.  <a href="#a559c8afa8e4f1f73768d7d90ff6a6db0">More...</a><br /></td></tr>
<tr class="separator:a559c8afa8e4f1f73768d7d90ff6a6db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af353ceb49f23fc4489b90899d97148fa"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#af353ceb49f23fc4489b90899d97148fa">max_het_bias</a> = 6</td></tr>
<tr class="separator:af353ceb49f23fc4489b90899d97148fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5338ae341b244e3bd0d90edf122e829"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#ad5338ae341b244e3bd0d90edf122e829">max_ref_het_bias</a> = 6</td></tr>
<tr class="memdesc:ad5338ae341b244e3bd0d90edf122e829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like above, but applied to ref / alt ratio (instead of alt / ref)  <a href="#ad5338ae341b244e3bd0d90edf122e829">More...</a><br /></td></tr>
<tr class="separator:ad5338ae341b244e3bd0d90edf122e829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6ef295fb70e944846576db3ff00ae9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#acb6ef295fb70e944846576db3ff00ae9">max_indel_het_bias</a> = 6</td></tr>
<tr class="memdesc:acb6ef295fb70e944846576db3ff00ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the max het bias, but applies to novel indels.  <a href="#acb6ef295fb70e944846576db3ff00ae9">More...</a><br /></td></tr>
<tr class="separator:acb6ef295fb70e944846576db3ff00ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a74962f3960ec76649d8137fe79821f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a4a74962f3960ec76649d8137fe79821f">max_ma_bias</a> = 0</td></tr>
<tr class="separator:a4a74962f3960ec76649d8137fe79821f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec268641676f41d2c24128cb9e17ac03"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#aec268641676f41d2c24128cb9e17ac03">min_mad_for_filter</a> = 1</td></tr>
<tr class="separator:aec268641676f41d2c24128cb9e17ac03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde07f3e5ca89a2a565e8859ee641159"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#adde07f3e5ca89a2a565e8859ee641159">min_site_depth</a> = 3</td></tr>
<tr class="separator:adde07f3e5ca89a2a565e8859ee641159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0157140a7fe7e7264315d1d881d39fb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#ac0157140a7fe7e7264315d1d881d39fb">min_ad_log_likelihood_for_filter</a> = -9</td></tr>
<tr class="memdesc:ac0157140a7fe7e7264315d1d881d39fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">what's the min log likelihood for allele depth assignments to PASS?  <a href="#ac0157140a7fe7e7264315d1d881d39fb">More...</a><br /></td></tr>
<tr class="separator:ac0157140a7fe7e7264315d1d881d39fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c75daf50553712dbba8f2327fafa1c3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a8c75daf50553712dbba8f2327fafa1c3">average_traversal_support_switch_threshold</a> = 50</td></tr>
<tr class="separator:a8c75daf50553712dbba8f2327fafa1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3ab178f80140739466574d4524b1e3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a7f3ab178f80140739466574d4524b1e3">average_node_support_switch_threshold</a> = 50</td></tr>
<tr class="separator:a7f3ab178f80140739466574d4524b1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f76956318b838695d8b120d553ce24"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a17f76956318b838695d8b120d553ce24">min_alt_path_support</a> = 0.2</td></tr>
<tr class="separator:a17f76956318b838695d8b120d553ce24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f5bd05d950be25e87a9f5fbc345a5c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#ab0f5bd05d950be25e87a9f5fbc345a5c">graph</a></td></tr>
<tr class="separator:ab0f5bd05d950be25e87a9f5fbc345a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c40f2d62950d1f484aa6dd84abf60d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a86c40f2d62950d1f484aa6dd84abf60d">snarl_manager</a></td></tr>
<tr class="separator:a86c40f2d62950d1f484aa6dd84abf60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Find the genotype of some traversals in a site using read support </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae6c35a2438dac057d7fd50152a004e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6c35a2438dac057d7fd50152a004e49">&#9670;&nbsp;</a></span>SupportBasedSnarlCaller()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::SupportBasedSnarlCaller::SupportBasedSnarlCaller </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl_manager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1bc8a2019ce7e220dbee5b26c4b27211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc8a2019ce7e220dbee5b26c4b27211">&#9670;&nbsp;</a></span>~SupportBasedSnarlCaller()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::SupportBasedSnarlCaller::~SupportBasedSnarlCaller </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adc9597fd0336a6bb227133939eeda7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc9597fd0336a6bb227133939eeda7a8">&#9670;&nbsp;</a></span>genotype()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; vg::SupportBasedSnarlCaller::genotype </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>traversals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ref_trav_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ploidy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the genotype of a site. </p>

<p>Implements <a class="el" href="classvg_1_1SnarlCaller.html#a1659a26128036d46bacc19407aebdd17">vg::SnarlCaller</a>.</p>

</div>
</div>
<a id="a12f3117542a1994dcc54044fafebfd9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f3117542a1994dcc54044fafebfd9c">&#9670;&nbsp;</a></span>get_average_traversal_support_switch_threshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::SupportBasedSnarlCaller::get_average_traversal_support_switch_threshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the average traversal support thresholdek. </p>

</div>
</div>
<a id="acc085bf1fe3a372ff6fa4a39f38931e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc085bf1fe3a372ff6fa4a39f38931e2">&#9670;&nbsp;</a></span>get_avg_node_support()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structvg_1_1Support.html">Support</a> vg::SupportBasedSnarlCaller::get_avg_node_support </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Average support of a node. </p>

<p>Implemented in <a class="el" href="classvg_1_1PackedSupportSnarlCaller.html#a5f9d60051f99acde7f4c1ac862f6f409">vg::PackedSupportSnarlCaller</a>.</p>

</div>
</div>
<a id="a1b5a50373729771229ada685b12627df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5a50373729771229ada685b12627df">&#9670;&nbsp;</a></span>get_best_support()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int vg::SupportBasedSnarlCaller::get_best_support </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1Support.html">Support</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>supports</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>skips</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the best support out of a list of supports, ignoring skips. </p>

</div>
</div>
<a id="a5bfeb4b6d8e5995aa3955b4aeb877252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bfeb4b6d8e5995aa3955b4aeb877252">&#9670;&nbsp;</a></span>get_bias()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::SupportBasedSnarlCaller::get_bias </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>traversal_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>best_trav</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>second_best_trav</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ref_trav_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the bias used to for comparing two traversals (It differrs heuristically depending whether they are alt/ref/het/hom/snp/indel see tuning parameters below) </p>

</div>
</div>
<a id="a227a274c77e013d1ae00249e290b6bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227a274c77e013d1ae00249e290b6bd9">&#9670;&nbsp;</a></span>get_child_support()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tuple&lt; <a class="el" href="structvg_1_1Support.html">Support</a>, <a class="el" href="structvg_1_1Support.html">Support</a>, int &gt; vg::SupportBasedSnarlCaller::get_child_support </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use node or edge support as proxy for child support (as was done in original calling code) </p>

</div>
</div>
<a id="ac6be34cbf8b8f0a8ef16cc65170d9999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6be34cbf8b8f0a8ef16cc65170d9999">&#9670;&nbsp;</a></span>get_edge_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::SupportBasedSnarlCaller::get_edge_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a3de8fe5f38b1730a36af4ad9c4258963">edge_t</a> &amp;&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Effective length of an edge. </p>

</div>
</div>
<a id="aabdec54f27e4c971f33e660d697b1380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabdec54f27e4c971f33e660d697b1380">&#9670;&nbsp;</a></span>get_edge_support() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structvg_1_1Support.html">Support</a> vg::SupportBasedSnarlCaller::get_edge_support </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a3de8fe5f38b1730a36af4ad9c4258963">edge_t</a> &amp;&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele. ">Support</a> of an edge. </p>

<p>Implemented in <a class="el" href="classvg_1_1PackedSupportSnarlCaller.html#a13d162fdcf379eff3ee8b025916b9bdb">vg::PackedSupportSnarlCaller</a>.</p>

</div>
</div>
<a id="a7a2682959038a70c7c95f617eafbdd9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2682959038a70c7c95f617eafbdd9e">&#9670;&nbsp;</a></span>get_edge_support() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structvg_1_1Support.html">Support</a> vg::SupportBasedSnarlCaller::get_edge_support </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_reverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classvg_1_1PackedSupportSnarlCaller.html#a9451cc180e0df568e1d65da5214d107b">vg::PackedSupportSnarlCaller</a>.</p>

</div>
</div>
<a id="afaf35e340cb6709d3f8ff3308f9f9bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf35e340cb6709d3f8ff3308f9f9bea">&#9670;&nbsp;</a></span>get_min_node_support()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structvg_1_1Support.html">Support</a> vg::SupportBasedSnarlCaller::get_min_node_support </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum support of a node. </p>

<p>Implemented in <a class="el" href="classvg_1_1PackedSupportSnarlCaller.html#a18f4b8af857c29fed458a8e4c2b27d61">vg::PackedSupportSnarlCaller</a>.</p>

</div>
</div>
<a id="ac7e36771ace6cf84d9f4f732cdbc692f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e36771ace6cf84d9f4f732cdbc692f">&#9670;&nbsp;</a></span>get_min_total_support_for_call()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int vg::SupportBasedSnarlCaller::get_min_total_support_for_call </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the minimum total support for call. </p>

</div>
</div>
<a id="a7fb1cab3eba7c1535fabba693d430ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb1cab3eba7c1535fabba693d430ce2">&#9670;&nbsp;</a></span>get_ref_offsets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, size_t &gt; vg::SupportBasedSnarlCaller::get_ref_offsets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>ref_trav</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get a map of the beginning of a node (in forward orientation) on a traversal used for up-weighting large deletion edges in complex snarls with average support </p>

</div>
</div>
<a id="a61c1b0c9ff28087add5e4c8b169bad9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c1b0c9ff28087add5e4c8b169bad9e">&#9670;&nbsp;</a></span>get_skip_allele_fn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">function&lt; bool(const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;)&gt; vg::SupportBasedSnarlCaller::get_skip_allele_fn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use min_alt_path_support threshold as cutoff. </p>

<p>Reimplemented from <a class="el" href="classvg_1_1SnarlCaller.html#a8a469bc2c03cd4f623286669e6410724">vg::SnarlCaller</a>.</p>

</div>
</div>
<a id="ac26fdca89320adfc6f1866a5a89e2e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26fdca89320adfc6f1866a5a89e2e0f">&#9670;&nbsp;</a></span>get_traversal_set_support()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Support.html">Support</a> &gt; vg::SupportBasedSnarlCaller::get_traversal_set_support </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>traversals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>shared_travs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exclusive_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exclusive_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ref_trav_idx</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the support of a set of traversals. Any support overlapping traversals in shared_travs will have their support split. If exclusive_only is true, then any split support gets rounded down to 0 (and ignored when computing mins or averages) . exclusive_count is like exclusive only except shared traversals will be counted (as 0) when doing average and min support if the ref_trav_idx is given, it will be used for computing (deletion) edge lengths </p>

</div>
</div>
<a id="ad61f74e84cfc2f249ab88b85d54d3e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad61f74e84cfc2f249ab88b85d54d3e76">&#9670;&nbsp;</a></span>get_traversal_sizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; vg::SupportBasedSnarlCaller::get_traversal_sizes </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>traversals</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total length of all nodes in the traversal. </p>

</div>
</div>
<a id="a435d0401a38ceaaf916ecd191b602d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a435d0401a38ceaaf916ecd191b602d8f">&#9670;&nbsp;</a></span>get_traversal_support()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Support.html">Support</a> vg::SupportBasedSnarlCaller::get_traversal_support </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>traversal</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the support of a traversal Child snarls are handled as in the old call code: their maximum support is used </p>

</div>
</div>
<a id="a59bcdab863b9de0ecafe7fb72707fddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59bcdab863b9de0ecafe7fb72707fddc">&#9670;&nbsp;</a></span>set_het_bias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SupportBasedSnarlCaller::set_het_bias </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>het_bias</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set some of the parameters. </p>

</div>
</div>
<a id="a3afbd8d1bc78b6716c587b93424db8cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3afbd8d1bc78b6716c587b93424db8cb">&#9670;&nbsp;</a></span>set_min_supports()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SupportBasedSnarlCaller::set_min_supports </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_mad_for_call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_support_for_call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_site_support</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84da98787b002a2ed9c8c1da6661cebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84da98787b002a2ed9c8c1da6661cebd">&#9670;&nbsp;</a></span>support_val()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double vg::SupportBasedSnarlCaller::support_val </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>support</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relic from old code. </p>

</div>
</div>
<a id="a4fc68060df93ea4a91d7cce0ac5ec19a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc68060df93ea4a91d7cce0ac5ec19a">&#9670;&nbsp;</a></span>update_vcf_header()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SupportBasedSnarlCaller::update_vcf_header </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>header</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define any header fields needed by the above. </p>

<p>Implements <a class="el" href="classvg_1_1SnarlCaller.html#a7fb3205d6e94505aadf0c9944fac7eb4">vg::SnarlCaller</a>.</p>

</div>
</div>
<a id="a0a1e45e1eff5208d489115539d621384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1e45e1eff5208d489115539d621384">&#9670;&nbsp;</a></span>update_vcf_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SupportBasedSnarlCaller::update_vcf_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>traversals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>genotype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>sample_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcflib::Variant &amp;&#160;</td>
          <td class="paramname"><em>variant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update INFO and FORMAT fields of the called variant. </p>

<p>Implements <a class="el" href="classvg_1_1SnarlCaller.html#ad0315e74aa5ea9df9820aa1000bd0291">vg::SnarlCaller</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7f3ab178f80140739466574d4524b1e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3ab178f80140739466574d4524b1e3">&#9670;&nbsp;</a></span>average_node_support_switch_threshold</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::SupportBasedSnarlCaller::average_node_support_switch_threshold = 50</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use average instead of minimum support when determining a node's support its position supports. </p>

</div>
</div>
<a id="a8c75daf50553712dbba8f2327fafa1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c75daf50553712dbba8f2327fafa1c3">&#9670;&nbsp;</a></span>average_traversal_support_switch_threshold</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::SupportBasedSnarlCaller::average_traversal_support_switch_threshold = 50</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use average instead of minimum support when determining a traversal's support its node and edge supports. </p>

</div>
</div>
<a id="ab0f5bd05d950be25e87a9f5fbc345a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f5bd05d950be25e87a9f5fbc345a5c">&#9670;&nbsp;</a></span>graph</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a>&amp; vg::SupportBasedSnarlCaller::graph</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af353ceb49f23fc4489b90899d97148fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af353ceb49f23fc4489b90899d97148fa">&#9670;&nbsp;</a></span>max_het_bias</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::SupportBasedSnarlCaller::max_het_bias = 6</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>What fraction of the reads supporting an alt are we willing to discount? At 2, if twice the reads support one allele as the other, we'll call homozygous instead of heterozygous. At infinity, every call will be heterozygous if even one read supports each allele. </p>

</div>
</div>
<a id="acb6ef295fb70e944846576db3ff00ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6ef295fb70e944846576db3ff00ae9">&#9670;&nbsp;</a></span>max_indel_het_bias</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::SupportBasedSnarlCaller::max_indel_het_bias = 6</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like the max het bias, but applies to novel indels. </p>

</div>
</div>
<a id="a4a74962f3960ec76649d8137fe79821f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a74962f3960ec76649d8137fe79821f">&#9670;&nbsp;</a></span>max_ma_bias</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::SupportBasedSnarlCaller::max_ma_bias = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used for calling 1/2 calls. If both alts (times this bias) are greater than the reference, the call is made. set to 0 to deactivate. </p>

</div>
</div>
<a id="ad5338ae341b244e3bd0d90edf122e829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5338ae341b244e3bd0d90edf122e829">&#9670;&nbsp;</a></span>max_ref_het_bias</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::SupportBasedSnarlCaller::max_ref_het_bias = 6</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like above, but applied to ref / alt ratio (instead of alt / ref) </p>

</div>
</div>
<a id="ac0157140a7fe7e7264315d1d881d39fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0157140a7fe7e7264315d1d881d39fb">&#9670;&nbsp;</a></span>min_ad_log_likelihood_for_filter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::SupportBasedSnarlCaller::min_ad_log_likelihood_for_filter = -9</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>what's the min log likelihood for allele depth assignments to PASS? </p>

</div>
</div>
<a id="a17f76956318b838695d8b120d553ce24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17f76956318b838695d8b120d553ce24">&#9670;&nbsp;</a></span>min_alt_path_support</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::SupportBasedSnarlCaller::min_alt_path_support = 0.2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>used only for pruning alleles in the <a class="el" href="classvg_1_1VCFTraversalFinder.html">VCFTraversalFinder</a>: minimum support of an allele's alt-path for it to be considered in the brute-force enumeration </p>

</div>
</div>
<a id="aec268641676f41d2c24128cb9e17ac03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec268641676f41d2c24128cb9e17ac03">&#9670;&nbsp;</a></span>min_mad_for_filter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::SupportBasedSnarlCaller::min_mad_for_filter = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>what's the minimum ref or alt allele depth to give a PASS in the filter column? Also used as a min actual support for a second-best allele call </p>

</div>
</div>
<a id="adde07f3e5ca89a2a565e8859ee641159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde07f3e5ca89a2a565e8859ee641159">&#9670;&nbsp;</a></span>min_site_depth</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::SupportBasedSnarlCaller::min_site_depth = 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>what's the minimum total support (over all alleles) of the site to make a call </p>

</div>
</div>
<a id="a559c8afa8e4f1f73768d7d90ff6a6db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559c8afa8e4f1f73768d7d90ff6a6db0">&#9670;&nbsp;</a></span>min_total_support_for_call</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int vg::SupportBasedSnarlCaller::min_total_support_for_call = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tuning. </p>
<p>What's the minimum integer number of reads that must support a call? We don't necessarily want to call a SNP as het because we have a single </p>

</div>
</div>
<a id="a86c40f2d62950d1f484aa6dd84abf60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c40f2d62950d1f484aa6dd84abf60d">&#9670;&nbsp;</a></span>snarl_manager</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a>&amp; vg::SupportBasedSnarlCaller::snarl_manager</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="snarl__caller_8hpp.html">snarl_caller.hpp</a></li>
<li>src/<a class="el" href="snarl__caller_8cpp.html">snarl_caller.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
