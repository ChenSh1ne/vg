<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>vg: vg::SupportBasedSnarlCaller Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html">SupportBasedSnarlCaller</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classvg_1_1SupportBasedSnarlCaller-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::SupportBasedSnarlCaller Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;snarl_caller.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vg::SupportBasedSnarlCaller:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvg_1_1SupportBasedSnarlCaller.png" usemap="#vg::SupportBasedSnarlCaller_map" alt=""/>
  <map id="vg::SupportBasedSnarlCaller_map" name="vg::SupportBasedSnarlCaller_map">
<area href="classvg_1_1SnarlCaller.html" alt="vg::SnarlCaller" shape="rect" coords="0,0,182,24"/>
<area href="classvg_1_1PackedSupportSnarlCaller.html" alt="vg::PackedSupportSnarlCaller" shape="rect" coords="0,112,182,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae6c35a2438dac057d7fd50152a004e49"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#ae6c35a2438dac057d7fd50152a004e49">SupportBasedSnarlCaller</a> (const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;<a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#ab0f5bd05d950be25e87a9f5fbc345a5c">graph</a>, <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;<a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a86c40f2d62950d1f484aa6dd84abf60d">snarl_manager</a>)</td></tr>
<tr class="separator:ae6c35a2438dac057d7fd50152a004e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc8a2019ce7e220dbee5b26c4b27211"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a1bc8a2019ce7e220dbee5b26c4b27211">~SupportBasedSnarlCaller</a> ()</td></tr>
<tr class="separator:a1bc8a2019ce7e220dbee5b26c4b27211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59bcdab863b9de0ecafe7fb72707fddc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a59bcdab863b9de0ecafe7fb72707fddc">set_het_bias</a> (double het_bias)</td></tr>
<tr class="memdesc:a59bcdab863b9de0ecafe7fb72707fddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set some of the parameters.  <a href="#a59bcdab863b9de0ecafe7fb72707fddc">More...</a><br/></td></tr>
<tr class="separator:a59bcdab863b9de0ecafe7fb72707fddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afbd8d1bc78b6716c587b93424db8cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a3afbd8d1bc78b6716c587b93424db8cb">set_min_supports</a> (double min_mad_for_call, double min_support_for_call, double min_site_support)</td></tr>
<tr class="separator:a3afbd8d1bc78b6716c587b93424db8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabdec54f27e4c971f33e660d697b1380"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structvg_1_1Support.html">Support</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#aabdec54f27e4c971f33e660d697b1380">get_edge_support</a> (const <a class="el" href="namespacevg.html#a3de8fe5f38b1730a36af4ad9c4258963">edge_t</a> &amp;edge) const =0</td></tr>
<tr class="memdesc:aabdec54f27e4c971f33e660d697b1380"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele. ">Support</a> of an edge.  <a href="#aabdec54f27e4c971f33e660d697b1380">More...</a><br/></td></tr>
<tr class="separator:aabdec54f27e4c971f33e660d697b1380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2682959038a70c7c95f617eafbdd9e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structvg_1_1Support.html">Support</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a7a2682959038a70c7c95f617eafbdd9e">get_edge_support</a> (<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> from, bool from_reverse, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> to, bool to_reverse) const =0</td></tr>
<tr class="separator:a7a2682959038a70c7c95f617eafbdd9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd739bec55918edd4a3d4914be06eab"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#adfd739bec55918edd4a3d4914be06eab">get_edge_length</a> (const <a class="el" href="namespacevg.html#a3de8fe5f38b1730a36af4ad9c4258963">edge_t</a> &amp;edge, const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, size_t &gt; &amp;ref_offsets) const </td></tr>
<tr class="memdesc:adfd739bec55918edd4a3d4914be06eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Effective length of an edge.  <a href="#adfd739bec55918edd4a3d4914be06eab">More...</a><br/></td></tr>
<tr class="separator:adfd739bec55918edd4a3d4914be06eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf35e340cb6709d3f8ff3308f9f9bea"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structvg_1_1Support.html">Support</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#afaf35e340cb6709d3f8ff3308f9f9bea">get_min_node_support</a> (<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> node) const =0</td></tr>
<tr class="memdesc:afaf35e340cb6709d3f8ff3308f9f9bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum support of a node.  <a href="#afaf35e340cb6709d3f8ff3308f9f9bea">More...</a><br/></td></tr>
<tr class="separator:afaf35e340cb6709d3f8ff3308f9f9bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc085bf1fe3a372ff6fa4a39f38931e2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structvg_1_1Support.html">Support</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#acc085bf1fe3a372ff6fa4a39f38931e2">get_avg_node_support</a> (<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> node) const =0</td></tr>
<tr class="memdesc:acc085bf1fe3a372ff6fa4a39f38931e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average support of a node.  <a href="#acc085bf1fe3a372ff6fa4a39f38931e2">More...</a><br/></td></tr>
<tr class="separator:acc085bf1fe3a372ff6fa4a39f38931e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59fa9a6995b1d03afcf7538bb87385c1"><td class="memItemLeft" align="right" valign="top">virtual tuple&lt; <a class="el" href="structvg_1_1Support.html">Support</a>, <br class="typebreak"/>
<a class="el" href="structvg_1_1Support.html">Support</a>, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a59fa9a6995b1d03afcf7538bb87385c1">get_child_support</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;snarl) const </td></tr>
<tr class="memdesc:a59fa9a6995b1d03afcf7538bb87385c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use node or edge support as proxy for child support (as was done in original calling code)  <a href="#a59fa9a6995b1d03afcf7538bb87385c1">More...</a><br/></td></tr>
<tr class="separator:a59fa9a6995b1d03afcf7538bb87385c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9597fd0336a6bb227133939eeda7a8"><td class="memItemLeft" align="right" valign="top">virtual vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#adc9597fd0336a6bb227133939eeda7a8">genotype</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;snarl, const vector&lt; <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt; &amp;traversals, int ref_trav_idx, int ploidy)</td></tr>
<tr class="memdesc:adc9597fd0336a6bb227133939eeda7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the genotype of a site.  <a href="#adc9597fd0336a6bb227133939eeda7a8">More...</a><br/></td></tr>
<tr class="separator:adc9597fd0336a6bb227133939eeda7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1e45e1eff5208d489115539d621384"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a0a1e45e1eff5208d489115539d621384">update_vcf_info</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;snarl, const vector&lt; <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt; &amp;traversals, const vector&lt; int &gt; &amp;<a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#adc9597fd0336a6bb227133939eeda7a8">genotype</a>, const string &amp;sample_name, vcflib::Variant &amp;variant)</td></tr>
<tr class="memdesc:a0a1e45e1eff5208d489115539d621384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update INFO and FORMAT fields of the called variant.  <a href="#a0a1e45e1eff5208d489115539d621384">More...</a><br/></td></tr>
<tr class="separator:a0a1e45e1eff5208d489115539d621384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c44dae396995577c679b0b3ab22449"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a42c44dae396995577c679b0b3ab22449">update_vcf_header</a> (string &amp;header) const </td></tr>
<tr class="memdesc:a42c44dae396995577c679b0b3ab22449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define any header fields needed by the above.  <a href="#a42c44dae396995577c679b0b3ab22449">More...</a><br/></td></tr>
<tr class="separator:a42c44dae396995577c679b0b3ab22449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637f503cf0ff7fc1cc89260d14d70f29"><td class="memItemLeft" align="right" valign="top">virtual function&lt; bool(const <br class="typebreak"/>
<a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a637f503cf0ff7fc1cc89260d14d70f29">get_skip_allele_fn</a> () const </td></tr>
<tr class="memdesc:a637f503cf0ff7fc1cc89260d14d70f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use min_alt_path_support threshold as cutoff.  <a href="#a637f503cf0ff7fc1cc89260d14d70f29">More...</a><br/></td></tr>
<tr class="separator:a637f503cf0ff7fc1cc89260d14d70f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c0add16300bcac819e916017d4dba1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structvg_1_1Support.html">Support</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#ac6c0add16300bcac819e916017d4dba1">get_traversal_support</a> (const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;traversal) const </td></tr>
<tr class="separator:ac6c0add16300bcac819e916017d4dba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f303d404dc00f4a8f991f7e903dce29"><td class="memItemLeft" align="right" valign="top">virtual vector&lt; <a class="el" href="structvg_1_1Support.html">Support</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a4f303d404dc00f4a8f991f7e903dce29">get_traversal_set_support</a> (const vector&lt; <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt; &amp;traversals, const vector&lt; int &gt; &amp;shared_travs, bool exclusive_only, bool exclusive_count, int ref_trav_idx=-1) const </td></tr>
<tr class="separator:a4f303d404dc00f4a8f991f7e903dce29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1514146b342469dc343756d6ade910d"><td class="memItemLeft" align="right" valign="top">virtual vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#ae1514146b342469dc343756d6ade910d">get_traversal_sizes</a> (const vector&lt; <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt; &amp;traversals) const </td></tr>
<tr class="memdesc:ae1514146b342469dc343756d6ade910d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total length of all nodes in the traversal.  <a href="#ae1514146b342469dc343756d6ade910d">More...</a><br/></td></tr>
<tr class="separator:ae1514146b342469dc343756d6ade910d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvg_1_1SnarlCaller"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classvg_1_1SnarlCaller')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvg_1_1SnarlCaller.html">vg::SnarlCaller</a></td></tr>
<tr class="memitem:abda61a55c21f1473db0443293144c96d inherit pub_methods_classvg_1_1SnarlCaller"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlCaller.html#abda61a55c21f1473db0443293144c96d">~SnarlCaller</a> ()</td></tr>
<tr class="separator:abda61a55c21f1473db0443293144c96d inherit pub_methods_classvg_1_1SnarlCaller"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5a29f27c3c19449c146f0ec69f4b5fa9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a5a29f27c3c19449c146f0ec69f4b5fa9">get_bias</a> (const vector&lt; int &gt; &amp;traversal_sizes, int best_trav, int second_best_trav, int ref_trav_idx) const </td></tr>
<tr class="separator:a5a29f27c3c19449c146f0ec69f4b5fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56bfa3837036187ade78bb47529d8111"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a56bfa3837036187ade78bb47529d8111">get_ref_offsets</a> (const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;ref_trav) const </td></tr>
<tr class="separator:a56bfa3837036187ade78bb47529d8111"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a1b5a50373729771229ada685b12627df"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a1b5a50373729771229ada685b12627df">get_best_support</a> (const vector&lt; <a class="el" href="structvg_1_1Support.html">Support</a> &gt; &amp;supports, const vector&lt; int &gt; &amp;skips)</td></tr>
<tr class="memdesc:a1b5a50373729771229ada685b12627df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the best support out of a list of supports, ignoring skips.  <a href="#a1b5a50373729771229ada685b12627df">More...</a><br/></td></tr>
<tr class="separator:a1b5a50373729771229ada685b12627df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84da98787b002a2ed9c8c1da6661cebd"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a84da98787b002a2ed9c8c1da6661cebd">support_val</a> (const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;support)</td></tr>
<tr class="memdesc:a84da98787b002a2ed9c8c1da6661cebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relic from old code.  <a href="#a84da98787b002a2ed9c8c1da6661cebd">More...</a><br/></td></tr>
<tr class="separator:a84da98787b002a2ed9c8c1da6661cebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a559c8afa8e4f1f73768d7d90ff6a6db0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a559c8afa8e4f1f73768d7d90ff6a6db0">min_total_support_for_call</a> = 1</td></tr>
<tr class="memdesc:a559c8afa8e4f1f73768d7d90ff6a6db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuning.  <a href="#a559c8afa8e4f1f73768d7d90ff6a6db0">More...</a><br/></td></tr>
<tr class="separator:a559c8afa8e4f1f73768d7d90ff6a6db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af353ceb49f23fc4489b90899d97148fa"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#af353ceb49f23fc4489b90899d97148fa">max_het_bias</a> = 6</td></tr>
<tr class="separator:af353ceb49f23fc4489b90899d97148fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5338ae341b244e3bd0d90edf122e829"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#ad5338ae341b244e3bd0d90edf122e829">max_ref_het_bias</a> = 6</td></tr>
<tr class="memdesc:ad5338ae341b244e3bd0d90edf122e829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like above, but applied to ref / alt ratio (instead of alt / ref)  <a href="#ad5338ae341b244e3bd0d90edf122e829">More...</a><br/></td></tr>
<tr class="separator:ad5338ae341b244e3bd0d90edf122e829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6ef295fb70e944846576db3ff00ae9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#acb6ef295fb70e944846576db3ff00ae9">max_indel_het_bias</a> = 6</td></tr>
<tr class="memdesc:acb6ef295fb70e944846576db3ff00ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the max het bias, but applies to novel indels.  <a href="#acb6ef295fb70e944846576db3ff00ae9">More...</a><br/></td></tr>
<tr class="separator:acb6ef295fb70e944846576db3ff00ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a74962f3960ec76649d8137fe79821f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a4a74962f3960ec76649d8137fe79821f">max_ma_bias</a> = 0</td></tr>
<tr class="separator:a4a74962f3960ec76649d8137fe79821f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec268641676f41d2c24128cb9e17ac03"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#aec268641676f41d2c24128cb9e17ac03">min_mad_for_filter</a> = 1</td></tr>
<tr class="separator:aec268641676f41d2c24128cb9e17ac03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde07f3e5ca89a2a565e8859ee641159"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#adde07f3e5ca89a2a565e8859ee641159">min_site_depth</a> = 3</td></tr>
<tr class="separator:adde07f3e5ca89a2a565e8859ee641159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0157140a7fe7e7264315d1d881d39fb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#ac0157140a7fe7e7264315d1d881d39fb">min_ad_log_likelihood_for_filter</a> = -9</td></tr>
<tr class="memdesc:ac0157140a7fe7e7264315d1d881d39fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">what's the min log likelihood for allele depth assignments to PASS?  <a href="#ac0157140a7fe7e7264315d1d881d39fb">More...</a><br/></td></tr>
<tr class="separator:ac0157140a7fe7e7264315d1d881d39fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c75daf50553712dbba8f2327fafa1c3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a8c75daf50553712dbba8f2327fafa1c3">average_traversal_support_switch_threshold</a> = 50</td></tr>
<tr class="separator:a8c75daf50553712dbba8f2327fafa1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3ab178f80140739466574d4524b1e3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a7f3ab178f80140739466574d4524b1e3">average_node_support_switch_threshold</a> = 50</td></tr>
<tr class="separator:a7f3ab178f80140739466574d4524b1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f76956318b838695d8b120d553ce24"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a17f76956318b838695d8b120d553ce24">min_alt_path_support</a> = 0.2</td></tr>
<tr class="separator:a17f76956318b838695d8b120d553ce24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f5bd05d950be25e87a9f5fbc345a5c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#ab0f5bd05d950be25e87a9f5fbc345a5c">graph</a></td></tr>
<tr class="separator:ab0f5bd05d950be25e87a9f5fbc345a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c40f2d62950d1f484aa6dd84abf60d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html#a86c40f2d62950d1f484aa6dd84abf60d">snarl_manager</a></td></tr>
<tr class="separator:a86c40f2d62950d1f484aa6dd84abf60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Find the genotype of some traversals in a site using read support </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae6c35a2438dac057d7fd50152a004e49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::SupportBasedSnarlCaller::SupportBasedSnarlCaller </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl_manager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1bc8a2019ce7e220dbee5b26c4b27211"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::SupportBasedSnarlCaller::~SupportBasedSnarlCaller </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="adc9597fd0336a6bb227133939eeda7a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; vg::SupportBasedSnarlCaller::genotype </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>traversals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ref_trav_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ploidy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the genotype of a site. </p>

<p>Implements <a class="el" href="classvg_1_1SnarlCaller.html#a1659a26128036d46bacc19407aebdd17">vg::SnarlCaller</a>.</p>

</div>
</div>
<a class="anchor" id="acc085bf1fe3a372ff6fa4a39f38931e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structvg_1_1Support.html">Support</a> vg::SupportBasedSnarlCaller::get_avg_node_support </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Average support of a node. </p>

<p>Implemented in <a class="el" href="classvg_1_1PackedSupportSnarlCaller.html#ab01420f7dc4bf05866d3fe562ce9ac2c">vg::PackedSupportSnarlCaller</a>.</p>

</div>
</div>
<a class="anchor" id="a1b5a50373729771229ada685b12627df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int vg::SupportBasedSnarlCaller::get_best_support </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1Support.html">Support</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>supports</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>skips</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the best support out of a list of supports, ignoring skips. </p>

</div>
</div>
<a class="anchor" id="a5a29f27c3c19449c146f0ec69f4b5fa9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::SupportBasedSnarlCaller::get_bias </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>traversal_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>best_trav</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>second_best_trav</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ref_trav_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the bias used to for comparing two traversals (It differrs heuristically depending whether they are alt/ref/het/hom/snp/indel see tuning parameters below) </p>

</div>
</div>
<a class="anchor" id="a59fa9a6995b1d03afcf7538bb87385c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tuple&lt; <a class="el" href="structvg_1_1Support.html">Support</a>, <a class="el" href="structvg_1_1Support.html">Support</a>, int &gt; vg::SupportBasedSnarlCaller::get_child_support </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use node or edge support as proxy for child support (as was done in original calling code) </p>

</div>
</div>
<a class="anchor" id="adfd739bec55918edd4a3d4914be06eab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::SupportBasedSnarlCaller::get_edge_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a3de8fe5f38b1730a36af4ad9c4258963">edge_t</a> &amp;&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Effective length of an edge. </p>

</div>
</div>
<a class="anchor" id="aabdec54f27e4c971f33e660d697b1380"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structvg_1_1Support.html">Support</a> vg::SupportBasedSnarlCaller::get_edge_support </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a3de8fe5f38b1730a36af4ad9c4258963">edge_t</a> &amp;&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele. ">Support</a> of an edge. </p>

<p>Implemented in <a class="el" href="classvg_1_1PackedSupportSnarlCaller.html#ab305a5f8f11961b4a51ffff28be74cd9">vg::PackedSupportSnarlCaller</a>.</p>

</div>
</div>
<a class="anchor" id="a7a2682959038a70c7c95f617eafbdd9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structvg_1_1Support.html">Support</a> vg::SupportBasedSnarlCaller::get_edge_support </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_reverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classvg_1_1PackedSupportSnarlCaller.html#a8799687a7ffb2558981f61372febcdd4">vg::PackedSupportSnarlCaller</a>.</p>

</div>
</div>
<a class="anchor" id="afaf35e340cb6709d3f8ff3308f9f9bea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structvg_1_1Support.html">Support</a> vg::SupportBasedSnarlCaller::get_min_node_support </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum support of a node. </p>

<p>Implemented in <a class="el" href="classvg_1_1PackedSupportSnarlCaller.html#ad6b0ba3bbe1782351221f4c5d056cc56">vg::PackedSupportSnarlCaller</a>.</p>

</div>
</div>
<a class="anchor" id="a56bfa3837036187ade78bb47529d8111"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, size_t &gt; vg::SupportBasedSnarlCaller::get_ref_offsets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>ref_trav</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get a map of the beginning of a node (in forward orientation) on a traversal used for up-weighting large deletion edges in complex snarls with average support </p>

</div>
</div>
<a class="anchor" id="a637f503cf0ff7fc1cc89260d14d70f29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">function&lt; bool(const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;)&gt; vg::SupportBasedSnarlCaller::get_skip_allele_fn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use min_alt_path_support threshold as cutoff. </p>

<p>Reimplemented from <a class="el" href="classvg_1_1SnarlCaller.html#aa06d17efec46759dd08f0caa8defda48">vg::SnarlCaller</a>.</p>

</div>
</div>
<a class="anchor" id="a4f303d404dc00f4a8f991f7e903dce29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Support.html">Support</a> &gt; vg::SupportBasedSnarlCaller::get_traversal_set_support </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>traversals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>shared_travs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exclusive_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exclusive_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ref_trav_idx</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the support of a set of traversals. Any support overlapping traversals in shared_travs will have their support split. If exclusive_only is true, then any split support gets rounded down to 0 (and ignored when computing mins or averages) . exclusive_count is like exclusive only except shared traversals will be counted (as 0) when doing average and min support if the ref_trav_idx is given, it will be used for computing (deletion) edge lengths </p>

</div>
</div>
<a class="anchor" id="ae1514146b342469dc343756d6ade910d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; vg::SupportBasedSnarlCaller::get_traversal_sizes </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>traversals</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total length of all nodes in the traversal. </p>

</div>
</div>
<a class="anchor" id="ac6c0add16300bcac819e916017d4dba1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Support.html">Support</a> vg::SupportBasedSnarlCaller::get_traversal_support </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>traversal</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the support of a traversal Child snarls are handled as in the old call code: their maximum support is used </p>

</div>
</div>
<a class="anchor" id="a59bcdab863b9de0ecafe7fb72707fddc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SupportBasedSnarlCaller::set_het_bias </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>het_bias</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set some of the parameters. </p>

</div>
</div>
<a class="anchor" id="a3afbd8d1bc78b6716c587b93424db8cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SupportBasedSnarlCaller::set_min_supports </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_mad_for_call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_support_for_call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_site_support</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a84da98787b002a2ed9c8c1da6661cebd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double vg::SupportBasedSnarlCaller::support_val </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>support</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relic from old code. </p>

</div>
</div>
<a class="anchor" id="a42c44dae396995577c679b0b3ab22449"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SupportBasedSnarlCaller::update_vcf_header </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>header</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define any header fields needed by the above. </p>

<p>Implements <a class="el" href="classvg_1_1SnarlCaller.html#a7fb3205d6e94505aadf0c9944fac7eb4">vg::SnarlCaller</a>.</p>

</div>
</div>
<a class="anchor" id="a0a1e45e1eff5208d489115539d621384"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SupportBasedSnarlCaller::update_vcf_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>traversals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>genotype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>sample_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcflib::Variant &amp;&#160;</td>
          <td class="paramname"><em>variant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update INFO and FORMAT fields of the called variant. </p>

<p>Implements <a class="el" href="classvg_1_1SnarlCaller.html#ad0315e74aa5ea9df9820aa1000bd0291">vg::SnarlCaller</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a7f3ab178f80140739466574d4524b1e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::SupportBasedSnarlCaller::average_node_support_switch_threshold = 50</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use average instead of minimum support when determining a node's support its position supports. </p>

</div>
</div>
<a class="anchor" id="a8c75daf50553712dbba8f2327fafa1c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::SupportBasedSnarlCaller::average_traversal_support_switch_threshold = 50</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use average instead of minimum support when determining a traversal's support its node and edge supports. </p>

</div>
</div>
<a class="anchor" id="ab0f5bd05d950be25e87a9f5fbc345a5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a>&amp; vg::SupportBasedSnarlCaller::graph</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af353ceb49f23fc4489b90899d97148fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::SupportBasedSnarlCaller::max_het_bias = 6</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>What fraction of the reads supporting an alt are we willing to discount? At 2, if twice the reads support one allele as the other, we'll call homozygous instead of heterozygous. At infinity, every call will be heterozygous if even one read supports each allele. </p>

</div>
</div>
<a class="anchor" id="acb6ef295fb70e944846576db3ff00ae9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::SupportBasedSnarlCaller::max_indel_het_bias = 6</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like the max het bias, but applies to novel indels. </p>

</div>
</div>
<a class="anchor" id="a4a74962f3960ec76649d8137fe79821f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::SupportBasedSnarlCaller::max_ma_bias = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used for calling 1/2 calls. If both alts (times this bias) are greater than the reference, the call is made. set to 0 to deactivate. </p>

</div>
</div>
<a class="anchor" id="ad5338ae341b244e3bd0d90edf122e829"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::SupportBasedSnarlCaller::max_ref_het_bias = 6</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like above, but applied to ref / alt ratio (instead of alt / ref) </p>

</div>
</div>
<a class="anchor" id="ac0157140a7fe7e7264315d1d881d39fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::SupportBasedSnarlCaller::min_ad_log_likelihood_for_filter = -9</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>what's the min log likelihood for allele depth assignments to PASS? </p>

</div>
</div>
<a class="anchor" id="a17f76956318b838695d8b120d553ce24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::SupportBasedSnarlCaller::min_alt_path_support = 0.2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>used only for pruning alleles in the <a class="el" href="classvg_1_1VCFTraversalFinder.html">VCFTraversalFinder</a>: minimum support of an allele's alt-path for it to be considered in the brute-force enumeration </p>

</div>
</div>
<a class="anchor" id="aec268641676f41d2c24128cb9e17ac03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::SupportBasedSnarlCaller::min_mad_for_filter = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>what's the minimum ref or alt allele depth to give a PASS in the filter column? Also used as a min actual support for a second-best allele call </p>

</div>
</div>
<a class="anchor" id="adde07f3e5ca89a2a565e8859ee641159"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::SupportBasedSnarlCaller::min_site_depth = 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>what's the minimum total support (over all alleles) of the site to make a call </p>

</div>
</div>
<a class="anchor" id="a559c8afa8e4f1f73768d7d90ff6a6db0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int vg::SupportBasedSnarlCaller::min_total_support_for_call = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tuning. </p>
<p>What's the minimum integer number of reads that must support a call? We don't necessarily want to call a SNP as het because we have a single </p>

</div>
</div>
<a class="anchor" id="a86c40f2d62950d1f484aa6dd84abf60d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a>&amp; vg::SupportBasedSnarlCaller::snarl_manager</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="snarl__caller_8hpp.html">snarl_caller.hpp</a></li>
<li>src/<a class="el" href="snarl__caller_8cpp.html">snarl_caller.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
