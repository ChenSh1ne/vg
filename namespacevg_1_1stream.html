<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>vg: vg::stream Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="namespacevg_1_1stream.html">stream</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">vg::stream Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1BlockedGzipInputStream.html">BlockedGzipInputStream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1stream_1_1hFILE__cppstream.html">hFILE_cppstream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1JSONStreamHelper.html">JSONStreamHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1ProtobufEmitter.html">ProtobufEmitter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">ProtobufIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae3b9ef39edd43389b0a24a7cc564ca14"><td class="memItemLeft" align="right" valign="top">hFILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1stream.html#ae3b9ef39edd43389b0a24a7cc564ca14">hfile_wrap</a> (std::istream &amp;input)</td></tr>
<tr class="memdesc:ae3b9ef39edd43389b0a24a7cc564ca14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a C++ input stream as an hFILE* that can be read by BGZF.  <a href="#ae3b9ef39edd43389b0a24a7cc564ca14">More...</a><br/></td></tr>
<tr class="separator:ae3b9ef39edd43389b0a24a7cc564ca14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068e999af5a714f976e2f2ce7b93ced5"><td class="memItemLeft" align="right" valign="top">hFILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1stream.html#a068e999af5a714f976e2f2ce7b93ced5">hfile_wrap</a> (std::ostream &amp;output)</td></tr>
<tr class="memdesc:a068e999af5a714f976e2f2ce7b93ced5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a C++ output stream as an hFILE* that can be written by BGZF.  <a href="#a068e999af5a714f976e2f2ce7b93ced5">More...</a><br/></td></tr>
<tr class="separator:a068e999af5a714f976e2f2ce7b93ced5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac7e0bd059a02304511157988f399f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1stream.html#a1ac7e0bd059a02304511157988f399f2">finish</a> (std::ostream &amp;out)</td></tr>
<tr class="separator:a1ac7e0bd059a02304511157988f399f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4defc58b618bed6cdb900ec085dddf7f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4defc58b618bed6cdb900ec085dddf7f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1stream.html#a4defc58b618bed6cdb900ec085dddf7f">write</a> (std::ostream &amp;out, size_t element_count, size_t chunk_elements, const std::function&lt; T(int64_t, size_t, size_t)&gt; &amp;lambda)</td></tr>
<tr class="separator:a4defc58b618bed6cdb900ec085dddf7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5100b174cb72c3eca71446a5ee97f67"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae5100b174cb72c3eca71446a5ee97f67"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1stream.html#ae5100b174cb72c3eca71446a5ee97f67">write</a> (std::ostream &amp;out, size_t element_count, size_t chunk_elements, const std::function&lt; T(size_t, size_t)&gt; &amp;lambda)</td></tr>
<tr class="separator:ae5100b174cb72c3eca71446a5ee97f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d23af3495a1ad1f3f8ed7d86d30eae6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0d23af3495a1ad1f3f8ed7d86d30eae6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1stream.html#a0d23af3495a1ad1f3f8ed7d86d30eae6">write</a> (std::ostream &amp;out, size_t count, const std::function&lt; T(int64_t, size_t)&gt; &amp;lambda)</td></tr>
<tr class="separator:a0d23af3495a1ad1f3f8ed7d86d30eae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ed959d1724cf4fc227d6f1be537c1d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae2ed959d1724cf4fc227d6f1be537c1d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1stream.html#ae2ed959d1724cf4fc227d6f1be537c1d">write</a> (std::ostream &amp;out, size_t count, const std::function&lt; T(size_t)&gt; &amp;lambda)</td></tr>
<tr class="separator:ae2ed959d1724cf4fc227d6f1be537c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eba0608b9d08880e3c9fed398098eec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2eba0608b9d08880e3c9fed398098eec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1stream.html#a2eba0608b9d08880e3c9fed398098eec">write_buffered</a> (std::ostream &amp;out, std::vector&lt; T &gt; &amp;buffer, size_t buffer_limit)</td></tr>
<tr class="separator:a2eba0608b9d08880e3c9fed398098eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2efdde9341f2baf60692948b8353f65"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae2efdde9341f2baf60692948b8353f65"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1stream.html#ae2efdde9341f2baf60692948b8353f65">for_each_with_group_length</a> (std::istream &amp;in, const std::function&lt; void(int64_t, T &amp;)&gt; &amp;lambda, const std::function&lt; void(size_t)&gt; &amp;handle_count)</td></tr>
<tr class="separator:ae2efdde9341f2baf60692948b8353f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300c797fd37e9fe51c1099be75637c8e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a300c797fd37e9fe51c1099be75637c8e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1stream.html#a300c797fd37e9fe51c1099be75637c8e">for_each</a> (std::istream &amp;in, const std::function&lt; void(int64_t, T &amp;)&gt; &amp;lambda)</td></tr>
<tr class="separator:a300c797fd37e9fe51c1099be75637c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fa6ca8c1ef9b3bfe1aeb5361c78f22"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad7fa6ca8c1ef9b3bfe1aeb5361c78f22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1stream.html#ad7fa6ca8c1ef9b3bfe1aeb5361c78f22">for_each</a> (std::istream &amp;in, const std::function&lt; void(T &amp;)&gt; &amp;lambda)</td></tr>
<tr class="separator:ad7fa6ca8c1ef9b3bfe1aeb5361c78f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f8fa78082bd8cf7485a0a6c86a9ae3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a42f8fa78082bd8cf7485a0a6c86a9ae3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1stream.html#a42f8fa78082bd8cf7485a0a6c86a9ae3">for_each_parallel_impl</a> (std::istream &amp;in, const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;lambda2, const std::function&lt; void(T &amp;)&gt; &amp;lambda1, const std::function&lt; void(size_t)&gt; &amp;handle_count, const std::function&lt; bool(void)&gt; &amp;single_threaded_until_true)</td></tr>
<tr class="separator:a42f8fa78082bd8cf7485a0a6c86a9ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff05539a772f4c48c987c7589255694f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aff05539a772f4c48c987c7589255694f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1stream.html#aff05539a772f4c48c987c7589255694f">for_each_interleaved_pair_parallel</a> (std::istream &amp;in, const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;lambda2)</td></tr>
<tr class="separator:aff05539a772f4c48c987c7589255694f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511cc88e1042fa47bbfb16f4d54cd19e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a511cc88e1042fa47bbfb16f4d54cd19e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1stream.html#a511cc88e1042fa47bbfb16f4d54cd19e">for_each_interleaved_pair_parallel_after_wait</a> (std::istream &amp;in, const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;lambda2, const std::function&lt; bool(void)&gt; &amp;single_threaded_until_true)</td></tr>
<tr class="separator:a511cc88e1042fa47bbfb16f4d54cd19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e03fa9ef82dda41db6bdc6c4c7f016"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a97e03fa9ef82dda41db6bdc6c4c7f016"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1stream.html#a97e03fa9ef82dda41db6bdc6c4c7f016">for_each_parallel</a> (std::istream &amp;in, const std::function&lt; void(T &amp;)&gt; &amp;lambda1, const std::function&lt; void(size_t)&gt; &amp;handle_count)</td></tr>
<tr class="separator:a97e03fa9ef82dda41db6bdc6c4c7f016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095e15e714cebe2bae8e34e604bb9387"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a095e15e714cebe2bae8e34e604bb9387"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1stream.html#a095e15e714cebe2bae8e34e604bb9387">for_each_parallel</a> (std::istream &amp;in, const std::function&lt; void(T &amp;)&gt; &amp;lambda)</td></tr>
<tr class="separator:a095e15e714cebe2bae8e34e604bb9387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8673acf30f1146bd34cfa5a10839759"><td class="memTemplParams" colspan="2">template&lt;typename Item &gt; </td></tr>
<tr class="memitem:ad8673acf30f1146bd34cfa5a10839759"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; void(const Item &amp;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1stream.html#ad8673acf30f1146bd34cfa5a10839759">emit_to</a> (ostream &amp;out)</td></tr>
<tr class="separator:ad8673acf30f1146bd34cfa5a10839759"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:adf7fc2961c0ef084178cd01989ea1f05"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1stream.html#adf7fc2961c0ef084178cd01989ea1f05">MAX_PROTOBUF_SIZE</a> = 1000000000</td></tr>
<tr class="memdesc:adf7fc2961c0ef084178cd01989ea1f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protobuf will refuse to read messages longer than this size.  <a href="#adf7fc2961c0ef084178cd01989ea1f05">More...</a><br/></td></tr>
<tr class="separator:adf7fc2961c0ef084178cd01989ea1f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c251c853915079cc6a23af49619db75"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1stream.html#a1c251c853915079cc6a23af49619db75">TARGET_PROTOBUF_SIZE</a> = <a class="el" href="namespacevg_1_1stream.html#adf7fc2961c0ef084178cd01989ea1f05">MAX_PROTOBUF_SIZE</a>/2</td></tr>
<tr class="memdesc:a1c251c853915079cc6a23af49619db75"><td class="mdescLeft">&#160;</td><td class="mdescRight">We aim to generate messages that are this size.  <a href="#a1c251c853915079cc6a23af49619db75">More...</a><br/></td></tr>
<tr class="separator:a1c251c853915079cc6a23af49619db75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ad8673acf30f1146bd34cfa5a10839759"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Item &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(const Item&amp;)&gt; vg::stream::emit_to </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce an std::function that can be invoked with Protobuf objects and save them to the given stream. Easy way to get a dumping callback to feed to something that wants a callback. The passed stream must outlive the resulting function. </p>

</div>
</div>
<a class="anchor" id="a1ac7e0bd059a02304511157988f399f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::stream::finish </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the EOF marker to the given stream, so that readers won't complain that it might be truncated when they read it in. Internal EOF markers MAY exist, but a file SHOULD have exactly one EOF marker at its end. </p>

</div>
</div>
<a class="anchor" id="a300c797fd37e9fe51c1099be75637c8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::stream::for_each </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(int64_t, T &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad7fa6ca8c1ef9b3bfe1aeb5361c78f22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::stream::for_each </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aff05539a772f4c48c987c7589255694f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::stream::for_each_interleaved_pair_parallel </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a511cc88e1042fa47bbfb16f4d54cd19e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::stream::for_each_interleaved_pair_parallel_after_wait </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>single_threaded_until_true</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a97e03fa9ef82dda41db6bdc6c4c7f016"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::stream::for_each_parallel </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>handle_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a095e15e714cebe2bae8e34e604bb9387"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::stream::for_each_parallel </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a42f8fa78082bd8cf7485a0a6c86a9ae3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::stream::for_each_parallel_impl </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>handle_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>single_threaded_until_true</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae2efdde9341f2baf60692948b8353f65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::stream::for_each_with_group_length </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(int64_t, T &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>handle_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deserialize the input stream into the objects. Skips over groups of objects with count 0. Takes a callback function to be called on the objects, with the object and the blocked gzip virtual offset of its group (or -1 if the input is not blocked gzipped), and another to be called per object group with the group size. </p>

</div>
</div>
<a class="anchor" id="ae3b9ef39edd43389b0a24a7cc564ca14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hFILE * vg::stream::hfile_wrap </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap a C++ input stream as an hFILE* that can be read by BGZF. </p>
<p>Make the base struct, making sure it knows how big we are </p>

</div>
</div>
<a class="anchor" id="a068e999af5a714f976e2f2ce7b93ced5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hFILE * vg::stream::hfile_wrap </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap a C++ output stream as an hFILE* that can be written by BGZF. </p>
<p>Make the base struct, making sure it knows how big we are </p>

</div>
</div>
<a class="anchor" id="a4defc58b618bed6cdb900ec085dddf7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vg::stream::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>element_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chunk_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; T(int64_t, size_t, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write objects using adaptive chunking. Takes a stream to write to, a total element count to write, a guess at how many elements should be in a chunk, and a function that, given a destination virtual offset in the output stream (or -1), a start element, and a length, returns a Protobuf object representing that range of elements.</p>
<p>Adaptively sets the chunk size, in elements, so that no too-large Protobuf records are serialized.</p>
<p>Returns true on success, but throws errors on failure. </p>

</div>
</div>
<a class="anchor" id="ae5100b174cb72c3eca71446a5ee97f67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vg::stream::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>element_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chunk_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; T(size_t, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write objects using adaptive chunking. Takes a stream to write to, a total element count to write, a guess at how many elements should be in a chunk, and a function that, given a start element and a length, returns a Protobuf object representing that range of elements.</p>
<p>Adaptively sets the chunk size, in elements, so that no too-large Protobuf records are serialized.</p>
<p>Returns true on success, but throws errors on failure. </p>

</div>
</div>
<a class="anchor" id="a0d23af3495a1ad1f3f8ed7d86d30eae6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vg::stream::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; T(int64_t, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write objects. count should be equal to the number of objects to write. count is written before the objects, but if it is 0, it is not written. To get the objects, calls lambda with the highest virtual offset that can be seek'd to in order to read the object (or -1 if the stream is not tellable), and the index of the object to retrieve. If not all objects are written, return false, otherwise true. </p>

</div>
</div>
<a class="anchor" id="ae2ed959d1724cf4fc227d6f1be537c1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vg::stream::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; T(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write objects. count should be equal to the number of objects to write. count is written before the objects, but if it is 0, it is not written. To get the objects, calls lambda with the index of the object to retrieve. If not all objects are written, return false, otherwise true. </p>

</div>
</div>
<a class="anchor" id="a2eba0608b9d08880e3c9fed398098eec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vg::stream::write_buffered </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start, continue, or finish a buffered stream of objects. If the length of the buffer is greater than the limit, writes the buffer out. Otherwise, leaves the objects in the buffer. Must be called with a buffer limit of 0 after all the objects have been produced, to flush the buffer. When called with a buffer limit of 0, automatically appends an EOF marker. Returns true unless an error occurs. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="adf7fc2961c0ef084178cd01989ea1f05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t vg::stream::MAX_PROTOBUF_SIZE = 1000000000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Protobuf will refuse to read messages longer than this size. </p>

</div>
</div>
<a class="anchor" id="a1c251c853915079cc6a23af49619db75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t vg::stream::TARGET_PROTOBUF_SIZE = <a class="el" href="namespacevg_1_1stream.html#adf7fc2961c0ef084178cd01989ea1f05">MAX_PROTOBUF_SIZE</a>/2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We aim to generate messages that are this size. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 2 2018 17:09:40 for vg by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
