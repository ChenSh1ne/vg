<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::HTSAlignmentEmitter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html">HTSAlignmentEmitter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classvg_1_1HTSAlignmentEmitter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::HTSAlignmentEmitter Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;hts_alignment_emitter.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vg::HTSAlignmentEmitter:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvg_1_1HTSAlignmentEmitter.png" usemap="#vg::HTSAlignmentEmitter_map" alt=""/>
  <map id="vg::HTSAlignmentEmitter_map" name="vg::HTSAlignmentEmitter_map">
<area href="classvg_1_1io_1_1AlignmentEmitter.html" alt="vg::io::AlignmentEmitter" shape="rect" coords="0,0,191,24"/>
<area href="classvg_1_1SplicedHTSAlignmentEmitter.html" alt="vg::SplicedHTSAlignmentEmitter" shape="rect" coords="0,112,191,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5d299e0ff9007ffe22286c886d1ec669"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html#a5d299e0ff9007ffe22286c886d1ec669">HTSAlignmentEmitter</a> (const string &amp;filename, const string &amp;<a class="el" href="classvg_1_1HTSAlignmentEmitter.html#a061053f7bdf3bf4e70483fad7d659761">format</a>, const map&lt; string, int64_t &gt; &amp;<a class="el" href="classvg_1_1HTSAlignmentEmitter.html#a120f7a095425d81db9fa4c3574f0bee5">path_length</a>, size_t max_threads)</td></tr>
<tr class="separator:a5d299e0ff9007ffe22286c886d1ec669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ce2a704ac1be71879e4277d405c330"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html#ae0ce2a704ac1be71879e4277d405c330">~HTSAlignmentEmitter</a> ()</td></tr>
<tr class="memdesc:ae0ce2a704ac1be71879e4277d405c330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tear down an <a class="el" href="classvg_1_1HTSAlignmentEmitter.html">HTSAlignmentEmitter</a> and destroy HTSlib structures.  <a href="#ae0ce2a704ac1be71879e4277d405c330">More...</a><br /></td></tr>
<tr class="separator:ae0ce2a704ac1be71879e4277d405c330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c76946bf064ecac88e21a2467ea2410"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html#a0c76946bf064ecac88e21a2467ea2410">HTSAlignmentEmitter</a> (const <a class="el" href="classvg_1_1HTSAlignmentEmitter.html">HTSAlignmentEmitter</a> &amp;other)=delete</td></tr>
<tr class="separator:a0c76946bf064ecac88e21a2467ea2410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcc0b64b3f9178c7e30bb15cccc4e21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html">HTSAlignmentEmitter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html#aadcc0b64b3f9178c7e30bb15cccc4e21">operator=</a> (const <a class="el" href="classvg_1_1HTSAlignmentEmitter.html">HTSAlignmentEmitter</a> &amp;other)=delete</td></tr>
<tr class="separator:aadcc0b64b3f9178c7e30bb15cccc4e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780156f43d54cf16906948ad8286c20f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html#a780156f43d54cf16906948ad8286c20f">HTSAlignmentEmitter</a> (<a class="el" href="classvg_1_1HTSAlignmentEmitter.html">HTSAlignmentEmitter</a> &amp;&amp;other)=delete</td></tr>
<tr class="separator:a780156f43d54cf16906948ad8286c20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19eafc506789bd80e235ebc63e2bbe7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html">HTSAlignmentEmitter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html#a19eafc506789bd80e235ebc63e2bbe7f">operator=</a> (<a class="el" href="classvg_1_1HTSAlignmentEmitter.html">HTSAlignmentEmitter</a> &amp;&amp;other)=delete</td></tr>
<tr class="separator:a19eafc506789bd80e235ebc63e2bbe7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e671da1b62eebf423f95c01a865fdd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html#a90e671da1b62eebf423f95c01a865fdd">emit_singles</a> (vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;&amp;aln_batch)</td></tr>
<tr class="memdesc:a90e671da1b62eebf423f95c01a865fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a batch of Alignments.  <a href="#a90e671da1b62eebf423f95c01a865fdd">More...</a><br /></td></tr>
<tr class="separator:a90e671da1b62eebf423f95c01a865fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3137223a14396af5a6284830c716b943"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html#a3137223a14396af5a6284830c716b943">emit_mapped_singles</a> (vector&lt; vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&gt; &amp;&amp;alns_batch)</td></tr>
<tr class="separator:a3137223a14396af5a6284830c716b943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2dbcf61c25fe6646b6753d51b73771"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html#a6c2dbcf61c25fe6646b6753d51b73771">emit_pairs</a> (vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;&amp;aln1_batch, vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;&amp;aln2_batch, vector&lt; int64_t &gt; &amp;&amp;tlen_limit_batch)</td></tr>
<tr class="memdesc:a6c2dbcf61c25fe6646b6753d51b73771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a batch of pairs of Alignments.  <a href="#a6c2dbcf61c25fe6646b6753d51b73771">More...</a><br /></td></tr>
<tr class="separator:a6c2dbcf61c25fe6646b6753d51b73771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144167b8b9b973a113beb3950d8f64e7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html#a144167b8b9b973a113beb3950d8f64e7">emit_mapped_pairs</a> (vector&lt; vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&gt; &amp;&amp;alns1_batch, vector&lt; vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&gt; &amp;&amp;alns2_batch, vector&lt; int64_t &gt; &amp;&amp;tlen_limit_batch)</td></tr>
<tr class="separator:a144167b8b9b973a113beb3950d8f64e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvg_1_1io_1_1AlignmentEmitter"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classvg_1_1io_1_1AlignmentEmitter')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvg_1_1io_1_1AlignmentEmitter.html">vg::io::AlignmentEmitter</a></td></tr>
<tr class="memitem:a9c09a54a452278ec02084ca498105b8d inherit pub_methods_classvg_1_1io_1_1AlignmentEmitter"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1AlignmentEmitter.html#a9c09a54a452278ec02084ca498105b8d">emit_single</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&amp;aln)</td></tr>
<tr class="memdesc:a9c09a54a452278ec02084ca498105b8d inherit pub_methods_classvg_1_1io_1_1AlignmentEmitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a single <a class="el" href="structvg_1_1Alignment.html">Alignment</a>.  <a href="classvg_1_1io_1_1AlignmentEmitter.html#a9c09a54a452278ec02084ca498105b8d">More...</a><br /></td></tr>
<tr class="separator:a9c09a54a452278ec02084ca498105b8d inherit pub_methods_classvg_1_1io_1_1AlignmentEmitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424cb81bfd87685b3be4823e95a023eb inherit pub_methods_classvg_1_1io_1_1AlignmentEmitter"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1AlignmentEmitter.html#a424cb81bfd87685b3be4823e95a023eb">emit_mapped_single</a> (vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;&amp;alns)</td></tr>
<tr class="memdesc:a424cb81bfd87685b3be4823e95a023eb inherit pub_methods_classvg_1_1io_1_1AlignmentEmitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a single <a class="el" href="structvg_1_1Alignment.html">Alignment</a> with secondaries. All secondaries must have is_secondary set already.  <a href="classvg_1_1io_1_1AlignmentEmitter.html#a424cb81bfd87685b3be4823e95a023eb">More...</a><br /></td></tr>
<tr class="separator:a424cb81bfd87685b3be4823e95a023eb inherit pub_methods_classvg_1_1io_1_1AlignmentEmitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719d2cbafa6160bf55e724be1ef9d6f9 inherit pub_methods_classvg_1_1io_1_1AlignmentEmitter"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1AlignmentEmitter.html#a719d2cbafa6160bf55e724be1ef9d6f9">emit_pair</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&amp;aln1, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&amp;aln2, int64_t tlen_limit=0)</td></tr>
<tr class="separator:a719d2cbafa6160bf55e724be1ef9d6f9 inherit pub_methods_classvg_1_1io_1_1AlignmentEmitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd17a6201b33a32f2bbb133952c0d26 inherit pub_methods_classvg_1_1io_1_1AlignmentEmitter"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1AlignmentEmitter.html#a9fd17a6201b33a32f2bbb133952c0d26">emit_mapped_pair</a> (vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;&amp;alns1, vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;&amp;alns2, int64_t tlen_limit=0)</td></tr>
<tr class="separator:a9fd17a6201b33a32f2bbb133952c0d26 inherit pub_methods_classvg_1_1io_1_1AlignmentEmitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2ed8eecf9bc49b0c82e0276a8c3ecf inherit pub_methods_classvg_1_1io_1_1AlignmentEmitter"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1AlignmentEmitter.html#a8a2ed8eecf9bc49b0c82e0276a8c3ecf">~AlignmentEmitter</a> ()=default</td></tr>
<tr class="memdesc:a8a2ed8eecf9bc49b0c82e0276a8c3ecf inherit pub_methods_classvg_1_1io_1_1AlignmentEmitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow destruction through base class pointer.  <a href="classvg_1_1io_1_1AlignmentEmitter.html#a8a2ed8eecf9bc49b0c82e0276a8c3ecf">More...</a><br /></td></tr>
<tr class="separator:a8a2ed8eecf9bc49b0c82e0276a8c3ecf inherit pub_methods_classvg_1_1io_1_1AlignmentEmitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a5cfe9918348db19fc8b8a153a953715b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html#a5cfe9918348db19fc8b8a153a953715b">convert_alignment</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, vector&lt; pair&lt; int, char &gt;&gt; &amp;cigar, bool &amp;pos_rev, int64_t &amp;pos, string &amp;path_name) const</td></tr>
<tr class="memdesc:a5cfe9918348db19fc8b8a153a953715b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describe the given alignment as a CIGAR and start position.  <a href="#a5cfe9918348db19fc8b8a153a953715b">More...</a><br /></td></tr>
<tr class="separator:a5cfe9918348db19fc8b8a153a953715b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b188cc73a956f6479e6e04ef34c8775"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html#a8b188cc73a956f6479e6e04ef34c8775">convert_unpaired</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, bam_hdr_t *header, vector&lt; bam1_t *&gt; &amp;dest)</td></tr>
<tr class="separator:a8b188cc73a956f6479e6e04ef34c8775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5df1805e0a893587e7e819e4c7e8f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html#a4f5df1805e0a893587e7e819e4c7e8f2">convert_paired</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln1, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln2, bam_hdr_t *header, int64_t tlen_limit, vector&lt; bam1_t *&gt; &amp;dest)</td></tr>
<tr class="separator:a4f5df1805e0a893587e7e819e4c7e8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428c49085c70806f2911b8dbc156b063"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html#a428c49085c70806f2911b8dbc156b063">save_records</a> (bam_hdr_t *header, vector&lt; bam1_t *&gt; &amp;records, size_t thread_number)</td></tr>
<tr class="separator:a428c49085c70806f2911b8dbc156b063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee9e23fb034f1267690defe2fde1ead"><td class="memItemLeft" align="right" valign="top">bam_hdr_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html#a5ee9e23fb034f1267690defe2fde1ead">ensure_header</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;sniff, size_t thread_number)</td></tr>
<tr class="separator:a5ee9e23fb034f1267690defe2fde1ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ea72ef0fd7badeb2ae3e951acc8c43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html#a13ea72ef0fd7badeb2ae3e951acc8c43">initialize_sam_file</a> (bam_hdr_t *header, size_t thread_number, bool keep_header=false)</td></tr>
<tr class="separator:a13ea72ef0fd7badeb2ae3e951acc8c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:af43debc963568d3ebf8008744dfc1f7b"><td class="memItemLeft" align="right" valign="top">unique_ptr&lt; ofstream &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html#af43debc963568d3ebf8008744dfc1f7b">out_file</a></td></tr>
<tr class="memdesc:af43debc963568d3ebf8008744dfc1f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we are doing output to a file, this will hold the open file. Otherwise (for stdout) it will be empty.  <a href="#af43debc963568d3ebf8008744dfc1f7b">More...</a><br /></td></tr>
<tr class="separator:af43debc963568d3ebf8008744dfc1f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08d9c47f238a13505835089d5c7b80b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html">vg::io::StreamMultiplexer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html#ac08d9c47f238a13505835089d5c7b80b">multiplexer</a></td></tr>
<tr class="separator:ac08d9c47f238a13505835089d5c7b80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061053f7bdf3bf4e70483fad7d659761"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html#a061053f7bdf3bf4e70483fad7d659761">format</a></td></tr>
<tr class="memdesc:a061053f7bdf3bf4e70483fad7d659761"><td class="mdescLeft">&#160;</td><td class="mdescRight">This holds our format name, for later error messages.  <a href="#a061053f7bdf3bf4e70483fad7d659761">More...</a><br /></td></tr>
<tr class="separator:a061053f7bdf3bf4e70483fad7d659761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120f7a095425d81db9fa4c3574f0bee5"><td class="memItemLeft" align="right" valign="top">map&lt; string, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html#a120f7a095425d81db9fa4c3574f0bee5">path_length</a></td></tr>
<tr class="memdesc:a120f7a095425d81db9fa4c3574f0bee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the path length map until the header can be made.  <a href="#a120f7a095425d81db9fa4c3574f0bee5">More...</a><br /></td></tr>
<tr class="separator:a120f7a095425d81db9fa4c3574f0bee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea45749521914fb3e8605b590591f13c"><td class="memItemLeft" align="right" valign="top">vector&lt; hFILE * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html#aea45749521914fb3e8605b590591f13c">backing_files</a></td></tr>
<tr class="separator:aea45749521914fb3e8605b590591f13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99755c86ec8c5b608d77113644d24db9"><td class="memItemLeft" align="right" valign="top">vector&lt; samFile * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html#a99755c86ec8c5b608d77113644d24db9">sam_files</a></td></tr>
<tr class="separator:a99755c86ec8c5b608d77113644d24db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8421e34401bc0eab7cd36d656e7acf"><td class="memItemLeft" align="right" valign="top">atomic&lt; bam_hdr_t * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html#a9c8421e34401bc0eab7cd36d656e7acf">atomic_header</a></td></tr>
<tr class="memdesc:a9c8421e34401bc0eab7cd36d656e7acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">We need a header.  <a href="#a9c8421e34401bc0eab7cd36d656e7acf">More...</a><br /></td></tr>
<tr class="separator:a9c8421e34401bc0eab7cd36d656e7acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c539d9f8130d8c33fa3334fc21a4f5"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html#a03c539d9f8130d8c33fa3334fc21a4f5">sam_header</a></td></tr>
<tr class="separator:a03c539d9f8130d8c33fa3334fc21a4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415bd90d7e4b2da45e534ec1810616fe"><td class="memItemLeft" align="right" valign="top">mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html#a415bd90d7e4b2da45e534ec1810616fe">header_mutex</a></td></tr>
<tr class="memdesc:a415bd90d7e4b2da45e534ec1810616fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the header isn't present when we want to write, we need a mutex to control creating it.  <a href="#a415bd90d7e4b2da45e534ec1810616fe">More...</a><br /></td></tr>
<tr class="separator:a415bd90d7e4b2da45e534ec1810616fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932706bb5a22a35092be3ddacd49c34c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html#a932706bb5a22a35092be3ddacd49c34c">output_is_bgzf</a></td></tr>
<tr class="separator:a932706bb5a22a35092be3ddacd49c34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153522a68e1a526fb794753ab666f840"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html#a153522a68e1a526fb794753ab666f840">hts_mode</a></td></tr>
<tr class="memdesc:a153522a68e1a526fb794753ab666f840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remember the HTSlib mode string we need to open our files.  <a href="#a153522a68e1a526fb794753ab666f840">More...</a><br /></td></tr>
<tr class="separator:a153522a68e1a526fb794753ab666f840"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:afd92ecc2668078e7601a02133d7619d9"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html#afd92ecc2668078e7601a02133d7619d9">BGZF_FOOTER_LENGTH</a> = 28</td></tr>
<tr class="memdesc:afd92ecc2668078e7601a02133d7619d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">We hack about with htslib's BGZF EOF footers, so we need to know how long they are.  <a href="#afd92ecc2668078e7601a02133d7619d9">More...</a><br /></td></tr>
<tr class="separator:afd92ecc2668078e7601a02133d7619d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Emit Alignments to a stream in SAM/BAM/CRAM format. Thread safe. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5d299e0ff9007ffe22286c886d1ec669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d299e0ff9007ffe22286c886d1ec669">&#9670;&nbsp;</a></span>HTSAlignmentEmitter() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::HTSAlignmentEmitter::HTSAlignmentEmitter </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; string, int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an <a class="el" href="classvg_1_1HTSAlignmentEmitter.html">HTSAlignmentEmitter</a> writing to the given file (or "-") in the given HTS format ("SAM", "BAM", "CRAM"). path_length must map from contig name to length to include in the header. Sample names and read groups for the header will be guessed from the first reads. HTSlib positions will be read from the alignments' refpos, and the alignments must be surjected. </p>

</div>
</div>
<a id="ae0ce2a704ac1be71879e4277d405c330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ce2a704ac1be71879e4277d405c330">&#9670;&nbsp;</a></span>~HTSAlignmentEmitter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::HTSAlignmentEmitter::~HTSAlignmentEmitter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tear down an <a class="el" href="classvg_1_1HTSAlignmentEmitter.html">HTSAlignmentEmitter</a> and destroy HTSlib structures. </p>

</div>
</div>
<a id="a0c76946bf064ecac88e21a2467ea2410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c76946bf064ecac88e21a2467ea2410">&#9670;&nbsp;</a></span>HTSAlignmentEmitter() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::HTSAlignmentEmitter::HTSAlignmentEmitter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1HTSAlignmentEmitter.html">HTSAlignmentEmitter</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a780156f43d54cf16906948ad8286c20f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780156f43d54cf16906948ad8286c20f">&#9670;&nbsp;</a></span>HTSAlignmentEmitter() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::HTSAlignmentEmitter::HTSAlignmentEmitter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html">HTSAlignmentEmitter</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5cfe9918348db19fc8b8a153a953715b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cfe9918348db19fc8b8a153a953715b">&#9670;&nbsp;</a></span>convert_alignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::HTSAlignmentEmitter::convert_alignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, char &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cigar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>pos_rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describe the given alignment as a CIGAR and start position. </p>

<p>Reimplemented in <a class="el" href="classvg_1_1SplicedHTSAlignmentEmitter.html#ac837e6ec08c270afb4f6d231e4f58473">vg::SplicedHTSAlignmentEmitter</a>.</p>

</div>
</div>
<a id="a4f5df1805e0a893587e7e819e4c7e8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f5df1805e0a893587e7e819e4c7e8f2">&#9670;&nbsp;</a></span>convert_paired()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::HTSAlignmentEmitter::convert_paired </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bam_hdr_t *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>tlen_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; bam1_t *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a paired alignment to HTS format. Header must have been created already. </p>

</div>
</div>
<a id="a8b188cc73a956f6479e6e04ef34c8775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b188cc73a956f6479e6e04ef34c8775">&#9670;&nbsp;</a></span>convert_unpaired()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::HTSAlignmentEmitter::convert_unpaired </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bam_hdr_t *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; bam1_t *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert an unpaired alignment to HTS format. Header must have been created already. </p>

</div>
</div>
<a id="a144167b8b9b973a113beb3950d8f64e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144167b8b9b973a113beb3950d8f64e7">&#9670;&nbsp;</a></span>emit_mapped_pairs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::HTSAlignmentEmitter::emit_mapped_pairs </td>
          <td>(</td>
          <td class="paramtype">vector&lt; vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>alns1_batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>alns2_batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int64_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>tlen_limit_batch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Emit the mappings of a batch of pairs of Alignments. All secondaries must have is_secondary set already. </p>

<p>Implements <a class="el" href="classvg_1_1io_1_1AlignmentEmitter.html#a430ea0461fdb40d7df836b92fc529a55">vg::io::AlignmentEmitter</a>.</p>

</div>
</div>
<a id="a3137223a14396af5a6284830c716b943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3137223a14396af5a6284830c716b943">&#9670;&nbsp;</a></span>emit_mapped_singles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::HTSAlignmentEmitter::emit_mapped_singles </td>
          <td>(</td>
          <td class="paramtype">vector&lt; vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>alns_batch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Emit a batch of Alignments with secondaries. All secondaries must have is_secondary set already. </p>

<p>Implements <a class="el" href="classvg_1_1io_1_1AlignmentEmitter.html#a3314c504ff0d278f5f44a316ec573b30">vg::io::AlignmentEmitter</a>.</p>

</div>
</div>
<a id="a6c2dbcf61c25fe6646b6753d51b73771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2dbcf61c25fe6646b6753d51b73771">&#9670;&nbsp;</a></span>emit_pairs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::HTSAlignmentEmitter::emit_pairs </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>aln1_batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>aln2_batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int64_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>tlen_limit_batch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit a batch of pairs of Alignments. </p>

<p>Implements <a class="el" href="classvg_1_1io_1_1AlignmentEmitter.html#aae5f5e6108e47d0a481d656abd4a8075">vg::io::AlignmentEmitter</a>.</p>

</div>
</div>
<a id="a90e671da1b62eebf423f95c01a865fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e671da1b62eebf423f95c01a865fdd">&#9670;&nbsp;</a></span>emit_singles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::HTSAlignmentEmitter::emit_singles </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>aln_batch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit a batch of Alignments. </p>

<p>Implements <a class="el" href="classvg_1_1io_1_1AlignmentEmitter.html#a132fc9cf3a53a99f1ac61538d6433760">vg::io::AlignmentEmitter</a>.</p>

</div>
</div>
<a id="a5ee9e23fb034f1267690defe2fde1ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee9e23fb034f1267690defe2fde1ead">&#9670;&nbsp;</a></span>ensure_header()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bam_hdr_t * vg::HTSAlignmentEmitter::ensure_header </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>sniff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>thread_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make sure that the HTS header has been written, and the samFile* in sam_files has been created for the given thread.</p>
<p>If the header has not been written, blocks until it has been written.</p>
<p>If we end up being the thread to write it, sniff header information from the given alignment.</p>
<p>Returns the header pointer, so we don't have to do another atomic read later. </p>

</div>
</div>
<a id="a13ea72ef0fd7badeb2ae3e951acc8c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ea72ef0fd7badeb2ae3e951acc8c43">&#9670;&nbsp;</a></span>initialize_sam_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::HTSAlignmentEmitter::initialize_sam_file </td>
          <td>(</td>
          <td class="paramtype">bam_hdr_t *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>thread_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keep_header</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a header and a thread number, make sure the samFile* for that thread is initialized and ready to have alignments written to it. If true, actually writes the given header into the output file created by the multiplexer. If the samFile* was already initialized, flushes it out and makes a breakpoint. </p>

</div>
</div>
<a id="aadcc0b64b3f9178c7e30bb15cccc4e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadcc0b64b3f9178c7e30bb15cccc4e21">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html">HTSAlignmentEmitter</a>&amp; vg::HTSAlignmentEmitter::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1HTSAlignmentEmitter.html">HTSAlignmentEmitter</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a19eafc506789bd80e235ebc63e2bbe7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19eafc506789bd80e235ebc63e2bbe7f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html">HTSAlignmentEmitter</a>&amp; vg::HTSAlignmentEmitter::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html">HTSAlignmentEmitter</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a428c49085c70806f2911b8dbc156b063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428c49085c70806f2911b8dbc156b063">&#9670;&nbsp;</a></span>save_records()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::HTSAlignmentEmitter::save_records </td>
          <td>(</td>
          <td class="paramtype">bam_hdr_t *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; bam1_t *&gt; &amp;&#160;</td>
          <td class="paramname"><em>records</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>thread_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write and deallocate a bunch of BAM records. Takes care of locking the file. Header must have been written already. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9c8421e34401bc0eab7cd36d656e7acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8421e34401bc0eab7cd36d656e7acf">&#9670;&nbsp;</a></span>atomic_header</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">atomic&lt;bam_hdr_t*&gt; vg::HTSAlignmentEmitter::atomic_header</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We need a header. </p>

</div>
</div>
<a id="aea45749521914fb3e8605b590591f13c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea45749521914fb3e8605b590591f13c">&#9670;&nbsp;</a></span>backing_files</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;hFILE*&gt; vg::HTSAlignmentEmitter::backing_files</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To back our samFile*s, we need the hFILE* objects wrapping our C++ streams. We need to manually flush these after HTS headers are written, since bgzf_flush, which samtools calls, closes a BGZF block and sends the data to the hFILE* but does not actually flush the hFILE*. These will be pointers to the hFILE* for each thread's samFile*. We may only use them while the samFile* they belong to is still open; closing the samFile* will free the hFILE* but not null it out of this vector. </p>

</div>
</div>
<a id="afd92ecc2668078e7601a02133d7619d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd92ecc2668078e7601a02133d7619d9">&#9670;&nbsp;</a></span>BGZF_FOOTER_LENGTH</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t vg::HTSAlignmentEmitter::BGZF_FOOTER_LENGTH = 28</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We hack about with htslib's BGZF EOF footers, so we need to know how long they are. </p>

</div>
</div>
<a id="a061053f7bdf3bf4e70483fad7d659761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a061053f7bdf3bf4e70483fad7d659761">&#9670;&nbsp;</a></span>format</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::HTSAlignmentEmitter::format</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This holds our format name, for later error messages. </p>

</div>
</div>
<a id="a415bd90d7e4b2da45e534ec1810616fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415bd90d7e4b2da45e534ec1810616fe">&#9670;&nbsp;</a></span>header_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mutex vg::HTSAlignmentEmitter::header_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the header isn't present when we want to write, we need a mutex to control creating it. </p>

</div>
</div>
<a id="a153522a68e1a526fb794753ab666f840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a153522a68e1a526fb794753ab666f840">&#9670;&nbsp;</a></span>hts_mode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::HTSAlignmentEmitter::hts_mode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remember the HTSlib mode string we need to open our files. </p>

</div>
</div>
<a id="ac08d9c47f238a13505835089d5c7b80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08d9c47f238a13505835089d5c7b80b">&#9670;&nbsp;</a></span>multiplexer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html">vg::io::StreamMultiplexer</a> vg::HTSAlignmentEmitter::multiplexer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This holds a StreamMultiplexer on the output stream, for sharing it between threads. </p>

</div>
</div>
<a id="af43debc963568d3ebf8008744dfc1f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af43debc963568d3ebf8008744dfc1f7b">&#9670;&nbsp;</a></span>out_file</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt;ofstream&gt; vg::HTSAlignmentEmitter::out_file</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If we are doing output to a file, this will hold the open file. Otherwise (for stdout) it will be empty. </p>

</div>
</div>
<a id="a932706bb5a22a35092be3ddacd49c34c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a932706bb5a22a35092be3ddacd49c34c">&#9670;&nbsp;</a></span>output_is_bgzf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::HTSAlignmentEmitter::output_is_bgzf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remember if we are outputting BGZF-compressed data or not. If we are, we trim off spurious EOF markers and append our own. </p>

</div>
</div>
<a id="a120f7a095425d81db9fa4c3574f0bee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120f7a095425d81db9fa4c3574f0bee5">&#9670;&nbsp;</a></span>path_length</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;string, int64_t&gt; vg::HTSAlignmentEmitter::path_length</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store the path length map until the header can be made. </p>

</div>
</div>
<a id="a99755c86ec8c5b608d77113644d24db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99755c86ec8c5b608d77113644d24db9">&#9670;&nbsp;</a></span>sam_files</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;samFile*&gt; vg::HTSAlignmentEmitter::sam_files</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>We make one samFile* per thread, on each thread's output stream form the multiplexer. As soon as we create them, we show them the header, so they are initialized properly. If they have not yet been filled in (because the header is not ready yet), they are null. </p>

</div>
</div>
<a id="a03c539d9f8130d8c33fa3334fc21a4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c539d9f8130d8c33fa3334fc21a4f5">&#9670;&nbsp;</a></span>sam_header</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::HTSAlignmentEmitter::sam_header</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>We also need a header string. Not atomic, because by the time we read it we know the header is ready and nobody is writing to it. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="hts__alignment__emitter_8hpp.html">hts_alignment_emitter.hpp</a></li>
<li>src/<a class="el" href="hts__alignment__emitter_8cpp.html">hts_alignment_emitter.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
