<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>vg: vg::stream::BlockedGzipOutputStream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="namespacevg_1_1stream.html">stream</a></li><li class="navelem"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classvg_1_1stream_1_1BlockedGzipOutputStream-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::stream::BlockedGzipOutputStream Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;blocked_gzip_output_stream.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vg::stream::BlockedGzipOutputStream:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvg_1_1stream_1_1BlockedGzipOutputStream.png" usemap="#vg::stream::BlockedGzipOutputStream_map" alt=""/>
  <map id="vg::stream::BlockedGzipOutputStream_map" name="vg::stream::BlockedGzipOutputStream_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae85219331328076dd02386730a7c7517"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#ae85219331328076dd02386730a7c7517">BlockedGzipOutputStream</a> (BGZF *bgzf_handle)</td></tr>
<tr class="separator:ae85219331328076dd02386730a7c7517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab581d099a524b1c97e52d92223de976"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#aab581d099a524b1c97e52d92223de976">BlockedGzipOutputStream</a> (std::ostream &amp;stream)</td></tr>
<tr class="separator:aab581d099a524b1c97e52d92223de976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672be800432069f59a224759995c5a5b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#a672be800432069f59a224759995c5a5b">~BlockedGzipOutputStream</a> ()</td></tr>
<tr class="memdesc:a672be800432069f59a224759995c5a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the stream, finishing all writes if necessary.  <a href="#a672be800432069f59a224759995c5a5b">More...</a><br/></td></tr>
<tr class="separator:a672be800432069f59a224759995c5a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6244ce354bd374db46ee61a87fe74ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#ab6244ce354bd374db46ee61a87fe74ad">BlockedGzipOutputStream</a> (const <a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a> &amp;other)=delete</td></tr>
<tr class="separator:ab6244ce354bd374db46ee61a87fe74ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53e8a558bf0e2aa40cd5fdb1509bcdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#ae53e8a558bf0e2aa40cd5fdb1509bcdb">operator=</a> (const <a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a> &amp;other)=delete</td></tr>
<tr class="separator:ae53e8a558bf0e2aa40cd5fdb1509bcdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585326bfcfb5a0360a8c7f4d3588bd59"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#a585326bfcfb5a0360a8c7f4d3588bd59">BlockedGzipOutputStream</a> (<a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a> &amp;&amp;other)=delete</td></tr>
<tr class="separator:a585326bfcfb5a0360a8c7f4d3588bd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115398cc09c58b04cdfc65aa6554a2ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#a115398cc09c58b04cdfc65aa6554a2ab">operator=</a> (<a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a> &amp;&amp;other)=delete</td></tr>
<tr class="separator:a115398cc09c58b04cdfc65aa6554a2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d6bed7235946cfbf3f5a11846dc9b9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#ab7d6bed7235946cfbf3f5a11846dc9b9">Next</a> (void **data, int *size)</td></tr>
<tr class="separator:ab7d6bed7235946cfbf3f5a11846dc9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3e131dcc1bfb36367b601d292ab882"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#afa3e131dcc1bfb36367b601d292ab882">BackUp</a> (int count)</td></tr>
<tr class="separator:afa3e131dcc1bfb36367b601d292ab882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8febf3ee8c92340eb68bb5f3dde388e"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#ae8febf3ee8c92340eb68bb5f3dde388e">ByteCount</a> () const </td></tr>
<tr class="memdesc:ae8febf3ee8c92340eb68bb5f3dde388e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes written since the stream was constructed.  <a href="#ae8febf3ee8c92340eb68bb5f3dde388e">More...</a><br/></td></tr>
<tr class="separator:ae8febf3ee8c92340eb68bb5f3dde388e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae773a258d6a13f7db22a372cc96857e9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#ae773a258d6a13f7db22a372cc96857e9">WriteAliasedRaw</a> (const void *data, int size)</td></tr>
<tr class="separator:ae773a258d6a13f7db22a372cc96857e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7876d2c5395d9a328931db4048872039"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#a7876d2c5395d9a328931db4048872039">AllowsAliasing</a> () const </td></tr>
<tr class="memdesc:a7876d2c5395d9a328931db4048872039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#ae773a258d6a13f7db22a372cc96857e9">WriteAliasedRaw()</a> is actually available, and false otherwise.  <a href="#a7876d2c5395d9a328931db4048872039">More...</a><br/></td></tr>
<tr class="separator:a7876d2c5395d9a328931db4048872039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4dbb4d5c6b0b32d3c564774b423372f"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#ae4dbb4d5c6b0b32d3c564774b423372f">Tell</a> ()</td></tr>
<tr class="separator:ae4dbb4d5c6b0b32d3c564774b423372f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ee32ab42576adb73f888492c8863a9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#ac8ee32ab42576adb73f888492c8863a9">StartFile</a> ()</td></tr>
<tr class="separator:ac8ee32ab42576adb73f888492c8863a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be03180ed746666fb21de326d5b3cd5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#a7be03180ed746666fb21de326d5b3cd5">EndFile</a> ()</td></tr>
<tr class="separator:a7be03180ed746666fb21de326d5b3cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad2b6ec5ae62ee6f707e9540ba0b57673"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#ad2b6ec5ae62ee6f707e9540ba0b57673">flush</a> ()</td></tr>
<tr class="separator:ad2b6ec5ae62ee6f707e9540ba0b57673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc4828554f57960eb300be866126cd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#a7cc4828554f57960eb300be866126cd1">force_close</a> ()</td></tr>
<tr class="separator:a7cc4828554f57960eb300be866126cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a0a752132a6bf314a9df7751a14d43e38"><td class="memItemLeft" align="right" valign="top">BGZF *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#a0a752132a6bf314a9df7751a14d43e38">handle</a></td></tr>
<tr class="memdesc:a0a752132a6bf314a9df7751a14d43e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">The open BGZF handle being written to.  <a href="#a0a752132a6bf314a9df7751a14d43e38">More...</a><br/></td></tr>
<tr class="separator:a0a752132a6bf314a9df7751a14d43e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98302659d661fb9eff95d13e9d9e12f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#ac98302659d661fb9eff95d13e9d9e12f">buffer</a></td></tr>
<tr class="memdesc:ac98302659d661fb9eff95d13e9d9e12f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This vector will own the memory we use as our void* buffer.  <a href="#ac98302659d661fb9eff95d13e9d9e12f">More...</a><br/></td></tr>
<tr class="separator:ac98302659d661fb9eff95d13e9d9e12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60648a670929e17c8100f0c4da174efb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#a60648a670929e17c8100f0c4da174efb">backed_up</a></td></tr>
<tr class="memdesc:a60648a670929e17c8100f0c4da174efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of characters that have been backed up from the end of the buffer.  <a href="#a60648a670929e17c8100f0c4da174efb">More...</a><br/></td></tr>
<tr class="separator:a60648a670929e17c8100f0c4da174efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e375f86feaa6a6401c98da373995c7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#a06e375f86feaa6a6401c98da373995c7">byte_count</a></td></tr>
<tr class="memdesc:a06e375f86feaa6a6401c98da373995c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The counter to back ByteCount.  <a href="#a06e375f86feaa6a6401c98da373995c7">More...</a><br/></td></tr>
<tr class="separator:a06e375f86feaa6a6401c98da373995c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eebd2cabc4a006342ef16ef9b5786b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#a3eebd2cabc4a006342ef16ef9b5786b2">know_offset</a></td></tr>
<tr class="memdesc:a3eebd2cabc4a006342ef16ef9b5786b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for whether our backing stream is tellable.  <a href="#a3eebd2cabc4a006342ef16ef9b5786b2">More...</a><br/></td></tr>
<tr class="separator:a3eebd2cabc4a006342ef16ef9b5786b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18802c0ebbdbc7f32d98ccc50206097"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#ac18802c0ebbdbc7f32d98ccc50206097">end_file</a></td></tr>
<tr class="memdesc:ac18802c0ebbdbc7f32d98ccc50206097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for whether we are supposed to close out the BGZF file.  <a href="#ac18802c0ebbdbc7f32d98ccc50206097">More...</a><br/></td></tr>
<tr class="separator:ac18802c0ebbdbc7f32d98ccc50206097"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Protobuf-style ZeroCopyOutputStream that writes data in blocked gzip format, and allows interacting with virtual offsets. Does NOT emit the BGZF end-of-file marker unless told to, because we don't want an empty block after every vg <a class="el" href="namespacevg_1_1stream.html#a4defc58b618bed6cdb900ec085dddf7f">stream::write</a> call. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae85219331328076dd02386730a7c7517"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::stream::BlockedGzipOutputStream::BlockedGzipOutputStream </td>
          <td>(</td>
          <td class="paramtype">BGZF *&#160;</td>
          <td class="paramname"><em>bgzf_handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a new stream outputting to the given open BGZF file handle. The stream will own the BGZF file and close it when destructed. </p>

</div>
</div>
<a class="anchor" id="aab581d099a524b1c97e52d92223de976"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::stream::BlockedGzipOutputStream::BlockedGzipOutputStream </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a new stream outputting to the given C++ std::ostream, wrapping it in a BGZF. </p>

</div>
</div>
<a class="anchor" id="a672be800432069f59a224759995c5a5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::stream::BlockedGzipOutputStream::~BlockedGzipOutputStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the stream, finishing all writes if necessary. </p>

</div>
</div>
<a class="anchor" id="ab6244ce354bd374db46ee61a87fe74ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::stream::BlockedGzipOutputStream::BlockedGzipOutputStream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a585326bfcfb5a0360a8c7f4d3588bd59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::stream::BlockedGzipOutputStream::BlockedGzipOutputStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7876d2c5395d9a328931db4048872039"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::stream::BlockedGzipOutputStream::AllowsAliasing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if <a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#ae773a258d6a13f7db22a372cc96857e9">WriteAliasedRaw()</a> is actually available, and false otherwise. </p>

</div>
</div>
<a class="anchor" id="afa3e131dcc1bfb36367b601d292ab882"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::stream::BlockedGzipOutputStream::BackUp </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When called after <a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#ab7d6bed7235946cfbf3f5a11846dc9b9">Next()</a>, mark the last count bytes of the buffer that <a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#ab7d6bed7235946cfbf3f5a11846dc9b9">Next()</a> produced as not to be written to the output. The user must not have touched those bytes. </p>

</div>
</div>
<a class="anchor" id="ae8febf3ee8c92340eb68bb5f3dde388e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::stream::BlockedGzipOutputStream::ByteCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of bytes written since the stream was constructed. </p>

</div>
</div>
<a class="anchor" id="a7be03180ed746666fb21de326d5b3cd5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::stream::BlockedGzipOutputStream::EndFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make this <a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a> write the BGZF-required empty end of file block, when it finishes writing to the BGZF. These blocks are permitted in the interior of files, but we don't want to add them all the time because they're superfluous and they are supposed to be EOF indicators while we are supposed to be able to append data to a file in progress. </p>

</div>
</div>
<a class="anchor" id="ad2b6ec5ae62ee6f707e9540ba0b57673"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::stream::BlockedGzipOutputStream::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Actually dump the buffer data to the BGZF, if needed. Sadly, we can't really be zero-copy because the BGZF library isn't. Throws on failure. </p>

</div>
</div>
<a class="anchor" id="a7cc4828554f57960eb300be866126cd1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::stream::BlockedGzipOutputStream::force_close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Force the BGZF handle closed without letting the library write its EOF marker. TODO: This is necessarily a hack that depends strongly on htslib internals. Should not be called unless data has been flushed into the BGZF. </p>

</div>
</div>
<a class="anchor" id="ab7d6bed7235946cfbf3f5a11846dc9b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::stream::BlockedGzipOutputStream::Next </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a buffer to write to. Saves the address of the buffer where data points, and the size of the buffer where size points. Returns false on an unrecoverable error, and true if a buffer was gotten. The stream is responsible for making sure data in the buffer makes it into the output. The data pointer must be valid until the next write call or until the stream is destroyed. </p>

</div>
</div>
<a class="anchor" id="ae53e8a558bf0e2aa40cd5fdb1509bcdb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a>&amp; vg::stream::BlockedGzipOutputStream::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a115398cc09c58b04cdfc65aa6554a2ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a>&amp; vg::stream::BlockedGzipOutputStream::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac8ee32ab42576adb73f888492c8863a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::stream::BlockedGzipOutputStream::StartFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tell this <a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a> that it is at the beginning of a file, when the backing stream is unseekable. Must be called before anything has been written. Enables <a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#ae4dbb4d5c6b0b32d3c564774b423372f">Tell()</a> and sets the current virtual offset to 0. </p>

</div>
</div>
<a class="anchor" id="ae4dbb4d5c6b0b32d3c564774b423372f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::stream::BlockedGzipOutputStream::Tell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the blocked gzip virtual offset at which the next buffer returned by <a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#ab7d6bed7235946cfbf3f5a11846dc9b9">Next()</a> will start, or -1 if operating on an untellable stream like standard output. Note that this will only get you the position of the next write if anything you are writing through is fully backed up to the next actually-unwritten byte. See Protobuf's CodedOutputStream::Trim(). Not const because buffered data may need to be sent to the compressor to get the virtual offset. </p>

</div>
</div>
<a class="anchor" id="ae773a258d6a13f7db22a372cc96857e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::stream::BlockedGzipOutputStream::WriteAliasedRaw </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Take the given data at the given address into the stream as written. Only works if <a class="el" href="classvg_1_1stream_1_1BlockedGzipOutputStream.html#a7876d2c5395d9a328931db4048872039" title="Return true if WriteAliasedRaw() is actually available, and false otherwise. ">AllowsAliasing()</a> returns true. Returns true on success, and false on an unrecoverable error. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a60648a670929e17c8100f0c4da174efb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::stream::BlockedGzipOutputStream::backed_up</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of characters that have been backed up from the end of the buffer. </p>

</div>
</div>
<a class="anchor" id="ac98302659d661fb9eff95d13e9d9e12f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;char&gt; vg::stream::BlockedGzipOutputStream::buffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This vector will own the memory we use as our void* buffer. </p>

</div>
</div>
<a class="anchor" id="a06e375f86feaa6a6401c98da373995c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::stream::BlockedGzipOutputStream::byte_count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The counter to back ByteCount. </p>

</div>
</div>
<a class="anchor" id="ac18802c0ebbdbc7f32d98ccc50206097"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::stream::BlockedGzipOutputStream::end_file</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag for whether we are supposed to close out the BGZF file. </p>

</div>
</div>
<a class="anchor" id="a0a752132a6bf314a9df7751a14d43e38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BGZF* vg::stream::BlockedGzipOutputStream::handle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The open BGZF handle being written to. </p>

</div>
</div>
<a class="anchor" id="a3eebd2cabc4a006342ef16ef9b5786b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::stream::BlockedGzipOutputStream::know_offset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag for whether our backing stream is tellable. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="blocked__gzip__output__stream_8hpp.html">blocked_gzip_output_stream.hpp</a></li>
<li>src/<a class="el" href="blocked__gzip__output__stream_8cpp.html">blocked_gzip_output_stream.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Sep 28 2018 17:49:56 for vg by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
