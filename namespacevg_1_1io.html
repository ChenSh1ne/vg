<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::io Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="namespacevg_1_1io.html">io</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">vg::io Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html">BlockedGzipInputStream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1fdinbuf.html">fdinbuf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1fdistream.html">fdistream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1fdostream.html">fdostream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1fdoutbuf.html">fdoutbuf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1io_1_1hFILE__cppstream.html">hFILE_cppstream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1JSONStreamHelper.html">JSONStreamHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageEmitter.html">MessageEmitter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html">MessageIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">ProtobufEmitter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">ProtobufIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1Registry.html">Registry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html">StreamMultiplexer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1VPKG.html">VPKG</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a618e8c9e44f63328bb2c0742ab0e69c2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a618e8c9e44f63328bb2c0742ab0e69c2">message_consumer_function_t</a> = function&lt; void(const string &amp;)&gt;</td></tr>
<tr class="memdesc:a618e8c9e44f63328bb2c0742ab0e69c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of a function that can be fed a series of messages.  <a href="#a618e8c9e44f63328bb2c0742ab0e69c2">More...</a><br /></td></tr>
<tr class="separator:a618e8c9e44f63328bb2c0742ab0e69c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ea41d1ec4cf44b436a345f1eefccf1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a26ea41d1ec4cf44b436a345f1eefccf1">message_sender_function_t</a> = function&lt; void(const <a class="el" href="namespacevg_1_1io.html#a618e8c9e44f63328bb2c0742ab0e69c2">message_consumer_function_t</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a26ea41d1ec4cf44b436a345f1eefccf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of a function that can be given a message consumer to feed messages to.  <a href="#a26ea41d1ec4cf44b436a345f1eefccf1">More...</a><br /></td></tr>
<tr class="separator:a26ea41d1ec4cf44b436a345f1eefccf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645533291ad3ae31bd8db73e51b3ac31"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a645533291ad3ae31bd8db73e51b3ac31">load_function_t</a> = function&lt; void *(const <a class="el" href="namespacevg_1_1io.html#a26ea41d1ec4cf44b436a345f1eefccf1">message_sender_function_t</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a645533291ad3ae31bd8db73e51b3ac31"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of a function that can allocate and load an object of unspecified type from a message source.  <a href="#a645533291ad3ae31bd8db73e51b3ac31">More...</a><br /></td></tr>
<tr class="separator:a645533291ad3ae31bd8db73e51b3ac31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161bd20a13c1fd9993bcddd7ea3cbe57"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a161bd20a13c1fd9993bcddd7ea3cbe57">save_function_t</a> = function&lt; void(const void *, const <a class="el" href="namespacevg_1_1io.html#a618e8c9e44f63328bb2c0742ab0e69c2">message_consumer_function_t</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a161bd20a13c1fd9993bcddd7ea3cbe57"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of a function that can serialize an object of unspecified type to a message consumer.  <a href="#a161bd20a13c1fd9993bcddd7ea3cbe57">More...</a><br /></td></tr>
<tr class="separator:a161bd20a13c1fd9993bcddd7ea3cbe57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e90871d34e2a1d10329d419f809cea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a53e90871d34e2a1d10329d419f809cea">bare_load_function_t</a> = function&lt; void *(istream &amp;)&gt;</td></tr>
<tr class="memdesc:a53e90871d34e2a1d10329d419f809cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of a function that can load an object of unspecified type from a bare input stream.  <a href="#a53e90871d34e2a1d10329d419f809cea">More...</a><br /></td></tr>
<tr class="separator:a53e90871d34e2a1d10329d419f809cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c1fde642062992c5179d67196ee4f2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#af8c1fde642062992c5179d67196ee4f2">bare_save_function_t</a> = function&lt; void(const void *, ostream &amp;)&gt;</td></tr>
<tr class="memdesc:af8c1fde642062992c5179d67196ee4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of a function that can save an object of unspecified type to a bare output stream.  <a href="#af8c1fde642062992c5179d67196ee4f2">More...</a><br /></td></tr>
<tr class="separator:af8c1fde642062992c5179d67196ee4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aeef1360dbaeba693008f3ee0d39dde30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#aeef1360dbaeba693008f3ee0d39dde30">load_proto_to_graph</a> (<a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">vg::MutablePathMutableHandleGraph</a> *destination, const <a class="el" href="namespacevg_1_1io.html#a26ea41d1ec4cf44b436a345f1eefccf1">vg::io::message_sender_function_t</a> &amp;for_each_message)</td></tr>
<tr class="separator:aeef1360dbaeba693008f3ee0d39dde30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96a1414b35d7f181ddbb3194d6dcf6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#ad96a1414b35d7f181ddbb3194d6dcf6c">load_proto_to_graph</a> (<a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">vg::MutablePathMutableHandleGraph</a> *destination, const function&lt; void(const function&lt; void(<a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;)&gt; &amp;)&gt; &amp;chunk_sender)</td></tr>
<tr class="separator:ad96a1414b35d7f181ddbb3194d6dcf6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93f27be4f07ab9c6a91a1501b992f70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#ad93f27be4f07ab9c6a91a1501b992f70">register_libvg_io</a> ()</td></tr>
<tr class="separator:ad93f27be4f07ab9c6a91a1501b992f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45372f8f761a3bce9e7ef6e1422db47b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a45372f8f761a3bce9e7ef6e1422db47b">register_loader_saver_distance_index</a> ()</td></tr>
<tr class="separator:a45372f8f761a3bce9e7ef6e1422db47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fc4c5122bf0f0810993822d194eb20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a47fc4c5122bf0f0810993822d194eb20">register_loader_saver_gbwt</a> ()</td></tr>
<tr class="separator:a47fc4c5122bf0f0810993822d194eb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6143362abf3060042589f1ffb22ff498"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a6143362abf3060042589f1ffb22ff498">register_loader_saver_gbwtgraph</a> ()</td></tr>
<tr class="separator:a6143362abf3060042589f1ffb22ff498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affca170910f12393eb1381c4d72e4e73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#affca170910f12393eb1381c4d72e4e73">register_loader_saver_gcsa</a> ()</td></tr>
<tr class="separator:affca170910f12393eb1381c4d72e4e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d41e6f52ad981f96d772396fd4eee5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a49d41e6f52ad981f96d772396fd4eee5">register_loader_saver_hash_graph</a> ()</td></tr>
<tr class="separator:a49d41e6f52ad981f96d772396fd4eee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7df97a78891ada683647c88c6393eb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#af7df97a78891ada683647c88c6393eb9">register_loader_saver_lcp</a> ()</td></tr>
<tr class="separator:af7df97a78891ada683647c88c6393eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69bc026abe7a1db4530704dfc7e7b3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#aa69bc026abe7a1db4530704dfc7e7b3f">register_loader_saver_minimizer</a> ()</td></tr>
<tr class="separator:aa69bc026abe7a1db4530704dfc7e7b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae638cf2f14d5c444b0164f2e9c587213"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#ae638cf2f14d5c444b0164f2e9c587213">register_loader_saver_odgi</a> ()</td></tr>
<tr class="separator:ae638cf2f14d5c444b0164f2e9c587213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776b6490958856d44dc2d962d629440d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a776b6490958856d44dc2d962d629440d">register_loader_saver_packed_graph</a> ()</td></tr>
<tr class="separator:a776b6490958856d44dc2d962d629440d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8072168ee8165f81afb2688ef0825ea8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a8072168ee8165f81afb2688ef0825ea8">register_loader_saver_snarl_manager</a> ()</td></tr>
<tr class="separator:a8072168ee8165f81afb2688ef0825ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3485846033fd4accb221b0a866dfeb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#ac3485846033fd4accb221b0a866dfeb7">register_loader_saver_vg</a> ()</td></tr>
<tr class="separator:ac3485846033fd4accb221b0a866dfeb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a23bf45ec66db4b724b7f8a9f223c33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a7a23bf45ec66db4b724b7f8a9f223c33">register_loader_saver_xg</a> ()</td></tr>
<tr class="separator:a7a23bf45ec66db4b724b7f8a9f223c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f5510bd6a0e5514d3083fcd2ffdd32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#af3f5510bd6a0e5514d3083fcd2ffdd32">save_handle_graph</a> (<a class="el" href="namespacevg.html#ad5781c55c25f1446e1fc74c72c051c62">HandleGraph</a> *graph, ostream &amp;os)</td></tr>
<tr class="separator:af3f5510bd6a0e5514d3083fcd2ffdd32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571f402ff74b738d9070a598a41b58da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a571f402ff74b738d9070a598a41b58da">save_handle_graph</a> (<a class="el" href="namespacevg.html#ad5781c55c25f1446e1fc74c72c051c62">HandleGraph</a> *graph, const string &amp;dest_path)</td></tr>
<tr class="separator:a571f402ff74b738d9070a598a41b58da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd0bfdce54ff793cf2fae6b1122ec54"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#accd0bfdce54ff793cf2fae6b1122ec54">valid_output_format</a> (const string &amp;fmt_string)</td></tr>
<tr class="separator:accd0bfdce54ff793cf2fae6b1122ec54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6ad53e3fc9e4c143221b213932db70"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4b6ad53e3fc9e4c143221b213932db70"><td class="memTemplItemLeft" align="right" valign="top">unique_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a4b6ad53e3fc9e4c143221b213932db70">new_output_graph</a> (const string &amp;fmt_string)</td></tr>
<tr class="separator:a4b6ad53e3fc9e4c143221b213932db70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b6c55dd368ec0c3e85f51a87321ba2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a09b6c55dd368ec0c3e85f51a87321ba2">mergeGraphs</a> (<a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;graph, const <a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;part)</td></tr>
<tr class="separator:a09b6c55dd368ec0c3e85f51a87321ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857cf3810d138ef43e25aa37f147ac25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a857cf3810d138ef43e25aa37f147ac25">inputStream</a> (const string &amp;filename)</td></tr>
<tr class="separator:a857cf3810d138ef43e25aa37f147ac25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477841175891d3e770995307eea45f38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a477841175891d3e770995307eea45f38">outputStream</a> (const <a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;g)</td></tr>
<tr class="separator:a477841175891d3e770995307eea45f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b10a042ea08faa5da35ff07183d49b"><td class="memItemLeft" align="right" valign="top">hFILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a62b10a042ea08faa5da35ff07183d49b">hfile_wrap</a> (std::istream &amp;input)</td></tr>
<tr class="memdesc:a62b10a042ea08faa5da35ff07183d49b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a C++ input stream as an hFILE* that can be read by BGZF.  <a href="#a62b10a042ea08faa5da35ff07183d49b">More...</a><br /></td></tr>
<tr class="separator:a62b10a042ea08faa5da35ff07183d49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa9b57a79b55cf4eeb10806be649ede"><td class="memItemLeft" align="right" valign="top">hFILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a4fa9b57a79b55cf4eeb10806be649ede">hfile_wrap</a> (std::ostream &amp;output)</td></tr>
<tr class="memdesc:a4fa9b57a79b55cf4eeb10806be649ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a C++ output stream as an hFILE* that can be written by BGZF.  <a href="#a4fa9b57a79b55cf4eeb10806be649ede">More...</a><br /></td></tr>
<tr class="separator:a4fa9b57a79b55cf4eeb10806be649ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36870772d6af0c6fbc0a099f6bed2caf"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a36870772d6af0c6fbc0a099f6bed2caf">wrap_bare_loader</a> (function&lt; void *(istream &amp;)&gt; istream_loader) -&gt; <a class="el" href="namespacevg_1_1io.html#a645533291ad3ae31bd8db73e51b3ac31">load_function_t</a></td></tr>
<tr class="separator:a36870772d6af0c6fbc0a099f6bed2caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1a63276edf814575b7afb3b2b9844d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a8b1a63276edf814575b7afb3b2b9844d">with_function_calling_stream</a> (const <a class="el" href="namespacevg_1_1io.html#a618e8c9e44f63328bb2c0742ab0e69c2">message_consumer_function_t</a> &amp;emit_message, const function&lt; void(ostream &amp;)&gt; &amp;use_stream)</td></tr>
<tr class="separator:a8b1a63276edf814575b7afb3b2b9844d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cd97ec5478403a25e02c9805f3d286"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#ae0cd97ec5478403a25e02c9805f3d286">wrap_bare_saver</a> (function&lt; void(const void *, ostream &amp;)&gt; ostream_saver) -&gt; <a class="el" href="namespacevg_1_1io.html#a161bd20a13c1fd9993bcddd7ea3cbe57">save_function_t</a></td></tr>
<tr class="separator:ae0cd97ec5478403a25e02c9805f3d286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b562b3e8bd001bb10bcd0353bf5a929"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a9b562b3e8bd001bb10bcd0353bf5a929">finish</a> (std::ostream &amp;out, bool compressed)</td></tr>
<tr class="separator:a9b562b3e8bd001bb10bcd0353bf5a929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ab0e97965e5b5e461a997ed374423e"><td class="memTemplParams" colspan="2">template&lt;typename Item &gt; </td></tr>
<tr class="memitem:ae5ab0e97965e5b5e461a997ed374423e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#ae5ab0e97965e5b5e461a997ed374423e">emit_to</a> (ostream &amp;out) -&gt; std::function&lt; void(const Item &amp;)&gt;</td></tr>
<tr class="separator:ae5ab0e97965e5b5e461a997ed374423e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6b275aeefcf193d8d25a6b3b7b8f11"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1b6b275aeefcf193d8d25a6b3b7b8f11"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a1b6b275aeefcf193d8d25a6b3b7b8f11">write</a> (std::ostream &amp;out, size_t count, const std::function&lt; T &amp;(size_t)&gt; &amp;lambda, bool compressed=true)</td></tr>
<tr class="separator:a1b6b275aeefcf193d8d25a6b3b7b8f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c230c8fd256d7a5dfd16aa2014a51f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa4c230c8fd256d7a5dfd16aa2014a51f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#aa4c230c8fd256d7a5dfd16aa2014a51f">write</a> (std::ostream &amp;out, size_t count, const std::function&lt; T(size_t)&gt; &amp;lambda, bool compressed=true)</td></tr>
<tr class="separator:aa4c230c8fd256d7a5dfd16aa2014a51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482c50dd5f56410de4988931f2510f57"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a482c50dd5f56410de4988931f2510f57"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a482c50dd5f56410de4988931f2510f57">write_buffered</a> (std::ostream &amp;out, std::vector&lt; T &gt; &amp;buffer, size_t buffer_limit, bool compressed=true)</td></tr>
<tr class="separator:a482c50dd5f56410de4988931f2510f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cb8e7bbebb78a2ef3bdce1c64ba077"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a88cb8e7bbebb78a2ef3bdce1c64ba077"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a88cb8e7bbebb78a2ef3bdce1c64ba077">write_to_file</a> (const T &amp;item, const string &amp;filename)</td></tr>
<tr class="memdesc:a88cb8e7bbebb78a2ef3bdce1c64ba077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a single message to a file.  <a href="#a88cb8e7bbebb78a2ef3bdce1c64ba077">More...</a><br /></td></tr>
<tr class="separator:a88cb8e7bbebb78a2ef3bdce1c64ba077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022b50c432dde9a1f4195fd0ec3dce94"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a022b50c432dde9a1f4195fd0ec3dce94"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a022b50c432dde9a1f4195fd0ec3dce94">for_each</a> (std::istream &amp;in, const std::function&lt; void(int64_t, T &amp;)&gt; &amp;lambda)</td></tr>
<tr class="separator:a022b50c432dde9a1f4195fd0ec3dce94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c791466c3bae889ab6cc86eb6fd0a5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a32c791466c3bae889ab6cc86eb6fd0a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a32c791466c3bae889ab6cc86eb6fd0a5">for_each</a> (std::istream &amp;in, const std::function&lt; void(T &amp;)&gt; &amp;lambda)</td></tr>
<tr class="separator:a32c791466c3bae889ab6cc86eb6fd0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb82f7ea648c689f84cf5d492934a9aa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afb82f7ea648c689f84cf5d492934a9aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#afb82f7ea648c689f84cf5d492934a9aa">for_each_parallel_impl</a> (std::istream &amp;in, const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;lambda2, const std::function&lt; void(T &amp;)&gt; &amp;lambda1, const std::function&lt; bool(void)&gt; &amp;single_threaded_until_true, size_t batch_size)</td></tr>
<tr class="separator:afb82f7ea648c689f84cf5d492934a9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91f319911353b606799afdefe88f7da"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae91f319911353b606799afdefe88f7da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#ae91f319911353b606799afdefe88f7da">for_each_interleaved_pair_parallel</a> (std::istream &amp;in, const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;lambda2, size_t batch_size=256)</td></tr>
<tr class="separator:ae91f319911353b606799afdefe88f7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc54e920105c8bf53fe936cc196f323"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8bc54e920105c8bf53fe936cc196f323"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a8bc54e920105c8bf53fe936cc196f323">for_each_interleaved_pair_parallel_after_wait</a> (std::istream &amp;in, const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;lambda2, const std::function&lt; bool(void)&gt; &amp;single_threaded_until_true, size_t batch_size=256)</td></tr>
<tr class="separator:a8bc54e920105c8bf53fe936cc196f323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3ddf4b05771fabe7c543dae992e13a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6a3ddf4b05771fabe7c543dae992e13a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a6a3ddf4b05771fabe7c543dae992e13a">for_each_parallel</a> (std::istream &amp;in, const std::function&lt; void(T &amp;)&gt; &amp;lambda1, size_t batch_size=256)</td></tr>
<tr class="separator:a6a3ddf4b05771fabe7c543dae992e13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a4547db1ae9c6b6b3cf0ba9f4aed17e14"><td class="memTemplParams" colspan="2">template&lt;typename Item &gt; </td></tr>
<tr class="memitem:a4547db1ae9c6b6b3cf0ba9f4aed17e14"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; void(const Item &amp;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a4547db1ae9c6b6b3cf0ba9f4aed17e14">emit_to</a> (ostream &amp;out)</td></tr>
<tr class="separator:a4547db1ae9c6b6b3cf0ba9f4aed17e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a53e90871d34e2a1d10329d419f809cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53e90871d34e2a1d10329d419f809cea">&#9670;&nbsp;</a></span>bare_load_function_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg_1_1io.html#a53e90871d34e2a1d10329d419f809cea">vg::io::bare_load_function_t</a> = typedef function&lt;void*(istream&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the type of a function that can load an object of unspecified type from a bare input stream. </p>

</div>
</div>
<a id="af8c1fde642062992c5179d67196ee4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c1fde642062992c5179d67196ee4f2">&#9670;&nbsp;</a></span>bare_save_function_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg_1_1io.html#af8c1fde642062992c5179d67196ee4f2">vg::io::bare_save_function_t</a> = typedef function&lt;void(const void*, ostream&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the type of a function that can save an object of unspecified type to a bare output stream. </p>

</div>
</div>
<a id="a645533291ad3ae31bd8db73e51b3ac31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645533291ad3ae31bd8db73e51b3ac31">&#9670;&nbsp;</a></span>load_function_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg_1_1io.html#a645533291ad3ae31bd8db73e51b3ac31">vg::io::load_function_t</a> = typedef function&lt;void*(const <a class="el" href="namespacevg_1_1io.html#a26ea41d1ec4cf44b436a345f1eefccf1">message_sender_function_t</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the type of a function that can allocate and load an object of unspecified type from a message source. </p>

</div>
</div>
<a id="a618e8c9e44f63328bb2c0742ab0e69c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618e8c9e44f63328bb2c0742ab0e69c2">&#9670;&nbsp;</a></span>message_consumer_function_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg_1_1io.html#a618e8c9e44f63328bb2c0742ab0e69c2">vg::io::message_consumer_function_t</a> = typedef function&lt;void(const string&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the type of a function that can be fed a series of messages. </p>

</div>
</div>
<a id="a26ea41d1ec4cf44b436a345f1eefccf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ea41d1ec4cf44b436a345f1eefccf1">&#9670;&nbsp;</a></span>message_sender_function_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg_1_1io.html#a26ea41d1ec4cf44b436a345f1eefccf1">vg::io::message_sender_function_t</a> = typedef function&lt;void(const <a class="el" href="namespacevg_1_1io.html#a618e8c9e44f63328bb2c0742ab0e69c2">message_consumer_function_t</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the type of a function that can be given a message consumer to feed messages to. </p>

</div>
</div>
<a id="a161bd20a13c1fd9993bcddd7ea3cbe57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161bd20a13c1fd9993bcddd7ea3cbe57">&#9670;&nbsp;</a></span>save_function_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg_1_1io.html#a161bd20a13c1fd9993bcddd7ea3cbe57">vg::io::save_function_t</a> = typedef function&lt;void(const void*, const <a class="el" href="namespacevg_1_1io.html#a618e8c9e44f63328bb2c0742ab0e69c2">message_consumer_function_t</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the type of a function that can serialize an object of unspecified type to a message consumer. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae5ab0e97965e5b5e461a997ed374423e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ab0e97965e5b5e461a997ed374423e">&#9670;&nbsp;</a></span>emit_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Item &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vg::io::emit_to </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> -&gt; std::function&lt;void(const Item&amp;)&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b562b3e8bd001bb10bcd0353bf5a929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b562b3e8bd001bb10bcd0353bf5a929">&#9670;&nbsp;</a></span>finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::finish </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the EOF marker to the given stream, so that readers won't complain that it might be truncated when they read it in. Internal EOF markers MAY exist, but a file SHOULD have exactly one EOF marker at its end. Needs to know if the output stream is compressed or not. Note that uncompressed streams don't actually have nonempty EOF markers. </p>

</div>
</div>
<a id="a022b50c432dde9a1f4195fd0ec3dce94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022b50c432dde9a1f4195fd0ec3dce94">&#9670;&nbsp;</a></span>for_each() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::for_each </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(int64_t, T &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a32c791466c3bae889ab6cc86eb6fd0a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c791466c3bae889ab6cc86eb6fd0a5">&#9670;&nbsp;</a></span>for_each() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::for_each </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae91f319911353b606799afdefe88f7da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae91f319911353b606799afdefe88f7da">&#9670;&nbsp;</a></span>for_each_interleaved_pair_parallel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::for_each_interleaved_pair_parallel </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>batch_size</em> = <code>256</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8bc54e920105c8bf53fe936cc196f323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc54e920105c8bf53fe936cc196f323">&#9670;&nbsp;</a></span>for_each_interleaved_pair_parallel_after_wait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::for_each_interleaved_pair_parallel_after_wait </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>single_threaded_until_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>batch_size</em> = <code>256</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a3ddf4b05771fabe7c543dae992e13a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a3ddf4b05771fabe7c543dae992e13a">&#9670;&nbsp;</a></span>for_each_parallel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::for_each_parallel </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>batch_size</em> = <code>256</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb82f7ea648c689f84cf5d492934a9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb82f7ea648c689f84cf5d492934a9aa">&#9670;&nbsp;</a></span>for_each_parallel_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::for_each_parallel_impl </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>single_threaded_until_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>batch_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a62b10a042ea08faa5da35ff07183d49b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b10a042ea08faa5da35ff07183d49b">&#9670;&nbsp;</a></span>hfile_wrap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hFILE * vg::io::hfile_wrap </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap a C++ input stream as an hFILE* that can be read by BGZF. </p>
<p>Make the base struct, making sure it knows how big we are </p>

</div>
</div>
<a id="a4fa9b57a79b55cf4eeb10806be649ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa9b57a79b55cf4eeb10806be649ede">&#9670;&nbsp;</a></span>hfile_wrap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hFILE * vg::io::hfile_wrap </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap a C++ output stream as an hFILE* that can be written by BGZF. </p>
<p>Make the base struct, making sure it knows how big we are </p>

</div>
</div>
<a id="a857cf3810d138ef43e25aa37f147ac25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857cf3810d138ef43e25aa37f147ac25">&#9670;&nbsp;</a></span>inputStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Graph.html">Graph</a> vg::io::inputStream </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeef1360dbaeba693008f3ee0d39dde30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef1360dbaeba693008f3ee0d39dde30">&#9670;&nbsp;</a></span>load_proto_to_graph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::load_proto_to_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">vg::MutablePathMutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg_1_1io.html#a26ea41d1ec4cf44b436a345f1eefccf1">vg::io::message_sender_function_t</a> &amp;&#160;</td>
          <td class="paramname"><em>for_each_message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read all string messages supplied by the given message sender as Protobuf <a class="el" href="structvg_1_1Graph.html">Graph</a> objects, and create the specified graph in the destination graph.</p>
<p><a class="el" href="classvg_1_1Paths.html">Paths</a> need to be cached until the end for ranks to be respected. </p>

</div>
</div>
<a id="ad96a1414b35d7f181ddbb3194d6dcf6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad96a1414b35d7f181ddbb3194d6dcf6c">&#9670;&nbsp;</a></span>load_proto_to_graph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::load_proto_to_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">vg::MutablePathMutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const function&lt; void(<a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;)&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>chunk_sender</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the given function with a callback which it can call with a series of Protobuf <a class="el" href="structvg_1_1Graph.html">Graph</a> objects, possibly in multiple threads. The Protobuf <a class="el" href="structvg_1_1Graph.html">Graph</a> objects may have dangling edges.</p>
<p>Resolves all the dangling edges and writes all the graph data into the given MutablePathMutableHandleGraph, with the destination graph being protected from concurrent modification. </p>

</div>
</div>
<a id="a09b6c55dd368ec0c3e85f51a87321ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b6c55dd368ec0c3e85f51a87321ba2">&#9670;&nbsp;</a></span>mergeGraphs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::mergeGraphs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b6ad53e3fc9e4c143221b213932db70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6ad53e3fc9e4c143221b213932db70">&#9670;&nbsp;</a></span>new_output_graph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt;T&gt; vg::io::new_output_graph </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>fmt_string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a477841175891d3e770995307eea45f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a477841175891d3e770995307eea45f38">&#9670;&nbsp;</a></span>outputStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::outputStream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad93f27be4f07ab9c6a91a1501b992f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93f27be4f07ab9c6a91a1501b992f70">&#9670;&nbsp;</a></span>register_libvg_io()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::register_libvg_io </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register libvg types with libvgio. Must be called by library users before doing IO. Does not magically statically call itself. TODO: work out a way it can. Returns true on success. </p>

</div>
</div>
<a id="a45372f8f761a3bce9e7ef6e1422db47b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45372f8f761a3bce9e7ef6e1422db47b">&#9670;&nbsp;</a></span>register_loader_saver_distance_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::register_loader_saver_distance_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a47fc4c5122bf0f0810993822d194eb20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47fc4c5122bf0f0810993822d194eb20">&#9670;&nbsp;</a></span>register_loader_saver_gbwt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::register_loader_saver_gbwt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6143362abf3060042589f1ffb22ff498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6143362abf3060042589f1ffb22ff498">&#9670;&nbsp;</a></span>register_loader_saver_gbwtgraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::register_loader_saver_gbwtgraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="affca170910f12393eb1381c4d72e4e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affca170910f12393eb1381c4d72e4e73">&#9670;&nbsp;</a></span>register_loader_saver_gcsa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::register_loader_saver_gcsa </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a49d41e6f52ad981f96d772396fd4eee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d41e6f52ad981f96d772396fd4eee5">&#9670;&nbsp;</a></span>register_loader_saver_hash_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::register_loader_saver_hash_graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af7df97a78891ada683647c88c6393eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7df97a78891ada683647c88c6393eb9">&#9670;&nbsp;</a></span>register_loader_saver_lcp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::register_loader_saver_lcp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa69bc026abe7a1db4530704dfc7e7b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa69bc026abe7a1db4530704dfc7e7b3f">&#9670;&nbsp;</a></span>register_loader_saver_minimizer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::register_loader_saver_minimizer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae638cf2f14d5c444b0164f2e9c587213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae638cf2f14d5c444b0164f2e9c587213">&#9670;&nbsp;</a></span>register_loader_saver_odgi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::register_loader_saver_odgi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a776b6490958856d44dc2d962d629440d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776b6490958856d44dc2d962d629440d">&#9670;&nbsp;</a></span>register_loader_saver_packed_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::register_loader_saver_packed_graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8072168ee8165f81afb2688ef0825ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8072168ee8165f81afb2688ef0825ea8">&#9670;&nbsp;</a></span>register_loader_saver_snarl_manager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::register_loader_saver_snarl_manager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3485846033fd4accb221b0a866dfeb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3485846033fd4accb221b0a866dfeb7">&#9670;&nbsp;</a></span>register_loader_saver_vg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::register_loader_saver_vg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a23bf45ec66db4b724b7f8a9f223c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a23bf45ec66db4b724b7f8a9f223c33">&#9670;&nbsp;</a></span>register_loader_saver_xg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::register_loader_saver_xg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af3f5510bd6a0e5514d3083fcd2ffdd32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f5510bd6a0e5514d3083fcd2ffdd32">&#9670;&nbsp;</a></span>save_handle_graph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::save_handle_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#ad5781c55c25f1446e1fc74c72c051c62">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save a handle graph using the <a class="el" href="classvg_1_1io_1_1VPKG.html#a80551b46351f1e8d47e8b3ebaf028847">VPKG::save()</a> function. Todo: should this be somewhere else (ie in vgio with new types registered?) </p>

</div>
</div>
<a id="a571f402ff74b738d9070a598a41b58da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571f402ff74b738d9070a598a41b58da">&#9670;&nbsp;</a></span>save_handle_graph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::save_handle_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#ad5781c55c25f1446e1fc74c72c051c62">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>dest_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="accd0bfdce54ff793cf2fae6b1122ec54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd0bfdce54ff793cf2fae6b1122ec54">&#9670;&nbsp;</a></span>valid_output_format()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::valid_output_format </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>fmt_string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b1a63276edf814575b7afb3b2b9844d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1a63276edf814575b7afb3b2b9844d">&#9670;&nbsp;</a></span>with_function_calling_stream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::with_function_calling_stream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg_1_1io.html#a618e8c9e44f63328bb2c0742ab0e69c2">message_consumer_function_t</a> &amp;&#160;</td>
          <td class="paramname"><em>emit_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(ostream &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>use_stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This calls the given stream-using callback with a stream that, when written to, calls the given emit_message function. The emit_message function and the stream-using callback will run in different threads. </p>

</div>
</div>
<a id="a36870772d6af0c6fbc0a099f6bed2caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36870772d6af0c6fbc0a099f6bed2caf">&#9670;&nbsp;</a></span>wrap_bare_loader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg_1_1io.html#a645533291ad3ae31bd8db73e51b3ac31">load_function_t</a> vg::io::wrap_bare_loader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg_1_1io.html#a53e90871d34e2a1d10329d419f809cea">bare_load_function_t</a>&#160;</td>
          <td class="paramname"><em>istream_loader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We also have an adapter that takes a function from an istream&amp; to a void* object, and runs that in a thread to adapt it to the message consuming shape of interface. It captures the wrapped function by value. </p>

</div>
</div>
<a id="ae0cd97ec5478403a25e02c9805f3d286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0cd97ec5478403a25e02c9805f3d286">&#9670;&nbsp;</a></span>wrap_bare_saver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg_1_1io.html#a161bd20a13c1fd9993bcddd7ea3cbe57">save_function_t</a> vg::io::wrap_bare_saver </td>
          <td>(</td>
          <td class="paramtype">function&lt; void(const void *, ostream &amp;)&gt;&#160;</td>
          <td class="paramname"><em>ostream_saver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We have an adapter that takes a function of void* and ostream&amp;, and adapts that to a message consumer destination. </p>

</div>
</div>
<a id="a1b6b275aeefcf193d8d25a6b3b7b8f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6b275aeefcf193d8d25a6b3b7b8f11">&#9670;&nbsp;</a></span>write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; T &amp;(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write objects. count should be equal to the number of objects to write. count is written before the objects, but if it is 0, it is not written. To get the objects, calls lambda with the index of the object to retrieve. If not all objects are written, return false, otherwise true. Needs to know whether to BGZF-compress the output or not. </p>

</div>
</div>
<a id="aa4c230c8fd256d7a5dfd16aa2014a51f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c230c8fd256d7a5dfd16aa2014a51f">&#9670;&nbsp;</a></span>write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; T(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write objects. count should be equal to the number of objects to write. count is written before the objects, but if it is 0, it is not written. To get the objects, calls lambda with the index of the object to retrieve. If not all objects are written, return false, otherwise true. This implementation takes a function that returns actual objects and not references. Needs to know whether to BGZF-compress the output or not. </p>

</div>
</div>
<a id="a482c50dd5f56410de4988931f2510f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482c50dd5f56410de4988931f2510f57">&#9670;&nbsp;</a></span>write_buffered()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::write_buffered </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start, continue, or finish a buffered stream of objects. If the length of the buffer is greater than the limit, writes the buffer out. Otherwise, leaves the objects in the buffer. Must be called with a buffer limit of 0 after all the objects have been produced, to flush the buffer. When called with a buffer limit of 0, automatically appends an EOF marker. Returns true unless an error occurs. Needs to know whether to BGZF-compress the output or not. </p>

</div>
</div>
<a id="a88cb8e7bbebb78a2ef3bdce1c64ba077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88cb8e7bbebb78a2ef3bdce1c64ba077">&#9670;&nbsp;</a></span>write_to_file()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::write_to_file </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a single message to a file. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a4547db1ae9c6b6b3cf0ba9f4aed17e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4547db1ae9c6b6b3cf0ba9f4aed17e14">&#9670;&nbsp;</a></span>emit_to</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Item &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(const Item&amp;)&gt; vg::io::emit_to(ostream &amp;out)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce an std::function that can be invoked with Protobuf objects and save them to the given stream. Easy way to get a dumping callback to feed to something that wants a callback. The passed stream must outlive the resulting function. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
