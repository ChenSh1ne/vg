<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>vg: vg Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">vg Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacevg_1_1stream"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1stream.html">stream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevg_1_1subcommand"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1subcommand.html">subcommand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevg_1_1temp__file"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1temp__file.html">temp_file</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevg_1_1unittest"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1unittest.html">unittest</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Annotation.html">Annotation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1NoAlignmentInBandException.html">NoAlignmentInBandException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BandedGlobalAligner.html">BandedGlobalAligner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1BenchmarkResult.html">BenchmarkResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1CactusSide.html">CactusSide</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PathChunker.html">PathChunker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ShuffledPairs.html">ShuffledPairs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MEMChainModelVertex.html">MEMChainModelVertex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MEMChainModel.html">MEMChainModel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MEMClusterer.html">MEMClusterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceMeasurer.html">OrientedDistanceMeasurer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PathOrientedDistanceMeasurer.html">PathOrientedDistanceMeasurer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlOrientedDistanceMeasurer.html">SnarlOrientedDistanceMeasurer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceClusterer.html">OrientedDistanceClusterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DistanceHeuristic.html">DistanceHeuristic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlMinDistance.html">SnarlMinDistance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1TipAnchoredMaxDistance.html">TipAnchoredMaxDistance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1TargetValueSearch.html">TargetValueSearch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1TVSClusterer.html">TVSClusterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Colors.html">Colors</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1ConstructedChunk.html">ConstructedChunk</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html">Constructor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Deconstructor.html">Deconstructor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DistanceIndex.html">DistanceIndex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1uniform__real__distribution.html">uniform_real_distribution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1normal__distribution.html">normal_distribution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1WideningPRNG.html">WideningPRNG</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1uniform__int__distribution.html">uniform_int_distribution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1discrete__distribution.html">discrete_distribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">We provide a partial <a class="el" href="classvg_1_1discrete__distribution.html" title="We provide a partial discrete_distribution implementation that is just the parts we need...">discrete_distribution</a> implementation that is just the parts we need.  <a href="classvg_1_1discrete__distribution.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1FeatureSet.html">FeatureSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Filter.html">Filter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1FlowSort.html">FlowSort</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlState.html">SnarlState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1GenomeStateCommand.html">GenomeStateCommand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1InsertHaplotypeCommand.html">InsertHaplotypeCommand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1DeleteHaplotypeCommand.html">DeleteHaplotypeCommand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1SwapHaplotypesCommand.html">SwapHaplotypesCommand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1AppendHaplotypeCommand.html">AppendHaplotypeCommand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1ReplaceSnarlHaplotypeCommand.html">ReplaceSnarlHaplotypeCommand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1ReplaceLocalHaplotypeCommand.html">ReplaceLocalHaplotypeCommand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GenomeState.html">GenomeState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ConsistencyCalculator.html">ConsistencyCalculator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1TraversalSupportCalculator.html">TraversalSupportCalculator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GenotypeLikelihoodCalculator.html">GenotypeLikelihoodCalculator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GenotypePriorCalculator.html">GenotypePriorCalculator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VcfRecordConverter.html">VcfRecordConverter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VcfRecordFilter.html">VcfRecordFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1AugmentedGraph.html">AugmentedGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1SupportAugmentedGraph.html">SupportAugmentedGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Augmented <a class="el" href="structvg_1_1Graph.html">Graph</a> that holds some <a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele. ">Support</a> annotation data specific to vg call.  <a href="structvg_1_1SupportAugmentedGraph.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SimpleConsistencyCalculator.html">SimpleConsistencyCalculator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1FixedGenotypePriorCalculator.html">FixedGenotypePriorCalculator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SimpleTraversalSupportCalculator.html">SimpleTraversalSupportCalculator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Genotyper.html">Genotyper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GFAToPinchTranslator.html">GFAToPinchTranslator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PinchToVGTranslator.html">PinchToVGTranslator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GraphSynchronizer.html">GraphSynchronizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html">BaseAligner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Aligner.html">Aligner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1handle__t.html">handle_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1EasyHandlePacking.html">EasyHandlePacking</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1wang__hash_3_01handle__t_01_4.html">wang_hash&lt; handle_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A path handle is an opaque reference to a named path in a graph.  <a href="structvg_1_1path__handle__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HandleGraph.html">HandleGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PathHandleGraph.html">PathHandleGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MutableHandleGraph.html">MutableHandleGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DeletableHandleGraph.html">DeletableHandleGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MutablePathHandleGraph.html">MutablePathHandleGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MutablePathDeletableHandleGraph.html">MutablePathDeletableHandleGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html">HashGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1wang__hash.html">wang_hash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1wang__hash_3_01T_01_5_01_4.html">wang_hash&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1wang__hash_3_01T_00_01typename_01std_1_1enable__if_3_01std_1_1is__integral_3_01T_01_4_1_1value_01_4_1_1type_01_4.html">wang_hash&lt; T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1wang__hash_3_01std_1_1pair_3_01A_00_01B_01_4_01_4.html">wang_hash&lt; std::pair&lt; A, B &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1hash__map.html">hash_map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1string__hash__map.html">string_hash_map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1pair__hash__map.html">pair_hash_map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1hash__map_3_01K_01_5_00_01V_01_4.html">hash_map&lt; K *, V &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1hash__set.html">hash_set</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1string__hash__set.html">string_hash_set</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1pair__hash__set.html">pair_hash_set</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1hash__set_3_01K_01_5_01_4.html">hash_set&lt; K * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Homogenizer.html">Homogenizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Index.html">Index</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1indexOpenException.html">indexOpenException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1keyNotFoundException.html">keyNotFoundException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IndexedVG.html">IndexedVG</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1kmer__t.html">kmer_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignmentChainModelVertex.html">AlignmentChainModelVertex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignmentChainModel.html">AlignmentChainModel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1FragmentLengthDistribution.html">FragmentLengthDistribution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html">BaseMapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1FragmentLengthStatistics.html">FragmentLengthStatistics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Mapper.html">Mapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MSAConverter.html">MSAConverter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1MultipathProblem.html">MultipathProblem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PathNode.html">PathNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html">MultipathAlignmentGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html">MultipathMapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1NameMapper.html">NameMapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1NestedTraversalFinder.html">NestedTraversalFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1wang__hash_3_01NodeSide_01_4.html">wang_hash&lt; NodeSide &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1wang__hash_3_01NodeTraversal_01_4.html">wang_hash&lt; NodeTraversal &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash function for NodeTraversals  <a href="structvg_1_1wang__hash_3_01NodeTraversal_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OptionInterface.html">OptionInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Configurable.html">Configurable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ConfigurableParser.html">ConfigurableParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OptionValueParser.html">OptionValueParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OptionValueParser_3_01vector_3_01Item_01_4_01_4.html">OptionValueParser&lt; vector&lt; Item &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseOption.html">BaseOption</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Option.html">Option</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Option_3_01vector_3_01Item_01_4_00_01Parser_01_4.html">Option&lt; vector&lt; Item &gt;, Parser &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html">PackedGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedVector.html">PackedVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PagedVector.html">PagedVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedDeque.html">PackedDeque</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedSplayTree.html">PackedSplayTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Packer.html">Packer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Packers.html">Packers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1mapping__t.html">mapping_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Paths.html">Paths</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html">PathIndex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathBranch.html">PathBranch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html">PhaseUnfolder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhasedGenome.html">PhasedGenome</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pictographs.html">Pictographs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html">Pileups</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1StrandSupport.html">StrandSupport</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1NodeDivider.html">NodeDivider</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PileupAugmenter.html">PileupAugmenter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html">Progressive</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1walk__t.html">walk_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record a &lt;=k-length walk in the context of a graph.  <a href="structvg_1_1walk__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1RareVariantSimplifier.html">RareVariantSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html">ReadFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Region.html">Region</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Sampler.html">Sampler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1NGSSimulator.html">NGSSimulator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PositionIDScanner.html">PositionIDScanner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1IDScanner.html">IDScanner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1WrappingPositionScanner.html">WrappingPositionScanner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SmallSnarlSimplifier.html">SmallSnarlSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlFinder.html">SnarlFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1CactusSnarlFinder.html">CactusSnarlFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1NetGraph.html">NetGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SourceSinkOverlay.html">SourceSinkOverlay</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1BREAKPOINT.html">BREAKPOINT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DepthMap.html">DepthMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SRPE.html">SRPE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SSWAligner.html">SSWAligner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BitString.html">BitString</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BitStringTree.html">BitStringTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndexBase.html">StreamIndexBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndex.html">StreamIndex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamSorter.html">StreamSorter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SubHandleGraph.html">SubHandleGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1IntervalBitfield.html">IntervalBitfield</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html">SupportCaller</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html">Surjector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Translator.html">Translator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1TraversalFinder.html">TraversalFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ExhaustiveTraversalFinder.html">ExhaustiveTraversalFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportRestrictedTraversalFinder.html">SupportRestrictedTraversalFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadRestrictedTraversalFinder.html">ReadRestrictedTraversalFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PathRestrictedTraversalFinder.html">PathRestrictedTraversalFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PathBasedTraversalFinder.html">PathBasedTraversalFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1TrivialTraversalFinder.html">TrivialTraversalFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1RepresentativeTraversalFinder.html">RepresentativeTraversalFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1TreeNode.html">TreeNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Tree.html">Tree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1IncrementIter.html">IncrementIter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VariantAdder.html">VariantAdder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VcfBuffer.html">VcfBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1WindowedVcfBuffer.html">WindowedVcfBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Version.html">Version</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for holding vg version and build environment information.  <a href="classvg_1_1Version.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1KmerPosition.html">KmerPosition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html">VG</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Graph.html">Graph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Nodes</em> store sequence data.  <a href="structvg_1_1Node.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Edge.html">Edge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Edit.html">Edit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Mapping.html">Mapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Position.html">Position</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Path.html">Path</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Alignment.html">Alignment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Subpath.html">Subpath</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-branching path of a <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>.  <a href="structvg_1_1Subpath.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1KmerMatch.html">KmerMatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to serialize kmer matches.  <a href="structvg_1_1KmerMatch.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1BasePileup.html">BasePileup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1NodePileup.html">NodePileup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1EdgePileup.html">EdgePileup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep pileup-like record for reads that span edges.  <a href="structvg_1_1EdgePileup.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Pileup.html">Pileup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bundle up <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a> and <a class="el" href="structvg_1_1Edge.html">Edge</a> pileups.  <a href="structvg_1_1Pileup.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Snarl.html">Snarl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a subgraph that is connected to the rest of the graph by two nodes.  <a href="structvg_1_1Snarl.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Visit.html">Visit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a step of a walk through a <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> either on a node or through a child <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a>.  <a href="structvg_1_1Visit.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Locus.html">Locus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a genetic locus with multiple possible alleles, a genotype, and observational support.  <a href="structvg_1_1Locus.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Genotype.html">Genotype</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a genotype at a particular locus.  <a href="structvg_1_1Genotype.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Support.html">Support</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggregates information about the reads supporting an allele.  <a href="structvg_1_1Support.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1LocationSupport.html">LocationSupport</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele. ">Support</a> pinned to a location, which can be either a node or an edge.  <a href="structvg_1_1LocationSupport.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Translation.html">Translation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VGset.html">VGset</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Viz.html">Viz</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Watchdog.html">Watchdog</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1graph__pos__s.html">graph_pos_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html">XdropAligner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4ab10687f0a0cca11ecfd062d9bb0a07"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4ab10687f0a0cca11ecfd062d9bb0a07">benchtime</a> = chrono::nanoseconds</td></tr>
<tr class="memdesc:a4ab10687f0a0cca11ecfd062d9bb0a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">We define a duration type for expressing benchmark times in.  <a href="#a4ab10687f0a0cca11ecfd062d9bb0a07">More...</a><br/></td></tr>
<tr class="separator:a4ab10687f0a0cca11ecfd062d9bb0a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0942a662fe36dad76d2d0e310ec66e3f"><td class="memItemLeft" align="right" valign="top">typedef unordered_set&lt; <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0942a662fe36dad76d2d0e310ec66e3f">HandleSet</a></td></tr>
<tr class="separator:a0942a662fe36dad76d2d0e310ec66e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7143bc6d4008d03bc4a0ac4d4ba26948"><td class="memItemLeft" align="right" valign="top">typedef unordered_map<br class="typebreak"/>
&lt; <a class="el" href="structvg_1_1handle__t.html">handle_t</a>, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7143bc6d4008d03bc4a0ac4d4ba26948">Handle2Component</a></td></tr>
<tr class="separator:a7143bc6d4008d03bc4a0ac4d4ba26948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7392de2ef03532b2ec3461ebb178c75a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> = long double</td></tr>
<tr class="separator:a7392de2ef03532b2ec3461ebb178c75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a29090bbc6b842c2362f9da44a4a57c"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, <br class="typebreak"/>
std::vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7a29090bbc6b842c2362f9da44a4a57c">EdgeMapping</a></td></tr>
<tr class="separator:a7a29090bbc6b842c2362f9da44a4a57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6225846768d2b6dbbbefab9e240a9e02"><td class="memItemLeft" align="right" valign="top">typedef pair&lt; <a class="el" href="structvg_1_1handle__t.html">handle_t</a>, <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a6225846768d2b6dbbbefab9e240a9e02">edge_t</a></td></tr>
<tr class="separator:a6225846768d2b6dbbbefab9e240a9e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101965168ba874bb68cb69198dbf84d0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a101965168ba874bb68cb69198dbf84d0">thread_t</a> = vector&lt; <a class="el" href="structxg_1_1XG_1_1ThreadMapping.html">xg::XG::ThreadMapping</a> &gt;</td></tr>
<tr class="separator:a101965168ba874bb68cb69198dbf84d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d8b2ece3ab50a38656273662553f2d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa9d8b2ece3ab50a38656273662553f2d">Chain</a> = vector&lt; pair&lt; const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *, bool &gt;&gt;</td></tr>
<tr class="separator:aa9d8b2ece3ab50a38656273662553f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b677be2f409ffcbefd5d9f6149c80c1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9b677be2f409ffcbefd5d9f6149c80c1">GAMIndex</a> = <a class="el" href="classvg_1_1StreamIndex.html">StreamIndex</a>&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;</td></tr>
<tr class="memdesc:a9b677be2f409ffcbefd5d9f6149c80c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a GAM index as a stream index over a stream of Alignments.  <a href="#a9b677be2f409ffcbefd5d9f6149c80c1">More...</a><br/></td></tr>
<tr class="separator:a9b677be2f409ffcbefd5d9f6149c80c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c00bf57d75db83e41ac19a88882c043"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a6c00bf57d75db83e41ac19a88882c043">GAMSorter</a> = <a class="el" href="classvg_1_1StreamSorter.html">StreamSorter</a>&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;</td></tr>
<tr class="separator:a6c00bf57d75db83e41ac19a88882c043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc2511884a0496ff2193e1a1151350a"><td class="memItemLeft" align="right" valign="top">typedef int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a></td></tr>
<tr class="separator:a4bc2511884a0496ff2193e1a1151350a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdb6d0305bd8cbf46efed9b2799877a"><td class="memItemLeft" align="right" valign="top">typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9cdb6d0305bd8cbf46efed9b2799877a">off_t</a></td></tr>
<tr class="separator:a9cdb6d0305bd8cbf46efed9b2799877a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54512eefe4b0e14cb3b0057c23350240"><td class="memItemLeft" align="right" valign="top">typedef std::tuple&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool, <br class="typebreak"/>
<a class="el" href="namespacevg.html#a9cdb6d0305bd8cbf46efed9b2799877a">off_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a></td></tr>
<tr class="separator:a54512eefe4b0e14cb3b0057c23350240"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae8af508a4586e2447fdbf2a30a213b39"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae8af508a4586e2447fdbf2a30a213b39">MappingQualityMethod</a> { <a class="el" href="namespacevg.html#ae8af508a4586e2447fdbf2a30a213b39a9ab31888ec6c2da1a29c051c49f2d5ea">Approx</a>, 
<a class="el" href="namespacevg.html#ae8af508a4586e2447fdbf2a30a213b39a71ab21548d5ec730cee91982aa78275e">Exact</a>, 
<a class="el" href="namespacevg.html#ae8af508a4586e2447fdbf2a30a213b39a0f1da9e8a7bb929e940b4fa8be187340">Adaptive</a>, 
<a class="el" href="namespacevg.html#ae8af508a4586e2447fdbf2a30a213b39aa676d6ce23c4076e354ffb65936c03d1">None</a>
 }</td></tr>
<tr class="separator:ae8af508a4586e2447fdbf2a30a213b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47f059d08b97304ea21d00dfc19cd97"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac47f059d08b97304ea21d00dfc19cd97">SnarlType</a> { <a class="el" href="namespacevg.html#ac47f059d08b97304ea21d00dfc19cd97a7db3292851220acc20f75deebe0924ff">UNCLASSIFIED</a> = 0, 
<a class="el" href="namespacevg.html#ac47f059d08b97304ea21d00dfc19cd97aea6b4b85aa567a940c7434df2fcb56fb">ULTRABUBBLE</a> = 1, 
<a class="el" href="namespacevg.html#ac47f059d08b97304ea21d00dfc19cd97a0e62c0ff8521d5960a5cc819a7bf7230">UNARY</a> = 2
 }</td></tr>
<tr class="memdesc:ac47f059d08b97304ea21d00dfc19cd97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the classifications of snarls.  <a href="namespacevg.html#ac47f059d08b97304ea21d00dfc19cd97">More...</a><br/></td></tr>
<tr class="separator:ac47f059d08b97304ea21d00dfc19cd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad78ddf79cde91ee5ee05cf6d74dbec39"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad78ddf79cde91ee5ee05cf6d74dbec39">hts_for_each</a> (string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda, <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgindex)</td></tr>
<tr class="separator:ad78ddf79cde91ee5ee05cf6d74dbec39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7abb14966c1c20cff85c5744a47de0e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad7abb14966c1c20cff85c5744a47de0e">hts_for_each</a> (string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda)</td></tr>
<tr class="separator:ad7abb14966c1c20cff85c5744a47de0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffaa04b09a709602834dbf5a4e8509b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a5ffaa04b09a709602834dbf5a4e8509b">hts_for_each_parallel</a> (string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda, <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgindex)</td></tr>
<tr class="separator:a5ffaa04b09a709602834dbf5a4e8509b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c6c494c2e7663fb14e40c978b4f9e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a59c6c494c2e7663fb14e40c978b4f9e5">hts_for_each_parallel</a> (string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda)</td></tr>
<tr class="separator:a59c6c494c2e7663fb14e40c978b4f9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0676eec9e08d9589fe286cabdd16ffb3"><td class="memItemLeft" align="right" valign="top">bam_hdr_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0676eec9e08d9589fe286cabdd16ffb3">hts_file_header</a> (string &amp;filename, string &amp;header)</td></tr>
<tr class="separator:a0676eec9e08d9589fe286cabdd16ffb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03de4dcf9bfbc8ef1735076da3b922cc"><td class="memItemLeft" align="right" valign="top">bam_hdr_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a03de4dcf9bfbc8ef1735076da3b922cc">hts_string_header</a> (string &amp;header, map&lt; string, int64_t &gt; &amp;path_length, map&lt; string, string &gt; &amp;rg_sample)</td></tr>
<tr class="separator:a03de4dcf9bfbc8ef1735076da3b922cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f91415350a5b07bb4b4f90dd531658d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4f91415350a5b07bb4b4f90dd531658d">get_next_alignment_from_fastq</a> (gzFile fp, char *buffer, size_t len, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment)</td></tr>
<tr class="separator:a4f91415350a5b07bb4b4f90dd531658d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9108ffcadb902a9d82ca882919a38c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afb9108ffcadb902a9d82ca882919a38c">get_next_interleaved_alignment_pair_from_fastq</a> (gzFile fp, char *buffer, size_t len, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;mate1, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;mate2)</td></tr>
<tr class="separator:afb9108ffcadb902a9d82ca882919a38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9fd0ae285f5f9dd8605c9f5343e071"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a6e9fd0ae285f5f9dd8605c9f5343e071">get_next_alignment_pair_from_fastqs</a> (gzFile fp1, gzFile fp2, char *buffer, size_t len, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;mate1, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;mate2)</td></tr>
<tr class="separator:a6e9fd0ae285f5f9dd8605c9f5343e071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d7a5ca192b47b922e17a717774ff66"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad9d7a5ca192b47b922e17a717774ff66">unpaired_for_each_parallel</a> (function&lt; bool(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; get_read_if_available, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda)</td></tr>
<tr class="separator:ad9d7a5ca192b47b922e17a717774ff66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00797829eaa5dfe97f075716dc81e186"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a00797829eaa5dfe97f075716dc81e186">paired_for_each_parallel_after_wait</a> (function&lt; bool(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; get_pair_if_available, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda, function&lt; bool(void)&gt; single_threaded_until_true)</td></tr>
<tr class="separator:a00797829eaa5dfe97f075716dc81e186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa17f82de171af01bcc971db6f225dcf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afa17f82de171af01bcc971db6f225dcf">fastq_unpaired_for_each_parallel</a> (const string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda)</td></tr>
<tr class="separator:afa17f82de171af01bcc971db6f225dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b116363d0208d6448452a3fc0729fef"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4b116363d0208d6448452a3fc0729fef">fastq_paired_interleaved_for_each_parallel</a> (const string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda)</td></tr>
<tr class="separator:a4b116363d0208d6448452a3fc0729fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8af448cba49f55b411bad975a1ecec6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae8af448cba49f55b411bad975a1ecec6">fastq_paired_two_files_for_each_parallel</a> (const string &amp;file1, const string &amp;file2, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda)</td></tr>
<tr class="separator:ae8af448cba49f55b411bad975a1ecec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba2dd4c8634d1269dedd22ea5f87597"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3ba2dd4c8634d1269dedd22ea5f87597">fastq_paired_interleaved_for_each_parallel_after_wait</a> (const string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda, function&lt; bool(void)&gt; single_threaded_until_true)</td></tr>
<tr class="separator:a3ba2dd4c8634d1269dedd22ea5f87597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37cf7e912026ec16af129067619de796"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a37cf7e912026ec16af129067619de796">fastq_paired_two_files_for_each_parallel_after_wait</a> (const string &amp;file1, const string &amp;file2, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda, function&lt; bool(void)&gt; single_threaded_until_true)</td></tr>
<tr class="separator:a37cf7e912026ec16af129067619de796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581952a0bdf921e9388ace316dbe3a63"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a581952a0bdf921e9388ace316dbe3a63">fastq_unpaired_for_each</a> (const string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda)</td></tr>
<tr class="separator:a581952a0bdf921e9388ace316dbe3a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50976b47c0b2b13fb095a0ef92b3b027"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a50976b47c0b2b13fb095a0ef92b3b027">fastq_paired_interleaved_for_each</a> (const string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda)</td></tr>
<tr class="separator:a50976b47c0b2b13fb095a0ef92b3b027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcdef25c312dba95a599ff9c1b44b50"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aedcdef25c312dba95a599ff9c1b44b50">fastq_paired_two_files_for_each</a> (const string &amp;file1, const string &amp;file2, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda)</td></tr>
<tr class="separator:aedcdef25c312dba95a599ff9c1b44b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637c855dffc0296c6575ae8a4cac6b43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a637c855dffc0296c6575ae8a4cac6b43">parse_rg_sample_map</a> (char *hts_header, map&lt; string, string &gt; &amp;rg_sample)</td></tr>
<tr class="separator:a637c855dffc0296c6575ae8a4cac6b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dae5becf3e0669fc5143dbf1270c910"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8dae5becf3e0669fc5143dbf1270c910">quality_char_to_short</a> (char c)</td></tr>
<tr class="separator:a8dae5becf3e0669fc5143dbf1270c910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa98c788fa60695c20994ddeb008afe"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3fa98c788fa60695c20994ddeb008afe">quality_short_to_char</a> (short i)</td></tr>
<tr class="separator:a3fa98c788fa60695c20994ddeb008afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5723504dd654ecf3ee17566070e9fc0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a5723504dd654ecf3ee17566070e9fc0f">alignment_quality_short_to_char</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment)</td></tr>
<tr class="separator:a5723504dd654ecf3ee17566070e9fc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4851c5fbea81739228502a86a0134c8"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac4851c5fbea81739228502a86a0134c8">string_quality_short_to_char</a> (const string &amp;quality)</td></tr>
<tr class="separator:ac4851c5fbea81739228502a86a0134c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97001b9147dae4b72454839d411ced97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a97001b9147dae4b72454839d411ced97">alignment_quality_char_to_short</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment)</td></tr>
<tr class="separator:a97001b9147dae4b72454839d411ced97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01985b9f56eb0f7e566bb957cf839a97"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a01985b9f56eb0f7e566bb957cf839a97">string_quality_char_to_short</a> (const string &amp;quality)</td></tr>
<tr class="separator:a01985b9f56eb0f7e566bb957cf839a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc968aaecb3a7f5a5e000aa937db0721"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afc968aaecb3a7f5a5e000aa937db0721">alignment_to_sam_internal</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const string &amp;refseq, const int32_t refpos, const bool refrev, const string &amp;cigar, const string &amp;mateseq, const int32_t matepos, const int32_t tlen, bool paired)</td></tr>
<tr class="separator:afc968aaecb3a7f5a5e000aa937db0721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e2925cdadc924a1acab1e0d9b3ea8d"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a02e2925cdadc924a1acab1e0d9b3ea8d">alignment_to_sam</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const string &amp;refseq, const int32_t refpos, const bool refrev, const string &amp;cigar, const string &amp;mateseq, const int32_t matepos, const int32_t tlen)</td></tr>
<tr class="separator:a02e2925cdadc924a1acab1e0d9b3ea8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a56e92a8f087c406fd957f6632d239f"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3a56e92a8f087c406fd957f6632d239f">alignment_to_sam</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const string &amp;refseq, const int32_t refpos, const bool refrev, const string &amp;cigar)</td></tr>
<tr class="separator:a3a56e92a8f087c406fd957f6632d239f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d96468183e72f5c516769eed2692de1"><td class="memItemLeft" align="right" valign="top">bam1_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4d96468183e72f5c516769eed2692de1">alignment_to_bam_internal</a> (const string &amp;sam_header, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const string &amp;refseq, const int32_t refpos, const bool refrev, const string &amp;cigar, const string &amp;mateseq, const int32_t matepos, const int32_t tlen, bool paired)</td></tr>
<tr class="separator:a4d96468183e72f5c516769eed2692de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8a5ed350653399ec4cf9009ebecd7a"><td class="memItemLeft" align="right" valign="top">bam1_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1a8a5ed350653399ec4cf9009ebecd7a">alignment_to_bam</a> (const string &amp;sam_header, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const string &amp;refseq, const int32_t refpos, const bool refrev, const string &amp;cigar, const string &amp;mateseq, const int32_t matepos, const int32_t tlen)</td></tr>
<tr class="separator:a1a8a5ed350653399ec4cf9009ebecd7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6c2a0b561c1b062f3b68ecf1c3dfe9"><td class="memItemLeft" align="right" valign="top">bam1_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afc6c2a0b561c1b062f3b68ecf1c3dfe9">alignment_to_bam</a> (const string &amp;sam_header, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const string &amp;refseq, const int32_t refpos, const bool refrev, const string &amp;cigar)</td></tr>
<tr class="separator:afc6c2a0b561c1b062f3b68ecf1c3dfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b35effbcf29e6860145ca7775b913c5"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4b35effbcf29e6860145ca7775b913c5">cigar_string</a> (vector&lt; pair&lt; int, char &gt; &gt; &amp;cigar)</td></tr>
<tr class="separator:a4b35effbcf29e6860145ca7775b913c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad993b1f289a57f3413b85840984b459c"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad993b1f289a57f3413b85840984b459c">mapping_string</a> (const string &amp;source, const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;mapping)</td></tr>
<tr class="separator:ad993b1f289a57f3413b85840984b459c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27af27aefacd2822744823bee4fe9366"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a27af27aefacd2822744823bee4fe9366">mapping_cigar</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;mapping, vector&lt; pair&lt; int, char &gt; &gt; &amp;cigar)</td></tr>
<tr class="separator:a27af27aefacd2822744823bee4fe9366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4efe4d07205cd54c050ca00fc259d92b"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4efe4d07205cd54c050ca00fc259d92b">cigar_mapping</a> (const bam1_t *b, <a class="el" href="structvg_1_1Mapping.html">Mapping</a> *mapping, <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgindex)</td></tr>
<tr class="separator:a4efe4d07205cd54c050ca00fc259d92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c1de94b56959d2c5ece78540fe6727"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa8c1de94b56959d2c5ece78540fe6727">mapping_against_path</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const bam1_t *b, char *chr, <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgindex, bool on_reverse_strand)</td></tr>
<tr class="separator:aa8c1de94b56959d2c5ece78540fe6727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff409d47a3c337dd9d8a046dc14aaa81"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aff409d47a3c337dd9d8a046dc14aaa81">cigar_against_path</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, bool on_reverse_strand, int64_t &amp;pos, size_t path_len, size_t softclip_suppress)</td></tr>
<tr class="separator:aff409d47a3c337dd9d8a046dc14aaa81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37c6d66a01cef6f92707d367ebf4cdb"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae37c6d66a01cef6f92707d367ebf4cdb">sam_flag</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, bool on_reverse_strand, bool paired)</td></tr>
<tr class="separator:ae37c6d66a01cef6f92707d367ebf4cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ca9b103dff30c9383204b427260d00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a25ca9b103dff30c9383204b427260d00">bam_to_alignment</a> (const bam1_t *b, map&lt; string, string &gt; &amp;rg_sample, const bam_hdr_t *bh, <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgindex)</td></tr>
<tr class="separator:a25ca9b103dff30c9383204b427260d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0235b33ab3f656ef6bc9b8700f553511"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0235b33ab3f656ef6bc9b8700f553511">bam_to_alignment</a> (const bam1_t *b, map&lt; string, string &gt; &amp;rg_sample)</td></tr>
<tr class="separator:a0235b33ab3f656ef6bc9b8700f553511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38cb960f8c643934d65c03f0cc85442c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a38cb960f8c643934d65c03f0cc85442c">alignment_to_length</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;a)</td></tr>
<tr class="separator:a38cb960f8c643934d65c03f0cc85442c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4defc9906e81731eab06f8acaa28369"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae4defc9906e81731eab06f8acaa28369">alignment_from_length</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;a)</td></tr>
<tr class="separator:ae4defc9906e81731eab06f8acaa28369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6786ea9551b426f95fba325beff138"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#acd6786ea9551b426f95fba325beff138">strip_from_start</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, size_t drop)</td></tr>
<tr class="separator:acd6786ea9551b426f95fba325beff138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe45b79675104ebc36691774d4124c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#adbe45b79675104ebc36691774d4124c4">strip_from_end</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, size_t drop)</td></tr>
<tr class="separator:adbe45b79675104ebc36691774d4124c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83da8607e104967dd51d9230f4b51bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad83da8607e104967dd51d9230f4b51bb">trim_alignment</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;pos1, const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;pos2)</td></tr>
<tr class="separator:ad83da8607e104967dd51d9230f4b51bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc3ca4569facd77e26c78ba583e4f0a"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#acdc3ca4569facd77e26c78ba583e4f0a">alignment_ends</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, size_t len1, size_t len2)</td></tr>
<tr class="separator:acdc3ca4569facd77e26c78ba583e4f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b82cc5c99cc3e8f78229ac971ec9c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a15b82cc5c99cc3e8f78229ac971ec9c3">alignment_middle</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, int len)</td></tr>
<tr class="separator:a15b82cc5c99cc3e8f78229ac971ec9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed045b02277d7704e997cbede67c2662"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aed045b02277d7704e997cbede67c2662">reverse_complement_alignments</a> (const vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;alns, const function&lt; int64_t(int64_t)&gt; &amp;node_length)</td></tr>
<tr class="separator:aed045b02277d7704e997cbede67c2662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e512ed0fca2503ccc370435591a6c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a98e512ed0fca2503ccc370435591a6c1">reverse_complement_alignment</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const function&lt; int64_t(<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>)&gt; &amp;node_length)</td></tr>
<tr class="separator:a98e512ed0fca2503ccc370435591a6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96610ffc81d6207e0b13f675296c234"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab96610ffc81d6207e0b13f675296c234">reverse_complement_alignment_in_place</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> *aln, const function&lt; int64_t(<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>)&gt; &amp;node_length)</td></tr>
<tr class="separator:ab96610ffc81d6207e0b13f675296c234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2d2a5d955cff1e7a99369055ebe75d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afa2d2a5d955cff1e7a99369055ebe75d">merge_alignments</a> (const vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;alns)</td></tr>
<tr class="separator:afa2d2a5d955cff1e7a99369055ebe75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491e9c11712ae965b8c6745ab33aba21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a491e9c11712ae965b8c6745ab33aba21">extend_alignment</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;a1, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;a2, bool debug)</td></tr>
<tr class="separator:a491e9c11712ae965b8c6745ab33aba21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d71527a132d7e6bf364d2108b269e09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9d71527a132d7e6bf364d2108b269e09">merge_alignments</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;a1, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;a2, bool debug)</td></tr>
<tr class="separator:a9d71527a132d7e6bf364d2108b269e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98dcd16f2a4eae4c223a374dd2ab2da4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a98dcd16f2a4eae4c223a374dd2ab2da4">translate_nodes</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;a, const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;ids, const std::function&lt; size_t(int64_t)&gt; &amp;node_length)</td></tr>
<tr class="separator:a98dcd16f2a4eae4c223a374dd2ab2da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4eaa1a100e433af698e794afa8857b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1f4eaa1a100e433af698e794afa8857b">flip_nodes</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;a, const set&lt; int64_t &gt; &amp;ids, const std::function&lt; size_t(int64_t)&gt; &amp;node_length)</td></tr>
<tr class="separator:a1f4eaa1a100e433af698e794afa8857b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae838e7d89edc59dd87747238cee49b49"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae838e7d89edc59dd87747238cee49b49">non_match_start</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment)</td></tr>
<tr class="separator:ae838e7d89edc59dd87747238cee49b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec2e2ef9679291d966bc348a47c3537"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3ec2e2ef9679291d966bc348a47c3537">non_match_end</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment)</td></tr>
<tr class="separator:a3ec2e2ef9679291d966bc348a47c3537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f2af92a34fdf5fb4ddfee8f8880b48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a90f2af92a34fdf5fb4ddfee8f8880b48">softclip_start</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment)</td></tr>
<tr class="separator:a90f2af92a34fdf5fb4ddfee8f8880b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d6d0388148a996d9423524fa4bcc91"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a05d6d0388148a996d9423524fa4bcc91">softclip_end</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment)</td></tr>
<tr class="separator:a05d6d0388148a996d9423524fa4bcc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffe466a3ca83097eceac30a09b9a010"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#acffe466a3ca83097eceac30a09b9a010">query_overlap</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln1, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln2)</td></tr>
<tr class="separator:acffe466a3ca83097eceac30a09b9a010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2610da8a8fbe723e13519d79ac2d0afe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2610da8a8fbe723e13519d79ac2d0afe">edit_count</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment)</td></tr>
<tr class="separator:a2610da8a8fbe723e13519d79ac2d0afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47f373b3433b3190f9f1c0f5f17274d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad47f373b3433b3190f9f1c0f5f17274d">to_length_after_pos</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;pos)</td></tr>
<tr class="separator:ad47f373b3433b3190f9f1c0f5f17274d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b4e98d0d99a9b58b56f0946f49b1ab"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a59b4e98d0d99a9b58b56f0946f49b1ab">from_length_after_pos</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;pos)</td></tr>
<tr class="separator:a59b4e98d0d99a9b58b56f0946f49b1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40f0cfd74a9eeaa7b6ffecbc0926a6d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa40f0cfd74a9eeaa7b6ffecbc0926a6d">to_length_before_pos</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;pos)</td></tr>
<tr class="separator:aa40f0cfd74a9eeaa7b6ffecbc0926a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d316f0ae049289cacab5117678d6ab"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a21d316f0ae049289cacab5117678d6ab">from_length_before_pos</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;pos)</td></tr>
<tr class="separator:a21d316f0ae049289cacab5117678d6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f469aebb2be5b0028c337108d253fb"><td class="memItemLeft" align="right" valign="top">const string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a94f469aebb2be5b0028c337108d253fb">hash_alignment</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln)</td></tr>
<tr class="separator:a94f469aebb2be5b0028c337108d253fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486054f13a4dc43e37c0f0131f6a51ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a486054f13a4dc43e37c0f0131f6a51ad">simplify</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;a, bool trim_internal_deletions)</td></tr>
<tr class="separator:a486054f13a4dc43e37c0f0131f6a51ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c8bc6d3b973fd1a34c3457a9d2e401"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a81c8bc6d3b973fd1a34c3457a9d2e401">write_alignment_to_file</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const string &amp;filename)</td></tr>
<tr class="separator:a81c8bc6d3b973fd1a34c3457a9d2e401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4413a5d745c8fdc6339efdcd13310c"><td class="memItemLeft" align="right" valign="top">map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2a4413a5d745c8fdc6339efdcd13310c">alignment_quality_per_node</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln)</td></tr>
<tr class="separator:a2a4413a5d745c8fdc6339efdcd13310c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7848d492a243a93f37b1ac52a541a96a"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7848d492a243a93f37b1ac52a541a96a">middle_signature</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, int len)</td></tr>
<tr class="separator:a7848d492a243a93f37b1ac52a541a96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64c67658563ff567bc0b103ef1d8af4"><td class="memItemLeft" align="right" valign="top">pair&lt; string, string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af64c67658563ff567bc0b103ef1d8af4">middle_signature</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln1, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln2, int len)</td></tr>
<tr class="separator:af64c67658563ff567bc0b103ef1d8af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2616dde2763b947a15ac562fd631e688"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2616dde2763b947a15ac562fd631e688">signature</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln)</td></tr>
<tr class="separator:a2616dde2763b947a15ac562fd631e688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134fc6762c4b66dd4847078b0ddbfdd6"><td class="memItemLeft" align="right" valign="top">pair&lt; string, string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a134fc6762c4b66dd4847078b0ddbfdd6">signature</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln1, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln2)</td></tr>
<tr class="separator:a134fc6762c4b66dd4847078b0ddbfdd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b91ade80c8471ff1c5434dfd701cbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a50b91ade80c8471ff1c5434dfd701cbe">parse_bed_regions</a> (istream &amp;bedstream, <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgindex, vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; *out_alignments)</td></tr>
<tr class="separator:a50b91ade80c8471ff1c5434dfd701cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429a2a57a7edf349cbf082d662bc24a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a429a2a57a7edf349cbf082d662bc24a3">parse_gff_regions</a> (istream &amp;gffstream, <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgindex, vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; *out_alignments)</td></tr>
<tr class="separator:a429a2a57a7edf349cbf082d662bc24a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f897cb4a7bbbd40edcb938cdbd4e7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Position.html">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab7f897cb4a7bbbd40edcb938cdbd4e7c">alignment_start</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln)</td></tr>
<tr class="separator:ab7f897cb4a7bbbd40edcb938cdbd4e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63fccb24f075243da0ba145eb8d6aca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Position.html">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa63fccb24f075243da0ba145eb8d6aca">alignment_end</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln)</td></tr>
<tr class="separator:aa63fccb24f075243da0ba145eb8d6aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad13bf14c3488a2d7a86931831ce25d"><td class="memItemLeft" align="right" valign="top">map&lt; string,vector&lt; pair<br class="typebreak"/>
&lt; size_t, bool &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3ad13bf14c3488a2d7a86931831ce25d">alignment_refpos_to_path_offsets</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln)</td></tr>
<tr class="memdesc:a3ad13bf14c3488a2d7a86931831ce25d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the path offsets as cached in the alignment  <a href="#a3ad13bf14c3488a2d7a86931831ce25d">More...</a><br/></td></tr>
<tr class="separator:a3ad13bf14c3488a2d7a86931831ce25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac05a70ed0313422bd481c7bec32f830"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aac05a70ed0313422bd481c7bec32f830">alignment_set_distance_to_correct</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;base)</td></tr>
<tr class="memdesc:aac05a70ed0313422bd481c7bec32f830"><td class="mdescLeft">&#160;</td><td class="mdescRight">annotate the first alignment with its minimum distance to the second in their annotated paths  <a href="#aac05a70ed0313422bd481c7bec32f830">More...</a><br/></td></tr>
<tr class="separator:aac05a70ed0313422bd481c7bec32f830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc99c5b394f220a3280d632cc8e3d528"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#acc99c5b394f220a3280d632cc8e3d528">alignment_set_distance_to_correct</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const map&lt; string, vector&lt; pair&lt; size_t, bool &gt; &gt; &gt; &amp;base_offsets)</td></tr>
<tr class="separator:acc99c5b394f220a3280d632cc8e3d528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9365497bbf0bc45a9fbae2530397fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7b9365497bbf0bc45a9fbae2530397fe">alignment_is_valid</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const <a class="el" href="classvg_1_1HandleGraph.html">HandleGraph</a> *hgraph)</td></tr>
<tr class="memdesc:a7b9365497bbf0bc45a9fbae2530397fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">check to make sure edits on the alignment's path don't assume incorrect node lengths or ids  <a href="#a7b9365497bbf0bc45a9fbae2530397fe">More...</a><br/></td></tr>
<tr class="separator:a7b9365497bbf0bc45a9fbae2530397fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b58aa1a0c067044f1fcbf97627e390"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a99b58aa1a0c067044f1fcbf97627e390">fastq_for_each</a> (string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda)</td></tr>
<tr class="separator:a99b58aa1a0c067044f1fcbf97627e390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfeff6a4607cc66108f55909e82445e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#acfeff6a4607cc66108f55909e82445e2">cigar_mapping</a> (const bam1_t *b, <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;mapping, <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgindex)</td></tr>
<tr class="separator:acfeff6a4607cc66108f55909e82445e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a704ecec885cb89b7b3845c8a990e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a57a704ecec885cb89b7b3845c8a990e7">mapping_against_path</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const bam1_t *b, <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgindex, bool on_reverse_strand)</td></tr>
<tr class="separator:a57a704ecec885cb89b7b3845c8a990e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fda752e24eaed100f6c30904d2ca3e1"><td class="memTemplParams" colspan="2">template&lt;typename AnnotationType , typename Annotated &gt; </td></tr>
<tr class="memitem:a1fda752e24eaed100f6c30904d2ca3e1"><td class="memTemplItemLeft" align="right" valign="top">AnnotationType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1fda752e24eaed100f6c30904d2ca3e1">get_annotation</a> (const Annotated &amp;annotated, const string &amp;name)</td></tr>
<tr class="separator:a1fda752e24eaed100f6c30904d2ca3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9f371af54160a44a44afd80c6cf71a"><td class="memTemplParams" colspan="2">template&lt;typename AnnotationType , typename Annotated &gt; </td></tr>
<tr class="memitem:a1c9f371af54160a44a44afd80c6cf71a"><td class="memTemplItemLeft" align="right" valign="top">AnnotationType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1c9f371af54160a44a44afd80c6cf71a">get_annotation</a> (Annotated *annotated, const string &amp;name)</td></tr>
<tr class="separator:a1c9f371af54160a44a44afd80c6cf71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea29af7b94ac90b1db0eacd908511c0"><td class="memTemplParams" colspan="2">template&lt;typename AnnotationType , typename Annotated &gt; </td></tr>
<tr class="memitem:adea29af7b94ac90b1db0eacd908511c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#adea29af7b94ac90b1db0eacd908511c0">set_annotation</a> (Annotated *annotated, const string &amp;name, const AnnotationType &amp;annotation)</td></tr>
<tr class="separator:adea29af7b94ac90b1db0eacd908511c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bcd5d5fc5318bbdbe784f224b906bd"><td class="memTemplParams" colspan="2">template&lt;typename AnnotationType , typename Annotated &gt; </td></tr>
<tr class="memitem:a54bcd5d5fc5318bbdbe784f224b906bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a54bcd5d5fc5318bbdbe784f224b906bd">set_annotation</a> (Annotated &amp;annotated, const string &amp;name, const AnnotationType &amp;annotation)</td></tr>
<tr class="separator:a54bcd5d5fc5318bbdbe784f224b906bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad970d2836c53996c21e5c5d9d3e0a6d8"><td class="memTemplParams" colspan="2">template&lt;typename Annotated &gt; </td></tr>
<tr class="memitem:ad970d2836c53996c21e5c5d9d3e0a6d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad970d2836c53996c21e5c5d9d3e0a6d8">clear_annotation</a> (Annotated *annotated, const string &amp;name)</td></tr>
<tr class="memdesc:ad970d2836c53996c21e5c5d9d3e0a6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the annotation with the given name.  <a href="#ad970d2836c53996c21e5c5d9d3e0a6d8">More...</a><br/></td></tr>
<tr class="separator:ad970d2836c53996c21e5c5d9d3e0a6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae414970cfc37049b4dc9b308d9ed5f59"><td class="memTemplParams" colspan="2">template&lt;typename Annotated &gt; </td></tr>
<tr class="memitem:ae414970cfc37049b4dc9b308d9ed5f59"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae414970cfc37049b4dc9b308d9ed5f59">clear_annotation</a> (Annotated &amp;annotated, const string &amp;name)</td></tr>
<tr class="memdesc:ae414970cfc37049b4dc9b308d9ed5f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the annotation with the given name.  <a href="#ae414970cfc37049b4dc9b308d9ed5f59">More...</a><br/></td></tr>
<tr class="separator:ae414970cfc37049b4dc9b308d9ed5f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fc86953f8c080621c080cd35bc9ae0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a76fc86953f8c080621c080cd35bc9ae0"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a76fc86953f8c080621c080cd35bc9ae0">value_cast</a> (const google::protobuf::Value &amp;value)</td></tr>
<tr class="memdesc:a76fc86953f8c080621c080cd35bc9ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a Protobuf generic Value to any type.  <a href="#a76fc86953f8c080621c080cd35bc9ae0">More...</a><br/></td></tr>
<tr class="separator:a76fc86953f8c080621c080cd35bc9ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84a9621d5108f53976d51f1188e7214"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac84a9621d5108f53976d51f1188e7214"><td class="memTemplItemLeft" align="right" valign="top">google::protobuf::Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac84a9621d5108f53976d51f1188e7214">value_cast</a> (const T &amp;wrap)</td></tr>
<tr class="memdesc:ac84a9621d5108f53976d51f1188e7214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast any type to a generic Protobuf value.  <a href="#ac84a9621d5108f53976d51f1188e7214">More...</a><br/></td></tr>
<tr class="separator:ac84a9621d5108f53976d51f1188e7214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90d23f22ad3ec78da4e03dc011cabf8"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac90d23f22ad3ec78da4e03dc011cabf8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac90d23f22ad3ec78da4e03dc011cabf8">value_cast&lt; bool &gt;</a> (const google::protobuf::Value &amp;value)</td></tr>
<tr class="separator:ac90d23f22ad3ec78da4e03dc011cabf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a0cc45e4277281efeedb821c1444f6"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a13a0cc45e4277281efeedb821c1444f6"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a13a0cc45e4277281efeedb821c1444f6">value_cast&lt; double &gt;</a> (const google::protobuf::Value &amp;value)</td></tr>
<tr class="separator:a13a0cc45e4277281efeedb821c1444f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16575a017d153499fe4a0976e801be61"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a16575a017d153499fe4a0976e801be61"><td class="memTemplItemLeft" align="right" valign="top">string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a16575a017d153499fe4a0976e801be61">value_cast&lt; string &gt;</a> (const google::protobuf::Value &amp;value)</td></tr>
<tr class="separator:a16575a017d153499fe4a0976e801be61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab572dfa4b65db43984f1572d74a94036"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ab572dfa4b65db43984f1572d74a94036"><td class="memTemplItemLeft" align="right" valign="top">google::protobuf::Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab572dfa4b65db43984f1572d74a94036">value_cast&lt; bool &gt;</a> (const bool &amp;wrap)</td></tr>
<tr class="separator:ab572dfa4b65db43984f1572d74a94036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16fdb4078f95e252450a80a1e9e14f2"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac16fdb4078f95e252450a80a1e9e14f2"><td class="memTemplItemLeft" align="right" valign="top">google::protobuf::Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac16fdb4078f95e252450a80a1e9e14f2">value_cast&lt; double &gt;</a> (const double &amp;wrap)</td></tr>
<tr class="separator:ac16fdb4078f95e252450a80a1e9e14f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e6a112ff1115272420d46ca4316f63"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a51e6a112ff1115272420d46ca4316f63"><td class="memTemplItemLeft" align="right" valign="top">google::protobuf::Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a51e6a112ff1115272420d46ca4316f63">value_cast&lt; string &gt;</a> (const string &amp;wrap)</td></tr>
<tr class="separator:a51e6a112ff1115272420d46ca4316f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12109d27c9801031e32a408e75af2bd1"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a12109d27c9801031e32a408e75af2bd1"><td class="memTemplItemLeft" align="right" valign="top">Container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a12109d27c9801031e32a408e75af2bd1">value_cast</a> (const google::protobuf::Value &amp;value)</td></tr>
<tr class="memdesc:a12109d27c9801031e32a408e75af2bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a Protobuf generic Value to any type.  <a href="#a12109d27c9801031e32a408e75af2bd1">More...</a><br/></td></tr>
<tr class="separator:a12109d27c9801031e32a408e75af2bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca53457219a2ced000f439df5bd0d71f"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:aca53457219a2ced000f439df5bd0d71f"><td class="memTemplItemLeft" align="right" valign="top">google::protobuf::Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#aca53457219a2ced000f439df5bd0d71f">value_cast</a> (const Container &amp;wrap)</td></tr>
<tr class="separator:aca53457219a2ced000f439df5bd0d71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc9c4d4d792e1e7f38c2c6009207706"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7cc9c4d4d792e1e7f38c2c6009207706">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="structvg_1_1BenchmarkResult.html">BenchmarkResult</a> &amp;result)</td></tr>
<tr class="separator:a7cc9c4d4d792e1e7f38c2c6009207706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71046fb34dc43f0a3e102e1394ce8697"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a71046fb34dc43f0a3e102e1394ce8697">benchmark_control</a> ()</td></tr>
<tr class="separator:a71046fb34dc43f0a3e102e1394ce8697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac101c453ab2076d74f0324f73d174695"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1BenchmarkResult.html">BenchmarkResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac101c453ab2076d74f0324f73d174695">run_benchmark</a> (const string &amp;name, size_t iterations, const function&lt; void(void)&gt; &amp;under_test)</td></tr>
<tr class="separator:ac101c453ab2076d74f0324f73d174695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:added44ff3bb1c0ce606563a40923c513"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1BenchmarkResult.html">BenchmarkResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#added44ff3bb1c0ce606563a40923c513">run_benchmark</a> (const string &amp;name, size_t iterations, const function&lt; void(void)&gt; &amp;setup, const function&lt; void(void)&gt; &amp;under_test)</td></tr>
<tr class="separator:added44ff3bb1c0ce606563a40923c513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b89433618346e971606020965b10ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a34b89433618346e971606020965b10ed">build_gcsa_lcp</a> (const <a class="el" href="classvg_1_1HandleGraph.html">HandleGraph</a> &amp;graph, gcsa::GCSA *&amp;gcsa, gcsa::LCPArray *&amp;lcp, int kmer_size, size_t doubling_steps, size_t size_limit, const string &amp;base_file_name)</td></tr>
<tr class="separator:a34b89433618346e971606020965b10ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade346bce814fece7984fbe841cce8063"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ade346bce814fece7984fbe841cce8063">xg_cached_node</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>, <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgidx, LRUCache&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, <a class="el" href="structvg_1_1Node.html">Node</a> &gt; &amp;node_cache)</td></tr>
<tr class="separator:ade346bce814fece7984fbe841cce8063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5706d56f6ae537ad6ffe60ae55a16644"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a5706d56f6ae537ad6ffe60ae55a16644">xg_cached_edges_of</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>, <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgidx, LRUCache&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> &gt; &gt; &amp;edge_cache)</td></tr>
<tr class="separator:a5706d56f6ae537ad6ffe60ae55a16644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280cd654eb74ab3e214cd485d6db0816"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a280cd654eb74ab3e214cd485d6db0816">xg_cached_edges_on_start</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>, <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgidx, LRUCache&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> &gt; &gt; &amp;edge_cache)</td></tr>
<tr class="separator:a280cd654eb74ab3e214cd485d6db0816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1fb4fd7cf939c646ca6b14325ca128"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afa1fb4fd7cf939c646ca6b14325ca128">xg_cached_edges_on_end</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>, <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgidx, LRUCache&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> &gt; &gt; &amp;edge_cache)</td></tr>
<tr class="separator:afa1fb4fd7cf939c646ca6b14325ca128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cbe2762b34b22c3752259dc7843b3b"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae0cbe2762b34b22c3752259dc7843b3b">xg_cached_node_sequence</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>, <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgidx, LRUCache&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, <a class="el" href="structvg_1_1Node.html">Node</a> &gt; &amp;node_cache)</td></tr>
<tr class="separator:ae0cbe2762b34b22c3752259dc7843b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f867e47afc5277d494355a4be810957"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3f867e47afc5277d494355a4be810957">xg_cached_node_length</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>, <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgidx, LRUCache&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, <a class="el" href="structvg_1_1Node.html">Node</a> &gt; &amp;node_cache)</td></tr>
<tr class="memdesc:a3f867e47afc5277d494355a4be810957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a> from an <a class="el" href="classxg_1_1XG.html">xg::XG</a> index, with cacheing of deserialized nodes.  <a href="#a3f867e47afc5277d494355a4be810957">More...</a><br/></td></tr>
<tr class="separator:a3f867e47afc5277d494355a4be810957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883b08d376012aafd5653da7d384a859"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a883b08d376012aafd5653da7d384a859">xg_cached_node_start</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>, <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgidx, LRUCache&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, int64_t &gt; &amp;node_start_cache)</td></tr>
<tr class="memdesc:a883b08d376012aafd5653da7d384a859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node start position in the sequence vector.  <a href="#a883b08d376012aafd5653da7d384a859">More...</a><br/></td></tr>
<tr class="separator:a883b08d376012aafd5653da7d384a859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5473152cd3961a2b2a08ec7a294bffe1"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a5473152cd3961a2b2a08ec7a294bffe1">xg_cached_pos_char</a> (<a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> pos, <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgidx, LRUCache&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, <a class="el" href="structvg_1_1Node.html">Node</a> &gt; &amp;node_cache)</td></tr>
<tr class="memdesc:a5473152cd3961a2b2a08ec7a294bffe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the character at a position in an <a class="el" href="classxg_1_1XG.html">xg::XG</a> index, with cacheing of deserialized nodes.  <a href="#a5473152cd3961a2b2a08ec7a294bffe1">More...</a><br/></td></tr>
<tr class="separator:a5473152cd3961a2b2a08ec7a294bffe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8bc6a314b6acfc67c019060ee1068c9"><td class="memItemLeft" align="right" valign="top">map&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>, char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab8bc6a314b6acfc67c019060ee1068c9">xg_cached_next_pos_chars</a> (<a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> pos, <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgidx, LRUCache&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, <a class="el" href="structvg_1_1Node.html">Node</a> &gt; &amp;node_cache, LRUCache&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> &gt; &gt; &amp;edge_cache)</td></tr>
<tr class="memdesc:ab8bc6a314b6acfc67c019060ee1068c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the characters at positions after the given position from an <a class="el" href="classxg_1_1XG.html">xg::XG</a> index, with cacheing of deserialized nodes.  <a href="#ab8bc6a314b6acfc67c019060ee1068c9">More...</a><br/></td></tr>
<tr class="separator:ab8bc6a314b6acfc67c019060ee1068c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223d4edec998d7a1f1ad22c4b4344e1c"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a223d4edec998d7a1f1ad22c4b4344e1c">xg_cached_next_pos</a> (<a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> pos, bool whole_node, <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgidx, LRUCache&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, <a class="el" href="structvg_1_1Node.html">Node</a> &gt; &amp;node_cache, LRUCache&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> &gt; &gt; &amp;edge_cache)</td></tr>
<tr class="separator:a223d4edec998d7a1f1ad22c4b4344e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d1e76d40f6ffb18441a58d57d34e0a"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a33d1e76d40f6ffb18441a58d57d34e0a">xg_cached_distance</a> (<a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> pos1, <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> pos2, int64_t maximum, <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgidx, LRUCache&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, <a class="el" href="structvg_1_1Node.html">Node</a> &gt; &amp;node_cache, LRUCache&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> &gt; &gt; &amp;edge_cache)</td></tr>
<tr class="separator:a33d1e76d40f6ffb18441a58d57d34e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a907acff2a5f9fbdf66b8373792a2e"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa8a907acff2a5f9fbdf66b8373792a2e">xg_cached_positions_bp_from</a> (<a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> pos, int64_t distance, bool rev, <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgidx, LRUCache&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, <a class="el" href="structvg_1_1Node.html">Node</a> &gt; &amp;node_cache, LRUCache&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> &gt; &gt; &amp;edge_cache)</td></tr>
<tr class="separator:aa8a907acff2a5f9fbdf66b8373792a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa539af4f481d4e955ede26ee85c320c5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa539af4f481d4e955ede26ee85c320c5">mergeNodeObjects</a> (void *a, void *b)</td></tr>
<tr class="separator:aa539af4f481d4e955ede26ee85c320c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc613a63afb3f23851c96494006630d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2dc613a63afb3f23851c96494006630d">getReachableBridges2</a> (stCactusEdgeEnd *edgeEnd1, stHash *bridgeEndsToBridgeNodes, stList *bridgeEnds)</td></tr>
<tr class="separator:a2dc613a63afb3f23851c96494006630d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af601021f7ec2c0b0d7404030ee7271c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af601021f7ec2c0b0d7404030ee7271c9">getReachableBridges</a> (stCactusEdgeEnd *edgeEnd1, stList *bridgeEnds)</td></tr>
<tr class="separator:af601021f7ec2c0b0d7404030ee7271c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948a49f6716e35c8da05e84497dc01e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a948a49f6716e35c8da05e84497dc01e4">addArbitraryTelomerePair</a> (vector&lt; stCactusEdgeEnd * &gt; ends, stList *telomeres)</td></tr>
<tr class="separator:a948a49f6716e35c8da05e84497dc01e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6d7cffb12deb3ea3f7ae293755edf4"><td class="memItemLeft" align="right" valign="top">pair&lt; stCactusGraph *, stList * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2a6d7cffb12deb3ea3f7ae293755edf4">handle_graph_to_cactus</a> (<a class="el" href="classvg_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;graph, const unordered_set&lt; string &gt; &amp;hint_paths)</td></tr>
<tr class="separator:a2a6d7cffb12deb3ea3f7ae293755edf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf53e86632a6d1d4b54370e6d948d08c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1VG.html">VG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#adf53e86632a6d1d4b54370e6d948d08c">cactus_to_vg</a> (stCactusGraph *cactus_graph)</td></tr>
<tr class="separator:adf53e86632a6d1d4b54370e6d948d08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d05bc207717708d48e1da09f83eec6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1VG.html">VG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa4d05bc207717708d48e1da09f83eec6">cactusify</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;graph)</td></tr>
<tr class="separator:aa4d05bc207717708d48e1da09f83eec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab166cf79239664721ff1768e331f43ce"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; gcsa::node_type, <br class="typebreak"/>
size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab166cf79239664721ff1768e331f43ce">mem_node_start_positions</a> (const <a class="el" href="classxg_1_1XG.html">xg::XG</a> &amp;xg, const <a class="el" href="classvg_1_1MaximalExactMatch.html">vg::MaximalExactMatch</a> &amp;mem)</td></tr>
<tr class="memdesc:ab166cf79239664721ff1768e331f43ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the handles that a mem covers  <a href="#ab166cf79239664721ff1768e331f43ce">More...</a><br/></td></tr>
<tr class="separator:ab166cf79239664721ff1768e331f43ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3763744eb52f4ac12c14443e6ce31623"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3763744eb52f4ac12c14443e6ce31623">cluster_subgraph_walk</a> (const <a class="el" href="classxg_1_1XG.html">xg::XG</a> &amp;xg, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">vg::MaximalExactMatch</a> &gt; &amp;mems, double expansion)</td></tr>
<tr class="memdesc:a3763744eb52f4ac12c14443e6ce31623"><td class="mdescLeft">&#160;</td><td class="mdescRight">use walking to get the hits  <a href="#a3763744eb52f4ac12c14443e6ce31623">More...</a><br/></td></tr>
<tr class="separator:a3763744eb52f4ac12c14443e6ce31623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de30198879002058213d22de2ce3b4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a6de30198879002058213d22de2ce3b4b">cluster_subgraph</a> (const <a class="el" href="classxg_1_1XG.html">xg::XG</a> &amp;xg, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">vg::MaximalExactMatch</a> &gt; &amp;mems, double expansion)</td></tr>
<tr class="memdesc:a6de30198879002058213d22de2ce3b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a subgraph form an xg for a cluster of MEMs from the given alignment  <a href="#a6de30198879002058213d22de2ce3b4b">More...</a><br/></td></tr>
<tr class="separator:a6de30198879002058213d22de2ce3b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55dd67908e8c8a11e0d9effcb5aa725"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af55dd67908e8c8a11e0d9effcb5aa725">cluster_subgraph</a> (const <a class="el" href="classxg_1_1XG.html">xg::XG</a> &amp;xg, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, double expansion)</td></tr>
<tr class="memdesc:af55dd67908e8c8a11e0d9effcb5aa725"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a subgraph form an xg for a cluster of MEMs from the given alignment  <a href="#af55dd67908e8c8a11e0d9effcb5aa725">More...</a><br/></td></tr>
<tr class="separator:af55dd67908e8c8a11e0d9effcb5aa725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5674e45f23020370046d49c674fd691f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5674e45f23020370046d49c674fd691f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a5674e45f23020370046d49c674fd691f">convert</a> (const std::string &amp;s, T &amp;r)</td></tr>
<tr class="separator:a5674e45f23020370046d49c674fd691f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b1ca8b13ad1732d0679723bb206f18"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad7b1ca8b13ad1732d0679723bb206f18"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad7b1ca8b13ad1732d0679723bb206f18">convert</a> (const T &amp;r)</td></tr>
<tr class="separator:ad7b1ca8b13ad1732d0679723bb206f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d771862cc44504508267240462cb043"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8d771862cc44504508267240462cb043">stacktrace_manually</a> (ostream &amp;out, int signalNumber, void *ip, void **bp)</td></tr>
<tr class="separator:a8d771862cc44504508267240462cb043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40556998a17c0f59c8ecc682af3a99a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a40556998a17c0f59c8ecc682af3a99a3">emit_stacktrace</a> (int signalNumber, siginfo_t *signalInfo, void *signalContext)</td></tr>
<tr class="memdesc:a40556998a17c0f59c8ecc682af3a99a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a stack trace when something bad happens. Add as a signal handler with sigaction.  <a href="#a40556998a17c0f59c8ecc682af3a99a3">More...</a><br/></td></tr>
<tr class="separator:a40556998a17c0f59c8ecc682af3a99a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4461f901aba4b67353768ee25e23d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1f4461f901aba4b67353768ee25e23d7">enable_crash_handling</a> ()</td></tr>
<tr class="memdesc:a1f4461f901aba4b67353768ee25e23d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main should call this to turn on our stack tracing support.  <a href="#a1f4461f901aba4b67353768ee25e23d7">More...</a><br/></td></tr>
<tr class="separator:a1f4461f901aba4b67353768ee25e23d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05748ab256c93e2393252aa8ebbdde3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a05748ab256c93e2393252aa8ebbdde3d">gamma_ln</a> (<a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> x)</td></tr>
<tr class="separator:a05748ab256c93e2393252aa8ebbdde3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a32f7feb38c9f86d7796f0b4f1dac7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a54a32f7feb38c9f86d7796f0b4f1dac7">factorial_ln</a> (int n)</td></tr>
<tr class="separator:a54a32f7feb38c9f86d7796f0b4f1dac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7a8c98d80a9daacbc72386bc6ad00c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3a7a8c98d80a9daacbc72386bc6ad00c">pow_ln</a> (<a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> m, int n)</td></tr>
<tr class="separator:a3a7a8c98d80a9daacbc72386bc6ad00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf777e701e331bb422d91135a13408d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#abf777e701e331bb422d91135a13408d2">choose_ln</a> (int n, int k)</td></tr>
<tr class="separator:abf777e701e331bb422d91135a13408d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f09f05f7894863e9cd852c63266078"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a15f09f05f7894863e9cd852c63266078">multinomial_choose_ln</a> (int n, vector&lt; int &gt; k)</td></tr>
<tr class="separator:a15f09f05f7894863e9cd852c63266078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9238b15cc78a87f27c335fc1e3627a62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9238b15cc78a87f27c335fc1e3627a62">poisson_prob_ln</a> (int observed, <a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> expected)</td></tr>
<tr class="separator:a9238b15cc78a87f27c335fc1e3627a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d69cf9a7d7e6272960fcb9f0a0a00c"><td class="memTemplParams" colspan="2">template&lt;typename ProbIn &gt; </td></tr>
<tr class="memitem:af4d69cf9a7d7e6272960fcb9f0a0a00c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#af4d69cf9a7d7e6272960fcb9f0a0a00c">multinomial_sampling_prob_ln</a> (const vector&lt; ProbIn &gt; &amp;probs, const vector&lt; int &gt; &amp;obs)</td></tr>
<tr class="separator:af4d69cf9a7d7e6272960fcb9f0a0a00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038ccb26c0c9c0a87601edc7b8b5df70"><td class="memTemplParams" colspan="2">template&lt;typename ProbIn &gt; </td></tr>
<tr class="memitem:a038ccb26c0c9c0a87601edc7b8b5df70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a038ccb26c0c9c0a87601edc7b8b5df70">binomial_cmf_ln</a> (ProbIn success_logprob, size_t trials, size_t successes)</td></tr>
<tr class="separator:a038ccb26c0c9c0a87601edc7b8b5df70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae923ee7bdb53f33511c95f66a9c2773a"><td class="memTemplParams" colspan="2">template&lt;typename ProbIn &gt; </td></tr>
<tr class="memitem:ae923ee7bdb53f33511c95f66a9c2773a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae923ee7bdb53f33511c95f66a9c2773a">geometric_sampling_prob_ln</a> (ProbIn success_logprob, size_t trials)</td></tr>
<tr class="separator:ae923ee7bdb53f33511c95f66a9c2773a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df0c35a951519aa4a74bf098a253516"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:a0df0c35a951519aa4a74bf098a253516"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0df0c35a951519aa4a74bf098a253516">advance_split</a> (Iter start, Iter end)</td></tr>
<tr class="separator:a0df0c35a951519aa4a74bf098a253516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074fcebfeb68fc970b5b2a0db3722f01"><td class="memTemplParams" colspan="2">template&lt;typename ProbIn &gt; </td></tr>
<tr class="memitem:a074fcebfeb68fc970b5b2a0db3722f01"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a074fcebfeb68fc970b5b2a0db3722f01">multinomial_censored_sampling_prob_ln</a> (const vector&lt; ProbIn &gt; &amp;probs, const unordered_map&lt; vector&lt; bool &gt;, int &gt; &amp;obs)</td></tr>
<tr class="separator:a074fcebfeb68fc970b5b2a0db3722f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f634c48d66ace99c90ed9e9adea317"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a97f634c48d66ace99c90ed9e9adea317">edit_is_match</a> (const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;e)</td></tr>
<tr class="separator:a97f634c48d66ace99c90ed9e9adea317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050347fc49e0ac78c1ab9a0d7238b3df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a050347fc49e0ac78c1ab9a0d7238b3df">edit_is_sub</a> (const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;e)</td></tr>
<tr class="separator:a050347fc49e0ac78c1ab9a0d7238b3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179a9dfaf52b28a041ecb121b89a97ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a179a9dfaf52b28a041ecb121b89a97ef">edit_is_insertion</a> (const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;e)</td></tr>
<tr class="separator:a179a9dfaf52b28a041ecb121b89a97ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5390be8a05d69c4807cb63f74d7975"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#abb5390be8a05d69c4807cb63f74d7975">edit_is_deletion</a> (const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;e)</td></tr>
<tr class="separator:abb5390be8a05d69c4807cb63f74d7975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e5aa1a7b7ef3a03f12091e9ab82940"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af2e5aa1a7b7ef3a03f12091e9ab82940">edit_is_empty</a> (const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;e)</td></tr>
<tr class="separator:af2e5aa1a7b7ef3a03f12091e9ab82940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5f2b0dfee9f62cbd472210d9ff801f"><td class="memItemLeft" align="right" valign="top">pair&lt; <a class="el" href="structvg_1_1Edit.html">Edit</a>, <a class="el" href="structvg_1_1Edit.html">Edit</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0f5f2b0dfee9f62cbd472210d9ff801f">cut_edit_at_to</a> (const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;e, size_t to_off)</td></tr>
<tr class="separator:a0f5f2b0dfee9f62cbd472210d9ff801f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21f33338c0114d3f715f0a3667f3973"><td class="memItemLeft" align="right" valign="top">pair&lt; <a class="el" href="structvg_1_1Edit.html">Edit</a>, <a class="el" href="structvg_1_1Edit.html">Edit</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac21f33338c0114d3f715f0a3667f3973">cut_edit_at_from</a> (const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;e, size_t from_off)</td></tr>
<tr class="separator:ac21f33338c0114d3f715f0a3667f3973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6cdc6eeeb82efd61650f4958566575f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Edit.html">Edit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac6cdc6eeeb82efd61650f4958566575f">reverse_complement_edit</a> (const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;e)</td></tr>
<tr class="separator:ac6cdc6eeeb82efd61650f4958566575f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6481a02a8e31c9da8862769bd7e705"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aef6481a02a8e31c9da8862769bd7e705">operator==</a> (const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;e1, const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;e2)</td></tr>
<tr class="separator:aef6481a02a8e31c9da8862769bd7e705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3165438256db24864e88601839197df"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac3165438256db24864e88601839197df">entropy</a> (const string &amp;st)</td></tr>
<tr class="separator:ac3165438256db24864e88601839197df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c1cb6069f865239d0365b55649bc8a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a77c1cb6069f865239d0365b55649bc8a">entropy</a> (const char *st, size_t len)</td></tr>
<tr class="separator:a77c1cb6069f865239d0365b55649bc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871d5cdd29e1806636314021d0b6d451"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a871d5cdd29e1806636314021d0b6d451">get_traversal_of_snarl</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;graph, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *snarl, const <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;manager, const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:a871d5cdd29e1806636314021d0b6d451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94385b32246fc81a0a44ea1b47d994ee"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a94385b32246fc81a0a44ea1b47d994ee">traversal_to_string</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;graph, const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;path)</td></tr>
<tr class="separator:a94385b32246fc81a0a44ea1b47d994ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0ae5cc687e77bb7cee28e975a005b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Support.html">Support</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1c0ae5cc687e77bb7cee28e975a005b3">make_support</a> (double forward, double <a class="el" href="namespacevg.html#ac52fd5878b0be1d53de644eea3458663">reverse</a>, double quality)</td></tr>
<tr class="separator:a1c0ae5cc687e77bb7cee28e975a005b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a064dd8829b2100c6a38780311073f3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0a064dd8829b2100c6a38780311073f3">total</a> (const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;support)</td></tr>
<tr class="separator:a0a064dd8829b2100c6a38780311073f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2ae4c37201ebbc6f6d4faaf27fe4de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Support.html">Support</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3c2ae4c37201ebbc6f6d4faaf27fe4de">support_min</a> (const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;a, const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;b)</td></tr>
<tr class="separator:a3c2ae4c37201ebbc6f6d4faaf27fe4de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3787b0a7fc02bbfe45dc5eb082d5779"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Support.html">Support</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac3787b0a7fc02bbfe45dc5eb082d5779">support_max</a> (const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;a, const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;b)</td></tr>
<tr class="separator:ac3787b0a7fc02bbfe45dc5eb082d5779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a651561299e3236ec62af61d509112"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Support.html">Support</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad8a651561299e3236ec62af61d509112">flip</a> (const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;to_flip)</td></tr>
<tr class="separator:ad8a651561299e3236ec62af61d509112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27dd5c8f7c6d984a396665cbab5eba01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Support.html">Support</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a27dd5c8f7c6d984a396665cbab5eba01">operator+</a> (const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;one, const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;other)</td></tr>
<tr class="separator:a27dd5c8f7c6d984a396665cbab5eba01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f550213560bfa3c3ad8446478be24d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4f550213560bfa3c3ad8446478be24d8">operator+=</a> (<a class="el" href="structvg_1_1Support.html">Support</a> &amp;one, const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;other)</td></tr>
<tr class="separator:a4f550213560bfa3c3ad8446478be24d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab554a977204c1f756bd0e2738a797447"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab554a977204c1f756bd0e2738a797447">operator&lt;</a> (const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;a, const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;b)</td></tr>
<tr class="separator:ab554a977204c1f756bd0e2738a797447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955d56fb4c95213de77c1fcce44c77b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a955d56fb4c95213de77c1fcce44c77b8">operator&gt;</a> (const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;a, const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;b)</td></tr>
<tr class="separator:a955d56fb4c95213de77c1fcce44c77b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141fbf9c40f389909c5c46132ab6c615"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a141fbf9c40f389909c5c46132ab6c615">operator&lt;&lt;</a> (ostream &amp;stream, const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;support)</td></tr>
<tr class="separator:a141fbf9c40f389909c5c46132ab6c615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420f2fd8ef6d04f1a34a08af2a3dee0e"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a420f2fd8ef6d04f1a34a08af2a3dee0e">to_vcf_genotype</a> (const <a class="el" href="structvg_1_1Genotype.html">Genotype</a> &amp;gt)</td></tr>
<tr class="separator:a420f2fd8ef6d04f1a34a08af2a3dee0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84dfc966c7511b05c234d215e3b6aec7"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a84dfc966c7511b05c234d215e3b6aec7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Support.html">Support</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a84dfc966c7511b05c234d215e3b6aec7">operator*</a> (const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;support, const Scalar &amp;scale)</td></tr>
<tr class="separator:a84dfc966c7511b05c234d215e3b6aec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7831ba6fe294e8be36fa0359a63848"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:abe7831ba6fe294e8be36fa0359a63848"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#abe7831ba6fe294e8be36fa0359a63848">operator*=</a> (<a class="el" href="structvg_1_1Support.html">Support</a> &amp;support, const Scalar &amp;scale)</td></tr>
<tr class="separator:abe7831ba6fe294e8be36fa0359a63848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10844a7c14d7ff54051bad20c75d012e"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a10844a7c14d7ff54051bad20c75d012e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Support.html">Support</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a10844a7c14d7ff54051bad20c75d012e">operator*</a> (const Scalar &amp;scale, const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;support)</td></tr>
<tr class="separator:a10844a7c14d7ff54051bad20c75d012e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9eefddbec41755309a378fb150071c"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a5a9eefddbec41755309a378fb150071c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Support.html">Support</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a5a9eefddbec41755309a378fb150071c">operator/</a> (const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;support, const Scalar &amp;scale)</td></tr>
<tr class="separator:a5a9eefddbec41755309a378fb150071c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1807752a0b6b83fd5952d36cc64b758d"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a1807752a0b6b83fd5952d36cc64b758d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1807752a0b6b83fd5952d36cc64b758d">operator/=</a> (<a class="el" href="structvg_1_1Support.html">Support</a> &amp;support, const Scalar &amp;scale)</td></tr>
<tr class="separator:a1807752a0b6b83fd5952d36cc64b758d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b46a0183527dc1713f3ab30ef85b185"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3b46a0183527dc1713f3ab30ef85b185">allele_to_string</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;graph, const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;allele)</td></tr>
<tr class="separator:a3b46a0183527dc1713f3ab30ef85b185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234b2ca417edb50a3c738991fcfc269a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a234b2ca417edb50a3c738991fcfc269a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a234b2ca417edb50a3c738991fcfc269a">set_intersection</a> (const unordered_set&lt; T &gt; &amp;set_1, const unordered_set&lt; T &gt; &amp;set_2, unordered_set&lt; T &gt; *out_intersection)</td></tr>
<tr class="separator:a234b2ca417edb50a3c738991fcfc269a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d681cff3270646ab87c07bbf5a8d72"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab5d681cff3270646ab87c07bbf5a8d72">stPinchSegment_getBlockOrientationSafe</a> (stPinchSegment *segment)</td></tr>
<tr class="memdesc:ab5d681cff3270646ab87c07bbf5a8d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the segment's orientation in its block (false=backward, true=forward), or true (forward) if there is no block.  <a href="#ab5d681cff3270646ab87c07bbf5a8d72">More...</a><br/></td></tr>
<tr class="separator:ab5d681cff3270646ab87c07bbf5a8d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1d1f2f3c885ddf15f941b869c3030c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#acd1d1f2f3c885ddf15f941b869c3030c">gfa_to_graph</a> (istream &amp;in, <a class="el" href="classvg_1_1VG.html">VG</a> *graph, bool only_perfect_match)</td></tr>
<tr class="separator:acd1d1f2f3c885ddf15f941b869c3030c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60786b653f375199240b023be44313d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a60786b653f375199240b023be44313d7">graph_to_gfa</a> (const <a class="el" href="classvg_1_1VG.html">VG</a> *graph, ostream &amp;out)</td></tr>
<tr class="memdesc:a60786b653f375199240b023be44313d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export the given <a class="el" href="classvg_1_1VG.html">VG</a> graph to the given GFA file.  <a href="#a60786b653f375199240b023be44313d7">More...</a><br/></td></tr>
<tr class="separator:a60786b653f375199240b023be44313d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984c1d2199f90f58677096772b870390"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a984c1d2199f90f58677096772b870390">sort_by_id_dedup_and_clean</a> (<a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a984c1d2199f90f58677096772b870390"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove duplicates and sort by id  <a href="#a984c1d2199f90f58677096772b870390">More...</a><br/></td></tr>
<tr class="separator:a984c1d2199f90f58677096772b870390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd2e49750e94ed6f9de917dd9c72ac2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aecd2e49750e94ed6f9de917dd9c72ac2">remove_duplicates</a> (<a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:aecd2e49750e94ed6f9de917dd9c72ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove duplicate nodes and edges  <a href="#aecd2e49750e94ed6f9de917dd9c72ac2">More...</a><br/></td></tr>
<tr class="separator:aecd2e49750e94ed6f9de917dd9c72ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4d3a3d1917566a8df138c80b38e548"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#add4d3a3d1917566a8df138c80b38e548">remove_duplicate_edges</a> (<a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:add4d3a3d1917566a8df138c80b38e548"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove duplicate edges  <a href="#add4d3a3d1917566a8df138c80b38e548">More...</a><br/></td></tr>
<tr class="separator:add4d3a3d1917566a8df138c80b38e548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbe8468f2f2bcf8ceb859e6a0f8b4b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a6dbe8468f2f2bcf8ceb859e6a0f8b4b1">remove_duplicate_nodes</a> (<a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a6dbe8468f2f2bcf8ceb859e6a0f8b4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove duplicate nodes  <a href="#a6dbe8468f2f2bcf8ceb859e6a0f8b4b1">More...</a><br/></td></tr>
<tr class="separator:a6dbe8468f2f2bcf8ceb859e6a0f8b4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b38f4f0d7e63b1f7f20d2dc985f88c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0b38f4f0d7e63b1f7f20d2dc985f88c4">remove_orphan_edges</a> (<a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a0b38f4f0d7e63b1f7f20d2dc985f88c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove edges that link to a node that is not in the graph  <a href="#a0b38f4f0d7e63b1f7f20d2dc985f88c4">More...</a><br/></td></tr>
<tr class="separator:a0b38f4f0d7e63b1f7f20d2dc985f88c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25c227066a422379ff06d81b5990865"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af25c227066a422379ff06d81b5990865">sort_by_id</a> (<a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:af25c227066a422379ff06d81b5990865"><td class="mdescLeft">&#160;</td><td class="mdescRight">order the nodes and edges in the graph by id  <a href="#af25c227066a422379ff06d81b5990865">More...</a><br/></td></tr>
<tr class="separator:af25c227066a422379ff06d81b5990865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb37b16823e6e26cfd8571a1bb621651"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afb37b16823e6e26cfd8571a1bb621651">sort_nodes_by_id</a> (<a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:afb37b16823e6e26cfd8571a1bb621651"><td class="mdescLeft">&#160;</td><td class="mdescRight">order the nodes in the graph by id  <a href="#afb37b16823e6e26cfd8571a1bb621651">More...</a><br/></td></tr>
<tr class="separator:afb37b16823e6e26cfd8571a1bb621651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cc117e3ac781c77cf8fdaa7802048b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a90cc117e3ac781c77cf8fdaa7802048b">sort_edges_by_id</a> (<a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a90cc117e3ac781c77cf8fdaa7802048b"><td class="mdescLeft">&#160;</td><td class="mdescRight">order the edges in the graph by id pairs  <a href="#a90cc117e3ac781c77cf8fdaa7802048b">More...</a><br/></td></tr>
<tr class="separator:a90cc117e3ac781c77cf8fdaa7802048b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5570a5685bef6eee6ac2697920ebc6c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a5570a5685bef6eee6ac2697920ebc6c0">is_id_sortable</a> (const <a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a5570a5685bef6eee6ac2697920ebc6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the graph is id-sortable (no reverse links)  <a href="#a5570a5685bef6eee6ac2697920ebc6c0">More...</a><br/></td></tr>
<tr class="separator:a5570a5685bef6eee6ac2697920ebc6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b545f6474c6e528176031149a8bc570"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1b545f6474c6e528176031149a8bc570">has_inversion</a> (const <a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a1b545f6474c6e528176031149a8bc570"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if we find an edge that may specify an inversion  <a href="#a1b545f6474c6e528176031149a8bc570">More...</a><br/></td></tr>
<tr class="separator:a1b545f6474c6e528176031149a8bc570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c2bb28b708cb4acf67eabfaa4b0168"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a89c2bb28b708cb4acf67eabfaa4b0168">flip_doubly_reversed_edges</a> (<a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a89c2bb28b708cb4acf67eabfaa4b0168"><td class="mdescLeft">&#160;</td><td class="mdescRight">clean up doubly-reversed edges  <a href="#a89c2bb28b708cb4acf67eabfaa4b0168">More...</a><br/></td></tr>
<tr class="separator:a89c2bb28b708cb4acf67eabfaa4b0168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5371479058860d693988710d54156e2f"><td class="memItemLeft" align="right" valign="top">uint64_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a5371479058860d693988710d54156e2f">as_integer</a> (<a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;handle)</td></tr>
<tr class="memdesc:a5371479058860d693988710d54156e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">View a handle as an integer.  <a href="#a5371479058860d693988710d54156e2f">More...</a><br/></td></tr>
<tr class="separator:a5371479058860d693988710d54156e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929e2dd773c4903310e2aa66e583bbf5"><td class="memItemLeft" align="right" valign="top">const uint64_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a929e2dd773c4903310e2aa66e583bbf5">as_integer</a> (const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;handle)</td></tr>
<tr class="memdesc:a929e2dd773c4903310e2aa66e583bbf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">View a const handle as a const integer.  <a href="#a929e2dd773c4903310e2aa66e583bbf5">More...</a><br/></td></tr>
<tr class="separator:a929e2dd773c4903310e2aa66e583bbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a42fa986c71fc55eac583efbb06099"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa4a42fa986c71fc55eac583efbb06099">as_handle</a> (uint64_t &amp;value)</td></tr>
<tr class="memdesc:aa4a42fa986c71fc55eac583efbb06099"><td class="mdescLeft">&#160;</td><td class="mdescRight">View an integer as a handle.  <a href="#aa4a42fa986c71fc55eac583efbb06099">More...</a><br/></td></tr>
<tr class="separator:aa4a42fa986c71fc55eac583efbb06099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3489366dd7da532de38d699f14c8b8ac"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3489366dd7da532de38d699f14c8b8ac">as_handle</a> (const uint64_t &amp;value)</td></tr>
<tr class="memdesc:a3489366dd7da532de38d699f14c8b8ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">View a const integer as a const handle.  <a href="#a3489366dd7da532de38d699f14c8b8ac">More...</a><br/></td></tr>
<tr class="separator:a3489366dd7da532de38d699f14c8b8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf943805c4b8a16e5852d9168faa2558"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aaf943805c4b8a16e5852d9168faa2558">operator==</a> (const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;a, const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;b)</td></tr>
<tr class="memdesc:aaf943805c4b8a16e5852d9168faa2558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define equality on handles.  <a href="#aaf943805c4b8a16e5852d9168faa2558">More...</a><br/></td></tr>
<tr class="separator:aaf943805c4b8a16e5852d9168faa2558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67330944ed89a02074373b18253ea603"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a67330944ed89a02074373b18253ea603">operator!=</a> (const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;a, const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;b)</td></tr>
<tr class="memdesc:a67330944ed89a02074373b18253ea603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define inequality on handles.  <a href="#a67330944ed89a02074373b18253ea603">More...</a><br/></td></tr>
<tr class="separator:a67330944ed89a02074373b18253ea603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24378aaa280058f30fba353c35838672"><td class="memItemLeft" align="right" valign="top">int64_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a24378aaa280058f30fba353c35838672">as_integer</a> (<a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle)</td></tr>
<tr class="memdesc:a24378aaa280058f30fba353c35838672"><td class="mdescLeft">&#160;</td><td class="mdescRight">View a path handle as an integer.  <a href="#a24378aaa280058f30fba353c35838672">More...</a><br/></td></tr>
<tr class="separator:a24378aaa280058f30fba353c35838672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d0323f2d1456730663d3ccd69f533c"><td class="memItemLeft" align="right" valign="top">const int64_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad3d0323f2d1456730663d3ccd69f533c">as_integer</a> (const <a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle)</td></tr>
<tr class="memdesc:ad3d0323f2d1456730663d3ccd69f533c"><td class="mdescLeft">&#160;</td><td class="mdescRight">View a const path handle as a const integer.  <a href="#ad3d0323f2d1456730663d3ccd69f533c">More...</a><br/></td></tr>
<tr class="separator:ad3d0323f2d1456730663d3ccd69f533c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ec713923bfa35f80558524ed024c78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad5ec713923bfa35f80558524ed024c78">as_path_handle</a> (int64_t &amp;value)</td></tr>
<tr class="memdesc:ad5ec713923bfa35f80558524ed024c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">View an integer as a path handle.  <a href="#ad5ec713923bfa35f80558524ed024c78">More...</a><br/></td></tr>
<tr class="separator:ad5ec713923bfa35f80558524ed024c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b3d74458047408bc21360ebe36d06d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af3b3d74458047408bc21360ebe36d06d">as_path_handle</a> (const int64_t &amp;value)</td></tr>
<tr class="memdesc:af3b3d74458047408bc21360ebe36d06d"><td class="mdescLeft">&#160;</td><td class="mdescRight">View a const integer as a const path handle.  <a href="#af3b3d74458047408bc21360ebe36d06d">More...</a><br/></td></tr>
<tr class="separator:af3b3d74458047408bc21360ebe36d06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422ed05af6be2bde2cce68a45e60b664"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a422ed05af6be2bde2cce68a45e60b664">operator==</a> (const <a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a> &amp;a, const <a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a> &amp;b)</td></tr>
<tr class="memdesc:a422ed05af6be2bde2cce68a45e60b664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define equality on path handles.  <a href="#a422ed05af6be2bde2cce68a45e60b664">More...</a><br/></td></tr>
<tr class="separator:a422ed05af6be2bde2cce68a45e60b664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996b75a4d8bfba1de1d286ec91e9d63a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a996b75a4d8bfba1de1d286ec91e9d63a">operator!=</a> (const <a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a> &amp;a, const <a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a> &amp;b)</td></tr>
<tr class="memdesc:a996b75a4d8bfba1de1d286ec91e9d63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define inequality on path handles.  <a href="#a996b75a4d8bfba1de1d286ec91e9d63a">More...</a><br/></td></tr>
<tr class="separator:a996b75a4d8bfba1de1d286ec91e9d63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452168726a0c91d15efd88b3b67f227a"><td class="memItemLeft" align="right" valign="top">int64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a452168726a0c91d15efd88b3b67f227a">as_integers</a> (<a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;occurrence_handle)</td></tr>
<tr class="memdesc:a452168726a0c91d15efd88b3b67f227a"><td class="mdescLeft">&#160;</td><td class="mdescRight">View an occurrence handle as an integer.  <a href="#a452168726a0c91d15efd88b3b67f227a">More...</a><br/></td></tr>
<tr class="separator:a452168726a0c91d15efd88b3b67f227a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31278b67bd98569e13f12dca47ebec79"><td class="memItemLeft" align="right" valign="top">const int64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a31278b67bd98569e13f12dca47ebec79">as_integers</a> (const <a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;occurrence_handle)</td></tr>
<tr class="memdesc:a31278b67bd98569e13f12dca47ebec79"><td class="mdescLeft">&#160;</td><td class="mdescRight">View a const occurrence handle as a const integer.  <a href="#a31278b67bd98569e13f12dca47ebec79">More...</a><br/></td></tr>
<tr class="separator:a31278b67bd98569e13f12dca47ebec79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198a65c2e7235bb674a9e13485d0db8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a198a65c2e7235bb674a9e13485d0db8a">operator==</a> (const <a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;a, const <a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;b)</td></tr>
<tr class="memdesc:a198a65c2e7235bb674a9e13485d0db8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define equality on occurrence handles.  <a href="#a198a65c2e7235bb674a9e13485d0db8a">More...</a><br/></td></tr>
<tr class="separator:a198a65c2e7235bb674a9e13485d0db8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab079eab67b88bbf3c28e43d3dcf5690f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab079eab67b88bbf3c28e43d3dcf5690f">operator!=</a> (const <a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;a, const <a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;b)</td></tr>
<tr class="memdesc:ab079eab67b88bbf3c28e43d3dcf5690f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define inequality on occurrence handles.  <a href="#ab079eab67b88bbf3c28e43d3dcf5690f">More...</a><br/></td></tr>
<tr class="separator:ab079eab67b88bbf3c28e43d3dcf5690f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfbbf25510f3a739532e075c2d59041a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1VG.html">VG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#adfbbf25510f3a739532e075c2d59041a">handle_to_vg</a> (const <a class="el" href="classvg_1_1HandleGraph.html">HandleGraph</a> *g)</td></tr>
<tr class="memdesc:adfbbf25510f3a739532e075c2d59041a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes in a pointer to a <a class="el" href="classvg_1_1HandleGraph.html">HandleGraph</a> and converts it to a <a class="el" href="classvg_1_1VG.html">VG</a> graph.  <a href="#adfbbf25510f3a739532e075c2d59041a">More...</a><br/></td></tr>
<tr class="separator:adfbbf25510f3a739532e075c2d59041a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa834f81743ae8666dd9071ce1b6443"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2fa834f81743ae8666dd9071ce1b6443">trace_haplotypes_and_paths</a> (<a class="el" href="classxg_1_1XG.html">xg::XG</a> &amp;index, const gbwt::GBWT *haplotype_database, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">vg::id_t</a> start_node, int extend_distance, <a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;out_graph, map&lt; string, int &gt; &amp;out_thread_frequencies, bool expand_graph)</td></tr>
<tr class="separator:a2fa834f81743ae8666dd9071ce1b6443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e505bf6d9321002a3bb2dd06423cd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae2e505bf6d9321002a3bb2dd06423cd1">output_haplotype_counts</a> (ostream &amp;annotation_ostream, vector&lt; pair&lt; <a class="el" href="namespacevg.html#a101965168ba874bb68cb69198dbf84d0">thread_t</a>, int &gt;&gt; &amp;haplotype_list, <a class="el" href="classxg_1_1XG.html">xg::XG</a> &amp;index)</td></tr>
<tr class="separator:ae2e505bf6d9321002a3bb2dd06423cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49a3c569a0de687ff444e802d9bfcc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af49a3c569a0de687ff444e802d9bfcc2">output_graph_with_embedded_paths</a> (vector&lt; pair&lt; <a class="el" href="namespacevg.html#a101965168ba874bb68cb69198dbf84d0">thread_t</a>, int &gt;&gt; &amp;haplotype_list, <a class="el" href="classxg_1_1XG.html">xg::XG</a> &amp;index)</td></tr>
<tr class="separator:af49a3c569a0de687ff444e802d9bfcc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25eb12b5c4ae3b18961b6fdbd19f13a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a25eb12b5c4ae3b18961b6fdbd19f13a8">output_graph_with_embedded_paths</a> (ostream &amp;subgraph_ostream, vector&lt; pair&lt; <a class="el" href="namespacevg.html#a101965168ba874bb68cb69198dbf84d0">thread_t</a>, int &gt;&gt; &amp;haplotype_list, <a class="el" href="classxg_1_1XG.html">xg::XG</a> &amp;index, bool json)</td></tr>
<tr class="separator:a25eb12b5c4ae3b18961b6fdbd19f13a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f6522436ea7320bf6728fe47451151"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad3f6522436ea7320bf6728fe47451151">thread_to_graph_spanned</a> (<a class="el" href="namespacevg.html#a101965168ba874bb68cb69198dbf84d0">thread_t</a> &amp;t, <a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;g, <a class="el" href="classxg_1_1XG.html">xg::XG</a> &amp;index)</td></tr>
<tr class="separator:ad3f6522436ea7320bf6728fe47451151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2adfa9e81b2553fefdd5e1d6b24c7a77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2adfa9e81b2553fefdd5e1d6b24c7a77">add_thread_nodes_to_set</a> (<a class="el" href="namespacevg.html#a101965168ba874bb68cb69198dbf84d0">thread_t</a> &amp;t, set&lt; int64_t &gt; &amp;nodes)</td></tr>
<tr class="separator:a2adfa9e81b2553fefdd5e1d6b24c7a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2d6096dfe672a486e44df018c713c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afe2d6096dfe672a486e44df018c713c2">add_thread_edges_to_set</a> (<a class="el" href="namespacevg.html#a101965168ba874bb68cb69198dbf84d0">thread_t</a> &amp;t, set&lt; pair&lt; int, int &gt; &gt; &amp;edges)</td></tr>
<tr class="separator:afe2d6096dfe672a486e44df018c713c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4eda7e05e5737af72556a59e4bba8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7f4eda7e05e5737af72556a59e4bba8f">construct_graph_from_nodes_and_edges</a> (<a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;g, <a class="el" href="classxg_1_1XG.html">xg::XG</a> &amp;index, set&lt; int64_t &gt; &amp;nodes, set&lt; pair&lt; int, int &gt; &gt; &amp;edges)</td></tr>
<tr class="separator:a7f4eda7e05e5737af72556a59e4bba8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18466ce6693ea51859957c9d23e91e72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a18466ce6693ea51859957c9d23e91e72">path_from_thread_t</a> (<a class="el" href="namespacevg.html#a101965168ba874bb68cb69198dbf84d0">thread_t</a> &amp;t, <a class="el" href="classxg_1_1XG.html">xg::XG</a> &amp;index)</td></tr>
<tr class="separator:a18466ce6693ea51859957c9d23e91e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8a42961530e37f3cebdb59ba4e8010"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a101965168ba874bb68cb69198dbf84d0">thread_t</a>, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9b8a42961530e37f3cebdb59ba4e8010">list_haplotypes</a> (<a class="el" href="classxg_1_1XG.html">xg::XG</a> &amp;index, <a class="el" href="structxg_1_1XG_1_1ThreadMapping.html">xg::XG::ThreadMapping</a> start_node, int extend_distance)</td></tr>
<tr class="separator:a9b8a42961530e37f3cebdb59ba4e8010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475f13479c0cfe87feb6ed287ca2a5ca"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a101965168ba874bb68cb69198dbf84d0">thread_t</a>, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a475f13479c0cfe87feb6ed287ca2a5ca">list_haplotypes</a> (<a class="el" href="classxg_1_1XG.html">xg::XG</a> &amp;index, const gbwt::GBWT &amp;haplotype_database, <a class="el" href="structxg_1_1XG_1_1ThreadMapping.html">xg::XG::ThreadMapping</a> start_node, int extend_distance)</td></tr>
<tr class="separator:a475f13479c0cfe87feb6ed287ca2a5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d35bca25e8a6d5fe10f603cb9048c3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a38d35bca25e8a6d5fe10f603cb9048c3">wang_hash_64</a> (size_t key)</td></tr>
<tr class="separator:a38d35bca25e8a6d5fe10f603cb9048c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64eca16947663155295546927b631e56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a64eca16947663155295546927b631e56">node_path_position</a> (int64_t <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>, string &amp;path_name, int64_t &amp;position, bool backward, int64_t &amp;<a class="el" href="namespacevg.html#a416939020600ce2996331c350f1fe68c">offset</a>)</td></tr>
<tr class="separator:a64eca16947663155295546927b631e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad3588bcc84b46c6ed107e604f9128e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3ad3588bcc84b46c6ed107e604f9128e">index_positions</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;graph, map&lt; long, <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;node_path, map&lt; long, <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;edge_path)</td></tr>
<tr class="separator:a3ad3588bcc84b46c6ed107e604f9128e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2dc76ed1d84a8e2043955ba3c8a9bb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad2dc76ed1d84a8e2043955ba3c8a9bb7">for_each_kmer</a> (const <a class="el" href="classvg_1_1HandleGraph.html">HandleGraph</a> &amp;graph, size_t k, const function&lt; void(const <a class="el" href="structvg_1_1kmer__t.html">kmer_t</a> &amp;)&gt; &amp;lambda, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> head_id=0, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> tail_id=0)</td></tr>
<tr class="memdesc:ad2dc76ed1d84a8e2043955ba3c8a9bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all the kmers in the graph, running lambda on each.  <a href="#ad2dc76ed1d84a8e2043955ba3c8a9bb7">More...</a><br/></td></tr>
<tr class="separator:ad2dc76ed1d84a8e2043955ba3c8a9bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e459d4a7dda13edf5b79ea8996cfd82"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0e459d4a7dda13edf5b79ea8996cfd82">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="structvg_1_1kmer__t.html">kmer_t</a> &amp;kmer)</td></tr>
<tr class="memdesc:a0e459d4a7dda13edf5b79ea8996cfd82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a <a class="el" href="structvg_1_1kmer__t.html">kmer_t</a> to a stream.  <a href="#a0e459d4a7dda13edf5b79ea8996cfd82">More...</a><br/></td></tr>
<tr class="separator:a0e459d4a7dda13edf5b79ea8996cfd82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661fc17618ee9ff7bd9d469c74c63369"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a661fc17618ee9ff7bd9d469c74c63369">kmer_to_gcsa_kmers</a> (const <a class="el" href="structvg_1_1kmer__t.html">kmer_t</a> &amp;kmer, const gcsa::Alphabet &amp;alpha, const function&lt; void(const gcsa::KMer &amp;)&gt; &amp;lambda)</td></tr>
<tr class="memdesc:a661fc17618ee9ff7bd9d469c74c63369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the <a class="el" href="structvg_1_1kmer__t.html">kmer_t</a> to a set of gcsa2 binary kmers which are exposed via a callback.  <a href="#a661fc17618ee9ff7bd9d469c74c63369">More...</a><br/></td></tr>
<tr class="separator:a661fc17618ee9ff7bd9d469c74c63369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25419c15b3dcae6b217f893c243c487"><td class="memItemLeft" align="right" valign="top">gcsa::byte_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa25419c15b3dcae6b217f893c243c487">encode_chars</a> (const vector&lt; char &gt; &amp;chars, const gcsa::Alphabet &amp;alpha)</td></tr>
<tr class="memdesc:aa25419c15b3dcae6b217f893c243c487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode the chars into the gcsa2 byte.  <a href="#aa25419c15b3dcae6b217f893c243c487">More...</a><br/></td></tr>
<tr class="separator:aa25419c15b3dcae6b217f893c243c487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8c71ff9f77ddd4a366119e83122771"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a6d8c71ff9f77ddd4a366119e83122771">write_gcsa_kmers</a> (const <a class="el" href="classvg_1_1HandleGraph.html">HandleGraph</a> &amp;graph, int kmer_size, ostream &amp;out, size_t &amp;size_limit, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> head_id, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> tail_id)</td></tr>
<tr class="separator:a6d8c71ff9f77ddd4a366119e83122771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d9326cbc013aed614bc052c8c224e6"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a38d9326cbc013aed614bc052c8c224e6">write_gcsa_kmers_to_tmpfile</a> (const <a class="el" href="classvg_1_1HandleGraph.html">HandleGraph</a> &amp;graph, int kmer_size, size_t &amp;size_limit, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> head_id, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> tail_id, const string &amp;base_file_name)</td></tr>
<tr class="separator:a38d9326cbc013aed614bc052c8c224e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63c41956b73af429507b469108d1759"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab63c41956b73af429507b469108d1759">sub_overlaps_of_first_aln</a> (const vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;alns, float overlap_fraction)</td></tr>
<tr class="separator:ab63c41956b73af429507b469108d1759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3240e7b9bf787fb218d6324389ea234e"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3240e7b9bf787fb218d6324389ea234e">gcsa_nodes_to_positions</a> (const vector&lt; gcsa::node_type &gt; &amp;nodes)</td></tr>
<tr class="separator:a3240e7b9bf787fb218d6324389ea234e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7211eb89509ce3ca625333936c08ec9b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7211eb89509ce3ca625333936c08ec9b">balanced_stride</a> (int read_length, int kmer_size, int stride)</td></tr>
<tr class="separator:a7211eb89509ce3ca625333936c08ec9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7caa49b187d9fc25833daa572cdf770"><td class="memItemLeft" align="right" valign="top">const vector&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab7caa49b187d9fc25833daa572cdf770">balanced_kmers</a> (const string &amp;seq, const int kmer_size, const int stride)</td></tr>
<tr class="separator:ab7caa49b187d9fc25833daa572cdf770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1678438e6011469b88ddf3b54023013"><td class="memItemLeft" align="right" valign="top">pair&lt; int64_t, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae1678438e6011469b88ddf3b54023013">mem_min_oriented_distances</a> (const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;m1, const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;m2)</td></tr>
<tr class="separator:ae1678438e6011469b88ddf3b54023013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94d73312bfd787493e87d207398d73a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af94d73312bfd787493e87d207398d73a">operator==</a> (const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;m1, const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;m2)</td></tr>
<tr class="separator:af94d73312bfd787493e87d207398d73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac476fcc21a47f34d00b4a449b28c686b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac476fcc21a47f34d00b4a449b28c686b">operator&lt;</a> (const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;m1, const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;m2)</td></tr>
<tr class="separator:ac476fcc21a47f34d00b4a449b28c686b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a4b11db620d43a7e20886d5563e5b8"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af0a4b11db620d43a7e20886d5563e5b8">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;mem)</td></tr>
<tr class="separator:af0a4b11db620d43a7e20886d5563e5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bec9992b4441128754ac4ed1a330e8"><td class="memItemLeft" align="right" valign="top">const string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab0bec9992b4441128754ac4ed1a330e8">mems_to_json</a> (const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems)</td></tr>
<tr class="separator:ab0bec9992b4441128754ac4ed1a330e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3e65f9aafb5ab9ce5455cc72fa0b56"><td class="memItemLeft" align="right" valign="top">vector&lt; string::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afe3e65f9aafb5ab9ce5455cc72fa0b56">cluster_cover</a> (const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;cluster)</td></tr>
<tr class="separator:afe3e65f9aafb5ab9ce5455cc72fa0b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3380e0f81fc879601afe493949814a4d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3380e0f81fc879601afe493949814a4d">cluster_coverage</a> (const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;cluster)</td></tr>
<tr class="separator:a3380e0f81fc879601afe493949814a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa412de4741b61d2a8b863f50f31209e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa412de4741b61d2a8b863f50f31209e0">mems_overlap</a> (const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;mem1, const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;mem2)</td></tr>
<tr class="separator:aa412de4741b61d2a8b863f50f31209e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d04132733b3487e3dab20729645850"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af5d04132733b3487e3dab20729645850">mems_overlap_length</a> (const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;mem1, const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;mem2)</td></tr>
<tr class="separator:af5d04132733b3487e3dab20729645850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67eb440256877ac857d6649052d7db1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af67eb440256877ac857d6649052d7db1">clusters_overlap_in_read</a> (const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;cluster1, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;cluster2)</td></tr>
<tr class="separator:af67eb440256877ac857d6649052d7db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50260b7d42777dd7f352a5ba40ac655e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a50260b7d42777dd7f352a5ba40ac655e">clusters_overlap_length</a> (const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;cluster1, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;cluster2)</td></tr>
<tr class="separator:a50260b7d42777dd7f352a5ba40ac655e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c60d6eb4cafd02a45384cf71a12bfe"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af6c60d6eb4cafd02a45384cf71a12bfe">cluster_nodes</a> (const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;cluster)</td></tr>
<tr class="separator:af6c60d6eb4cafd02a45384cf71a12bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8947e51da3156529e12ae131c25a47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9d8947e51da3156529e12ae131c25a47">clusters_overlap_in_graph</a> (const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;cluster1, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;cluster2)</td></tr>
<tr class="separator:a9d8947e51da3156529e12ae131c25a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc1837d8c1cca33ab223957402b70ba"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4bc1837d8c1cca33ab223957402b70ba">translate_mems</a> (const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;trans)</td></tr>
<tr class="separator:a4bc1837d8c1cca33ab223957402b70ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb67697fd1e49bcb389a735ba9fa8f2"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9fb67697fd1e49bcb389a735ba9fa8f2">get_proc_status_value</a> (const string &amp;name)</td></tr>
<tr class="memdesc:a9fb67697fd1e49bcb389a735ba9fa8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string value for a field in /proc/self/status by name, or "" if unsupported or not found.  <a href="#a9fb67697fd1e49bcb389a735ba9fa8f2">More...</a><br/></td></tr>
<tr class="separator:a9fb67697fd1e49bcb389a735ba9fa8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546b60e87f7fc326074f6dcf2cdd0659"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a546b60e87f7fc326074f6dcf2cdd0659">get_max_rss_kb</a> ()</td></tr>
<tr class="memdesc:a546b60e87f7fc326074f6dcf2cdd0659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the max RSS usage ever, in kb, or 0 if unsupported.  <a href="#a546b60e87f7fc326074f6dcf2cdd0659">More...</a><br/></td></tr>
<tr class="separator:a546b60e87f7fc326074f6dcf2cdd0659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917d8892f93a31e2d8c3161de264fea1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a917d8892f93a31e2d8c3161de264fea1">get_max_vmem_kb</a> ()</td></tr>
<tr class="memdesc:a917d8892f93a31e2d8c3161de264fea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the max virtual memory size ever, in kb, or 0 if unsupported.  <a href="#a917d8892f93a31e2d8c3161de264fea1">More...</a><br/></td></tr>
<tr class="separator:a917d8892f93a31e2d8c3161de264fea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd30aaebcab130194ac375f23e6f098"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8cd30aaebcab130194ac375f23e6f098">get_current_vmem_kb</a> ()</td></tr>
<tr class="memdesc:a8cd30aaebcab130194ac375f23e6f098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current virtual memory size, in kb, or 0 if unsupported.  <a href="#a8cd30aaebcab130194ac375f23e6f098">More...</a><br/></td></tr>
<tr class="separator:a8cd30aaebcab130194ac375f23e6f098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03e9d67c4a774a71895ade9f10c6d19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae03e9d67c4a774a71895ade9f10c6d19">topologically_order_subpaths</a> (<a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln)</td></tr>
<tr class="memdesc:ae03e9d67c4a774a71895ade9f10c6d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put subpaths in topological order (assumed to be true for other algorithms)  <a href="#ae03e9d67c4a774a71895ade9f10c6d19">More...</a><br/></td></tr>
<tr class="separator:ae03e9d67c4a774a71895ade9f10c6d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d3918e06a7c8948bb6e91ba1226fa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a84d3918e06a7c8948bb6e91ba1226fa9">identify_start_subpaths</a> (<a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln)</td></tr>
<tr class="separator:a84d3918e06a7c8948bb6e91ba1226fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b28c682c013f735434f20e4d97ba1b"><td class="memItemLeft" align="right" valign="top">tuple&lt; <a class="el" href="structvg_1_1MultipathProblem.html">MultipathProblem</a>, <br class="typebreak"/>
int64_t, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af0b28c682c013f735434f20e4d97ba1b">run_multipath_dp</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln, bool subpath_global=false)</td></tr>
<tr class="separator:af0b28c682c013f735434f20e4d97ba1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856b55f4d89ae8bd7e6dacaa70fba0e0"><td class="memTemplParams" colspan="2">template&lt;typename TracebackIterator &gt; </td></tr>
<tr class="memitem:a856b55f4d89ae8bd7e6dacaa70fba0e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a856b55f4d89ae8bd7e6dacaa70fba0e0">populate_path_from_traceback</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln, const <a class="el" href="structvg_1_1MultipathProblem.html">MultipathProblem</a> &amp;problem, TracebackIterator traceback_start, TracebackIterator traceback_end, <a class="el" href="structvg_1_1Path.html">Path</a> *output)</td></tr>
<tr class="separator:a856b55f4d89ae8bd7e6dacaa70fba0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881ca4cff9243336ba8cf64a18f713e6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a881ca4cff9243336ba8cf64a18f713e6">optimal_alignment_internal</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> *aln_out, bool subpath_global)</td></tr>
<tr class="separator:a881ca4cff9243336ba8cf64a18f713e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f75115e0fa67db91cc2e0102008b995"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7f75115e0fa67db91cc2e0102008b995">optimal_alignment</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln_out, bool subpath_global)</td></tr>
<tr class="separator:a7f75115e0fa67db91cc2e0102008b995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e693b91cabeed2d861ba666e98a3cab"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3e693b91cabeed2d861ba666e98a3cab">optimal_alignment_score</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln, bool subpath_global)</td></tr>
<tr class="separator:a3e693b91cabeed2d861ba666e98a3cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb27a72a431b2f681c6eb88eb594a62c"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aeb27a72a431b2f681c6eb88eb594a62c">optimal_alignments</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln, size_t count)</td></tr>
<tr class="separator:aeb27a72a431b2f681c6eb88eb594a62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ead1fdf3f2d57f7a35755d24fd5999"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a78ead1fdf3f2d57f7a35755d24fd5999">optimal_alignments_with_disjoint_subpaths</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln, size_t count)</td></tr>
<tr class="separator:a78ead1fdf3f2d57f7a35755d24fd5999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9618d2d1905ec3bbb4721441f380f13c"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9618d2d1905ec3bbb4721441f380f13c">haplotype_consistent_alignments</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln, const <a class="el" href="classhaplo_1_1ScoreProvider.html">haplo::ScoreProvider</a> &amp;score_provider, size_t count, bool optimal_first)</td></tr>
<tr class="separator:a9618d2d1905ec3bbb4721441f380f13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41446f39233ac6ca5343d95b50329b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad41446f39233ac6ca5343d95b50329b2">rev_comp_subpath</a> (const <a class="el" href="structvg_1_1Subpath.html">Subpath</a> &amp;subpath, const function&lt; int64_t(int64_t)&gt; &amp;node_length, <a class="el" href="structvg_1_1Subpath.html">Subpath</a> &amp;rev_comp_out)</td></tr>
<tr class="separator:ad41446f39233ac6ca5343d95b50329b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40132bfddc17b143e18279d1e176652d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a40132bfddc17b143e18279d1e176652d">rev_comp_multipath_alignment</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln, const function&lt; int64_t(int64_t)&gt; &amp;node_length, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;rev_comp_out)</td></tr>
<tr class="separator:a40132bfddc17b143e18279d1e176652d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd751a7942664d45206cc1754755a1d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afd751a7942664d45206cc1754755a1d9">rev_comp_multipath_alignment_in_place</a> (<a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> *multipath_aln, const function&lt; int64_t(int64_t)&gt; &amp;node_length)</td></tr>
<tr class="separator:afd751a7942664d45206cc1754755a1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4b02bdea78f086b0e207563d7de800"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2d4b02bdea78f086b0e207563d7de800">to_multipath_alignment</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln_out)</td></tr>
<tr class="separator:a2d4b02bdea78f086b0e207563d7de800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741300a76b92c74a269946d7f859646c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a741300a76b92c74a269946d7f859646c">transfer_read_metadata</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;from, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;to)</td></tr>
<tr class="separator:a741300a76b92c74a269946d7f859646c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d6f299474100353ddcec9cc68a14b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a43d6f299474100353ddcec9cc68a14b2">transfer_read_metadata</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;from, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;to)</td></tr>
<tr class="separator:a43d6f299474100353ddcec9cc68a14b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a29ae37efd47f324b7d9d50f132271"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af5a29ae37efd47f324b7d9d50f132271">transfer_read_metadata</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;from, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;to)</td></tr>
<tr class="separator:af5a29ae37efd47f324b7d9d50f132271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a24c86c25b540e0e4e75a01d1bfb8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af6a24c86c25b540e0e4e75a01d1bfb8f">merge_non_branching_subpaths</a> (<a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln)</td></tr>
<tr class="memdesc:af6a24c86c25b540e0e4e75a01d1bfb8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges non-branching paths in a multipath alignment in place.  <a href="#af6a24c86c25b540e0e4e75a01d1bfb8f">More...</a><br/></td></tr>
<tr class="separator:af6a24c86c25b540e0e4e75a01d1bfb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa057b3bcb25a7d3ee7f2e4021238982f"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; int64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa057b3bcb25a7d3ee7f2e4021238982f">connected_components</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln)</td></tr>
<tr class="separator:aa057b3bcb25a7d3ee7f2e4021238982f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3beb4892a91e602904b90307803cf176"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3beb4892a91e602904b90307803cf176">extract_sub_multipath_alignment</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln, const vector&lt; int64_t &gt; &amp;subpath_indexes, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;sub_multipath_aln)</td></tr>
<tr class="separator:a3beb4892a91e602904b90307803cf176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a7010176a6425c2a8183054cc9781f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a89a7010176a6425c2a8183054cc9781f">validate_multipath_alignment</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln, const <a class="el" href="classvg_1_1HandleGraph.html">HandleGraph</a> &amp;handle_graph)</td></tr>
<tr class="separator:a89a7010176a6425c2a8183054cc9781f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b67eeb9262ee4034a35e068e25a26b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0b67eeb9262ee4034a35e068e25a26b1">view_multipath_alignment</a> (ostream &amp;out, const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln, const <a class="el" href="classvg_1_1HandleGraph.html">HandleGraph</a> &amp;handle_graph)</td></tr>
<tr class="memdesc:a0b67eeb9262ee4034a35e068e25a26b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a formatted string representation of the <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> into the ostream.  <a href="#a0b67eeb9262ee4034a35e068e25a26b1">More...</a><br/></td></tr>
<tr class="separator:a0b67eeb9262ee4034a35e068e25a26b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e5fc95fa04fafdfef347867f7d4aaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a23e5fc95fa04fafdfef347867f7d4aaa">view_multipath_alignment_as_dot</a> (ostream &amp;out, const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln, bool show_graph=false)</td></tr>
<tr class="memdesc:a23e5fc95fa04fafdfef347867f7d4aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> to a GraphViz Dot representation, output to the given ostream.  <a href="#a23e5fc95fa04fafdfef347867f7d4aaa">More...</a><br/></td></tr>
<tr class="separator:a23e5fc95fa04fafdfef347867f7d4aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f5b0dc3732e48a6d9b8d1c895cd8d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a30f5b0dc3732e48a6d9b8d1c895cd8d1">node_start</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:a30f5b0dc3732e48a6d9b8d1c895cd8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce the start <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> of a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a>.  <a href="#a30f5b0dc3732e48a6d9b8d1c895cd8d1">More...</a><br/></td></tr>
<tr class="separator:a30f5b0dc3732e48a6d9b8d1c895cd8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434e32ac84fd027508a6506e80107331"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a434e32ac84fd027508a6506e80107331">node_end</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:a434e32ac84fd027508a6506e80107331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce the end <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> of a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a>.  <a href="#a434e32ac84fd027508a6506e80107331">More...</a><br/></td></tr>
<tr class="separator:a434e32ac84fd027508a6506e80107331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4bea48392e7bb9e745b3b04e5bf223"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9b4bea48392e7bb9e745b3b04e5bf223">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;nodeside)</td></tr>
<tr class="memdesc:a9b4bea48392e7bb9e745b3b04e5bf223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> to a stream.  <a href="#a9b4bea48392e7bb9e745b3b04e5bf223">More...</a><br/></td></tr>
<tr class="separator:a9b4bea48392e7bb9e745b3b04e5bf223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bdeb550c6f5fa632ad61454321e001"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad1bdeb550c6f5fa632ad61454321e001">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;nodetraversal)</td></tr>
<tr class="memdesc:ad1bdeb550c6f5fa632ad61454321e001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>.  <a href="#ad1bdeb550c6f5fa632ad61454321e001">More...</a><br/></td></tr>
<tr class="separator:ad1bdeb550c6f5fa632ad61454321e001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81357f8477c9ed2c3839489e0ada1ced"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a81357f8477c9ed2c3839489e0ada1ced">operator&lt;&lt;</a> (ostream &amp;out, <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> mapping)</td></tr>
<tr class="memdesc:a81357f8477c9ed2c3839489e0ada1ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow a <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> to be printed, for debugging purposes.  <a href="#a81357f8477c9ed2c3839489e0ada1ced">More...</a><br/></td></tr>
<tr class="separator:a81357f8477c9ed2c3839489e0ada1ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a663b07489d2aba3f800943eeb0eaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a75a663b07489d2aba3f800943eeb0eaf">append_path</a> (<a class="el" href="structvg_1_1Path.html">Path</a> &amp;a, const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;b)</td></tr>
<tr class="separator:a75a663b07489d2aba3f800943eeb0eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48108a0abc0fdfc187437d174f88e590"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a48108a0abc0fdfc187437d174f88e590">path_to_length</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:a48108a0abc0fdfc187437d174f88e590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1524b7b1b7e67c048c0c5e88b204de08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1524b7b1b7e67c048c0c5e88b204de08">path_from_length</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:a1524b7b1b7e67c048c0c5e88b204de08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef1ccef545dfc30f9123eba61267b4a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9ef1ccef545dfc30f9123eba61267b4a">mapping_to_length</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m)</td></tr>
<tr class="separator:a9ef1ccef545dfc30f9123eba61267b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2aa77c6d4db628d13488c0bd82538ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa2aa77c6d4db628d13488c0bd82538ed">mapping_from_length</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m)</td></tr>
<tr class="separator:aa2aa77c6d4db628d13488c0bd82538ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe66eebecbc5017b05c9044413b2b4e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9fe66eebecbc5017b05c9044413b2b4e">softclip_start</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;mapping)</td></tr>
<tr class="separator:a9fe66eebecbc5017b05c9044413b2b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84e4c417206a9b3a910dfde0fec3857"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa84e4c417206a9b3a910dfde0fec3857">softclip_end</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;mapping)</td></tr>
<tr class="separator:aa84e4c417206a9b3a910dfde0fec3857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7557d06abd0fca3d66f9ca73fe81db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Position.html">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ada7557d06abd0fca3d66f9ca73fe81db">first_path_position</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:ada7557d06abd0fca3d66f9ca73fe81db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c1e5b8ce9f9607976913317102d6dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Position.html">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa1c1e5b8ce9f9607976913317102d6dc">last_path_position</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:aa1c1e5b8ce9f9607976913317102d6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed83dc32e575ae68b591d142eb38912"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a5ed83dc32e575ae68b591d142eb38912">to_length</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m)</td></tr>
<tr class="separator:a5ed83dc32e575ae68b591d142eb38912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d1f079508a3ee8a2705773109a5a8e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a83d1f079508a3ee8a2705773109a5a8e">from_length</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m)</td></tr>
<tr class="separator:a83d1f079508a3ee8a2705773109a5a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc55b3037b4e078c4268f08dda7cf4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afcc55b3037b4e078c4268f08dda7cf4b">extend_path</a> (<a class="el" href="structvg_1_1Path.html">Path</a> &amp;path1, const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path2)</td></tr>
<tr class="separator:afcc55b3037b4e078c4268f08dda7cf4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d43d119d665bda802489b3309e0bce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac7d43d119d665bda802489b3309e0bce">concat_paths</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path1, const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path2)</td></tr>
<tr class="separator:ac7d43d119d665bda802489b3309e0bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86653c665afe3c8932f60cc39163e202"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a86653c665afe3c8932f60cc39163e202">simplify</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;p, bool trim_internal_deletions)</td></tr>
<tr class="separator:a86653c665afe3c8932f60cc39163e202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc7225da088d27cd1201422ba011f51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Mapping.html">Mapping</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8fc7225da088d27cd1201422ba011f51">concat_mappings</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m, const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;n, bool trim_internal_deletions)</td></tr>
<tr class="separator:a8fc7225da088d27cd1201422ba011f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9514446da89671007ae40e420c1297d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Mapping.html">Mapping</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9514446da89671007ae40e420c1297d7">simplify</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m, bool trim_internal_deletions)</td></tr>
<tr class="separator:a9514446da89671007ae40e420c1297d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a83a9e127a0c7d75118dc14a8985f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Mapping.html">Mapping</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a30a83a9e127a0c7d75118dc14a8985f6">merge_adjacent_edits</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m)</td></tr>
<tr class="memdesc:a30a83a9e127a0c7d75118dc14a8985f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge adjacent edits of the same type.  <a href="#a30a83a9e127a0c7d75118dc14a8985f6">More...</a><br/></td></tr>
<tr class="separator:a30a83a9e127a0c7d75118dc14a8985f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990f54fb0e09dc439dace1519aff5e9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a990f54fb0e09dc439dace1519aff5e9f">trim_hanging_ends</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;p)</td></tr>
<tr class="separator:a990f54fb0e09dc439dace1519aff5e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeef6a4c023183ead5725398b14d443c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afeef6a4c023183ead5725398b14d443c">mapping_ends_in_deletion</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m)</td></tr>
<tr class="separator:afeef6a4c023183ead5725398b14d443c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa377b3e776e312c717aedec842216f48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa377b3e776e312c717aedec842216f48">mapping_starts_in_deletion</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m)</td></tr>
<tr class="separator:aa377b3e776e312c717aedec842216f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d10b5bc5677fdb0ae164f79848bb1bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a6d10b5bc5677fdb0ae164f79848bb1bb">mapping_is_total_deletion</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m)</td></tr>
<tr class="separator:a6d10b5bc5677fdb0ae164f79848bb1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ba5042b838f859a078cf014f1a0871"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae8ba5042b838f859a078cf014f1a0871">mapping_is_simple_match</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m)</td></tr>
<tr class="separator:ae8ba5042b838f859a078cf014f1a0871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c4a438edc31c7b0d2aa0731c522e8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a43c4a438edc31c7b0d2aa0731c522e8a">path_is_simple_match</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;p)</td></tr>
<tr class="separator:a43c4a438edc31c7b0d2aa0731c522e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b648cd1a51584623d6618565d3ca9c6"><td class="memItemLeft" align="right" valign="top">const string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2b648cd1a51584623d6618565d3ca9c6">mapping_sequence</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;mp, const string &amp;node_seq)</td></tr>
<tr class="separator:a2b648cd1a51584623d6618565d3ca9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23702705b681eacdfd1b3bcbc5254b5"><td class="memItemLeft" align="right" valign="top">const string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac23702705b681eacdfd1b3bcbc5254b5">mapping_sequence</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;mp, const <a class="el" href="structvg_1_1Node.html">Node</a> &amp;n)</td></tr>
<tr class="separator:ac23702705b681eacdfd1b3bcbc5254b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce6fa1d8f3ba4f8f361fa77a6fd5261"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Mapping.html">Mapping</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3ce6fa1d8f3ba4f8f361fa77a6fd5261">reverse_complement_mapping</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m, const function&lt; int64_t(<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>)&gt; &amp;node_length)</td></tr>
<tr class="separator:a3ce6fa1d8f3ba4f8f361fa77a6fd5261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2dc9d6ee4403027eb5965aa6a71eb4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af2dc9d6ee4403027eb5965aa6a71eb4e">reverse_complement_mapping_in_place</a> (<a class="el" href="structvg_1_1Mapping.html">Mapping</a> *m, const function&lt; int64_t(<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>)&gt; &amp;node_length)</td></tr>
<tr class="separator:af2dc9d6ee4403027eb5965aa6a71eb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463d9eaed29cd6d46a8e2afb645c8fda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a463d9eaed29cd6d46a8e2afb645c8fda">reverse_complement_path</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, const function&lt; int64_t(<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>)&gt; &amp;node_length)</td></tr>
<tr class="separator:a463d9eaed29cd6d46a8e2afb645c8fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2941a3c80481d02c65d9d72bd835807"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af2941a3c80481d02c65d9d72bd835807">reverse_complement_path_in_place</a> (<a class="el" href="structvg_1_1Path.html">Path</a> *path, const function&lt; int64_t(<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>)&gt; &amp;node_length)</td></tr>
<tr class="separator:af2941a3c80481d02c65d9d72bd835807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f45a0764dcd0711bb37067151c78d6a"><td class="memItemLeft" align="right" valign="top">pair&lt; <a class="el" href="structvg_1_1Mapping.html">Mapping</a>, <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4f45a0764dcd0711bb37067151c78d6a">cut_mapping</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m, const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;pos)</td></tr>
<tr class="separator:a4f45a0764dcd0711bb37067151c78d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb07d52156c2d1a3e13c566bf629760"><td class="memItemLeft" align="right" valign="top">pair&lt; <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a>, <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1cb07d52156c2d1a3e13c566bf629760">cut_mapping</a> (const <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &amp;m, const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;pos)</td></tr>
<tr class="separator:a1cb07d52156c2d1a3e13c566bf629760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9091c8bf2f73d219522420a705dc1f"><td class="memItemLeft" align="right" valign="top">pair&lt; <a class="el" href="structvg_1_1Mapping.html">Mapping</a>, <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9e9091c8bf2f73d219522420a705dc1f">cut_mapping_offset</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m, size_t <a class="el" href="namespacevg.html#a416939020600ce2996331c350f1fe68c">offset</a>)</td></tr>
<tr class="separator:a9e9091c8bf2f73d219522420a705dc1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455dd0d543b21690c3e71e67ff45e57d"><td class="memItemLeft" align="right" valign="top">pair&lt; <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a>, <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a455dd0d543b21690c3e71e67ff45e57d">cut_mapping_offset</a> (const <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &amp;m, size_t <a class="el" href="namespacevg.html#a416939020600ce2996331c350f1fe68c">offset</a>)</td></tr>
<tr class="separator:a455dd0d543b21690c3e71e67ff45e57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86cd2447c52bf50d938b0142bf98dc57"><td class="memItemLeft" align="right" valign="top">pair&lt; <a class="el" href="structvg_1_1Mapping.html">Mapping</a>, <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a86cd2447c52bf50d938b0142bf98dc57">cut_mapping</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m, size_t <a class="el" href="namespacevg.html#a416939020600ce2996331c350f1fe68c">offset</a>)</td></tr>
<tr class="separator:a86cd2447c52bf50d938b0142bf98dc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98f355163fd3a01d1d23c978fa1dbd3"><td class="memItemLeft" align="right" valign="top">pair&lt; <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a>, <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af98f355163fd3a01d1d23c978fa1dbd3">cut_mapping</a> (const <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &amp;m, size_t <a class="el" href="namespacevg.html#a416939020600ce2996331c350f1fe68c">offset</a>)</td></tr>
<tr class="separator:af98f355163fd3a01d1d23c978fa1dbd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0456e049dd685a689886372f4b0a354d"><td class="memItemLeft" align="right" valign="top">pair&lt; <a class="el" href="structvg_1_1Path.html">Path</a>, <a class="el" href="structvg_1_1Path.html">Path</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0456e049dd685a689886372f4b0a354d">cut_path</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;pos)</td></tr>
<tr class="separator:a0456e049dd685a689886372f4b0a354d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbdbb650e0a076cd3890c2a74515260"><td class="memItemLeft" align="right" valign="top">pair&lt; <a class="el" href="structvg_1_1Path.html">Path</a>, <a class="el" href="structvg_1_1Path.html">Path</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1dbdbb650e0a076cd3890c2a74515260">cut_path</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, size_t <a class="el" href="namespacevg.html#a416939020600ce2996331c350f1fe68c">offset</a>)</td></tr>
<tr class="separator:a1dbdbb650e0a076cd3890c2a74515260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242b97c26d74e9fc05ad16c31b21dcca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a242b97c26d74e9fc05ad16c31b21dcca">maps_to_node</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;p, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="separator:a242b97c26d74e9fc05ad16c31b21dcca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712dc26fa1460b97e84b31f78a4a04ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Position.html">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a712dc26fa1460b97e84b31f78a4a04ff">path_start</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:a712dc26fa1460b97e84b31f78a4a04ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe0993e79f4ef7bb4b37456b0b08402"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afbe0993e79f4ef7bb4b37456b0b08402">path_to_string</a> (<a class="el" href="structvg_1_1Path.html">Path</a> p)</td></tr>
<tr class="separator:afbe0993e79f4ef7bb4b37456b0b08402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7f51d37c0c0a70bc792989bfc26da4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Position.html">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aab7f51d37c0c0a70bc792989bfc26da4">path_end</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:aab7f51d37c0c0a70bc792989bfc26da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92de94b4571057762bb3152de1376e51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a92de94b4571057762bb3152de1376e51">adjacent_mappings</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m1, const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m2)</td></tr>
<tr class="separator:a92de94b4571057762bb3152de1376e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ea8a2cf04759a3cfecbe4bf3e926c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a78ea8a2cf04759a3cfecbe4bf3e926c2">mapping_is_match</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m)</td></tr>
<tr class="separator:a78ea8a2cf04759a3cfecbe4bf3e926c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b0a534daaa4c4eb7204b139fbbe3b7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad3b0a534daaa4c4eb7204b139fbbe3b7">divergence</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m)</td></tr>
<tr class="separator:ad3b0a534daaa4c4eb7204b139fbbe3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c5c7a407962a8c735c1d533cc0b186"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab3c5c7a407962a8c735c1d533cc0b186">identity</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:ab3c5c7a407962a8c735c1d533cc0b186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90fe8f4de1196dd902ac05f7567b9b7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a90fe8f4de1196dd902ac05f7567b9b7b">decompose</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, map&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>, int &gt; &amp;ref_positions, map&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>, <a class="el" href="structvg_1_1Edit.html">Edit</a> &gt; &amp;edits)</td></tr>
<tr class="separator:a90fe8f4de1196dd902ac05f7567b9b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac70d8b120ca61591561cba307dcc1b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aaac70d8b120ca61591561cba307dcc1b">overlap</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;p1, const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;p2)</td></tr>
<tr class="separator:aaac70d8b120ca61591561cba307dcc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71770196fc31c2e3c9c2a83f3497177"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af71770196fc31c2e3c9c2a83f3497177">translate_node_ids</a> (<a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &amp;translator)</td></tr>
<tr class="memdesc:af71770196fc31c2e3c9c2a83f3497177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switches the node ids in the path to the ones indicated by the translator.  <a href="#af71770196fc31c2e3c9c2a83f3497177">More...</a><br/></td></tr>
<tr class="separator:af71770196fc31c2e3c9c2a83f3497177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49e4506c94e5747c88805e39aa18090"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa49e4506c94e5747c88805e39aa18090">translate_node_ids</a> (<a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &amp;translator, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> cut_node, size_t bases_removed, bool from_right)</td></tr>
<tr class="separator:aa49e4506c94e5747c88805e39aa18090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0ba7a1d0cf7630b79d03ba0ab65c53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2b0ba7a1d0cf7630b79d03ba0ab65c53">translate_oriented_node_ids</a> (<a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;translator)</td></tr>
<tr class="memdesc:a2b0ba7a1d0cf7630b79d03ba0ab65c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switches the node ids and orientations in the path to the ones indicated by the translator.  <a href="#a2b0ba7a1d0cf7630b79d03ba0ab65c53">More...</a><br/></td></tr>
<tr class="separator:a2b0ba7a1d0cf7630b79d03ba0ab65c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd31d3a8dc67801f147d0ba1b0059c3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#acd31d3a8dc67801f147d0ba1b0059c3f">initial_position</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:acd31d3a8dc67801f147d0ba1b0059c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad435098725ff21d822052abee009d2bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad435098725ff21d822052abee009d2bd">final_position</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:ad435098725ff21d822052abee009d2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aef5ee16ad883f8defeaa0f52fc342c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3aef5ee16ad883f8defeaa0f52fc342c">path_from_node_traversals</a> (const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;traversals)</td></tr>
<tr class="separator:a3aef5ee16ad883f8defeaa0f52fc342c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbc811a743bb67f5425058843f51f1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4bbc811a743bb67f5425058843f51f1c">remove_paths</a> (<a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;graph, const std::regex &amp;paths_to_take, std::list&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; *matching)</td></tr>
<tr class="separator:a4bbc811a743bb67f5425058843f51f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa6175557c33cd572b8726222cf6547"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9fa6175557c33cd572b8726222cf6547">increment_node_mapping_ids</a> (<a class="el" href="structvg_1_1Path.html">Path</a> &amp;p, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> inc)</td></tr>
<tr class="separator:a9fa6175557c33cd572b8726222cf6547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5ffc03255d72f1901a7b1ce34c058a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1Paths.html">Paths</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1b5ffc03255d72f1901a7b1ce34c058a">paths_from_graph</a> (<a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;g)</td></tr>
<tr class="separator:a1b5ffc03255d72f1901a7b1ce34c058a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9985bf70965bd36bb54f910ab74e3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2c9985bf70965bd36bb54f910ab74e3b">merge_adjacent_edits</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;m)</td></tr>
<tr class="memdesc:a2c9985bf70965bd36bb54f910ab74e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge adjacent edits of the same type.  <a href="#a2c9985bf70965bd36bb54f910ab74e3b">More...</a><br/></td></tr>
<tr class="separator:a2c9985bf70965bd36bb54f910ab74e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089543e57bff72391dca9116157958b5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a089543e57bff72391dca9116157958b5">path_size</a> (const <a class="el" href="classxg_1_1XGPath.html">xg::XGPath</a> &amp;path)</td></tr>
<tr class="separator:a089543e57bff72391dca9116157958b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c911ba34849a4afd407812fe6373579"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0c911ba34849a4afd407812fe6373579">path_size</a> (const gbwt::vector_type &amp;path)</td></tr>
<tr class="separator:a0c911ba34849a4afd407812fe6373579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8626775da579a828867bae2f828cbaf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">vg::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8626775da579a828867bae2f828cbaf6">path_node</a> (const <a class="el" href="classxg_1_1XGPath.html">xg::XGPath</a> &amp;path, size_t i)</td></tr>
<tr class="separator:a8626775da579a828867bae2f828cbaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bdd8e00dd9f63a0d9049ffe3461d47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">vg::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac6bdd8e00dd9f63a0d9049ffe3461d47">path_node</a> (const gbwt::vector_type &amp;path, size_t i)</td></tr>
<tr class="separator:ac6bdd8e00dd9f63a0d9049ffe3461d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97747231cdf00e8947a4a350c7d80a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae97747231cdf00e8947a4a350c7d80a9">path_reverse</a> (const <a class="el" href="classxg_1_1XGPath.html">xg::XGPath</a> &amp;path, size_t i)</td></tr>
<tr class="separator:ae97747231cdf00e8947a4a350c7d80a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0439b7fcf30da565152d9800ff4473d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa0439b7fcf30da565152d9800ff4473d">path_reverse</a> (const gbwt::vector_type &amp;path, size_t i)</td></tr>
<tr class="separator:aa0439b7fcf30da565152d9800ff4473d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa0776e6865e98b3f7a2e8c6722cfb1"><td class="memTemplParams" colspan="2">template&lt;class PathType &gt; </td></tr>
<tr class="memitem:a8fa0776e6865e98b3f7a2e8c6722cfb1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8fa0776e6865e98b3f7a2e8c6722cfb1">verify_path</a> (const PathType &amp;path, <a class="el" href="classvg_1_1VG.html">VG</a> &amp;unfolded, const <a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">vg::id_t</a>, std::vector&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">vg::id_t</a> &gt;&gt; &amp;reverse_mapping)</td></tr>
<tr class="separator:a8fa0776e6865e98b3f7a2e8c6722cfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf8f408b11966feb9695d4bb723dfac"><td class="memTemplParams" colspan="2">template&lt;class Decoder &gt; </td></tr>
<tr class="memitem:a8bf8f408b11966feb9695d4bb723dfac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8bf8f408b11966feb9695d4bb723dfac">printId</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">vg::id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="separator:a8bf8f408b11966feb9695d4bb723dfac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74563bc5f9f3268b9a933688ad1a5edb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1PhaseUnfolder.html#a402b0f84990279594bfbb1cd71ffd8e5">PhaseUnfolder::path_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a74563bc5f9f3268b9a933688ad1a5edb">canonical_orientation</a> (const <a class="el" href="classvg_1_1PhaseUnfolder.html#a402b0f84990279594bfbb1cd71ffd8e5">PhaseUnfolder::path_type</a> &amp;path, bool &amp;from_border, bool &amp;to_border)</td></tr>
<tr class="separator:a74563bc5f9f3268b9a933688ad1a5edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4010a133b32505431f21d802d910eae2"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4010a133b32505431f21d802d910eae2">operator&lt;&lt;</a> (ostream &amp;os, const <a class="el" href="structvg_1_1NodeDivider.html#a5b836a4174fc7ab4d0e47d1a93dfdd8e">NodeDivider::NodeMap</a> &amp;nm)</td></tr>
<tr class="separator:a4010a133b32505431f21d802d910eae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1afd90e217e729defd8da8c4de03406"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae1afd90e217e729defd8da8c4de03406">operator&lt;&lt;</a> (ostream &amp;os, <a class="el" href="structvg_1_1NodeDivider_1_1Entry.html">NodeDivider::Entry</a> entry)</td></tr>
<tr class="separator:ae1afd90e217e729defd8da8c4de03406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead3eeae15cdb2798222c59c2fe4b3aa"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aead3eeae15cdb2798222c59c2fe4b3aa">operator&lt;&lt;</a> (ostream &amp;os, const <a class="el" href="classvg_1_1PileupAugmenter.html#a27e9a56508b2b69bb572c73aaef65bd3">PileupAugmenter::NodeOffSide</a> &amp;no)</td></tr>
<tr class="separator:aead3eeae15cdb2798222c59c2fe4b3aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545d769a5b2efb252ae12b1babc68a5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1StrandSupport.html">StrandSupport</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a545d769a5b2efb252ae12b1babc68a5f">minSup</a> (vector&lt; <a class="el" href="structvg_1_1StrandSupport.html">StrandSupport</a> &gt; &amp;s)</td></tr>
<tr class="separator:a545d769a5b2efb252ae12b1babc68a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4eddcd66a511a113e44ae2589c7ce6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1StrandSupport.html">StrandSupport</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7b4eddcd66a511a113e44ae2589c7ce6">maxSup</a> (vector&lt; <a class="el" href="structvg_1_1StrandSupport.html">StrandSupport</a> &gt; &amp;s)</td></tr>
<tr class="separator:a7b4eddcd66a511a113e44ae2589c7ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4ff62f183c00e91085c2fa24559077"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1StrandSupport.html">StrandSupport</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aca4ff62f183c00e91085c2fa24559077">avgSup</a> (vector&lt; <a class="el" href="structvg_1_1StrandSupport.html">StrandSupport</a> &gt; &amp;s)</td></tr>
<tr class="separator:aca4ff62f183c00e91085c2fa24559077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bab41ee9f0370c0b4233acea61658b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1StrandSupport.html">StrandSupport</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a35bab41ee9f0370c0b4233acea61658b">totalSup</a> (vector&lt; <a class="el" href="structvg_1_1StrandSupport.html">StrandSupport</a> &gt; &amp;s)</td></tr>
<tr class="separator:a35bab41ee9f0370c0b4233acea61658b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f2c6fe818db874e4aa04ee6e8ea685"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa5f2c6fe818db874e4aa04ee6e8ea685">operator&lt;&lt;</a> (ostream &amp;os, const <a class="el" href="structvg_1_1StrandSupport.html">StrandSupport</a> &amp;sup)</td></tr>
<tr class="separator:aa5f2c6fe818db874e4aa04ee6e8ea685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9f0a2379194fb00d706e90d373b378"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2d9f0a2379194fb00d706e90d373b378">make_pos_t</a> (const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;pos)</td></tr>
<tr class="memdesc:a2d9f0a2379194fb00d706e90d373b378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="structvg_1_1Position.html">Position</a> to a (much smaller) pos_t.  <a href="#a2d9f0a2379194fb00d706e90d373b378">More...</a><br/></td></tr>
<tr class="separator:a2d9f0a2379194fb00d706e90d373b378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb641e072b9e234aac717885669533b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#acb641e072b9e234aac717885669533b3">make_pos_t</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>, bool <a class="el" href="namespacevg.html#aac725dd44bc5a8f540554d4b1882c1fe">is_rev</a>, <a class="el" href="namespacevg.html#a9cdb6d0305bd8cbf46efed9b2799877a">off_t</a> off)</td></tr>
<tr class="memdesc:acb641e072b9e234aac717885669533b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pos_t from a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a> ID, an orientation flag, and an offset along that strand of the node.  <a href="#acb641e072b9e234aac717885669533b3">More...</a><br/></td></tr>
<tr class="separator:acb641e072b9e234aac717885669533b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc066dab7543192bf782959ef160f2d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afc066dab7543192bf782959ef160f2d4">make_pos_t</a> (gcsa::node_type node)</td></tr>
<tr class="memdesc:afc066dab7543192bf782959ef160f2d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pos_t from a gcsa node.  <a href="#afc066dab7543192bf782959ef160f2d4">More...</a><br/></td></tr>
<tr class="separator:afc066dab7543192bf782959ef160f2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6247de8deb27aaabf2bc0d6fc755f693"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Position.html">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a6247de8deb27aaabf2bc0d6fc755f693">make_position</a> (const <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &amp;pos)</td></tr>
<tr class="memdesc:a6247de8deb27aaabf2bc0d6fc755f693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a pos_t to a <a class="el" href="structvg_1_1Position.html">Position</a>.  <a href="#a6247de8deb27aaabf2bc0d6fc755f693">More...</a><br/></td></tr>
<tr class="separator:a6247de8deb27aaabf2bc0d6fc755f693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2794a8e24388f4dca7063d583b74ba2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Position.html">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2794a8e24388f4dca7063d583b74ba2f">make_position</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>, bool <a class="el" href="namespacevg.html#aac725dd44bc5a8f540554d4b1882c1fe">is_rev</a>, <a class="el" href="namespacevg.html#a9cdb6d0305bd8cbf46efed9b2799877a">off_t</a> off)</td></tr>
<tr class="memdesc:a2794a8e24388f4dca7063d583b74ba2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="structvg_1_1Position.html">Position</a> from a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a> ID, an orientation flag, and an offset along that strand of the node.  <a href="#a2794a8e24388f4dca7063d583b74ba2f">More...</a><br/></td></tr>
<tr class="separator:a2794a8e24388f4dca7063d583b74ba2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdd9b08b7b6d6e15d00536554f3ca56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Position.html">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4cdd9b08b7b6d6e15d00536554f3ca56">make_position</a> (gcsa::node_type node)</td></tr>
<tr class="memdesc:a4cdd9b08b7b6d6e15d00536554f3ca56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="structvg_1_1Position.html">Position</a> from a gcsa node.  <a href="#a4cdd9b08b7b6d6e15d00536554f3ca56">More...</a><br/></td></tr>
<tr class="separator:a4cdd9b08b7b6d6e15d00536554f3ca56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3620df68e5af61a8eb660e4a4838ea06"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3620df68e5af61a8eb660e4a4838ea06">is_empty</a> (const <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &amp;pos)</td></tr>
<tr class="memdesc:a3620df68e5af61a8eb660e4a4838ea06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if a pos_t is unset.  <a href="#a3620df68e5af61a8eb660e4a4838ea06">More...</a><br/></td></tr>
<tr class="separator:a3620df68e5af61a8eb660e4a4838ea06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6602b7e7a46c19819c8f362147b315"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a> (const <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &amp;pos)</td></tr>
<tr class="memdesc:a9f6602b7e7a46c19819c8f362147b315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the id of the node a pos_t is on.  <a href="#a9f6602b7e7a46c19819c8f362147b315">More...</a><br/></td></tr>
<tr class="separator:a9f6602b7e7a46c19819c8f362147b315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac725dd44bc5a8f540554d4b1882c1fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aac725dd44bc5a8f540554d4b1882c1fe">is_rev</a> (const <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &amp;pos)</td></tr>
<tr class="memdesc:aac725dd44bc5a8f540554d4b1882c1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if a pos_t is on the reverse strand of its node.  <a href="#aac725dd44bc5a8f540554d4b1882c1fe">More...</a><br/></td></tr>
<tr class="separator:aac725dd44bc5a8f540554d4b1882c1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416939020600ce2996331c350f1fe68c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a9cdb6d0305bd8cbf46efed9b2799877a">off_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a416939020600ce2996331c350f1fe68c">offset</a> (const <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &amp;pos)</td></tr>
<tr class="memdesc:a416939020600ce2996331c350f1fe68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the offset along the selected strand of the node from a pos_t.  <a href="#a416939020600ce2996331c350f1fe68c">More...</a><br/></td></tr>
<tr class="separator:a416939020600ce2996331c350f1fe68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d7deafb5fe4ce9c7e85a6d7ed9db65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a87d7deafb5fe4ce9c7e85a6d7ed9db65">get_id</a> (<a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &amp;pos)</td></tr>
<tr class="memdesc:a87d7deafb5fe4ce9c7e85a6d7ed9db65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a> ID of a pos_t.  <a href="#a87d7deafb5fe4ce9c7e85a6d7ed9db65">More...</a><br/></td></tr>
<tr class="separator:a87d7deafb5fe4ce9c7e85a6d7ed9db65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371d288efeaa5884ce28170274bbc21a"><td class="memItemLeft" align="right" valign="top">bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a371d288efeaa5884ce28170274bbc21a">get_is_rev</a> (<a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &amp;pos)</td></tr>
<tr class="memdesc:a371d288efeaa5884ce28170274bbc21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the reverse flag of a pos_t.  <a href="#a371d288efeaa5884ce28170274bbc21a">More...</a><br/></td></tr>
<tr class="separator:a371d288efeaa5884ce28170274bbc21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716ebc4e690ac383342cc1c750bdddd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a9cdb6d0305bd8cbf46efed9b2799877a">off_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a716ebc4e690ac383342cc1c750bdddd0">get_offset</a> (<a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &amp;pos)</td></tr>
<tr class="memdesc:a716ebc4e690ac383342cc1c750bdddd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the offset field of a pos_t, which counts along the selected strand of the node.  <a href="#a716ebc4e690ac383342cc1c750bdddd0">More...</a><br/></td></tr>
<tr class="separator:a716ebc4e690ac383342cc1c750bdddd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52fd5878b0be1d53de644eea3458663"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac52fd5878b0be1d53de644eea3458663">reverse</a> (const <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &amp;pos, size_t node_length)</td></tr>
<tr class="memdesc:ac52fd5878b0be1d53de644eea3458663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse a pos_t and get a pos_t at the same base, going the other direction.  <a href="#ac52fd5878b0be1d53de644eea3458663">More...</a><br/></td></tr>
<tr class="separator:ac52fd5878b0be1d53de644eea3458663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91adfc6327b5709dc73fcc7edbe5da57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Position.html">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a91adfc6327b5709dc73fcc7edbe5da57">reverse</a> (const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;pos, size_t node_length)</td></tr>
<tr class="memdesc:a91adfc6327b5709dc73fcc7edbe5da57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse a <a class="el" href="structvg_1_1Position.html">Position</a> and get a <a class="el" href="structvg_1_1Position.html">Position</a> at the same base, going the other direction.  <a href="#a91adfc6327b5709dc73fcc7edbe5da57">More...</a><br/></td></tr>
<tr class="separator:a91adfc6327b5709dc73fcc7edbe5da57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8108426a3ac5985b0f86493fc524d131"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8108426a3ac5985b0f86493fc524d131">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &amp;pos)</td></tr>
<tr class="memdesc:a8108426a3ac5985b0f86493fc524d131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a pos_t to a stream.  <a href="#a8108426a3ac5985b0f86493fc524d131">More...</a><br/></td></tr>
<tr class="separator:a8108426a3ac5985b0f86493fc524d131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95de8f8ed7a5768c89ac738ca6afc692"><td class="memItemLeft" align="right" valign="top">pair&lt; int64_t, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a95de8f8ed7a5768c89ac738ca6afc692">min_oriented_distances</a> (const map&lt; string, vector&lt; pair&lt; size_t, bool &gt; &gt; &gt; &amp;path_offsets1, const map&lt; string, vector&lt; pair&lt; size_t, bool &gt; &gt; &gt; &amp;path_offsets2)</td></tr>
<tr class="memdesc:a95de8f8ed7a5768c89ac738ca6afc692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the min distance in the path offsets where the path orientation is the same and different.  <a href="#a95de8f8ed7a5768c89ac738ca6afc692">More...</a><br/></td></tr>
<tr class="separator:a95de8f8ed7a5768c89ac738ca6afc692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ac31e5878660a97207b6ade1418c81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a65ac31e5878660a97207b6ade1418c81">preflight_check</a> ()</td></tr>
<tr class="separator:a65ac31e5878660a97207b6ade1418c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e892bf26f768618a2b8c2abea6a6a60"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="namespacevg.html#a6225846768d2b6dbbbefab9e240a9e02">edge_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9e892bf26f768618a2b8c2abea6a6a60">find_edges_to_prune</a> (const <a class="el" href="classvg_1_1HandleGraph.html">HandleGraph</a> &amp;graph, size_t k, size_t edge_max)</td></tr>
<tr class="memdesc:a9e892bf26f768618a2b8c2abea6a6a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all the walks up to length k, adding edges which.  <a href="#a9e892bf26f768618a2b8c2abea6a6a60">More...</a><br/></td></tr>
<tr class="separator:a9e892bf26f768618a2b8c2abea6a6a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e701675f6d1b67522349bf5b7651bb0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4e701675f6d1b67522349bf5b7651bb0">is_alt_path</a> (const string &amp;name)</td></tr>
<tr class="memdesc:a4e701675f6d1b67522349bf5b7651bb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given path name is a variant ref or alt allele alt path.  <a href="#a4e701675f6d1b67522349bf5b7651bb0">More...</a><br/></td></tr>
<tr class="separator:a4e701675f6d1b67522349bf5b7651bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253257615743a1cfb948b749be7700e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a253257615743a1cfb948b749be7700e2">parse_region</a> (const string &amp;target, string &amp;name, int64_t &amp;start, int64_t &amp;end)</td></tr>
<tr class="separator:a253257615743a1cfb948b749be7700e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b06b5a51ac3e6f4567852020354732b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9b06b5a51ac3e6f4567852020354732b">parse_bed_regions</a> (const string &amp;bed_path, vector&lt; <a class="el" href="structvg_1_1Region.html">Region</a> &gt; &amp;out_regions)</td></tr>
<tr class="separator:a9b06b5a51ac3e6f4567852020354732b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a3beb8908adf7a6e4d641243937830"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af0a3beb8908adf7a6e4d641243937830">parse_region</a> (string &amp;region, <a class="el" href="structvg_1_1Region.html">Region</a> &amp;out_region)</td></tr>
<tr class="separator:af0a3beb8908adf7a6e4d641243937830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca76d456a115d68ea096528468e0f77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aaca76d456a115d68ea096528468e0f77">position_at</a> (<a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgidx, const string &amp;path_name, const size_t &amp;path_offset, bool is_reverse)</td></tr>
<tr class="separator:aaca76d456a115d68ea096528468e0f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f061abac718e0386965aa537398e74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a43f061abac718e0386965aa537398e74">start_backward</a> (const <a class="el" href="namespacevg.html#aa9d8b2ece3ab50a38656273662553f2d">Chain</a> &amp;chain)</td></tr>
<tr class="separator:a43f061abac718e0386965aa537398e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab8d2ef076a0e866c7849aace290124"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#acab8d2ef076a0e866c7849aace290124">end_backward</a> (const <a class="el" href="namespacevg.html#aa9d8b2ece3ab50a38656273662553f2d">Chain</a> &amp;chain)</td></tr>
<tr class="separator:acab8d2ef076a0e866c7849aace290124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa918cf29c1c8238d88f2bbc94b6abef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Visit.html">Visit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afa918cf29c1c8238d88f2bbc94b6abef">get_start_of</a> (const <a class="el" href="namespacevg.html#aa9d8b2ece3ab50a38656273662553f2d">Chain</a> &amp;chain)</td></tr>
<tr class="separator:afa918cf29c1c8238d88f2bbc94b6abef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76e8a5e74f67093a40ed5f2cd15ff28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Visit.html">Visit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af76e8a5e74f67093a40ed5f2cd15ff28">get_end_of</a> (const <a class="el" href="namespacevg.html#aa9d8b2ece3ab50a38656273662553f2d">Chain</a> &amp;chain)</td></tr>
<tr class="separator:af76e8a5e74f67093a40ed5f2cd15ff28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b14246f4fe83e3fbdadb1ba838faeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac3b14246f4fe83e3fbdadb1ba838faeb">chain_begin</a> (const <a class="el" href="namespacevg.html#aa9d8b2ece3ab50a38656273662553f2d">Chain</a> &amp;chain)</td></tr>
<tr class="separator:ac3b14246f4fe83e3fbdadb1ba838faeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0612d7af2f7366ff81c89824f43a5865"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0612d7af2f7366ff81c89824f43a5865">chain_end</a> (const <a class="el" href="namespacevg.html#aa9d8b2ece3ab50a38656273662553f2d">Chain</a> &amp;chain)</td></tr>
<tr class="separator:a0612d7af2f7366ff81c89824f43a5865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24387fbb4606765c23a280316bfcb65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa24387fbb4606765c23a280316bfcb65">chain_rbegin</a> (const <a class="el" href="namespacevg.html#aa9d8b2ece3ab50a38656273662553f2d">Chain</a> &amp;chain)</td></tr>
<tr class="separator:aa24387fbb4606765c23a280316bfcb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c65134c67609a001a61291b22337f8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2c65134c67609a001a61291b22337f8d">chain_rend</a> (const <a class="el" href="namespacevg.html#aa9d8b2ece3ab50a38656273662553f2d">Chain</a> &amp;chain)</td></tr>
<tr class="separator:a2c65134c67609a001a61291b22337f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aed054b974860f2cc4d5be4b7615de0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7aed054b974860f2cc4d5be4b7615de0">chain_rcbegin</a> (const <a class="el" href="namespacevg.html#aa9d8b2ece3ab50a38656273662553f2d">Chain</a> &amp;chain)</td></tr>
<tr class="separator:a7aed054b974860f2cc4d5be4b7615de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1369d5e29159750fd14482f73421660"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae1369d5e29159750fd14482f73421660">chain_rcend</a> (const <a class="el" href="namespacevg.html#aa9d8b2ece3ab50a38656273662553f2d">Chain</a> &amp;chain)</td></tr>
<tr class="separator:ae1369d5e29159750fd14482f73421660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefacc656d2c444dfd6e0e445218265cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aefacc656d2c444dfd6e0e445218265cc">chain_begin_from</a> (const <a class="el" href="namespacevg.html#aa9d8b2ece3ab50a38656273662553f2d">Chain</a> &amp;chain, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *start_snarl, bool snarl_orientation)</td></tr>
<tr class="separator:aefacc656d2c444dfd6e0e445218265cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0627b5d536b881a355d8b419b6f329c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0627b5d536b881a355d8b419b6f329c6">chain_end_from</a> (const <a class="el" href="namespacevg.html#aa9d8b2ece3ab50a38656273662553f2d">Chain</a> &amp;chain, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *start_snarl, bool snarl_orientation)</td></tr>
<tr class="separator:a0627b5d536b881a355d8b419b6f329c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b890a4bc73725bbea08984d7510df4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a87b890a4bc73725bbea08984d7510df4">operator==</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;a, const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;b)</td></tr>
<tr class="separator:a87b890a4bc73725bbea08984d7510df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6063b76b70947010198b46c053b578"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#abb6063b76b70947010198b46c053b578">operator!=</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;a, const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;b)</td></tr>
<tr class="separator:abb6063b76b70947010198b46c053b578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2e2066b3b4534b62cde6e4423efd81"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9d2e2066b3b4534b62cde6e4423efd81">operator&lt;</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;a, const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;b)</td></tr>
<tr class="separator:a9d2e2066b3b4534b62cde6e4423efd81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38d6991537581f9ce3f4c549f966a33"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab38d6991537581f9ce3f4c549f966a33">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;visit)</td></tr>
<tr class="separator:ab38d6991537581f9ce3f4c549f966a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845213e6efb7204868c05afcae9c926f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a845213e6efb7204868c05afcae9c926f">operator==</a> (const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;a, const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;b)</td></tr>
<tr class="separator:a845213e6efb7204868c05afcae9c926f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e1e38ea29c615b2c5f5cd8dbaeeb2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a24e1e38ea29c615b2c5f5cd8dbaeeb2a">operator!=</a> (const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;a, const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;b)</td></tr>
<tr class="separator:a24e1e38ea29c615b2c5f5cd8dbaeeb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea87c61d2cc1d5acf1af1d2d351bdb75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aea87c61d2cc1d5acf1af1d2d351bdb75">operator&lt;</a> (const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;a, const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;b)</td></tr>
<tr class="separator:aea87c61d2cc1d5acf1af1d2d351bdb75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387ff1f8cefcf4feb705b0f1225d16c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a387ff1f8cefcf4feb705b0f1225d16c7">operator==</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;a, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;b)</td></tr>
<tr class="separator:a387ff1f8cefcf4feb705b0f1225d16c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654eca8448629e42ae87cadd893ee10e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a654eca8448629e42ae87cadd893ee10e">operator!=</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;a, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;b)</td></tr>
<tr class="separator:a654eca8448629e42ae87cadd893ee10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd908e60f72bd98dcba364a16ab7190"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0fd908e60f72bd98dcba364a16ab7190">operator&lt;</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;a, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;b)</td></tr>
<tr class="separator:a0fd908e60f72bd98dcba364a16ab7190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0744fdee12e0f4136de643a91c15f77"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae0744fdee12e0f4136de643a91c15f77">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;snarl)</td></tr>
<tr class="separator:ae0744fdee12e0f4136de643a91c15f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2e772d69c9e45cbc1c1d1a9e6df842"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a5a2e772d69c9e45cbc1c1d1a9e6df842">to_node_traversal</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;visit, const <a class="el" href="classvg_1_1VG.html">VG</a> &amp;graph)</td></tr>
<tr class="separator:a5a2e772d69c9e45cbc1c1d1a9e6df842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4a5c32294bf49aa7f0a6d180cc2832"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0b4a5c32294bf49aa7f0a6d180cc2832">to_rev_node_traversal</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;visit, const <a class="el" href="classvg_1_1VG.html">VG</a> &amp;graph)</td></tr>
<tr class="separator:a0b4a5c32294bf49aa7f0a6d180cc2832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d646b72482de0145745a64414ca5df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a84d646b72482de0145745a64414ca5df">to_left_side</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;visit)</td></tr>
<tr class="memdesc:a84d646b72482de0145745a64414ca5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> to a node or snarl into a <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> for its left side.  <a href="#a84d646b72482de0145745a64414ca5df">More...</a><br/></td></tr>
<tr class="separator:a84d646b72482de0145745a64414ca5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fab09b3ae1d9f799742a31b5206a35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a74fab09b3ae1d9f799742a31b5206a35">to_right_side</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;visit)</td></tr>
<tr class="memdesc:a74fab09b3ae1d9f799742a31b5206a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> to a node or snarl into a <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> for its right side.  <a href="#a74fab09b3ae1d9f799742a31b5206a35">More...</a><br/></td></tr>
<tr class="separator:a74fab09b3ae1d9f799742a31b5206a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827ce532cdbd4710e86a21ebd986e1cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Visit.html">Visit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a827ce532cdbd4710e86a21ebd986e1cc">to_visit</a> (const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;node_traversal)</td></tr>
<tr class="memdesc:a827ce532cdbd4710e86a21ebd986e1cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> to a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a>.  <a href="#a827ce532cdbd4710e86a21ebd986e1cc">More...</a><br/></td></tr>
<tr class="separator:a827ce532cdbd4710e86a21ebd986e1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd53873bb85623cbf5b797f09bf88dc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Visit.html">Visit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#acd53873bb85623cbf5b797f09bf88dc4">to_visit</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;mapping, bool make_full_node_match=false)</td></tr>
<tr class="separator:acd53873bb85623cbf5b797f09bf88dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76433c3398610bc58b842f2a4b462c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Visit.html">Visit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa76433c3398610bc58b842f2a4b462c7">to_visit</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> node_id, bool is_reverse)</td></tr>
<tr class="memdesc:aa76433c3398610bc58b842f2a4b462c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> from a node ID and an orientation.  <a href="#aa76433c3398610bc58b842f2a4b462c7">More...</a><br/></td></tr>
<tr class="separator:aa76433c3398610bc58b842f2a4b462c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a18238f71586af9b3eba2ba1dac2a6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Visit.html">Visit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0a18238f71586af9b3eba2ba1dac2a6e">to_visit</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;snarl)</td></tr>
<tr class="memdesc:a0a18238f71586af9b3eba2ba1dac2a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> from a snarl to traverse.  <a href="#a0a18238f71586af9b3eba2ba1dac2a6e">More...</a><br/></td></tr>
<tr class="separator:a0a18238f71586af9b3eba2ba1dac2a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e300d25fd8281f9453366f68b484196"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Visit.html">Visit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2e300d25fd8281f9453366f68b484196">reverse</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;visit)</td></tr>
<tr class="memdesc:a2e300d25fd8281f9453366f68b484196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reversed version of a visit.  <a href="#a2e300d25fd8281f9453366f68b484196">More...</a><br/></td></tr>
<tr class="separator:a2e300d25fd8281f9453366f68b484196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7164ae8636d1ca7783d6202c8ce316ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Visit.html">Visit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7164ae8636d1ca7783d6202c8ce316ca">to_rev_visit</a> (const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;node_traversal)</td></tr>
<tr class="memdesc:a7164ae8636d1ca7783d6202c8ce316ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> to a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> in the opposite orientation.  <a href="#a7164ae8636d1ca7783d6202c8ce316ca">More...</a><br/></td></tr>
<tr class="separator:a7164ae8636d1ca7783d6202c8ce316ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28be7f9898d5ad6e075e25b81df512e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Mapping.html">Mapping</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a28be7f9898d5ad6e075e25b81df512e8">to_mapping</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;visit, std::function&lt; size_t(<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>)&gt; node_length)</td></tr>
<tr class="separator:a28be7f9898d5ad6e075e25b81df512e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace232035b9ab613b2378baa3497b5da7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Mapping.html">Mapping</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ace232035b9ab613b2378baa3497b5da7">to_mapping</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;visit, <a class="el" href="classvg_1_1VG.html">VG</a> &amp;vg)</td></tr>
<tr class="separator:ace232035b9ab613b2378baa3497b5da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a83d7c54d733abee06d328f91ef5ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a82a83d7c54d733abee06d328f91ef5ee">transfer_boundary_info</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;from, <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;to)</td></tr>
<tr class="memdesc:a82a83d7c54d733abee06d328f91ef5ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the boundary Visits from one <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> into another.  <a href="#a82a83d7c54d733abee06d328f91ef5ee">More...</a><br/></td></tr>
<tr class="separator:a82a83d7c54d733abee06d328f91ef5ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c04918053577c402e4f2cab61abd754"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2c04918053577c402e4f2cab61abd754">to_node_traversal</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;visit, <a class="el" href="classvg_1_1VG.html">VG</a> &amp;graph)</td></tr>
<tr class="separator:a2c04918053577c402e4f2cab61abd754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64d7810e64af7119f1b1b3a2d08d797"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae64d7810e64af7119f1b1b3a2d08d797">to_rev_node_traversal</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;visit, <a class="el" href="classvg_1_1VG.html">VG</a> &amp;graph)</td></tr>
<tr class="separator:ae64d7810e64af7119f1b1b3a2d08d797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fc02ee1a5713060cd5f4b33e2eaaab"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac5fc02ee1a5713060cd5f4b33e2eaaab">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="classvg_1_1BitString.html">BitString</a> &amp;bs)</td></tr>
<tr class="memdesc:ac5fc02ee1a5713060cd5f4b33e2eaaab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow BitStrings to be printed for debugging.  <a href="#ac5fc02ee1a5713060cd5f4b33e2eaaab">More...</a><br/></td></tr>
<tr class="separator:ac5fc02ee1a5713060cd5f4b33e2eaaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c1d798d3d99e95ee8c3fcb7cd3319a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a41c1d798d3d99e95ee8c3fcb7cd3319a"><td class="memTemplItemLeft" align="right" valign="top">string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a41c1d798d3d99e95ee8c3fcb7cd3319a">to_string_ss</a> (T val)</td></tr>
<tr class="separator:a41c1d798d3d99e95ee8c3fcb7cd3319a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9c4e83112e55a3862015c55c4fd273"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a5b9c4e83112e55a3862015c55c4fd273">strand_bias</a> (const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;support)</td></tr>
<tr class="separator:a5b9c4e83112e55a3862015c55c4fd273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c908e97c97825b3025f8aefc59f025"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab4c908e97c97825b3025f8aefc59f025">char_to_string</a> (const char &amp;letter)</td></tr>
<tr class="separator:ab4c908e97c97825b3025f8aefc59f025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ce0743c9a27e8b8ed32de37e4064fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a84ce0743c9a27e8b8ed32de37e4064fd">write_vcf_header</a> (ostream &amp;stream, const vector&lt; string &gt; &amp;sample_names, const vector&lt; string &gt; &amp;contig_names, const vector&lt; size_t &gt; &amp;contig_sizes, int min_mad_for_filter, int max_dp_for_filter, double max_dp_multiple_for_filter, double max_local_dp_multiple_for_filter, double min_ad_log_likelihood_for_filter, bool xref_enabled)</td></tr>
<tr class="separator:a84ce0743c9a27e8b8ed32de37e4064fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c96d053af80e78f785ea1ba4232a10"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa7c96d053af80e78f785ea1ba4232a10">can_write_alleles</a> (vcflib::Variant &amp;variant)</td></tr>
<tr class="separator:aa7c96d053af80e78f785ea1ba4232a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad98d082285cd6dcc92302924095d666"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aad98d082285cd6dcc92302924095d666">get_pileup_line</a> (const map&lt; int64_t, <a class="el" href="structvg_1_1NodePileup.html">NodePileup</a> &gt; &amp;node_pileups, const set&lt; pair&lt; int64_t, size_t &gt;&gt; &amp;refCrossreferences, const set&lt; pair&lt; int64_t, size_t &gt;&gt; &amp;altCrossreferences)</td></tr>
<tr class="separator:aad98d082285cd6dcc92302924095d666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a22f4c38561e62e9c752b5dbb9ee12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a41a22f4c38561e62e9c752b5dbb9ee12">trace_traversal</a> (const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;traversal, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;site, function&lt; void(size_t, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool)&gt; handle_node, function&lt; void(size_t, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>)&gt; handle_edge, function&lt; void(size_t, <a class="el" href="structvg_1_1Snarl.html">Snarl</a>, bool)&gt; handle_child)</td></tr>
<tr class="separator:a41a22f4c38561e62e9c752b5dbb9ee12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b6437e6aec966fbcd92fbaa48f98da"><td class="memItemLeft" align="right" valign="top">tuple&lt; <a class="el" href="structvg_1_1Support.html">Support</a>, <a class="el" href="structvg_1_1Support.html">Support</a>, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a75b6437e6aec966fbcd92fbaa48f98da">get_traversal_support</a> (<a class="el" href="structvg_1_1SupportAugmentedGraph.html">SupportAugmentedGraph</a> &amp;augmented, <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;snarl_manager, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;site, const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;traversal, const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> *already_used=nullptr)</td></tr>
<tr class="separator:a75b6437e6aec966fbcd92fbaa48f98da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52292dfd3869a811170f7c5c0d9da564"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a52292dfd3869a811170f7c5c0d9da564">is_match</a> (const <a class="el" href="structvg_1_1Translation.html">Translation</a> &amp;translation)</td></tr>
<tr class="separator:a52292dfd3869a811170f7c5c0d9da564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65de7dea52585f07bee6ae7f762eb95"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa65de7dea52585f07bee6ae7f762eb95">reverse_complement</a> (const char &amp;c)</td></tr>
<tr class="separator:aa65de7dea52585f07bee6ae7f762eb95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30732a1a1e8d20d6eaaaeafecc8a50a7"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a30732a1a1e8d20d6eaaaeafecc8a50a7">reverse_complement</a> (const string &amp;seq)</td></tr>
<tr class="separator:a30732a1a1e8d20d6eaaaeafecc8a50a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6353d47c867f1b4cc7053d82aef42f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae6353d47c867f1b4cc7053d82aef42f4">reverse_complement_in_place</a> (string &amp;seq)</td></tr>
<tr class="separator:ae6353d47c867f1b4cc7053d82aef42f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6f7955b97d8537da2133a47f37f462"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#abe6f7955b97d8537da2133a47f37f462">is_all_n</a> (const string &amp;seq)</td></tr>
<tr class="separator:abe6f7955b97d8537da2133a47f37f462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade988dd38efaa705be15ba17500fe219"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ade988dd38efaa705be15ba17500fe219">get_thread_count</a> (void)</td></tr>
<tr class="separator:ade988dd38efaa705be15ba17500fe219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1940ed8d1740511870d3617aa967559a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1940ed8d1740511870d3617aa967559a">split_delims</a> (const std::string &amp;s, const std::string &amp;delims, std::vector&lt; std::string &gt; &amp;elems)</td></tr>
<tr class="separator:a1940ed8d1740511870d3617aa967559a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261e76d1959c22119b567e59bf4c23ae"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a261e76d1959c22119b567e59bf4c23ae">split_delims</a> (const std::string &amp;s, const std::string &amp;delims)</td></tr>
<tr class="separator:a261e76d1959c22119b567e59bf4c23ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cada7d579d914675f53490e0488ab53"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0cada7d579d914675f53490e0488ab53">sha1sum</a> (const std::string &amp;data)</td></tr>
<tr class="separator:a0cada7d579d914675f53490e0488ab53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6821cd887e206752c50c1a7be764d1f5"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a6821cd887e206752c50c1a7be764d1f5">sha1head</a> (const std::string &amp;data, size_t head)</td></tr>
<tr class="separator:a6821cd887e206752c50c1a7be764d1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f111dda471f40192704110bae04a0f"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a57f111dda471f40192704110bae04a0f">wrap_text</a> (const string &amp;str, size_t width)</td></tr>
<tr class="separator:a57f111dda471f40192704110bae04a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af051490e6e94b4c476695610472cdf5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af051490e6e94b4c476695610472cdf5b">is_number</a> (const std::string &amp;s)</td></tr>
<tr class="separator:af051490e6e94b4c476695610472cdf5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1786f1e7e453c4b76b319ba101782d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7a1786f1e7e453c4b76b319ba101782d">allATGC</a> (const string &amp;s)</td></tr>
<tr class="separator:a7a1786f1e7e453c4b76b319ba101782d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24bea33b666a03a0065a10a60d64e9d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae24bea33b666a03a0065a10a60d64e9d">allATGCN</a> (const string &amp;s)</td></tr>
<tr class="separator:ae24bea33b666a03a0065a10a60d64e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453b457823e1ddf916ebf298befb4512"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a453b457823e1ddf916ebf298befb4512">nonATGCNtoN</a> (const string &amp;s)</td></tr>
<tr class="separator:a453b457823e1ddf916ebf298befb4512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a949105ae94b18ca72452a442b8ddb"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a00a949105ae94b18ca72452a442b8ddb">toUppercase</a> (const string &amp;s)</td></tr>
<tr class="separator:a00a949105ae94b18ca72452a442b8ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fc5855bb49062ce72e56c805e1545a"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae9fc5855bb49062ce72e56c805e1545a">get_or_make_variant_id</a> (const vcflib::Variant &amp;variant)</td></tr>
<tr class="separator:ae9fc5855bb49062ce72e56c805e1545a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74ef603900cf05ce35dbab813d21deb"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa74ef603900cf05ce35dbab813d21deb">make_variant_id</a> (const vcflib::Variant &amp;variant)</td></tr>
<tr class="separator:aa74ef603900cf05ce35dbab813d21deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eef175773ce8532826ba78eee0cece5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a6eef175773ce8532826ba78eee0cece5">median</a> (std::vector&lt; int &gt; &amp;v)</td></tr>
<tr class="separator:a6eef175773ce8532826ba78eee0cece5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931d9271de88fc786030fdd0ab4bf534"><td class="memItemLeft" align="right" valign="top">vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a931d9271de88fc786030fdd0ab4bf534">range_vector</a> (size_t begin, size_t end)</td></tr>
<tr class="separator:a931d9271de88fc786030fdd0ab4bf534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b8b686ef6eca09515be1abe566c013"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab1b8b686ef6eca09515be1abe566c013">get_input_file</a> (int &amp;optind, int argc, char **argv, function&lt; void(istream &amp;)&gt; callback)</td></tr>
<tr class="separator:ab1b8b686ef6eca09515be1abe566c013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511d30ecf4d39aaa944c2f59f6821fad"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a511d30ecf4d39aaa944c2f59f6821fad">get_input_file_name</a> (int &amp;optind, int argc, char **argv)</td></tr>
<tr class="separator:a511d30ecf4d39aaa944c2f59f6821fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a0425675c4a85289b230eef2c985b8"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae2a0425675c4a85289b230eef2c985b8">get_output_file_name</a> (int &amp;optind, int argc, char **argv)</td></tr>
<tr class="separator:ae2a0425675c4a85289b230eef2c985b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09969fef23098c7729a2f190cecb4694"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a09969fef23098c7729a2f190cecb4694">get_input_file</a> (const string &amp;file_name, function&lt; void(istream &amp;)&gt; callback)</td></tr>
<tr class="separator:a09969fef23098c7729a2f190cecb4694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2d2438c678d4fc4c0007b64b8ccd6f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ace2d2438c678d4fc4c0007b64b8ccd6f">phi</a> (double x1, double x2)</td></tr>
<tr class="separator:ace2d2438c678d4fc4c0007b64b8ccd6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbaafa0c783156a34cb7e16ec2958c1f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#adbaafa0c783156a34cb7e16ec2958c1f">normal_inverse_cdf</a> (double quantile)</td></tr>
<tr class="memdesc:adbaafa0c783156a34cb7e16ec2958c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse CDF of a standard normal distribution. Must have 0 &lt; quantile &lt; 1.  <a href="#adbaafa0c783156a34cb7e16ec2958c1f">More...</a><br/></td></tr>
<tr class="separator:adbaafa0c783156a34cb7e16ec2958c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e16eec9e4a4120718eba7d5711a7df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae9e16eec9e4a4120718eba7d5711a7df">create_ref_allele</a> (vcflib::Variant &amp;variant, const std::string &amp;allele)</td></tr>
<tr class="separator:ae9e16eec9e4a4120718eba7d5711a7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6391a10ec421fbb6c487f491bd978ef6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a6391a10ec421fbb6c487f491bd978ef6">add_alt_allele</a> (vcflib::Variant &amp;variant, const std::string &amp;allele)</td></tr>
<tr class="separator:a6391a10ec421fbb6c487f491bd978ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad477b45059373004136e69022e802e0b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad477b45059373004136e69022e802e0b">slope</a> (const std::vector&lt; double &gt; &amp;x, const std::vector&lt; double &gt; &amp;y)</td></tr>
<tr class="separator:ad477b45059373004136e69022e802e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa3b08acc22f29ea5d940317f6948ab"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9fa3b08acc22f29ea5d940317f6948ab">fit_zipf</a> (const vector&lt; double &gt; &amp;y)</td></tr>
<tr class="separator:a9fa3b08acc22f29ea5d940317f6948ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4239af1a9e3eb1283f78bf5cc1411a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aca4239af1a9e3eb1283f78bf5cc1411a">integer_power</a> (uint64_t base, uint64_t exponent)</td></tr>
<tr class="memdesc:aca4239af1a9e3eb1283f78bf5cc1411a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes base^exponent in log(exponent) time.  <a href="#aca4239af1a9e3eb1283f78bf5cc1411a">More...</a><br/></td></tr>
<tr class="separator:aca4239af1a9e3eb1283f78bf5cc1411a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8f8791be2575164e6070e1cef39b4e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#abc8f8791be2575164e6070e1cef39b4e">modular_exponent</a> (uint64_t base, uint64_t exponent, uint64_t modulus)</td></tr>
<tr class="separator:abc8f8791be2575164e6070e1cef39b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4012afd56ccb35387121c71c2119e244"><td class="memItemLeft" align="right" valign="top">default_random_engine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4012afd56ccb35387121c71c2119e244">random_sequence_gen</a> (102)</td></tr>
<tr class="separator:a4012afd56ccb35387121c71c2119e244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80fc8c8920c7ec53cfee81dc2fce852"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab80fc8c8920c7ec53cfee81dc2fce852">random_sequence</a> (size_t length)</td></tr>
<tr class="memdesc:ab80fc8c8920c7ec53cfee81dc2fce852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a uniformly random DNA sequence of the given length.  <a href="#ab80fc8c8920c7ec53cfee81dc2fce852">More...</a><br/></td></tr>
<tr class="separator:ab80fc8c8920c7ec53cfee81dc2fce852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab169ac1e2fc6ba662eebc1ede1ffe157"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab169ac1e2fc6ba662eebc1ede1ffe157">replace_in_string</a> (string subject, const string &amp;search, const string &amp;replace)</td></tr>
<tr class="separator:ab169ac1e2fc6ba662eebc1ede1ffe157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba15a613567689d941f30a5a17c6ead"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2ba15a613567689d941f30a5a17c6ead">percent_url_encode</a> (const string &amp;seq)</td></tr>
<tr class="memdesc:a2ba15a613567689d941f30a5a17c6ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape "%" to "%25".  <a href="#a2ba15a613567689d941f30a5a17c6ead">More...</a><br/></td></tr>
<tr class="separator:a2ba15a613567689d941f30a5a17c6ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d5f690fe272c74949e080aca561467"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair<br class="typebreak"/>
&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a86d5f690fe272c74949e080aca561467">overlay_node_translations</a> (const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;over, const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;under)</td></tr>
<tr class="memdesc:a86d5f690fe272c74949e080aca561467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose the translations from two graph operations, both of which involved oriented transformations.  <a href="#a86d5f690fe272c74949e080aca561467">More...</a><br/></td></tr>
<tr class="separator:a86d5f690fe272c74949e080aca561467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7816225a17a671ff849a79f064770ebb"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair<br class="typebreak"/>
&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7816225a17a671ff849a79f064770ebb">overlay_node_translations</a> (const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &amp;over, const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;under)</td></tr>
<tr class="memdesc:a7816225a17a671ff849a79f064770ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose the translations from two graph operations, the first of which involved oriented transformations.  <a href="#a7816225a17a671ff849a79f064770ebb">More...</a><br/></td></tr>
<tr class="separator:a7816225a17a671ff849a79f064770ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af224cfdc27efec675771ba4cc5143a3f"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair<br class="typebreak"/>
&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af224cfdc27efec675771ba4cc5143a3f">overlay_node_translations</a> (const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;over, const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &amp;under)</td></tr>
<tr class="memdesc:af224cfdc27efec675771ba4cc5143a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose the translations from two graph operations, the second of which involved oriented transformations.  <a href="#af224cfdc27efec675771ba4cc5143a3f">More...</a><br/></td></tr>
<tr class="separator:af224cfdc27efec675771ba4cc5143a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae996017b379b1178d5e588b96a7c7f3f"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae996017b379b1178d5e588b96a7c7f3f">overlay_node_translations</a> (const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &amp;over, const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &amp;under)</td></tr>
<tr class="memdesc:ae996017b379b1178d5e588b96a7c7f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose the translations from two graph operations, neither of which involved oriented transformations.  <a href="#ae996017b379b1178d5e588b96a7c7f3f">More...</a><br/></td></tr>
<tr class="separator:ae996017b379b1178d5e588b96a7c7f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c44463adc7ddcc77ac9664692a62b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a97c44463adc7ddcc77ac9664692a62b8">is_number</a> (const string &amp;s)</td></tr>
<tr class="separator:a97c44463adc7ddcc77ac9664692a62b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bdb2cdf1d9318f4bce86132244a874d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0bdb2cdf1d9318f4bce86132244a874d">stdev</a> (const std::vector&lt; double &gt; &amp;v)</td></tr>
<tr class="separator:a0bdb2cdf1d9318f4bce86132244a874d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11df8bd14dab3c0cfb7ecfa377a362f5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11df8bd14dab3c0cfb7ecfa377a362f5"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a11df8bd14dab3c0cfb7ecfa377a362f5">stdev</a> (const T &amp;v)</td></tr>
<tr class="separator:a11df8bd14dab3c0cfb7ecfa377a362f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4ce16064ad3986381aeead6afe317f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0d4ce16064ad3986381aeead6afe317f">add_log</a> (double log_x, double log_y)</td></tr>
<tr class="separator:a0d4ce16064ad3986381aeead6afe317f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c8f5153ad0766df2c72bbec623aa19"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a33c8f5153ad0766df2c72bbec623aa19">subtract_log</a> (double log_x, double log_y)</td></tr>
<tr class="separator:a33c8f5153ad0766df2c72bbec623aa19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664ec3301c226596ad971b97a8e1fa65"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a664ec3301c226596ad971b97a8e1fa65">ln_to_log10</a> (double ln)</td></tr>
<tr class="separator:a664ec3301c226596ad971b97a8e1fa65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d9ec9295afc7457506af4ddaf44217"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a48d9ec9295afc7457506af4ddaf44217">log10_to_ln</a> (double l10)</td></tr>
<tr class="separator:a48d9ec9295afc7457506af4ddaf44217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476a2102f4f5aa82c06be87780ae6d42"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a476a2102f4f5aa82c06be87780ae6d42">prob_to_logprob</a> (double prob)</td></tr>
<tr class="separator:a476a2102f4f5aa82c06be87780ae6d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea77a4ed92d78c48a08fce58cf319c4d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aea77a4ed92d78c48a08fce58cf319c4d">logprob_to_prob</a> (double logprob)</td></tr>
<tr class="separator:aea77a4ed92d78c48a08fce58cf319c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b25a99232585c5e76baf01d1ef5520"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a64b25a99232585c5e76baf01d1ef5520">logprob_add</a> (double logprob1, double logprob2)</td></tr>
<tr class="separator:a64b25a99232585c5e76baf01d1ef5520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1056422cd0697f2bbdcf8a085486793a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1056422cd0697f2bbdcf8a085486793a">logprob_invert</a> (double logprob)</td></tr>
<tr class="separator:a1056422cd0697f2bbdcf8a085486793a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa269a7de61c98b1c46b3cacd5d5a43d6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa269a7de61c98b1c46b3cacd5d5a43d6">phred_to_prob</a> (int phred)</td></tr>
<tr class="separator:aa269a7de61c98b1c46b3cacd5d5a43d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb81881c0a3b7cf276097d8142ddb312"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#acb81881c0a3b7cf276097d8142ddb312">prob_to_phred</a> (double prob)</td></tr>
<tr class="separator:acb81881c0a3b7cf276097d8142ddb312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b531c82b765cd54702665668a98448"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a35b531c82b765cd54702665668a98448">phred_to_logprob</a> (int phred)</td></tr>
<tr class="separator:a35b531c82b765cd54702665668a98448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d295b4b0f83393ce621b44d88680a6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a66d295b4b0f83393ce621b44d88680a6">logprob_to_phred</a> (double logprob)</td></tr>
<tr class="separator:a66d295b4b0f83393ce621b44d88680a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8a1a81a5402187152a97ca6293b4f1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0f8a1a81a5402187152a97ca6293b4f1">logprob_geometric_mean</a> (double lnprob1, double lnprob2)</td></tr>
<tr class="separator:a0f8a1a81a5402187152a97ca6293b4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04edc3daae77e9d3813a97da0f473def"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a04edc3daae77e9d3813a97da0f473def">phred_geometric_mean</a> (double phred1, double phred2)</td></tr>
<tr class="separator:a04edc3daae77e9d3813a97da0f473def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e831d426c5d0eaed85a981adb0704a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a97e831d426c5d0eaed85a981adb0704a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a97e831d426c5d0eaed85a981adb0704a">normal_pdf</a> (T x, T m, T s)</td></tr>
<tr class="separator:a97e831d426c5d0eaed85a981adb0704a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace99283a6b34f0891dc0b49f0cd60eea"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:ace99283a6b34f0891dc0b49f0cd60eea"><td class="memTemplItemLeft" align="right" valign="top">set&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ace99283a6b34f0891dc0b49f0cd60eea">map_keys_to_set</a> (const map&lt; T, V &gt; &amp;m)</td></tr>
<tr class="separator:ace99283a6b34f0891dc0b49f0cd60eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f5da8e25414026729f0c4d09243f6d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac7f5da8e25414026729f0c4d09243f6d"><td class="memTemplItemLeft" align="right" valign="top">vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac7f5da8e25414026729f0c4d09243f6d">pmax</a> (const std::vector&lt; T &gt; &amp;a, const std::vector&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:ac7f5da8e25414026729f0c4d09243f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4813274fc2af3d83679e128fdeb32f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec4813274fc2af3d83679e128fdeb32f"><td class="memTemplItemLeft" align="right" valign="top">vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#aec4813274fc2af3d83679e128fdeb32f">vpmax</a> (const std::vector&lt; std::vector&lt; T &gt;&gt; &amp;vv)</td></tr>
<tr class="separator:aec4813274fc2af3d83679e128fdeb32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70726366aa31b20debdcac41c89490c"><td class="memTemplParams" colspan="2">template&lt;typename Collection &gt; </td></tr>
<tr class="memitem:aa70726366aa31b20debdcac41c89490c"><td class="memTemplItemLeft" align="right" valign="top">Collection::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa70726366aa31b20debdcac41c89490c">sum</a> (const Collection &amp;collection)</td></tr>
<tr class="separator:aa70726366aa31b20debdcac41c89490c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d81b5193ecfc9600990bd427337adf"><td class="memTemplParams" colspan="2">template&lt;typename Collection &gt; </td></tr>
<tr class="memitem:a93d81b5193ecfc9600990bd427337adf"><td class="memTemplItemLeft" align="right" valign="top">Collection::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a93d81b5193ecfc9600990bd427337adf">logprob_sum</a> (const Collection &amp;collection)</td></tr>
<tr class="separator:a93d81b5193ecfc9600990bd427337adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4833086451a8b97af4709aa6c7385177"><td class="memTemplParams" colspan="2">template&lt;template&lt; class T, class A=std::allocator&lt; T &gt;&gt; class Container, typename Input , typename Output &gt; </td></tr>
<tr class="memitem:a4833086451a8b97af4709aa6c7385177"><td class="memTemplItemLeft" align="right" valign="top">Container&lt; Output &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4833086451a8b97af4709aa6c7385177">map_over</a> (const Container&lt; Input &gt; &amp;in, const std::function&lt; Output(const Input &amp;)&gt; &amp;lambda)</td></tr>
<tr class="separator:a4833086451a8b97af4709aa6c7385177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a210206858f806b345f8eb5c2c292a"><td class="memTemplParams" colspan="2">template&lt;template&lt; class T, class A=std::allocator&lt; T &gt;&gt; class Container, typename Item &gt; </td></tr>
<tr class="memitem:ae6a210206858f806b345f8eb5c2c292a"><td class="memTemplItemLeft" align="right" valign="top">Container&lt; const Item * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae6a210206858f806b345f8eb5c2c292a">pointerfy</a> (const Container&lt; Item &gt; &amp;in)</td></tr>
<tr class="separator:ae6a210206858f806b345f8eb5c2c292a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39adca1737de5d28d007d95b809deb7f"><td class="memItemLeft" align="right" valign="top">vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a39adca1737de5d28d007d95b809deb7f">range_vector</a> (size_t end)</td></tr>
<tr class="separator:a39adca1737de5d28d007d95b809deb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c32d1e90ec006624a7ee03655f3c35"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa7c32d1e90ec006624a7ee03655f3c35">integer_power</a> (size_t x, size_t power)</td></tr>
<tr class="separator:aa7c32d1e90ec006624a7ee03655f3c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f9a3f311a844e7a223da7e619d2937"><td class="memTemplParams" colspan="2">template&lt;class RandomIt &gt; </td></tr>
<tr class="memitem:a58f9a3f311a844e7a223da7e619d2937"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a58f9a3f311a844e7a223da7e619d2937">deterministic_shuffle</a> (RandomIt begin, RandomIt end, const uint32_t &amp;seed)</td></tr>
<tr class="separator:a58f9a3f311a844e7a223da7e619d2937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d97ef95a167bff0030346ed5880277"><td class="memTemplParams" colspan="2">template&lt;class RandomIt &gt; </td></tr>
<tr class="memitem:ac8d97ef95a167bff0030346ed5880277"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac8d97ef95a167bff0030346ed5880277">deterministic_shuffle</a> (RandomIt begin, RandomIt end, const string &amp;seed)</td></tr>
<tr class="separator:ac8d97ef95a167bff0030346ed5880277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc312d814d6a06a4a5159c7943675bbe"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#acc312d814d6a06a4a5159c7943675bbe">make_shuffle_seed</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln)</td></tr>
<tr class="memdesc:acc312d814d6a06a4a5159c7943675bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make seeds for Alignments based on their sequences.  <a href="#acc312d814d6a06a4a5159c7943675bbe">More...</a><br/></td></tr>
<tr class="separator:acc312d814d6a06a4a5159c7943675bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31063b9139a2b92d5c5742635ca9e090"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a31063b9139a2b92d5c5742635ca9e090">make_shuffle_seed</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> *aln)</td></tr>
<tr class="memdesc:a31063b9139a2b92d5c5742635ca9e090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make seeds for Alignments based on their sequences.  <a href="#a31063b9139a2b92d5c5742635ca9e090">More...</a><br/></td></tr>
<tr class="separator:a31063b9139a2b92d5c5742635ca9e090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1366c7a10c9c94dd390323fe8c3fe026"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1366c7a10c9c94dd390323fe8c3fe026">make_shuffle_seed</a> (const pair&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a>, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; *alns)</td></tr>
<tr class="memdesc:a1366c7a10c9c94dd390323fe8c3fe026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make seeds for pairs of Alignments based on their concatenated sequences.  <a href="#a1366c7a10c9c94dd390323fe8c3fe026">More...</a><br/></td></tr>
<tr class="separator:a1366c7a10c9c94dd390323fe8c3fe026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74e428a09df726b5c2f4998b9d0a442"><td class="memTemplParams" colspan="2">template&lt;class RandomIt &gt; </td></tr>
<tr class="memitem:ae74e428a09df726b5c2f4998b9d0a442"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae74e428a09df726b5c2f4998b9d0a442">deterministic_shuffle</a> (RandomIt begin, RandomIt end)</td></tr>
<tr class="memdesc:ae74e428a09df726b5c2f4998b9d0a442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a deterministic shuffle with automatic seed determination.  <a href="#ae74e428a09df726b5c2f4998b9d0a442">More...</a><br/></td></tr>
<tr class="separator:ae74e428a09df726b5c2f4998b9d0a442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73740805ee8d4d785c38cb1217807363"><td class="memTemplParams" colspan="2">template&lt;class RandomIt , class Compare , class MakeSeed &gt; </td></tr>
<tr class="memitem:a73740805ee8d4d785c38cb1217807363"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a73740805ee8d4d785c38cb1217807363">sort_shuffling_ties</a> (RandomIt begin, RandomIt end, Compare comp, MakeSeed seed)</td></tr>
<tr class="separator:a73740805ee8d4d785c38cb1217807363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa071bccfee3a9078930f2c385e8dda20"><td class="memTemplParams" colspan="2">template&lt;class RandomIt , class Compare &gt; </td></tr>
<tr class="memitem:aa071bccfee3a9078930f2c385e8dda20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa071bccfee3a9078930f2c385e8dda20">sort_shuffling_ties</a> (RandomIt begin, RandomIt end, Compare comp)</td></tr>
<tr class="separator:aa071bccfee3a9078930f2c385e8dda20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8873caafc22d22b52e0f6f3f164f6dc8"><td class="memTemplParams" colspan="2">template&lt;typename Result &gt; </td></tr>
<tr class="memitem:a8873caafc22d22b52e0f6f3f164f6dc8"><td class="memTemplItemLeft" align="right" valign="top">Result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8873caafc22d22b52e0f6f3f164f6dc8">parse</a> (const string &amp;arg)</td></tr>
<tr class="separator:a8873caafc22d22b52e0f6f3f164f6dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5c364797f623025b67b9aff0657112"><td class="memTemplParams" colspan="2">template&lt;typename Result &gt; </td></tr>
<tr class="memitem:a8c5c364797f623025b67b9aff0657112"><td class="memTemplItemLeft" align="right" valign="top">Result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8c5c364797f623025b67b9aff0657112">parse</a> (const char *arg)</td></tr>
<tr class="separator:a8c5c364797f623025b67b9aff0657112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627f5ad6fe6f1e6b4cc23ac97dfca4b8"><td class="memTemplParams" colspan="2">template&lt;typename Result &gt; </td></tr>
<tr class="memitem:a627f5ad6fe6f1e6b4cc23ac97dfca4b8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a627f5ad6fe6f1e6b4cc23ac97dfca4b8">parse</a> (const string &amp;arg, Result &amp;dest)</td></tr>
<tr class="separator:a627f5ad6fe6f1e6b4cc23ac97dfca4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077c59e824971d78208576c3a3b7e374"><td class="memTemplParams" colspan="2">template&lt;typename Result &gt; </td></tr>
<tr class="memitem:a077c59e824971d78208576c3a3b7e374"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a077c59e824971d78208576c3a3b7e374">parse</a> (const string &amp;arg, typename enable_if&lt; sizeof(Result)&lt;=sizeof(long long)&amp;&amp;is_integral&lt; Result &gt;::value &amp;&amp;is_signed&lt; Result &gt;::value, Result &gt;::type &amp;dest)</td></tr>
<tr class="separator:a077c59e824971d78208576c3a3b7e374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd328fd8abb43338a3ae9e0a3b0be1f"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a1dd328fd8abb43338a3ae9e0a3b0be1f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1dd328fd8abb43338a3ae9e0a3b0be1f">parse</a> (const string &amp;arg, double &amp;dest)</td></tr>
<tr class="separator:a1dd328fd8abb43338a3ae9e0a3b0be1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1de4a1752e875116c767ec49a8e2961"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aa1de4a1752e875116c767ec49a8e2961"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa1de4a1752e875116c767ec49a8e2961">parse</a> (const string &amp;arg, std::regex &amp;dest)</td></tr>
<tr class="separator:aa1de4a1752e875116c767ec49a8e2961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3374c888c7c37f1de8370e151af7f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7d3374c888c7c37f1de8370e151af7f9">genotype_svs</a> (<a class="el" href="classvg_1_1VG.html">VG</a> *graph, string gamfile, string refpath)</td></tr>
<tr class="separator:a7d3374c888c7c37f1de8370e151af7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0ad28109d9eb8efa2bf1ff97fe8e92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0c0ad28109d9eb8efa2bf1ff97fe8e92">variant_recall</a> (<a class="el" href="classvg_1_1VG.html">VG</a> *graph, vcflib::VariantCallFile *vars, FastaReference *ref_genome, vector&lt; FastaReference * &gt; insertions, string gamfile, bool isIndex)</td></tr>
<tr class="separator:a0c0ad28109d9eb8efa2bf1ff97fe8e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc1d89bbcee041956e59895ed605ca3"><td class="memItemLeft" align="right" valign="top">tuple&lt; double, double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8bc1d89bbcee041956e59895ed605ca3">hash_to_rgb</a> (const string &amp;str, double min_sum)</td></tr>
<tr class="separator:a8bc1d89bbcee041956e59895ed605ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9dd8ed096a730fcaa60ddd7565db84a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad9dd8ed096a730fcaa60ddd7565db84a">xg_node</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>, const <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgidx)</td></tr>
<tr class="separator:ad9dd8ed096a730fcaa60ddd7565db84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9c7332961acdb45c8fcd8b14ebdfce"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#abf9c7332961acdb45c8fcd8b14ebdfce">xg_edges_on_start</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>, const <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgidx)</td></tr>
<tr class="separator:abf9c7332961acdb45c8fcd8b14ebdfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ac96a405711a35f96e127bb8c8553e"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a70ac96a405711a35f96e127bb8c8553e">xg_edges_on_end</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>, const <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgidx)</td></tr>
<tr class="separator:a70ac96a405711a35f96e127bb8c8553e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df5e6b0e351c4c2d89dc95168974642"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2df5e6b0e351c4c2d89dc95168974642">xg_node_sequence</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>, const <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgidx)</td></tr>
<tr class="separator:a2df5e6b0e351c4c2d89dc95168974642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af120c0d9ebecd1b3a6da6a66a49f3855"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af120c0d9ebecd1b3a6da6a66a49f3855">xg_node_length</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>, const <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgidx)</td></tr>
<tr class="memdesc:af120c0d9ebecd1b3a6da6a66a49f3855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a> from an <a class="el" href="classxg_1_1XG.html">xg::XG</a> index, with cacheing of deserialized nodes.  <a href="#af120c0d9ebecd1b3a6da6a66a49f3855">More...</a><br/></td></tr>
<tr class="separator:af120c0d9ebecd1b3a6da6a66a49f3855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3373ba50df47dd6a5fcebc9a283c61d"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af3373ba50df47dd6a5fcebc9a283c61d">xg_node_start</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>, const <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgidx)</td></tr>
<tr class="memdesc:af3373ba50df47dd6a5fcebc9a283c61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node start position in the sequence vector.  <a href="#af3373ba50df47dd6a5fcebc9a283c61d">More...</a><br/></td></tr>
<tr class="separator:af3373ba50df47dd6a5fcebc9a283c61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4184dd0acd62bd6229a0119734a4914d"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4184dd0acd62bd6229a0119734a4914d">xg_pos_char</a> (<a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> pos, const <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgidx)</td></tr>
<tr class="memdesc:a4184dd0acd62bd6229a0119734a4914d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the character at a position in an <a class="el" href="classxg_1_1XG.html">xg::XG</a> index, with cacheing of deserialized nodes.  <a href="#a4184dd0acd62bd6229a0119734a4914d">More...</a><br/></td></tr>
<tr class="separator:a4184dd0acd62bd6229a0119734a4914d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8429876ce03b5b6702a63f8c9f735ab4"><td class="memItemLeft" align="right" valign="top">map&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>, char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8429876ce03b5b6702a63f8c9f735ab4">xg_next_pos_chars</a> (<a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> pos, const <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgidx)</td></tr>
<tr class="memdesc:a8429876ce03b5b6702a63f8c9f735ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the characters at positions after the given position from an <a class="el" href="classxg_1_1XG.html">xg::XG</a> index, with cacheing of deserialized nodes.  <a href="#a8429876ce03b5b6702a63f8c9f735ab4">More...</a><br/></td></tr>
<tr class="separator:a8429876ce03b5b6702a63f8c9f735ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3add5068be75e8c8f5da5d836d0793f0"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3add5068be75e8c8f5da5d836d0793f0">xg_next_pos</a> (<a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> pos, bool whole_node, const <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgidx)</td></tr>
<tr class="separator:a3add5068be75e8c8f5da5d836d0793f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86028cee0c33d849f37236619f93cf97"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a86028cee0c33d849f37236619f93cf97">xg_distance</a> (<a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> pos1, <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> pos2, int64_t maximum, const <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgidx)</td></tr>
<tr class="separator:a86028cee0c33d849f37236619f93cf97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260823500b0302ed6e8c7baa83f6df3e"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a260823500b0302ed6e8c7baa83f6df3e">xg_positions_bp_from</a> (<a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> pos, int64_t distance, bool rev, const <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgidx)</td></tr>
<tr class="separator:a260823500b0302ed6e8c7baa83f6df3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273ef8a0e90e251a499e12e213b78108"><td class="memItemLeft" align="right" valign="top">map&lt; string, vector&lt; pair<br class="typebreak"/>
&lt; size_t, bool &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a273ef8a0e90e251a499e12e213b78108">xg_alignment_path_offsets</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, bool just_min, bool nearby, const <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgidx)</td></tr>
<tr class="separator:a273ef8a0e90e251a499e12e213b78108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8dedb8c4f2db46cfabc83a465f640a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aea8dedb8c4f2db46cfabc83a465f640a">xg_annotate_with_initial_path_positions</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const <a class="el" href="classxg_1_1XG.html">xg::XG</a> *xgidx)</td></tr>
<tr class="separator:aea8dedb8c4f2db46cfabc83a465f640a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ade7204b42260155b9a98a6d18c24a0b7"><td class="memItemLeft" align="right" valign="top">const char *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ade7204b42260155b9a98a6d18c24a0b7">BAM_DNA_LOOKUP</a> = &quot;=ACMGRSVTWYHKDBN&quot;</td></tr>
<tr class="separator:ade7204b42260155b9a98a6d18c24a0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7fae89b379b5411189ac0ac74b2dd4"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afe7fae89b379b5411189ac0ac74b2dd4">var</a> = &quot;VG_FULL_TRACEBACK&quot;</td></tr>
<tr class="separator:afe7fae89b379b5411189ac0ac74b2dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1798abb6fcee86ab5b0539fb764eb2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#abd1798abb6fcee86ab5b0539fb764eb2">fullTrace</a> = false</td></tr>
<tr class="separator:abd1798abb6fcee86ab5b0539fb764eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a4ab10687f0a0cca11ecfd062d9bb0a07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg.html#a4ab10687f0a0cca11ecfd062d9bb0a07">vg::benchtime</a> = typedef chrono::nanoseconds</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We define a duration type for expressing benchmark times in. </p>

</div>
</div>
<a class="anchor" id="aa9d8b2ece3ab50a38656273662553f2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg.html#aa9d8b2ece3ab50a38656273662553f2d">vg::Chain</a> = typedef vector&lt;pair&lt;const <a class="el" href="structvg_1_1Snarl.html">Snarl</a>*, bool&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Snarls are defined at the Protobuf level, but here is how we define chains as real objects.</p>
<p>A chain is a sequence of Snarls, in either normal (false) or reverse (true) orientation.</p>
<p>The <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> is going to have one official copy of each chain stored, and it will give you a pointer to it on demand. </p>

</div>
</div>
<a class="anchor" id="a6225846768d2b6dbbbefab9e240a9e02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pair&lt;<a class="el" href="structvg_1_1handle__t.html">handle_t</a>, <a class="el" href="structvg_1_1handle__t.html">handle_t</a>&gt; <a class="el" href="namespacevg.html#a6225846768d2b6dbbbefab9e240a9e02">vg::edge_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7a29090bbc6b842c2362f9da44a4a57c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, std::vector&lt;<a class="el" href="structvg_1_1Edge.html">Edge</a>*&gt; &gt; <a class="el" href="namespacevg.html#a7a29090bbc6b842c2362f9da44a4a57c">vg::EdgeMapping</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9b677be2f409ffcbefd5d9f6149c80c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg.html#a9b677be2f409ffcbefd5d9f6149c80c1">vg::GAMIndex</a> = typedef <a class="el" href="classvg_1_1StreamIndex.html">StreamIndex</a>&lt;<a class="el" href="structvg_1_1Alignment.html">Alignment</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define a GAM index as a stream index over a stream of Alignments. </p>

</div>
</div>
<a class="anchor" id="a6c00bf57d75db83e41ac19a88882c043"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg.html#a6c00bf57d75db83e41ac19a88882c043">vg::GAMSorter</a> = typedef <a class="el" href="classvg_1_1StreamSorter.html">StreamSorter</a>&lt;<a class="el" href="structvg_1_1Alignment.html">Alignment</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7143bc6d4008d03bc4a0ac4d4ba26948"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unordered_map&lt;<a class="el" href="structvg_1_1handle__t.html">handle_t</a>, int&gt; <a class="el" href="namespacevg.html#a7143bc6d4008d03bc4a0ac4d4ba26948">vg::Handle2Component</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0942a662fe36dad76d2d0e310ec66e3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unordered_set&lt;<a class="el" href="structvg_1_1handle__t.html">handle_t</a>&gt; <a class="el" href="namespacevg.html#a0942a662fe36dad76d2d0e310ec66e3f">vg::HandleSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4bc2511884a0496ff2193e1a1151350a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int64_t <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">vg::id_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Represents a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a> ID. ID type is a 64-bit signed int. </p>

</div>
</div>
<a class="anchor" id="a9cdb6d0305bd8cbf46efed9b2799877a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t <a class="el" href="namespacevg.html#a9cdb6d0305bd8cbf46efed9b2799877a">vg::off_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Represents an offset along the sequence of a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a>. Offsets are size_t. </p>

</div>
</div>
<a class="anchor" id="a54512eefe4b0e14cb3b0057c23350240"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::tuple&lt;<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool, <a class="el" href="namespacevg.html#a9cdb6d0305bd8cbf46efed9b2799877a">off_t</a>&gt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">vg::pos_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Represents an oriented position on a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a>. <a class="el" href="structvg_1_1Position.html">Position</a> type: id, direction, offset. Offset is counted as for as prorobuf <a class="el" href="structvg_1_1Position.html">Position</a>, from the node's first base on the forward strand, and from its last base on the reverse strand. </p>

</div>
</div>
<a class="anchor" id="a7392de2ef03532b2ec3461ebb178c75a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">vg::real_t</a> = typedef long double</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a101965168ba874bb68cb69198dbf84d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg.html#a101965168ba874bb68cb69198dbf84d0">vg::thread_t</a> = typedef vector&lt;<a class="el" href="structxg_1_1XG_1_1ThreadMapping.html">xg::XG::ThreadMapping</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ae8af508a4586e2447fdbf2a30a213b39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacevg.html#ae8af508a4586e2447fdbf2a30a213b39">vg::MappingQualityMethod</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ae8af508a4586e2447fdbf2a30a213b39a9ab31888ec6c2da1a29c051c49f2d5ea"></a>Approx</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae8af508a4586e2447fdbf2a30a213b39a71ab21548d5ec730cee91982aa78275e"></a>Exact</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae8af508a4586e2447fdbf2a30a213b39a0f1da9e8a7bb929e940b4fa8be187340"></a>Adaptive</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae8af508a4586e2447fdbf2a30a213b39aa676d6ce23c4076e354ffb65936c03d1"></a>None</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ac47f059d08b97304ea21d00dfc19cd97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacevg.html#ac47f059d08b97304ea21d00dfc19cd97">vg::SnarlType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumeration of the classifications of snarls. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ac47f059d08b97304ea21d00dfc19cd97a7db3292851220acc20f75deebe0924ff"></a>UNCLASSIFIED</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ac47f059d08b97304ea21d00dfc19cd97aea6b4b85aa567a940c7434df2fcb56fb"></a>ULTRABUBBLE</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ac47f059d08b97304ea21d00dfc19cd97a0e62c0ff8521d5960a5cc819a7bf7230"></a>UNARY</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a6391a10ec421fbb6c487f491bd978ef6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::add_alt_allele </td>
          <td>(</td>
          <td class="paramtype">vcflib::Variant &amp;&#160;</td>
          <td class="paramname"><em>variant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>allele</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new alt allele to a vcflib Variant, since apaprently there's no method for that already.</p>
<p>If that allele already exists in the variant, does not add it again.</p>
<p>Retuerns the allele number (0, 1, 2, etc.) corresponding to the given allele string in the given variant. </p>

</div>
</div>
<a class="anchor" id="a0d4ce16064ad3986381aeead6afe317f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::add_log </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>log_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>log_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afe2d6096dfe672a486e44df018c713c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::add_thread_edges_to_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="trace__main_8cpp.html#a563ab679d6ece5cca62b6300d724188d">thread_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; pair&lt; int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2adfa9e81b2553fefdd5e1d6b24c7a77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::add_thread_nodes_to_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="trace__main_8cpp.html#a563ab679d6ece5cca62b6300d724188d">thread_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a948a49f6716e35c8da05e84497dc01e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::addArbitraryTelomerePair </td>
          <td>(</td>
          <td class="paramtype">vector&lt; stCactusEdgeEnd * &gt;&#160;</td>
          <td class="paramname"><em>ends</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stList *&#160;</td>
          <td class="paramname"><em>telomeres</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds an arbitrary pair of telomeres in a Cactus graph, which are are either a pair of bridge edge ends or a pair of chain edge ends, oriented such that they form a pair of boundaries.</p>
<p>Mostly copied from the pinchesAndCacti unit tests. </p>

</div>
</div>
<a class="anchor" id="a92de94b4571057762bb3152de1376e51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::adjacent_mappings </td>
          <td>(</td>
          <td class="paramtype">const Mapping &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mapping &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0df0c35a951519aa4a74bf098a253516"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vg::advance_split </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a split of items across a certain number of categories, as ints between the two given bidirectional iterators, advance to the next split and return true. If there is no next split, leave the collection unchanged and return false. </p>

</div>
</div>
<a class="anchor" id="aa63fccb24f075243da0ba145eb8d6aca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Position.html">Position</a> vg::alignment_end </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acdc3ca4569facd77e26c78ba583e4f0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; vg::alignment_ends </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae4defc9906e81731eab06f8acaa28369"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::alignment_from_length </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7b9365497bbf0bc45a9fbae2530397fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::alignment_is_valid </td>
          <td>(</td>
          <td class="paramtype">Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HandleGraph *&#160;</td>
          <td class="paramname"><em>hgraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check to make sure edits on the alignment's path don't assume incorrect node lengths or ids </p>

</div>
</div>
<a class="anchor" id="a15b82cc5c99cc3e8f78229ac971ec9c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::alignment_middle </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a97001b9147dae4b72454839d411ced97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::alignment_quality_char_to_short </td>
          <td>(</td>
          <td class="paramtype">Alignment &amp;&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2a4413a5d745c8fdc6339efdcd13310c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, int &gt; vg::alignment_quality_per_node </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5723504dd654ecf3ee17566070e9fc0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::alignment_quality_short_to_char </td>
          <td>(</td>
          <td class="paramtype">Alignment &amp;&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3ad13bf14c3488a2d7a86931831ce25d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; string,vector&lt; pair&lt; size_t, bool &gt; &gt; &gt; vg::alignment_refpos_to_path_offsets </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the path offsets as cached in the alignment </p>

</div>
</div>
<a class="anchor" id="aac05a70ed0313422bd481c7bec32f830"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::alignment_set_distance_to_correct </td>
          <td>(</td>
          <td class="paramtype">Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>annotate the first alignment with its minimum distance to the second in their annotated paths </p>

</div>
</div>
<a class="anchor" id="acc99c5b394f220a3280d632cc8e3d528"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::alignment_set_distance_to_correct </td>
          <td>(</td>
          <td class="paramtype">Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; string, vector&lt; pair&lt; size_t, bool &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>base_offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab7f897cb4a7bbbd40edcb938cdbd4e7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Position.html">Position</a> vg::alignment_start </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1a8a5ed350653399ec4cf9009ebecd7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bam1_t * vg::alignment_to_bam </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>sam_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>refseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>refpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>refrev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>cigar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>mateseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>matepos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>tlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a paired <a class="el" href="structvg_1_1Alignment.html">Alignment</a> to a BAM record. If the alignment is unmapped, refpos must be -1. Otherwise, refpos must be the position on the reference sequence to which the alignment is aligned. Similarly, refseq must be the sequence aligned to, or "" if unaligned. The mateseq and matepos fields must be set similarly for the mate. Note that mateseq must not be "=".</p>
<p>Remember to clean up with bam_destroy1(b); </p>

</div>
</div>
<a class="anchor" id="afc6c2a0b561c1b062f3b68ecf1c3dfe9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bam1_t * vg::alignment_to_bam </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>sam_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>refseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>refpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>refrev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>cigar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert an unpaired <a class="el" href="structvg_1_1Alignment.html">Alignment</a> to a BAM record. If the alignment is unmapped, refpos must be -1. Otherwise, refpos must be the position on the reference sequence to which the alignment is aligned. Similarly, refseq must be the sequence aligned to, or "" if unaligned.</p>
<p>Remember to clean up with bam_destroy1(b); </p>

</div>
</div>
<a class="anchor" id="a4d96468183e72f5c516769eed2692de1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bam1_t* vg::alignment_to_bam_internal </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>sam_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>refseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>refpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>refrev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>cigar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>mateseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>matepos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>tlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paired</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a38cb960f8c643934d65c03f0cc85442c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::alignment_to_length </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a02e2925cdadc924a1acab1e0d9b3ea8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::alignment_to_sam </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>refseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>refpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>refrev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>cigar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>mateseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>matepos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>tlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a paired <a class="el" href="structvg_1_1Alignment.html">Alignment</a> to a SAM record. If the alignment is unmapped, refpos must be -1. Otherwise, refpos must be the position on the reference sequence to which the alignment is aligned. Similarly, refseq must be the sequence aligned to, or "" if unaligned. The mateseq and matepos fields must be set similarly for the mate. Note that mateseq must not be "=". </p>

</div>
</div>
<a class="anchor" id="a3a56e92a8f087c406fd957f6632d239f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::alignment_to_sam </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>refseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>refpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>refrev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>cigar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert an unpaired <a class="el" href="structvg_1_1Alignment.html">Alignment</a> to a SAM record. If the alignment is unmapped, refpos must be -1. Otherwise, refpos must be the position on the reference sequence to which the alignment is aligned. Similarly, refseq must be the sequence aligned to, or "" if unaligned. </p>

</div>
</div>
<a class="anchor" id="afc968aaecb3a7f5a5e000aa937db0721"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::alignment_to_sam_internal </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>refseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>refpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>refrev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>cigar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>mateseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>matepos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>tlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paired</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7a1786f1e7e453c4b76b319ba101782d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::allATGC </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae24bea33b666a03a0065a10a60d64e9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::allATGCN </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3b46a0183527dc1713f3ab30ef85b185"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::allele_to_string </td>
          <td>(</td>
          <td class="paramtype">VG &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Path &amp;&#160;</td>
          <td class="paramname"><em>allele</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Turn the given path into an allele. Drops the first and last mappings and looks up the sequences for the nodes of the others. </p>

</div>
</div>
<a class="anchor" id="a75a663b07489d2aba3f800943eeb0eaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> &amp; vg::append_path </td>
          <td>(</td>
          <td class="paramtype">Path &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Path &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa4a42fa986c71fc55eac583efbb06099"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1handle__t.html">handle_t</a>&amp; vg::as_handle </td>
          <td>(</td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>View an integer as a handle. </p>

</div>
</div>
<a class="anchor" id="a3489366dd7da532de38d699f14c8b8ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvg_1_1handle__t.html">handle_t</a>&amp; vg::as_handle </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>View a const integer as a const handle. </p>

</div>
</div>
<a class="anchor" id="a5371479058860d693988710d54156e2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t&amp; vg::as_integer </td>
          <td>(</td>
          <td class="paramtype">handle_t &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>View a handle as an integer. </p>

</div>
</div>
<a class="anchor" id="a929e2dd773c4903310e2aa66e583bbf5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint64_t&amp; vg::as_integer </td>
          <td>(</td>
          <td class="paramtype">const handle_t &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>View a const handle as a const integer. </p>

</div>
</div>
<a class="anchor" id="a24378aaa280058f30fba353c35838672"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t&amp; vg::as_integer </td>
          <td>(</td>
          <td class="paramtype">path_handle_t &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>View a path handle as an integer. </p>

</div>
</div>
<a class="anchor" id="ad3d0323f2d1456730663d3ccd69f533c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int64_t&amp; vg::as_integer </td>
          <td>(</td>
          <td class="paramtype">const path_handle_t &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>View a const path handle as a const integer. </p>

</div>
</div>
<a class="anchor" id="a452168726a0c91d15efd88b3b67f227a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t* vg::as_integers </td>
          <td>(</td>
          <td class="paramtype">occurrence_handle_t &amp;&#160;</td>
          <td class="paramname"><em>occurrence_handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>View an occurrence handle as an integer. </p>

</div>
</div>
<a class="anchor" id="a31278b67bd98569e13f12dca47ebec79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int64_t* vg::as_integers </td>
          <td>(</td>
          <td class="paramtype">const occurrence_handle_t &amp;&#160;</td>
          <td class="paramname"><em>occurrence_handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>View a const occurrence handle as a const integer. </p>

</div>
</div>
<a class="anchor" id="ad5ec713923bfa35f80558524ed024c78"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a>&amp; vg::as_path_handle </td>
          <td>(</td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>View an integer as a path handle. </p>

</div>
</div>
<a class="anchor" id="af3b3d74458047408bc21360ebe36d06d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a>&amp; vg::as_path_handle </td>
          <td>(</td>
          <td class="paramtype">const int64_t &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>View a const integer as a const path handle. </p>

</div>
</div>
<a class="anchor" id="aca4ff62f183c00e91085c2fa24559077"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1StrandSupport.html">StrandSupport</a> vg::avgSup </td>
          <td>(</td>
          <td class="paramtype">vector&lt; StrandSupport &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab7caa49b187d9fc25833daa572cdf770"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt; string &gt; vg::balanced_kmers </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>kmer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7211eb89509ce3ca625333936c08ec9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int vg::balanced_stride </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>read_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kmer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a25ca9b103dff30c9383204b427260d00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::bam_to_alignment </td>
          <td>(</td>
          <td class="paramtype">const bam1_t *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; string, string &gt; &amp;&#160;</td>
          <td class="paramname"><em>rg_sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bam_hdr_t *&#160;</td>
          <td class="paramname"><em>bh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgindex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0235b33ab3f656ef6bc9b8700f553511"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::bam_to_alignment </td>
          <td>(</td>
          <td class="paramtype">const bam1_t *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; string, string &gt; &amp;&#160;</td>
          <td class="paramname"><em>rg_sample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a71046fb34dc43f0a3e102e1394ce8697"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::benchmark_control </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The benchmark control function, designed to take some amount of time that might vary with CPU load. </p>

</div>
</div>
<a class="anchor" id="a038ccb26c0c9c0a87601edc7b8b5df70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ProbIn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> vg::binomial_cmf_ln </td>
          <td>(</td>
          <td class="paramtype">ProbIn&#160;</td>
          <td class="paramname"><em>success_logprob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>trials</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>successes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the probability of having the given number of successes or fewer in the given number of trials, with the given success probability. Returns the resulting log probability. </p>

</div>
</div>
<a class="anchor" id="a34b89433618346e971606020965b10ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::build_gcsa_lcp </td>
          <td>(</td>
          <td class="paramtype">const HandleGraph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gcsa::GCSA *&amp;&#160;</td>
          <td class="paramname"><em>gcsa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gcsa::LCPArray *&amp;&#160;</td>
          <td class="paramname"><em>lcp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kmer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>doubling_steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>base_file_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adf53e86632a6d1d4b54370e6d948d08c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1VG.html">VG</a> vg::cactus_to_vg </td>
          <td>(</td>
          <td class="paramtype">stCactusGraph *&#160;</td>
          <td class="paramname"><em>cactus_graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa4d05bc207717708d48e1da09f83eec6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1VG.html">VG</a> vg::cactusify </td>
          <td>(</td>
          <td class="paramtype">VG &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa7c96d053af80e78f785ea1ba4232a10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::can_write_alleles </td>
          <td>(</td>
          <td class="paramtype">vcflib::Variant &amp;&#160;</td>
          <td class="paramname"><em>variant</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if a variant may be output, or false if this variant is valid but the GATK might choke on it.</p>
<p>Mostly used to throw out variants with very long alleles, because GATK has an allele length limit. How alleles that really <em>are</em> 1 megabase deletions are to be specified to GATK is left as an exercise to the reader. </p>

</div>
</div>
<a class="anchor" id="a74563bc5f9f3268b9a933688ad1a5edb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1PhaseUnfolder.html#a402b0f84990279594bfbb1cd71ffd8e5">PhaseUnfolder::path_type</a> vg::canonical_orientation </td>
          <td>(</td>
          <td class="paramtype">const PhaseUnfolder::path_type &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>from_border</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>to_border</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac3b14246f4fe83e3fbdadb1ba838faeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a> vg::chain_begin </td>
          <td>(</td>
          <td class="paramtype">const Chain &amp;&#160;</td>
          <td class="paramname"><em>chain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We define free functions for getting iterators forward and backward through chains. </p>

</div>
</div>
<a class="anchor" id="aefacc656d2c444dfd6e0e445218265cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a> vg::chain_begin_from </td>
          <td>(</td>
          <td class="paramtype">const Chain &amp;&#160;</td>
          <td class="paramname"><em>chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Snarl *&#160;</td>
          <td class="paramname"><em>start_snarl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>snarl_orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We also define a function for getting the <a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a> (forward or reverse complement) for a chain starting with a given snarl in the given inward orientation </p>

</div>
</div>
<a class="anchor" id="a0612d7af2f7366ff81c89824f43a5865"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a> vg::chain_end </td>
          <td>(</td>
          <td class="paramtype">const Chain &amp;&#160;</td>
          <td class="paramname"><em>chain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0627b5d536b881a355d8b419b6f329c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a> vg::chain_end_from </td>
          <td>(</td>
          <td class="paramtype">const Chain &amp;&#160;</td>
          <td class="paramname"><em>chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Snarl *&#160;</td>
          <td class="paramname"><em>start_snarl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>snarl_orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>And the end iterator for the chain (forward or reverse complement) viewed from a given snarl in the given inward orientation </p>

</div>
</div>
<a class="anchor" id="aa24387fbb4606765c23a280316bfcb65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a> vg::chain_rbegin </td>
          <td>(</td>
          <td class="paramtype">const Chain &amp;&#160;</td>
          <td class="paramname"><em>chain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7aed054b974860f2cc4d5be4b7615de0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a> vg::chain_rcbegin </td>
          <td>(</td>
          <td class="paramtype">const Chain &amp;&#160;</td>
          <td class="paramname"><em>chain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We also define some reverse complement iterators, which go from right to left through the chains, but give us the reverse view. For ecample, if all the snarls are oriented forward in the chain, we will iterate through the snarls in reverse order, with each individual snarl also reversed. </p>

</div>
</div>
<a class="anchor" id="ae1369d5e29159750fd14482f73421660"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a> vg::chain_rcend </td>
          <td>(</td>
          <td class="paramtype">const Chain &amp;&#160;</td>
          <td class="paramname"><em>chain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2c65134c67609a001a61291b22337f8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a> vg::chain_rend </td>
          <td>(</td>
          <td class="paramtype">const Chain &amp;&#160;</td>
          <td class="paramname"><em>chain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab4c908e97c97825b3025f8aefc59f025"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::char_to_string </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>letter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a letter into a full string because apparently that's too fancy for the standard library. </p>

</div>
</div>
<a class="anchor" id="abf777e701e331bb422d91135a13408d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> vg::choose_ln </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the number of ways to select k items from a collection of n distinguishable items, ignoring order. Returns the natural log of the (integer) result. </p>

</div>
</div>
<a class="anchor" id="aff409d47a3c337dd9d8a046dc14aaa81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::cigar_against_path </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on_reverse_strand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>path_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>softclip_suppress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acfeff6a4607cc66108f55909e82445e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::cigar_mapping </td>
          <td>(</td>
          <td class="paramtype">const bam1_t *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mapping &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgindex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4efe4d07205cd54c050ca00fc259d92b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::cigar_mapping </td>
          <td>(</td>
          <td class="paramtype">const bam1_t *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mapping *&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgindex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4b35effbcf29e6860145ca7775b913c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::cigar_string </td>
          <td>(</td>
          <td class="paramtype">vector&lt; pair&lt; int, char &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cigar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad970d2836c53996c21e5c5d9d3e0a6d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Annotated &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::clear_annotation </td>
          <td>(</td>
          <td class="paramtype">Annotated *&#160;</td>
          <td class="paramname"><em>annotated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the annotation with the given name. </p>

</div>
</div>
<a class="anchor" id="ae414970cfc37049b4dc9b308d9ed5f59"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Annotated &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::clear_annotation </td>
          <td>(</td>
          <td class="paramtype">Annotated &amp;&#160;</td>
          <td class="paramname"><em>annotated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the annotation with the given name. </p>

</div>
</div>
<a class="anchor" id="afe3e65f9aafb5ab9ce5455cc72fa0b56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; string::const_iterator &gt; vg::cluster_cover </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; MaximalExactMatch &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3380e0f81fc879601afe493949814a4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::cluster_coverage </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; MaximalExactMatch &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af6c60d6eb4cafd02a45384cf71a12bfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt; vg::cluster_nodes </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; MaximalExactMatch &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af55dd67908e8c8a11e0d9effcb5aa725"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Graph.html">Graph</a> vg::cluster_subgraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxg_1_1XG.html">xg::XG</a> &amp;&#160;</td>
          <td class="paramname"><em>xg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; MaximalExactMatch &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>expansion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a subgraph form an xg for a cluster of MEMs from the given alignment </p>

</div>
</div>
<a class="anchor" id="a6de30198879002058213d22de2ce3b4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Graph.html">Graph</a> vg::cluster_subgraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxg_1_1XG.html">xg::XG</a> &amp;&#160;</td>
          <td class="paramname"><em>xg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">vg::MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>expansion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a subgraph form an xg for a cluster of MEMs from the given alignment </p>

</div>
</div>
<a class="anchor" id="a3763744eb52f4ac12c14443e6ce31623"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Graph.html">Graph</a> vg::cluster_subgraph_walk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxg_1_1XG.html">xg::XG</a> &amp;&#160;</td>
          <td class="paramname"><em>xg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">vg::MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>expansion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>use walking to get the hits </p>

</div>
</div>
<a class="anchor" id="a9d8947e51da3156529e12ae131c25a47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::clusters_overlap_in_graph </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; MaximalExactMatch &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; MaximalExactMatch &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af67eb440256877ac857d6649052d7db1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::clusters_overlap_in_read </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; MaximalExactMatch &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; MaximalExactMatch &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a50260b7d42777dd7f352a5ba40ac655e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::clusters_overlap_length </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; MaximalExactMatch &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; MaximalExactMatch &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8fc7225da088d27cd1201422ba011f51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Mapping.html">Mapping</a> vg::concat_mappings </td>
          <td>(</td>
          <td class="paramtype">const Mapping &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mapping &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trim_internal_deletions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac7d43d119d665bda802489b3309e0bce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> vg::concat_paths </td>
          <td>(</td>
          <td class="paramtype">const Path &amp;&#160;</td>
          <td class="paramname"><em>path1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Path &amp;&#160;</td>
          <td class="paramname"><em>path2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa057b3bcb25a7d3ee7f2e4021238982f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt; int64_t &gt; &gt; vg::connected_components </td>
          <td>(</td>
          <td class="paramtype">const MultipathAlignment &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a vector whose elements are vectors with the indexes of the Subpaths in each connected component. An unmapped <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> with no subpaths produces an empty vector. </p>

</div>
</div>
<a class="anchor" id="a7f4eda7e05e5737af72556a59e4bba8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::construct_graph_from_nodes_and_edges </td>
          <td>(</td>
          <td class="paramtype">Graph &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; pair&lt; int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5674e45f23020370046d49c674fd691f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vg::convert </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad7b1ca8b13ad1732d0679723bb206f18"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string vg::convert </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae9e16eec9e4a4120718eba7d5711a7df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::create_ref_allele </td>
          <td>(</td>
          <td class="paramtype">vcflib::Variant &amp;&#160;</td>
          <td class="paramname"><em>variant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>allele</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create the reference allele for an empty vcflib Variant, since apaprently there's no method for that already. Must be called before any alt alleles are added. </p>

</div>
</div>
<a class="anchor" id="ac21f33338c0114d3f715f0a3667f3973"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="structvg_1_1Edit.html">Edit</a>, <a class="el" href="structvg_1_1Edit.html">Edit</a> &gt; vg::cut_edit_at_from </td>
          <td>(</td>
          <td class="paramtype">const Edit &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>from_off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0f5f2b0dfee9f62cbd472210d9ff801f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="structvg_1_1Edit.html">Edit</a>, <a class="el" href="structvg_1_1Edit.html">Edit</a> &gt; vg::cut_edit_at_to </td>
          <td>(</td>
          <td class="paramtype">const Edit &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>to_off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4f45a0764dcd0711bb37067151c78d6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="structvg_1_1Mapping.html">Mapping</a>, <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &gt; vg::cut_mapping </td>
          <td>(</td>
          <td class="paramtype">const Mapping &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Position &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1cb07d52156c2d1a3e13c566bf629760"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a>, <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &gt; vg::cut_mapping </td>
          <td>(</td>
          <td class="paramtype">const mapping_t &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Position &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a86cd2447c52bf50d938b0142bf98dc57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="structvg_1_1Mapping.html">Mapping</a>, <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &gt; vg::cut_mapping </td>
          <td>(</td>
          <td class="paramtype">const Mapping &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af98f355163fd3a01d1d23c978fa1dbd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a>, <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &gt; vg::cut_mapping </td>
          <td>(</td>
          <td class="paramtype">const mapping_t &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9e9091c8bf2f73d219522420a705dc1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="structvg_1_1Mapping.html">Mapping</a>, <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &gt; vg::cut_mapping_offset </td>
          <td>(</td>
          <td class="paramtype">const Mapping &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a455dd0d543b21690c3e71e67ff45e57d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a>, <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &gt; vg::cut_mapping_offset </td>
          <td>(</td>
          <td class="paramtype">const mapping_t &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0456e049dd685a689886372f4b0a354d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="structvg_1_1Path.html">Path</a>, <a class="el" href="structvg_1_1Path.html">Path</a> &gt; vg::cut_path </td>
          <td>(</td>
          <td class="paramtype">const Path &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Position &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1dbdbb650e0a076cd3890c2a74515260"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="structvg_1_1Path.html">Path</a>, <a class="el" href="structvg_1_1Path.html">Path</a> &gt; vg::cut_path </td>
          <td>(</td>
          <td class="paramtype">const Path &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a90fe8f4de1196dd902ac05f7567b9b7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::decompose </td>
          <td>(</td>
          <td class="paramtype">const Path &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; pos_t, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; pos_t, Edit &gt; &amp;&#160;</td>
          <td class="paramname"><em>edits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a58f9a3f311a844e7a223da7e619d2937"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::deterministic_shuffle </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a pair of random access iterators defining a range, deterministically shuffle the contents of the range based on the given integer seed. </p>

</div>
</div>
<a class="anchor" id="ac8d97ef95a167bff0030346ed5880277"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::deterministic_shuffle </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a pair of random access iterators defining a range, deterministically shuffle the contents of the range based on the given string seed. </p>

</div>
</div>
<a class="anchor" id="ae74e428a09df726b5c2f4998b9d0a442"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::deterministic_shuffle </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do a deterministic shuffle with automatic seed determination. </p>

</div>
</div>
<a class="anchor" id="ad3b0a534daaa4c4eb7204b139fbbe3b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::divergence </td>
          <td>(</td>
          <td class="paramtype">const Mapping &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2610da8a8fbe723e13519d79ac2d0afe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::edit_count </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abb5390be8a05d69c4807cb63f74d7975"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::edit_is_deletion </td>
          <td>(</td>
          <td class="paramtype">const Edit &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af2e5aa1a7b7ef3a03f12091e9ab82940"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::edit_is_empty </td>
          <td>(</td>
          <td class="paramtype">const Edit &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a179a9dfaf52b28a041ecb121b89a97ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::edit_is_insertion </td>
          <td>(</td>
          <td class="paramtype">const Edit &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a97f634c48d66ace99c90ed9e9adea317"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::edit_is_match </td>
          <td>(</td>
          <td class="paramtype">const Edit &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a050347fc49e0ac78c1ab9a0d7238b3df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::edit_is_sub </td>
          <td>(</td>
          <td class="paramtype">const Edit &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a40556998a17c0f59c8ecc682af3a99a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::emit_stacktrace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signalNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">siginfo_t *&#160;</td>
          <td class="paramname"><em>signalInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>signalContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a stack trace when something bad happens. Add as a signal handler with sigaction. </p>

</div>
</div>
<a class="anchor" id="a1f4461f901aba4b67353768ee25e23d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::enable_crash_handling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main should call this to turn on our stack tracing support. </p>

</div>
</div>
<a class="anchor" id="aa25419c15b3dcae6b217f893c243c487"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gcsa::byte_type vg::encode_chars </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gcsa::Alphabet &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode the chars into the gcsa2 byte. </p>

</div>
</div>
<a class="anchor" id="acab8d2ef076a0e866c7849aace290124"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::end_backward </td>
          <td>(</td>
          <td class="paramtype">const Chain &amp;&#160;</td>
          <td class="paramname"><em>chain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the last snarl in the given chain is backward relative to the chain. </p>

</div>
</div>
<a class="anchor" id="ac3165438256db24864e88601839197df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::entropy </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>st</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a77c1cb6069f865239d0365b55649bc8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::entropy </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a491e9c11712ae965b8c6745ab33aba21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp; vg::extend_alignment </td>
          <td>(</td>
          <td class="paramtype">Alignment &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afcc55b3037b4e078c4268f08dda7cf4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> &amp; vg::extend_path </td>
          <td>(</td>
          <td class="paramtype">Path &amp;&#160;</td>
          <td class="paramname"><em>path1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Path &amp;&#160;</td>
          <td class="paramname"><em>path2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3beb4892a91e602904b90307803cf176"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::extract_sub_multipath_alignment </td>
          <td>(</td>
          <td class="paramtype">const MultipathAlignment &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subpath_indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultipathAlignment &amp;&#160;</td>
          <td class="paramname"><em>sub_multipath_aln</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> consisting of the Subpaths with the given indexes into a new <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> object </p>

</div>
</div>
<a class="anchor" id="a54a32f7feb38c9f86d7796f0b4f1dac7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> vg::factorial_ln </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate the natural log of the factorial of the given integer. TODO: replace with a cache or giant lookup table from Freebayes. </p>

</div>
</div>
<a class="anchor" id="a99b58aa1a0c067044f1fcbf97627e390"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::fastq_for_each </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(Alignment &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a50976b47c0b2b13fb095a0ef92b3b027"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::fastq_paired_interleaved_for_each </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(Alignment &amp;, Alignment &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4b116363d0208d6448452a3fc0729fef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::fastq_paired_interleaved_for_each_parallel </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(Alignment &amp;, Alignment &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3ba2dd4c8634d1269dedd22ea5f87597"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::fastq_paired_interleaved_for_each_parallel_after_wait </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(Alignment &amp;, Alignment &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; bool(void)&gt;&#160;</td>
          <td class="paramname"><em>single_threaded_until_true</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aedcdef25c312dba95a599ff9c1b44b50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::fastq_paired_two_files_for_each </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>file1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>file2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(Alignment &amp;, Alignment &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae8af448cba49f55b411bad975a1ecec6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::fastq_paired_two_files_for_each_parallel </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>file1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>file2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(Alignment &amp;, Alignment &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a37cf7e912026ec16af129067619de796"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::fastq_paired_two_files_for_each_parallel_after_wait </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>file1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>file2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(Alignment &amp;, Alignment &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; bool(void)&gt;&#160;</td>
          <td class="paramname"><em>single_threaded_until_true</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a581952a0bdf921e9388ace316dbe3a63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::fastq_unpaired_for_each </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(Alignment &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afa17f82de171af01bcc971db6f225dcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::fastq_unpaired_for_each_parallel </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(Alignment &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad435098725ff21d822052abee009d2bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> vg::final_position </td>
          <td>(</td>
          <td class="paramtype">const Path &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9e892bf26f768618a2b8c2abea6a6a60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="namespacevg.html#a6225846768d2b6dbbbefab9e240a9e02">edge_t</a> &gt; vg::find_edges_to_prune </td>
          <td>(</td>
          <td class="paramtype">const HandleGraph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edge_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over all the walks up to length k, adding edges which. </p>

</div>
</div>
<a class="anchor" id="ada7557d06abd0fca3d66f9ca73fe81db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Position.html">Position</a> vg::first_path_position </td>
          <td>(</td>
          <td class="paramtype">const Path &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9fa3b08acc22f29ea5d940317f6948ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::fit_zipf </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad8a651561299e3236ec62af61d509112"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Support.html">Support</a> vg::flip </td>
          <td>(</td>
          <td class="paramtype">const Support &amp;&#160;</td>
          <td class="paramname"><em>to_flip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flip the orientations of a <a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele. ">Support</a>. </p>

</div>
</div>
<a class="anchor" id="a89c2bb28b708cb4acf67eabfaa4b0168"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::flip_doubly_reversed_edges </td>
          <td>(</td>
          <td class="paramtype">Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>clean up doubly-reversed edges </p>

</div>
</div>
<a class="anchor" id="a1f4eaa1a100e433af698e794afa8857b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::flip_nodes </td>
          <td>(</td>
          <td class="paramtype">Alignment &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const set&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; size_t(int64_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad2dc76ed1d84a8e2043955ba3c8a9bb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::for_each_kmer </td>
          <td>(</td>
          <td class="paramtype">const HandleGraph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const kmer_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">id_t&#160;</td>
          <td class="paramname"><em>head_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">id_t&#160;</td>
          <td class="paramname"><em>tail_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over all the kmers in the graph, running lambda on each. </p>

</div>
</div>
<a class="anchor" id="a83d1f079508a3ee8a2705773109a5a8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::from_length </td>
          <td>(</td>
          <td class="paramtype">const Mapping &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a59b4e98d0d99a9b58b56f0946f49b1ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::from_length_after_pos </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Position &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a21d316f0ae049289cacab5117678d6ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::from_length_before_pos </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Position &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a05748ab256c93e2393252aa8ebbdde3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> vg::gamma_ln </td>
          <td>(</td>
          <td class="paramtype">real_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate the natural log of the gamma function of the given argument. </p>

</div>
</div>
<a class="anchor" id="a3240e7b9bf787fb218d6324389ea234e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt; vg::gcsa_nodes_to_positions </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; gcsa::node_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7d3374c888c7c37f1de8370e151af7f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::genotype_svs </td>
          <td>(</td>
          <td class="paramtype">VG *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>gamfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>refpath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes a graph and two GAMs, one tumor and one normal Locates existing variation supported by the tumor and annotate it with a path Then overlay the normal sample Use a depthmap of snarltraversal transforms, one for tumor, one for normal which we can use to count the normal and tumor alleles void somatic_genotyper(VG* graph, string tumorgam, string normalgam);</p>
<p>Do smart augment, maintaining a depth map for tumor/normal perfect matches and then editing in all of the SV reads (after normalization) with a T/N_ prefix Then, get our Snarls count reads supporting each and genotype void somatic_caller_genotyper(VG* graph, string tumorgam, string normalgam); </p>

</div>
</div>
<a class="anchor" id="ae923ee7bdb53f33511c95f66a9c2773a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ProbIn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> vg::geometric_sampling_prob_ln </td>
          <td>(</td>
          <td class="paramtype">ProbIn&#160;</td>
          <td class="paramname"><em>success_logprob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>trials</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the log probability for sampling the given value from a geometric distribution with the given success log probability. The geometric distribution is the distribution of the number of trials, with a given success probability, required to observe a single success. </p>

</div>
</div>
<a class="anchor" id="a1fda752e24eaed100f6c30904d2ca3e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AnnotationType , typename Annotated &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AnnotationType vg::get_annotation </td>
          <td>(</td>
          <td class="paramtype">const Annotated &amp;&#160;</td>
          <td class="paramname"><em>annotated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the annotation with the given name and return it. If not present, returns the Protobuf default value for the annotation type. The value may be a primitive type or an entire Protobuf object. It is undefined behavior to read a value out into a different type than it was stored with. </p>

</div>
</div>
<a class="anchor" id="a1c9f371af54160a44a44afd80c6cf71a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AnnotationType , typename Annotated &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AnnotationType vg::get_annotation </td>
          <td>(</td>
          <td class="paramtype">Annotated *&#160;</td>
          <td class="paramname"><em>annotated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the annotation with the given name and return it. If not present, returns the Protobuf default value for the annotation type. The value may be a primitive type or an entire Protobuf object. It is undefined behavior to read a value out into a different type than it was stored with. </p>

</div>
</div>
<a class="anchor" id="a8cd30aaebcab130194ac375f23e6f098"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::get_current_vmem_kb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current virtual memory size, in kb, or 0 if unsupported. </p>

</div>
</div>
<a class="anchor" id="af76e8a5e74f67093a40ed5f2cd15ff28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Visit.html">Visit</a> vg::get_end_of </td>
          <td>(</td>
          <td class="paramtype">const Chain &amp;&#160;</td>
          <td class="paramname"><em>chain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the outward-facing end <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> for a chain. </p>

</div>
</div>
<a class="anchor" id="a87d7deafb5fe4ce9c7e85a6d7ed9db65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &amp; vg::get_id </td>
          <td>(</td>
          <td class="paramtype">pos_t &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reference to the <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a> ID of a pos_t. </p>

</div>
</div>
<a class="anchor" id="ab1b8b686ef6eca09515be1abe566c013"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::get_input_file </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>optind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(istream &amp;)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a callback with an istream&amp; to an open file if a file name argument is present after the parsed options, or print an error message and exit if one is not. Handles "-" as a filename as indicating standard input. The reference passed is guaranteed to be valid only until the callback returns. Bumps up optind to the next argument if a filename is found. </p>

</div>
</div>
<a class="anchor" id="a09969fef23098c7729a2f190cecb4694"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::get_input_file </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(istream &amp;)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a callback with an istream&amp; to an open file. Handles "-" as a filename as indicating standard input. The reference passed is guaranteed to be valid only until the callback returns. </p>

</div>
</div>
<a class="anchor" id="a511d30ecf4d39aaa944c2f59f6821fad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::get_input_file_name </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>optind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse out the name of an input file (i.e. the next positional argument), or throw an error. File name must be nonempty, but may be "-" or may not exist. </p>

</div>
</div>
<a class="anchor" id="a371d288efeaa5884ce28170274bbc21a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool &amp; vg::get_is_rev </td>
          <td>(</td>
          <td class="paramtype">pos_t &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reference to the reverse flag of a pos_t. </p>

</div>
</div>
<a class="anchor" id="a546b60e87f7fc326074f6dcf2cdd0659"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::get_max_rss_kb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the max RSS usage ever, in kb, or 0 if unsupported. </p>

</div>
</div>
<a class="anchor" id="a917d8892f93a31e2d8c3161de264fea1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::get_max_vmem_kb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the max virtual memory size ever, in kb, or 0 if unsupported. </p>

</div>
</div>
<a class="anchor" id="a4f91415350a5b07bb4b4f90dd531658d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::get_next_alignment_from_fastq </td>
          <td>(</td>
          <td class="paramtype">gzFile&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Alignment &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6e9fd0ae285f5f9dd8605c9f5343e071"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::get_next_alignment_pair_from_fastqs </td>
          <td>(</td>
          <td class="paramtype">gzFile&#160;</td>
          <td class="paramname"><em>fp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gzFile&#160;</td>
          <td class="paramname"><em>fp2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Alignment &amp;&#160;</td>
          <td class="paramname"><em>mate1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Alignment &amp;&#160;</td>
          <td class="paramname"><em>mate2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afb9108ffcadb902a9d82ca882919a38c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::get_next_interleaved_alignment_pair_from_fastq </td>
          <td>(</td>
          <td class="paramtype">gzFile&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Alignment &amp;&#160;</td>
          <td class="paramname"><em>mate1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Alignment &amp;&#160;</td>
          <td class="paramname"><em>mate2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a716ebc4e690ac383342cc1c750bdddd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a9cdb6d0305bd8cbf46efed9b2799877a">off_t</a> &amp; vg::get_offset </td>
          <td>(</td>
          <td class="paramtype">pos_t &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reference to the offset field of a pos_t, which counts along the selected strand of the node. </p>

</div>
</div>
<a class="anchor" id="ae9fc5855bb49062ce72e56c805e1545a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::get_or_make_variant_id </td>
          <td>(</td>
          <td class="paramtype">const vcflib::Variant &amp;&#160;</td>
          <td class="paramname"><em>variant</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae2a0425675c4a85289b230eef2c985b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::get_output_file_name </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>optind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse out the name of an output file (i.e. the next positional argument), or throw an error. File name must be nonempty. </p>

</div>
</div>
<a class="anchor" id="aad98d082285cd6dcc92302924095d666"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::get_pileup_line </td>
          <td>(</td>
          <td class="paramtype">const map&lt; int64_t, NodePileup &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_pileups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const set&lt; pair&lt; int64_t, size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>refCrossreferences</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const set&lt; pair&lt; int64_t, size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>altCrossreferences</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a collection of pileups by original node ID, and a set of original node id:offset cross-references in both ref and alt categories, produce a VCF comment line giving the pileup for each of those positions on those nodes. Includes a trailing newline if nonempty.</p>
<p>TODO: VCF comments aren't really a thing. </p>

</div>
</div>
<a class="anchor" id="a9fb67697fd1e49bcb389a735ba9fa8f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::get_proc_status_value </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the string value for a field in /proc/self/status by name, or "" if unsupported or not found. </p>

</div>
</div>
<a class="anchor" id="afa918cf29c1c8238d88f2bbc94b6abef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Visit.html">Visit</a> vg::get_start_of </td>
          <td>(</td>
          <td class="paramtype">const Chain &amp;&#160;</td>
          <td class="paramname"><em>chain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the inward-facing start <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> for a chain. </p>

</div>
</div>
<a class="anchor" id="ade988dd38efaa705be15ba17500fe219"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::get_thread_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of threads that OMP will produce for a parallel section. TODO: Assumes that this is the same for every parallel section. </p>

</div>
</div>
<a class="anchor" id="a871d5cdd29e1806636314021d0b6d451"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> vg::get_traversal_of_snarl </td>
          <td>(</td>
          <td class="paramtype">VG &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Snarl *&#160;</td>
          <td class="paramname"><em>snarl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlManager &amp;&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Path &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a path (which may run either direction through a snarl, or not touch the ends at all), collect a list of NodeTraversals in order for the part of the path that is inside the snarl, in the same orientation as the path. </p>

</div>
</div>
<a class="anchor" id="a75b6437e6aec966fbcd92fbaa48f98da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple&lt;<a class="el" href="structvg_1_1Support.html">Support</a>, <a class="el" href="structvg_1_1Support.html">Support</a>, size_t&gt; vg::get_traversal_support </td>
          <td>(</td>
          <td class="paramtype">SupportAugmentedGraph &amp;&#160;</td>
          <td class="paramname"><em>augmented</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SnarlManager &amp;&#160;</td>
          <td class="paramname"><em>snarl_manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Snarl &amp;&#160;</td>
          <td class="paramname"><em>site</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlTraversal &amp;&#160;</td>
          <td class="paramname"><em>traversal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlTraversal *&#160;</td>
          <td class="paramname"><em>already_used</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the min support, total support, bp size (to divide total by for average support), and min likelihood for a traversal, optionally special-casing the material used by another traversal. Material used by another traversal only makes half its coverage available to this traversal. </p>

</div>
</div>
<a class="anchor" id="af601021f7ec2c0b0d7404030ee7271c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::getReachableBridges </td>
          <td>(</td>
          <td class="paramtype">stCactusEdgeEnd *&#160;</td>
          <td class="paramname"><em>edgeEnd1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stList *&#160;</td>
          <td class="paramname"><em>bridgeEnds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the bridge ends that form boundary pairs with edgeEnd1. Duplicated from the pinchesAndCacti tests. </p>

</div>
</div>
<a class="anchor" id="a2dc613a63afb3f23851c96494006630d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::getReachableBridges2 </td>
          <td>(</td>
          <td class="paramtype">stCactusEdgeEnd *&#160;</td>
          <td class="paramname"><em>edgeEnd1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stHash *&#160;</td>
          <td class="paramname"><em>bridgeEndsToBridgeNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stList *&#160;</td>
          <td class="paramname"><em>bridgeEnds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the bridge ends that form boundary pairs with edgeEnd1, using the given getBridgeEdgeEndsToBridgeNodes hash map. Duplicated from the pinchesAndCacti tests. </p>

</div>
</div>
<a class="anchor" id="acd1d1f2f3c885ddf15f941b869c3030c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::gfa_to_graph </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VG *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>only_perfect_match</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Import the given GFA file into the given (empty) <a class="el" href="classvg_1_1VG.html">VG</a>. If only_perfect_match is set, only completely-M-operation CIGARs of length &lt;= node length for edge overlaps will be used, and sequence differences will be resolved arbitrarily. Otherwise, CIGAR strings will be respected, files containing alingments using more bases than the sequences will be rejected, and mismatches in CIGAR-M sequences will form bubbles.</p>
<p>Returns true if the import was successful. Returns false if the import failed because the GFA file is invalid. Throws an error if the import failed because of an apparent bug in the import code, or if the GFA tries to do something that might be technically valid but which we don't know how to interpret. </p>

</div>
</div>
<a class="anchor" id="a60786b653f375199240b023be44313d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::graph_to_gfa </td>
          <td>(</td>
          <td class="paramtype">const VG *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export the given <a class="el" href="classvg_1_1VG.html">VG</a> graph to the given GFA file. </p>

</div>
</div>
<a class="anchor" id="a2a6d7cffb12deb3ea3f7ae293755edf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; stCactusGraph *, stList * &gt; vg::handle_graph_to_cactus </td>
          <td>(</td>
          <td class="paramtype">PathHandleGraph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>hint_paths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adfbbf25510f3a739532e075c2d59041a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1VG.html">VG</a> vg::handle_to_vg </td>
          <td>(</td>
          <td class="paramtype">const HandleGraph *&#160;</td>
          <td class="paramname"><em>xg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes in a pointer to a <a class="el" href="classvg_1_1HandleGraph.html">HandleGraph</a> and converts it to a <a class="el" href="classvg_1_1VG.html">VG</a> graph. </p>

</div>
</div>
<a class="anchor" id="a9618d2d1905ec3bbb4721441f380f13c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; vg::haplotype_consistent_alignments </td>
          <td>(</td>
          <td class="paramtype">const MultipathAlignment &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhaplo_1_1ScoreProvider.html">haplo::ScoreProvider</a> &amp;&#160;</td>
          <td class="paramname"><em>score_provider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optimal_first</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds all alignments consistent with haplotypes available by incremental search with the given haplotype score provider. Pads to a certain count with haplotype-inconsistent alignments that are population-scorable (i.e. use only edges used by some haplotype in the index), and then with unscorable alignments if scorable ones are unavailable. This may result in an empty vector.</p>
<p>Output Alignments may not be unique. The input <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> may have exponentially many ways to spell the same <a class="el" href="structvg_1_1Alignment.html">Alignment</a>, and we will look at all of them. We also may have duplicates of the optimal alignment if we are asked to produce it unconsitionally.</p>
<p>Note: Assumes that each subpath's <a class="el" href="structvg_1_1Path.html">Path</a> object uses one <a class="el" href="structvg_1_1Mapping.html">Mapping</a> per node and that start subpaths have been identified</p>
<p>Args: multipath_aln multipath alignment to find optimal paths through score_provider a <a class="el" href="classhaplo_1_1ScoreProvider.html">haplo::ScoreProvider</a> that supports incremental search over its haplotype database (such as a GBWTScoreProvider) count maximum number of haplotype-inconsistent alignments to pad to optimal_first always compute and return first the optimal alignment, even if not haplotype-consistent </p>

</div>
</div>
<a class="anchor" id="a1b545f6474c6e528176031149a8bc570"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::has_inversion </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if we find an edge that may specify an inversion </p>

</div>
</div>
<a class="anchor" id="a94f469aebb2be5b0028c337108d253fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string vg::hash_alignment </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8bc1d89bbcee041956e59895ed605ca3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple&lt; double, double, double &gt; vg::hash_to_rgb </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_sum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0676eec9e08d9589fe286cabdd16ffb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bam_hdr_t * vg::hts_file_header </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad78ddf79cde91ee5ee05cf6d74dbec39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::hts_for_each </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(Alignment &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgindex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad7abb14966c1c20cff85c5744a47de0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::hts_for_each </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(Alignment &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5ffaa04b09a709602834dbf5a4e8509b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::hts_for_each_parallel </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(Alignment &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgindex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a59c6c494c2e7663fb14e40c978b4f9e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::hts_for_each_parallel </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(Alignment &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a03de4dcf9bfbc8ef1735076da3b922cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bam_hdr_t * vg::hts_string_header </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; string, int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; string, string &gt; &amp;&#160;</td>
          <td class="paramname"><em>rg_sample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9f6602b7e7a46c19819c8f362147b315"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> vg::id </td>
          <td>(</td>
          <td class="paramtype">const pos_t &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the id of the node a pos_t is on. </p>

</div>
</div>
<a class="anchor" id="a84d3918e06a7c8948bb6e91ba1226fa9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::identify_start_subpaths </td>
          <td>(</td>
          <td class="paramtype">MultipathAlignment &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the start subpaths (i.e. the source nodes of the multipath DAG) and stores them in the 'start' field of the <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> </p>

</div>
</div>
<a class="anchor" id="ab3c5c7a407962a8c735c1d533cc0b186"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::identity </td>
          <td>(</td>
          <td class="paramtype">const Path &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9fa6175557c33cd572b8726222cf6547"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a>&amp; vg::increment_node_mapping_ids </td>
          <td>(</td>
          <td class="paramtype">Path &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">id_t&#160;</td>
          <td class="paramname"><em>inc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3ad3588bcc84b46c6ed107e604f9128e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::index_positions </td>
          <td>(</td>
          <td class="paramtype">VG &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; long, Node * &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; long, Edge * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acd31d3a8dc67801f147d0ba1b0059c3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> vg::initial_position </td>
          <td>(</td>
          <td class="paramtype">const Path &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa7c32d1e90ec006624a7ee03655f3c35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::integer_power </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>power</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aca4239af1a9e3eb1283f78bf5cc1411a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::integer_power </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>exponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes base^exponent in log(exponent) time. </p>

</div>
</div>
<a class="anchor" id="abe6f7955b97d8537da2133a47f37f462"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::is_all_n </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return True if the given string is entirely Ns of either case, and false otherwise. </p>

</div>
</div>
<a class="anchor" id="a4e701675f6d1b67522349bf5b7651bb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::is_alt_path </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the given path name is a variant ref or alt allele alt path. </p>

</div>
</div>
<a class="anchor" id="a3620df68e5af61a8eb660e4a4838ea06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::is_empty </td>
          <td>(</td>
          <td class="paramtype">const pos_t &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if a pos_t is unset. </p>

</div>
</div>
<a class="anchor" id="a5570a5685bef6eee6ac2697920ebc6c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::is_id_sortable </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if the graph is id-sortable (no reverse links) </p>

</div>
</div>
<a class="anchor" id="a52292dfd3869a811170f7c5c0d9da564"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::is_match </td>
          <td>(</td>
          <td class="paramtype">const Translation &amp;&#160;</td>
          <td class="paramname"><em>translation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a97c44463adc7ddcc77ac9664692a62b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::is_number </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af051490e6e94b4c476695610472cdf5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::is_number </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aac725dd44bc5a8f540554d4b1882c1fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::is_rev </td>
          <td>(</td>
          <td class="paramtype">const pos_t &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if a pos_t is on the reverse strand of its node. </p>

</div>
</div>
<a class="anchor" id="a661fc17618ee9ff7bd9d469c74c63369"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::kmer_to_gcsa_kmers </td>
          <td>(</td>
          <td class="paramtype">const kmer_t &amp;&#160;</td>
          <td class="paramname"><em>kmer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gcsa::Alphabet &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const gcsa::KMer &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the <a class="el" href="structvg_1_1kmer__t.html">kmer_t</a> to a set of gcsa2 binary kmers which are exposed via a callback. </p>

</div>
</div>
<a class="anchor" id="aa1c1e5b8ce9f9607976913317102d6dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Position.html">Position</a> vg::last_path_position </td>
          <td>(</td>
          <td class="paramtype">const Path &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9b8a42961530e37f3cebdb59ba4e8010"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a101965168ba874bb68cb69198dbf84d0">thread_t</a>, int &gt; &gt; vg::list_haplotypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structxg_1_1XG_1_1ThreadMapping.html">xg::XG::ThreadMapping</a>&#160;</td>
          <td class="paramname"><em>start_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>extend_distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a475f13479c0cfe87feb6ed287ca2a5ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a101965168ba874bb68cb69198dbf84d0">thread_t</a>, int &gt; &gt; vg::list_haplotypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gbwt::GBWT &amp;&#160;</td>
          <td class="paramname"><em>haplotype_database</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structxg_1_1XG_1_1ThreadMapping.html">xg::XG::ThreadMapping</a>&#160;</td>
          <td class="paramname"><em>start_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>extend_distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a664ec3301c226596ad971b97a8e1fa65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::ln_to_log10 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a number ln to the same number log 10. </p>

</div>
</div>
<a class="anchor" id="a48d9ec9295afc7457506af4ddaf44217"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::log10_to_ln </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>l10</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a number log 10 to the same number ln. </p>

</div>
</div>
<a class="anchor" id="a64b25a99232585c5e76baf01d1ef5520"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::logprob_add </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>logprob1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>logprob2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0f8a1a81a5402187152a97ca6293b4f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::logprob_geometric_mean </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lnprob1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lnprob2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1056422cd0697f2bbdcf8a085486793a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::logprob_invert </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>logprob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a93d81b5193ecfc9600990bd427337adf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Collection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Collection::value_type vg::logprob_sum </td>
          <td>(</td>
          <td class="paramtype">const Collection &amp;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the sum of the values in a collection, where the values are log probabilities and the result is the log of the total probability. Items must be convertible to/from doubles for math. </p>

</div>
</div>
<a class="anchor" id="a66d295b4b0f83393ce621b44d88680a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::logprob_to_phred </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>logprob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aea77a4ed92d78c48a08fce58cf319c4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::logprob_to_prob </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>logprob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2d9f0a2379194fb00d706e90d373b378"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> vg::make_pos_t </td>
          <td>(</td>
          <td class="paramtype">const Position &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="structvg_1_1Position.html">Position</a> to a (much smaller) pos_t. </p>

</div>
</div>
<a class="anchor" id="acb641e072b9e234aac717885669533b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> vg::make_pos_t </td>
          <td>(</td>
          <td class="paramtype">id_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pos_t from a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a> ID, an orientation flag, and an offset along that strand of the node. </p>

</div>
</div>
<a class="anchor" id="afc066dab7543192bf782959ef160f2d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> vg::make_pos_t </td>
          <td>(</td>
          <td class="paramtype">gcsa::node_type&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pos_t from a gcsa node. </p>

</div>
</div>
<a class="anchor" id="a6247de8deb27aaabf2bc0d6fc755f693"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Position.html">Position</a> vg::make_position </td>
          <td>(</td>
          <td class="paramtype">const pos_t &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a pos_t to a <a class="el" href="structvg_1_1Position.html">Position</a>. </p>

</div>
</div>
<a class="anchor" id="a2794a8e24388f4dca7063d583b74ba2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Position.html">Position</a> vg::make_position </td>
          <td>(</td>
          <td class="paramtype">id_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="structvg_1_1Position.html">Position</a> from a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a> ID, an orientation flag, and an offset along that strand of the node. </p>

</div>
</div>
<a class="anchor" id="a4cdd9b08b7b6d6e15d00536554f3ca56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Position.html">Position</a> vg::make_position </td>
          <td>(</td>
          <td class="paramtype">gcsa::node_type&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a <a class="el" href="structvg_1_1Position.html">Position</a> from a gcsa node. </p>

</div>
</div>
<a class="anchor" id="acc312d814d6a06a4a5159c7943675bbe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::make_shuffle_seed </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make seeds for Alignments based on their sequences. </p>

</div>
</div>
<a class="anchor" id="a31063b9139a2b92d5c5742635ca9e090"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::make_shuffle_seed </td>
          <td>(</td>
          <td class="paramtype">const Alignment *&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make seeds for Alignments based on their sequences. </p>

</div>
</div>
<a class="anchor" id="a1366c7a10c9c94dd390323fe8c3fe026"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::make_shuffle_seed </td>
          <td>(</td>
          <td class="paramtype">const pair&lt; Alignment, Alignment &gt; *&#160;</td>
          <td class="paramname"><em>alns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make seeds for pairs of Alignments based on their concatenated sequences. </p>

</div>
</div>
<a class="anchor" id="a1c0ae5cc687e77bb7cee28e975a005b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Support.html">Support</a> vg::make_support </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>forward</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>reverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TBD Create a <a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele. ">Support</a> for the given forward and reverse coverage and quality. </p>

</div>
</div>
<a class="anchor" id="aa74ef603900cf05ce35dbab813d21deb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::make_variant_id </td>
          <td>(</td>
          <td class="paramtype">const vcflib::Variant &amp;&#160;</td>
          <td class="paramname"><em>variant</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ace99283a6b34f0891dc0b49f0cd60eea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">set&lt;T&gt; vg::map_keys_to_set </td>
          <td>(</td>
          <td class="paramtype">const map&lt; T, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4833086451a8b97af4709aa6c7385177"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class T, class A=std::allocator&lt; T &gt;&gt; class Container, typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container&lt;Output&gt; vg::map_over </td>
          <td>(</td>
          <td class="paramtype">const Container&lt; Input &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; Output(const Input &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We have a transforming map function that we can chain. </p>

</div>
</div>
<a class="anchor" id="a57a704ecec885cb89b7b3845c8a990e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::mapping_against_path </td>
          <td>(</td>
          <td class="paramtype">Alignment &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bam1_t *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on_reverse_strand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa8c1de94b56959d2c5ece78540fe6727"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::mapping_against_path </td>
          <td>(</td>
          <td class="paramtype">Alignment &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bam1_t *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>chr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on_reverse_strand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a27af27aefacd2822744823bee4fe9366"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::mapping_cigar </td>
          <td>(</td>
          <td class="paramtype">const Mapping &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, char &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cigar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afeef6a4c023183ead5725398b14d443c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::mapping_ends_in_deletion </td>
          <td>(</td>
          <td class="paramtype">const Mapping &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa2aa77c6d4db628d13488c0bd82538ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::mapping_from_length </td>
          <td>(</td>
          <td class="paramtype">const Mapping &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a78ea8a2cf04759a3cfecbe4bf3e926c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::mapping_is_match </td>
          <td>(</td>
          <td class="paramtype">const Mapping &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae8ba5042b838f859a078cf014f1a0871"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::mapping_is_simple_match </td>
          <td>(</td>
          <td class="paramtype">const Mapping &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6d10b5bc5677fdb0ae164f79848bb1bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::mapping_is_total_deletion </td>
          <td>(</td>
          <td class="paramtype">const Mapping &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2b648cd1a51584623d6618565d3ca9c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string vg::mapping_sequence </td>
          <td>(</td>
          <td class="paramtype">const Mapping &amp;&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>node_seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac23702705b681eacdfd1b3bcbc5254b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string vg::mapping_sequence </td>
          <td>(</td>
          <td class="paramtype">const Mapping &amp;&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Node &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa377b3e776e312c717aedec842216f48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::mapping_starts_in_deletion </td>
          <td>(</td>
          <td class="paramtype">const Mapping &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad993b1f289a57f3413b85840984b459c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::mapping_string </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mapping &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9ef1ccef545dfc30f9123eba61267b4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::mapping_to_length </td>
          <td>(</td>
          <td class="paramtype">const Mapping &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a242b97c26d74e9fc05ad16c31b21dcca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::maps_to_node </td>
          <td>(</td>
          <td class="paramtype">const Path &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">id_t&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7b4eddcd66a511a113e44ae2589c7ce6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1StrandSupport.html">StrandSupport</a> vg::maxSup </td>
          <td>(</td>
          <td class="paramtype">vector&lt; StrandSupport &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6eef175773ce8532826ba78eee0cece5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::median </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae1678438e6011469b88ddf3b54023013"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; int64_t, int64_t &gt; vg::mem_min_oriented_distances </td>
          <td>(</td>
          <td class="paramtype">const MaximalExactMatch &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaximalExactMatch &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab166cf79239664721ff1768e331f43ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; gcsa::node_type, size_t &gt; &gt; vg::mem_node_start_positions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxg_1_1XG.html">xg::XG</a> &amp;&#160;</td>
          <td class="paramname"><em>xg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1MaximalExactMatch.html">vg::MaximalExactMatch</a> &amp;&#160;</td>
          <td class="paramname"><em>mem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the handles that a mem covers </p>

</div>
</div>
<a class="anchor" id="aa412de4741b61d2a8b863f50f31209e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::mems_overlap </td>
          <td>(</td>
          <td class="paramtype">const MaximalExactMatch &amp;&#160;</td>
          <td class="paramname"><em>mem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaximalExactMatch &amp;&#160;</td>
          <td class="paramname"><em>mem2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af5d04132733b3487e3dab20729645850"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::mems_overlap_length </td>
          <td>(</td>
          <td class="paramtype">const MaximalExactMatch &amp;&#160;</td>
          <td class="paramname"><em>mem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaximalExactMatch &amp;&#160;</td>
          <td class="paramname"><em>mem2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab0bec9992b4441128754ac4ed1a330e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string vg::mems_to_json </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; MaximalExactMatch &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2c9985bf70965bd36bb54f910ab74e3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> vg::merge_adjacent_edits </td>
          <td>(</td>
          <td class="paramtype">const Path &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge adjacent edits of the same type. </p>

</div>
</div>
<a class="anchor" id="a30a83a9e127a0c7d75118dc14a8985f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Mapping.html">Mapping</a> vg::merge_adjacent_edits </td>
          <td>(</td>
          <td class="paramtype">const Mapping &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge adjacent edits of the same type. </p>

</div>
</div>
<a class="anchor" id="afa2d2a5d955cff1e7a99369055ebe75d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::merge_alignments </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; Alignment &gt; &amp;&#160;</td>
          <td class="paramname"><em>alns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9d71527a132d7e6bf364d2108b269e09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::merge_alignments </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af6a24c86c25b540e0e4e75a01d1bfb8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::merge_non_branching_subpaths </td>
          <td>(</td>
          <td class="paramtype">MultipathAlignment &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges non-branching paths in a multipath alignment in place. </p>

</div>
</div>
<a class="anchor" id="aa539af4f481d4e955ede26ee85c320c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* vg::mergeNodeObjects </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7848d492a243a93f37b1ac52a541a96a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::middle_signature </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af64c67658563ff567bc0b103ef1d8af4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; string, string &gt; vg::middle_signature </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a95de8f8ed7a5768c89ac738ca6afc692"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; int64_t, int64_t &gt; vg::min_oriented_distances </td>
          <td>(</td>
          <td class="paramtype">const map&lt; string, vector&lt; pair&lt; size_t, bool &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_offsets1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; string, vector&lt; pair&lt; size_t, bool &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_offsets2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the min distance in the path offsets where the path orientation is the same and different. </p>

</div>
</div>
<a class="anchor" id="a545d769a5b2efb252ae12b1babc68a5f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1StrandSupport.html">StrandSupport</a> vg::minSup </td>
          <td>(</td>
          <td class="paramtype">vector&lt; StrandSupport &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abc8f8791be2575164e6070e1cef39b4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::modular_exponent </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>exponent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes base^exponent mod modulus in log(exponent) time without requiring more than 64 bits to represent exponentiated number </p>

</div>
</div>
<a class="anchor" id="a074fcebfeb68fc970b5b2a0db3722f01"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ProbIn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> vg::multinomial_censored_sampling_prob_ln </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; ProbIn &gt; &amp;&#160;</td>
          <td class="paramname"><em>probs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; vector&lt; bool &gt;, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>obs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the log probability for sampling any actual set of category counts that is consistent with the constraints specified by obs, using the per-category probabilities defined in probs.</p>
<p>Obs maps from a vector of per-category flags (called a "class") to a number of items that might be in any of the flagged categories.</p>
<p>For example, if there are two equally likely categories, and one item flagged as potentially from either category, the probability of sampling a set of category counts consistent with that constraint is 1. If instead there are three equally likely categories, and one item flagged as potentially from two of the three but not the third, the probability of sampling a set of category counts consistent with that constraint is 2/3. </p>

</div>
</div>
<a class="anchor" id="a15f09f05f7894863e9cd852c63266078"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> vg::multinomial_choose_ln </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the number of ways to select k_1, k_2, ... k_i items into i buckets from a collection of n distinguishable items, ignoring order. All of the items have to go into the buckets, so all k_i must sum to n. To compute choose you have to call this function with a 2-element vector, to represent the chosen and not-chosen buckets. Returns the natural log of the (integer) result.</p>
<p>TODO: Turns out we don't actually need this for the ambiguous multinomial after all. </p>

</div>
</div>
<a class="anchor" id="af4d69cf9a7d7e6272960fcb9f0a0a00c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ProbIn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> vg::multinomial_sampling_prob_ln </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; ProbIn &gt; &amp;&#160;</td>
          <td class="paramname"><em>probs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>obs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the probability for sampling the counts in obs from a set of categories weighted by the probabilities in probs. Works for both double and real_t probabilities. Also works for binomials. </p>

</div>
</div>
<a class="anchor" id="a434e32ac84fd027508a6506e80107331"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> vg::node_end </td>
          <td>(</td>
          <td class="paramtype">id_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produce the end <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> of a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a>. </p>

</div>
</div>
<a class="anchor" id="a64eca16947663155295546927b631e56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::node_path_position </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>backward</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a30f5b0dc3732e48a6d9b8d1c895cd8d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> vg::node_start </td>
          <td>(</td>
          <td class="paramtype">id_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produce the start <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> of a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a>. </p>

</div>
</div>
<a class="anchor" id="a3ec2e2ef9679291d966bc348a47c3537"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::non_match_end </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae838e7d89edc59dd87747238cee49b49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::non_match_start </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a453b457823e1ddf916ebf298befb4512"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::nonATGCNtoN </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adbaafa0c783156a34cb7e16ec2958c1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::normal_inverse_cdf </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverse CDF of a standard normal distribution. Must have 0 &lt; quantile &lt; 1. </p>

</div>
</div>
<a class="anchor" id="a97e831d426c5d0eaed85a981adb0704a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T vg::normal_pdf </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a416939020600ce2996331c350f1fe68c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a9cdb6d0305bd8cbf46efed9b2799877a">off_t</a> vg::offset </td>
          <td>(</td>
          <td class="paramtype">const pos_t &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the offset along the selected strand of the node from a pos_t. </p>

</div>
</div>
<a class="anchor" id="a67330944ed89a02074373b18253ea603"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator!= </td>
          <td>(</td>
          <td class="paramtype">const handle_t &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const handle_t &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define inequality on handles. </p>

</div>
</div>
<a class="anchor" id="a996b75a4d8bfba1de1d286ec91e9d63a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator!= </td>
          <td>(</td>
          <td class="paramtype">const path_handle_t &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const path_handle_t &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define inequality on path handles. </p>

</div>
</div>
<a class="anchor" id="ab079eab67b88bbf3c28e43d3dcf5690f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator!= </td>
          <td>(</td>
          <td class="paramtype">const occurrence_handle_t &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const occurrence_handle_t &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define inequality on occurrence handles. </p>

</div>
</div>
<a class="anchor" id="abb6063b76b70947010198b46c053b578"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Visit &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Visit &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Two Visits are unequal if they are not equal. </p>

</div>
</div>
<a class="anchor" id="a24e1e38ea29c615b2c5f5cd8dbaeeb2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator!= </td>
          <td>(</td>
          <td class="paramtype">const SnarlTraversal &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlTraversal &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Two SnarlTraversals are unequal if they are not equal. </p>

</div>
</div>
<a class="anchor" id="a654eca8448629e42ae87cadd893ee10e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Snarl &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Snarl &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Two Snarls are unequal if they are not equal. </p>

</div>
</div>
<a class="anchor" id="a84dfc966c7511b05c234d215e3b6aec7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Support.html">Support</a> vg::operator* </td>
          <td>(</td>
          <td class="paramtype">const Support &amp;&#160;</td>
          <td class="paramname"><em>support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale a <a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele. ">Support</a> by a factor. </p>

</div>
</div>
<a class="anchor" id="a10844a7c14d7ff54051bad20c75d012e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Support.html">Support</a> vg::operator* </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Support &amp;&#160;</td>
          <td class="paramname"><em>support</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale a <a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele. ">Support</a> by a factor, the other way </p>

</div>
</div>
<a class="anchor" id="abe7831ba6fe294e8be36fa0359a63848"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Support.html">Support</a>&amp; vg::operator*= </td>
          <td>(</td>
          <td class="paramtype">Support &amp;&#160;</td>
          <td class="paramname"><em>support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale a <a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele. ">Support</a> by a factor, in place. </p>

</div>
</div>
<a class="anchor" id="a27dd5c8f7c6d984a396665cbab5eba01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Support.html">Support</a> vg::operator+ </td>
          <td>(</td>
          <td class="paramtype">const Support &amp;&#160;</td>
          <td class="paramname"><em>one</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Support &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add two <a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele. ">Support</a> values together, accounting for strand. </p>

</div>
</div>
<a class="anchor" id="a4f550213560bfa3c3ad8446478be24d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Support.html">Support</a> &amp; vg::operator+= </td>
          <td>(</td>
          <td class="paramtype">Support &amp;&#160;</td>
          <td class="paramname"><em>one</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Support &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add in a <a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele. ">Support</a> to another. </p>

</div>
</div>
<a class="anchor" id="a5a9eefddbec41755309a378fb150071c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Support.html">Support</a> vg::operator/ </td>
          <td>(</td>
          <td class="paramtype">const Support &amp;&#160;</td>
          <td class="paramname"><em>support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide a <a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele. ">Support</a> by a factor. </p>

</div>
</div>
<a class="anchor" id="a1807752a0b6b83fd5952d36cc64b758d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Support.html">Support</a>&amp; vg::operator/= </td>
          <td>(</td>
          <td class="paramtype">Support &amp;&#160;</td>
          <td class="paramname"><em>support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide a <a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele. ">Support</a> by a factor, in place. </p>

</div>
</div>
<a class="anchor" id="ac476fcc21a47f34d00b4a449b28c686b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const MaximalExactMatch &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaximalExactMatch &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab554a977204c1f756bd0e2738a797447"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const Support &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Support &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele. ">Support</a> less-than, based on total coverage. </p>

</div>
</div>
<a class="anchor" id="a9d2e2066b3b4534b62cde6e4423efd81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const Visit &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Visit &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> is less than another <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> if it represents a traversal of a smaller node, or it represents a traversal of a smaller snarl, or it represents a traversal of the same node or snarl forward instead of backward. </p>

</div>
</div>
<a class="anchor" id="aea87c61d2cc1d5acf1af1d2d351bdb75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const SnarlTraversal &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlTraversal &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A SnalTraversal is less than another if it is a traversal of a smaller <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a>, or if its list of Visits has a smaller <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> first, or if its list of Visits is shorter. </p>

</div>
</div>
<a class="anchor" id="a0fd908e60f72bd98dcba364a16ab7190"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const Snarl &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Snarl &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> is less than another <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> if its type is smaller, or its start <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> is smaller, or its end <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> is smaller, or its parent is smaller. </p>

</div>
</div>
<a class="anchor" id="a7cc9c4d4d792e1e7f38c2c6009207706"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BenchmarkResult &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Benchmark results can be output to streams </p>

</div>
</div>
<a class="anchor" id="af0a4b11db620d43a7e20886d5563e5b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaximalExactMatch &amp;&#160;</td>
          <td class="paramname"><em>mem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a81357f8477c9ed2c3839489e0ada1ced"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mapping_t&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow a <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> to be printed, for debugging purposes. </p>

</div>
</div>
<a class="anchor" id="ad1bdeb550c6f5fa632ad61454321e001"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NodeTraversal &amp;&#160;</td>
          <td class="paramname"><em>nodetraversal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>. </p>

</div>
</div>
<a class="anchor" id="a8108426a3ac5985b0f86493fc524d131"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pos_t &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a pos_t to a stream. </p>

</div>
</div>
<a class="anchor" id="aa5f2c6fe818db874e4aa04ee6e8ea685"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StrandSupport &amp;&#160;</td>
          <td class="paramname"><em>sup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9b4bea48392e7bb9e745b3b04e5bf223"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NodeSide &amp;&#160;</td>
          <td class="paramname"><em>nodeside</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> to a stream. </p>

</div>
</div>
<a class="anchor" id="ac5fc02ee1a5713060cd5f4b33e2eaaab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BitString &amp;&#160;</td>
          <td class="paramname"><em>bs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  ostream &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow BitStrings to be printed for debugging. </p>

</div>
</div>
<a class="anchor" id="a0e459d4a7dda13edf5b79ea8996cfd82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const kmer_t &amp;&#160;</td>
          <td class="paramname"><em>kmer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a <a class="el" href="structvg_1_1kmer__t.html">kmer_t</a> to a stream. </p>

</div>
</div>
<a class="anchor" id="a141fbf9c40f389909c5c46132ab6c615"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Support &amp;&#160;</td>
          <td class="paramname"><em>support</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allow printing a <a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele. ">Support</a>. </p>

</div>
</div>
<a class="anchor" id="a4010a133b32505431f21d802d910eae2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NodeDivider::NodeMap &amp;&#160;</td>
          <td class="paramname"><em>nm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae1afd90e217e729defd8da8c4de03406"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeDivider::Entry&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aead3eeae15cdb2798222c59c2fe4b3aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PileupAugmenter::NodeOffSide &amp;&#160;</td>
          <td class="paramname"><em>no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab38d6991537581f9ce3f4c549f966a33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Visit &amp;&#160;</td>
          <td class="paramname"><em>visit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> can be printed. </p>

</div>
</div>
<a class="anchor" id="ae0744fdee12e0f4136de643a91c15f77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Snarl &amp;&#160;</td>
          <td class="paramname"><em>snarl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> can be printed. </p>

</div>
</div>
<a class="anchor" id="af94d73312bfd787493e87d207398d73a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator== </td>
          <td>(</td>
          <td class="paramtype">const MaximalExactMatch &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaximalExactMatch &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaf943805c4b8a16e5852d9168faa2558"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator== </td>
          <td>(</td>
          <td class="paramtype">const handle_t &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const handle_t &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define equality on handles. </p>

</div>
</div>
<a class="anchor" id="aef6481a02a8e31c9da8862769bd7e705"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator== </td>
          <td>(</td>
          <td class="paramtype">const Edit &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Edit &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a422ed05af6be2bde2cce68a45e60b664"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator== </td>
          <td>(</td>
          <td class="paramtype">const path_handle_t &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const path_handle_t &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define equality on path handles. </p>

</div>
</div>
<a class="anchor" id="a198a65c2e7235bb674a9e13485d0db8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator== </td>
          <td>(</td>
          <td class="paramtype">const occurrence_handle_t &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const occurrence_handle_t &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define equality on occurrence handles. </p>

</div>
</div>
<a class="anchor" id="a87b890a4bc73725bbea08984d7510df4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator== </td>
          <td>(</td>
          <td class="paramtype">const Visit &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Visit &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Two Visits are equal if they represent the same traversal of the same <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a> or <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a>. </p>

</div>
</div>
<a class="anchor" id="a845213e6efb7204868c05afcae9c926f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator== </td>
          <td>(</td>
          <td class="paramtype">const SnarlTraversal &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlTraversal &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Two SnarlTraversals are equal if their snarls are equal and they have the same number of visits and all their visits are equal. </p>

</div>
</div>
<a class="anchor" id="a387ff1f8cefcf4feb705b0f1225d16c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator== </td>
          <td>(</td>
          <td class="paramtype">const Snarl &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Snarl &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Two Snarls are equal if their types are equal and their bounding Visits are equal and their parents are equal. </p>

</div>
</div>
<a class="anchor" id="a955d56fb4c95213de77c1fcce44c77b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const Support &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Support &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele. ">Support</a> greater-than, based on total coverage. </p>

</div>
</div>
<a class="anchor" id="a7f75115e0fa67db91cc2e0102008b995"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::optimal_alignment </td>
          <td>(</td>
          <td class="paramtype">const MultipathAlignment &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>subpath_global</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the highest scoring alignment contained in the <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> in an <a class="el" href="structvg_1_1Alignment.html">Alignment</a></p>
<p>Note: Assumes that each subpath's <a class="el" href="structvg_1_1Path.html">Path</a> object uses one <a class="el" href="structvg_1_1Mapping.html">Mapping</a> per node and that start subpaths have been identified</p>
<p>Args: multipath_aln multipath alignment to find optimal path through aln_out empty alignment to store optimal alignment in (data will be overwritten if not empty) subpath_global if true, only allows alignments that source subpath to sink subpath in the multipath DAG, else allows any start and end subpath </p>

</div>
</div>
<a class="anchor" id="a881ca4cff9243336ba8cf64a18f713e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vg::optimal_alignment_internal </td>
          <td>(</td>
          <td class="paramtype">const MultipathAlignment &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Alignment *&#160;</td>
          <td class="paramname"><em>aln_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>subpath_global</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3e693b91cabeed2d861ba666e98a3cab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vg::optimal_alignment_score </td>
          <td>(</td>
          <td class="paramtype">const MultipathAlignment &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>subpath_global</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the score of the highest scoring alignment contained in the <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a></p>
<p>Note: Assumes that each subpath's <a class="el" href="structvg_1_1Path.html">Path</a> object uses one <a class="el" href="structvg_1_1Mapping.html">Mapping</a> per node and that start subpaths have been identified</p>
<p>Args: multipath_aln multipath alignment to find optimal score in subpath_global if true, only allows alignments that source subpath to sink subpath in the multipath DAG, else allows any start and end subpath </p>

</div>
</div>
<a class="anchor" id="aeb27a72a431b2f681c6eb88eb594a62c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; vg::optimal_alignments </td>
          <td>(</td>
          <td class="paramtype">const MultipathAlignment &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the top k highest-scoring alignments contained in the <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>. Note that some or all of these may be duplicate Alignments, which were spelled out by tracebacks through different sequences of subpaths that shared alignment material.</p>
<p>If the best alignment is no alignment (i.e. the read is unmapped), returns an empty vector.</p>
<p>Note: Assumes that each subpath's <a class="el" href="structvg_1_1Path.html">Path</a> object uses one <a class="el" href="structvg_1_1Mapping.html">Mapping</a> per node and that start subpaths have been identified</p>
<p>Args: multipath_aln multipath alignment to find optimal paths through count maximum number of top alignments to return </p>

</div>
</div>
<a class="anchor" id="a78ead1fdf3f2d57f7a35755d24fd5999"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; vg::optimal_alignments_with_disjoint_subpaths </td>
          <td>(</td>
          <td class="paramtype">const MultipathAlignment &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds k or fewer top-scoring alignments using only distinct subpaths. Asymmetrical: the optimal alignment for each end subpath is found, greedily, subject to the constraint, but the other subpaths are first-come first-serve. Also, distinct subpaths may not guarantee distinct actual alignments, so alignments may need deduplication.</p>
<p>If the best alignment is no alignment (i.e. the read is unmapped), returns an empty vector.</p>
<p>Note: Assumes that each subpath's <a class="el" href="structvg_1_1Path.html">Path</a> object uses one <a class="el" href="structvg_1_1Mapping.html">Mapping</a> per node and that start subpaths have been identified</p>
<p>Args: multipath_aln multipath alignment to find optimal paths through count maximum number of top alignments to return </p>

</div>
</div>
<a class="anchor" id="af49a3c569a0de687ff444e802d9bfcc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Graph.html">Graph</a> vg::output_graph_with_embedded_paths </td>
          <td>(</td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="trace__main_8cpp.html#a563ab679d6ece5cca62b6300d724188d">thread_t</a>, int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>haplotype_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a25eb12b5c4ae3b18961b6fdbd19f13a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::output_graph_with_embedded_paths </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>subgraph_ostream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="trace__main_8cpp.html#a563ab679d6ece5cca62b6300d724188d">thread_t</a>, int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>haplotype_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>json</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae2e505bf6d9321002a3bb2dd06423cd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::output_haplotype_counts </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>annotation_ostream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="trace__main_8cpp.html#a563ab679d6ece5cca62b6300d724188d">thread_t</a>, int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>haplotype_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaac70d8b120ca61591561cba307dcc1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::overlap </td>
          <td>(</td>
          <td class="paramtype">const Path &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Path &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a86d5f690fe272c74949e080aca561467"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; vg::overlay_node_translations </td>
          <td>(</td>
          <td class="paramtype">const unordered_map&lt; id_t, pair&lt; id_t, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>over</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; id_t, pair&lt; id_t, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>under</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compose the translations from two graph operations, both of which involved oriented transformations. </p>

</div>
</div>
<a class="anchor" id="a7816225a17a671ff849a79f064770ebb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; vg::overlay_node_translations </td>
          <td>(</td>
          <td class="paramtype">const unordered_map&lt; id_t, id_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>over</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; id_t, pair&lt; id_t, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>under</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compose the translations from two graph operations, the first of which involved oriented transformations. </p>

</div>
</div>
<a class="anchor" id="af224cfdc27efec675771ba4cc5143a3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; vg::overlay_node_translations </td>
          <td>(</td>
          <td class="paramtype">const unordered_map&lt; id_t, pair&lt; id_t, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>over</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; id_t, id_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>under</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compose the translations from two graph operations, the second of which involved oriented transformations. </p>

</div>
</div>
<a class="anchor" id="ae996017b379b1178d5e588b96a7c7f3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; vg::overlay_node_translations </td>
          <td>(</td>
          <td class="paramtype">const unordered_map&lt; id_t, id_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>over</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; id_t, id_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>under</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compose the translations from two graph operations, neither of which involved oriented transformations. </p>

</div>
</div>
<a class="anchor" id="a00797829eaa5dfe97f075716dc81e186"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::paired_for_each_parallel_after_wait </td>
          <td>(</td>
          <td class="paramtype">function&lt; bool(Alignment &amp;, Alignment &amp;)&gt;&#160;</td>
          <td class="paramname"><em>get_pair_if_available</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(Alignment &amp;, Alignment &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; bool(void)&gt;&#160;</td>
          <td class="paramname"><em>single_threaded_until_true</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8873caafc22d22b52e0f6f3f164f6dc8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Result &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Result vg::parse </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse a command-line argument string. Exits with an error if the string does not contain exactly an item fo the appropriate type. </p>

</div>
</div>
<a class="anchor" id="a8c5c364797f623025b67b9aff0657112"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Result &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Result vg::parse </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse a command-line argument C string. Exits with an error if the string does not contain exactly an item fo the appropriate type. </p>

</div>
</div>
<a class="anchor" id="a627f5ad6fe6f1e6b4cc23ac97dfca4b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Result &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vg::parse </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Result &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse the appropriate type from the string to the destination value. Return true if parsing is successful and false (or throw something) otherwise. </p>

</div>
</div>
<a class="anchor" id="a077c59e824971d78208576c3a3b7e374"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::parse </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1dd328fd8abb43338a3ae9e0a3b0be1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::parse </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa1de4a1752e875116c767ec49a8e2961"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::parse </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::regex &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9b06b5a51ac3e6f4567852020354732b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::parse_bed_regions </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>bed_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; Region &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_regions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a50b91ade80c8471ff1c5434dfd701cbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::parse_bed_regions </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>bedstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; Alignment &gt; *&#160;</td>
          <td class="paramname"><em>out_alignments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse regions from the given BED file into Alignments in a vector. Reads the optional name, is_reverse, and score fields if present, and populates the relevant <a class="el" href="structvg_1_1Alignment.html">Alignment</a> fields. Skips and warns about malformed or illegal BED records. </p>

</div>
</div>
<a class="anchor" id="a429a2a57a7edf349cbf082d662bc24a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::parse_gff_regions </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>gffstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; Alignment &gt; *&#160;</td>
          <td class="paramname"><em>out_alignments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a253257615743a1cfb948b749be7700e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::parse_region </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af0a3beb8908adf7a6e4d641243937830"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::parse_region </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Region &amp;&#160;</td>
          <td class="paramname"><em>out_region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a637c855dffc0296c6575ae8a4cac6b43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::parse_rg_sample_map </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>hts_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; string, string &gt; &amp;&#160;</td>
          <td class="paramname"><em>rg_sample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aab7f51d37c0c0a70bc792989bfc26da4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Position.html">Position</a> vg::path_end </td>
          <td>(</td>
          <td class="paramtype">const Path &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1524b7b1b7e67c048c0c5e88b204de08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::path_from_length </td>
          <td>(</td>
          <td class="paramtype">const Path &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3aef5ee16ad883f8defeaa0f52fc342c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> vg::path_from_node_traversals </td>
          <td>(</td>
          <td class="paramtype">const list&lt; NodeTraversal &gt; &amp;&#160;</td>
          <td class="paramname"><em>traversals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a18466ce6693ea51859957c9d23e91e72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> vg::path_from_thread_t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="trace__main_8cpp.html#a563ab679d6ece5cca62b6300d724188d">thread_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a43c4a438edc31c7b0d2aa0731c522e8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::path_is_simple_match </td>
          <td>(</td>
          <td class="paramtype">const Path &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8626775da579a828867bae2f828cbaf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">vg::id_t</a> vg::path_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxg_1_1XGPath.html">xg::XGPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac6bdd8e00dd9f63a0d9049ffe3461d47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">vg::id_t</a> vg::path_node </td>
          <td>(</td>
          <td class="paramtype">const gbwt::vector_type &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae97747231cdf00e8947a4a350c7d80a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::path_reverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxg_1_1XGPath.html">xg::XGPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa0439b7fcf30da565152d9800ff4473d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::path_reverse </td>
          <td>(</td>
          <td class="paramtype">const gbwt::vector_type &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a089543e57bff72391dca9116157958b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::path_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxg_1_1XGPath.html">xg::XGPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0c911ba34849a4afd407812fe6373579"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::path_size </td>
          <td>(</td>
          <td class="paramtype">const gbwt::vector_type &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a712dc26fa1460b97e84b31f78a4a04ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Position.html">Position</a> vg::path_start </td>
          <td>(</td>
          <td class="paramtype">const Path &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a48108a0abc0fdfc187437d174f88e590"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::path_to_length </td>
          <td>(</td>
          <td class="paramtype">const Path &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afbe0993e79f4ef7bb4b37456b0b08402"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::path_to_string </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1b5ffc03255d72f1901a7b1ce34c058a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvg_1_1Paths.html">Paths</a> vg::paths_from_graph </td>
          <td>(</td>
          <td class="paramtype">Graph &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2ba15a613567689d941f30a5a17c6ead"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::percent_url_encode </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Escape "%" to "%25". </p>

</div>
</div>
<a class="anchor" id="ace2d2438c678d4fc4c0007b64b8ccd6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::phi </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a04edc3daae77e9d3813a97da0f473def"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::phred_geometric_mean </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>phred1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>phred2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a35b531c82b765cd54702665668a98448"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::phred_to_logprob </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>phred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa269a7de61c98b1c46b3cacd5d5a43d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::phred_to_prob </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>phred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac7f5da8e25414026729f0c4d09243f6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;T&gt; vg::pmax </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae6a210206858f806b345f8eb5c2c292a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class T, class A=std::allocator&lt; T &gt;&gt; class Container, typename Item &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container&lt;const Item*&gt; vg::pointerfy </td>
          <td>(</td>
          <td class="paramtype">const Container&lt; Item &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We have a wrapper of that to turn a container reference into a container of pointers. </p>

</div>
</div>
<a class="anchor" id="a9238b15cc78a87f27c335fc1e3627a62"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> vg::poisson_prob_ln </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>observed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t&#160;</td>
          <td class="paramname"><em>expected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the log probability of a Poisson-distributed process: observed events in an interval where expected events happen on average. </p>

</div>
</div>
<a class="anchor" id="a856b55f4d89ae8bd7e6dacaa70fba0e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TracebackIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::populate_path_from_traceback </td>
          <td>(</td>
          <td class="paramtype">const MultipathAlignment &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultipathProblem &amp;&#160;</td>
          <td class="paramname"><em>problem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TracebackIterator&#160;</td>
          <td class="paramname"><em>traceback_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TracebackIterator&#160;</td>
          <td class="paramname"><em>traceback_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We define this helper to turn tracebacks through a DP problem into <a class="el" href="classvg_1_1Paths.html">Paths</a> that we can put in an <a class="el" href="structvg_1_1Alignment.html">Alignment</a>. We use iterators to the start and past-the-end of the traceback (in some kind of list of int64_t subpath indexes) to define it. </p>

</div>
</div>
<a class="anchor" id="aaca76d456a115d68ea096528468e0f77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> vg::position_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>path_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We have a helper function to convert path positions and orientations to pos_t values.</p>
<p>We have a utility function for turning positions along paths, with orientations, into pos_ts. Remember that pos_t counts offset from the start of the reoriented node, while here we count offset from the beginning of the forward version of the path. </p>

</div>
</div>
<a class="anchor" id="a3a7a8c98d80a9daacbc72386bc6ad00c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> vg::pow_ln </td>
          <td>(</td>
          <td class="paramtype">real_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Raise a log probability to a power </p>

</div>
</div>
<a class="anchor" id="a65ac31e5878660a97207b6ade1418c81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::preflight_check </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8bf8f408b11966feb9695d4bb723dfac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Decoder &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::printId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">vg::id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a476a2102f4f5aa82c06be87780ae6d42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::prob_to_logprob </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>prob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acb81881c0a3b7cf276097d8142ddb312"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::prob_to_phred </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>prob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8dae5becf3e0669fc5143dbf1270c910"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short vg::quality_char_to_short </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3fa98c788fa60695c20994ddeb008afe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char vg::quality_short_to_char </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acffe466a3ca83097eceac30a09b9a010"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::query_overlap </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab80fc8c8920c7ec53cfee81dc2fce852"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::random_sequence </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a uniformly random DNA sequence of the given length. </p>

</div>
</div>
<a class="anchor" id="a4012afd56ccb35387121c71c2119e244"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">default_random_engine vg::random_sequence_gen </td>
          <td>(</td>
          <td class="paramtype">102&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a931d9271de88fc786030fdd0ab4bf534"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; size_t &gt; vg::range_vector </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a39adca1737de5d28d007d95b809deb7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;size_t&gt; vg::range_vector </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="add4d3a3d1917566a8df138c80b38e548"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::remove_duplicate_edges </td>
          <td>(</td>
          <td class="paramtype">Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>remove duplicate edges </p>

</div>
</div>
<a class="anchor" id="a6dbe8468f2f2bcf8ceb859e6a0f8b4b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::remove_duplicate_nodes </td>
          <td>(</td>
          <td class="paramtype">Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>remove duplicate nodes </p>

</div>
</div>
<a class="anchor" id="aecd2e49750e94ed6f9de917dd9c72ac2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::remove_duplicates </td>
          <td>(</td>
          <td class="paramtype">Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>remove duplicate nodes and edges </p>

</div>
</div>
<a class="anchor" id="a0b38f4f0d7e63b1f7f20d2dc985f88c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::remove_orphan_edges </td>
          <td>(</td>
          <td class="paramtype">Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>remove edges that link to a node that is not in the graph </p>

</div>
</div>
<a class="anchor" id="a4bbc811a743bb67f5425058843f51f1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::remove_paths </td>
          <td>(</td>
          <td class="paramtype">Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::regex &amp;&#160;</td>
          <td class="paramname"><em>paths_to_take</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; Path &gt; *&#160;</td>
          <td class="paramname"><em>matching</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab169ac1e2fc6ba662eebc1ede1ffe157"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::replace_in_string </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>subject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>replace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a40132bfddc17b143e18279d1e176652d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::rev_comp_multipath_alignment </td>
          <td>(</td>
          <td class="paramtype">const MultipathAlignment &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; int64_t(int64_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultipathAlignment &amp;&#160;</td>
          <td class="paramname"><em>rev_comp_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the reverse complement of a <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> in another <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a></p>
<p>Args: multipath_aln multipath alignment to reverse complement node_length a function that returns the length of a node sequence from its node ID rev_comp_out empty multipath alignment to store reverse complement in (some data may be overwritten if not empty) </p>

</div>
</div>
<a class="anchor" id="afd751a7942664d45206cc1754755a1d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::rev_comp_multipath_alignment_in_place </td>
          <td>(</td>
          <td class="paramtype">MultipathAlignment *&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; int64_t(int64_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the reverse complement of a <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> in another <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a></p>
<p>Args: multipath_aln multipath alignment to reverse complement in place node_length a function that returns the length of a node sequence from its node ID </p>

</div>
</div>
<a class="anchor" id="ad41446f39233ac6ca5343d95b50329b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::rev_comp_subpath </td>
          <td>(</td>
          <td class="paramtype">const Subpath &amp;&#160;</td>
          <td class="paramname"><em>subpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; int64_t(int64_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Subpath &amp;&#160;</td>
          <td class="paramname"><em>rev_comp_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores the reverse complement of a <a class="el" href="structvg_1_1Subpath.html" title="A non-branching path of a MultipathAlignment. ">Subpath</a> in another <a class="el" href="structvg_1_1Subpath.html" title="A non-branching path of a MultipathAlignment. ">Subpath</a></p>
<p>note: this is not included in the header because reversing a subpath without going through the multipath alignment can break invariants related to the edge lists</p>
<p>Args: subpath subpath to reverse complement node_length a function that returns the length of a node sequence from its node ID rev_comp_out empty subpath to store reverse complement in (data will be overwritten if not empty) </p>

</div>
</div>
<a class="anchor" id="ac52fd5878b0be1d53de644eea3458663"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> vg::reverse </td>
          <td>(</td>
          <td class="paramtype">const pos_t &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse a pos_t and get a pos_t at the same base, going the other direction. </p>

</div>
</div>
<a class="anchor" id="a91adfc6327b5709dc73fcc7edbe5da57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Position.html">Position</a> vg::reverse </td>
          <td>(</td>
          <td class="paramtype">const Position &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse a <a class="el" href="structvg_1_1Position.html">Position</a> and get a <a class="el" href="structvg_1_1Position.html">Position</a> at the same base, going the other direction. </p>

</div>
</div>
<a class="anchor" id="a2e300d25fd8281f9453366f68b484196"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Visit.html">Visit</a> vg::reverse </td>
          <td>(</td>
          <td class="paramtype">const Visit &amp;&#160;</td>
          <td class="paramname"><em>visit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the reversed version of a visit. </p>

</div>
</div>
<a class="anchor" id="aa65de7dea52585f07bee6ae7f762eb95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char vg::reverse_complement </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a30732a1a1e8d20d6eaaaeafecc8a50a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::reverse_complement </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a98e512ed0fca2503ccc370435591a6c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::reverse_complement_alignment </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; int64_t(id_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab96610ffc81d6207e0b13f675296c234"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::reverse_complement_alignment_in_place </td>
          <td>(</td>
          <td class="paramtype">Alignment *&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; int64_t(id_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aed045b02277d7704e997cbede67c2662"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; vg::reverse_complement_alignments </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; Alignment &gt; &amp;&#160;</td>
          <td class="paramname"><em>alns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; int64_t(int64_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac6cdc6eeeb82efd61650f4958566575f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Edit.html">Edit</a> vg::reverse_complement_edit </td>
          <td>(</td>
          <td class="paramtype">const Edit &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae6353d47c867f1b4cc7053d82aef42f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::reverse_complement_in_place </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3ce6fa1d8f3ba4f8f361fa77a6fd5261"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Mapping.html">Mapping</a> vg::reverse_complement_mapping </td>
          <td>(</td>
          <td class="paramtype">const Mapping &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; int64_t(id_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af2dc9d6ee4403027eb5965aa6a71eb4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::reverse_complement_mapping_in_place </td>
          <td>(</td>
          <td class="paramtype">Mapping *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; int64_t(id_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a463d9eaed29cd6d46a8e2afb645c8fda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> vg::reverse_complement_path </td>
          <td>(</td>
          <td class="paramtype">const Path &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; int64_t(id_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af2941a3c80481d02c65d9d72bd835807"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::reverse_complement_path_in_place </td>
          <td>(</td>
          <td class="paramtype">Path *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; int64_t(id_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac101c453ab2076d74f0324f73d174695"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1BenchmarkResult.html">BenchmarkResult</a> vg::run_benchmark </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>under_test</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Run the given function the given number of times, interleaved with runs of the control function, and return a <a class="el" href="structvg_1_1BenchmarkResult.html">BenchmarkResult</a> describing its performance. </p>

</div>
</div>
<a class="anchor" id="added44ff3bb1c0ce606563a40923c513"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1BenchmarkResult.html">BenchmarkResult</a> vg::run_benchmark </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>setup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>under_test</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Run a benchmark with a setup function. </p>

</div>
</div>
<a class="anchor" id="af0b28c682c013f735434f20e4d97ba1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple&lt;<a class="el" href="structvg_1_1MultipathProblem.html">MultipathProblem</a>, int64_t, int32_t&gt; vg::run_multipath_dp </td>
          <td>(</td>
          <td class="paramtype">const MultipathAlignment &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>subpath_global</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Internal helper function for running the dynamic programming problem represented by a multipath alignment. Returns the filled DP problem, the optimal ending subpath, or -1 if no subpath is optimal, and the optimal score, or 0 if no score is optimal. An option toggles whether the traceback should be global (a source to a sink in the multipath DAG) or local (starting and ending at any subpath) </p>

</div>
</div>
<a class="anchor" id="ae37c6d66a01cef6f92707d367ebf4cdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vg::sam_flag </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on_reverse_strand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paired</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adea29af7b94ac90b1db0eacd908511c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AnnotationType , typename Annotated &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::set_annotation </td>
          <td>(</td>
          <td class="paramtype">Annotated *&#160;</td>
          <td class="paramname"><em>annotated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AnnotationType &amp;&#160;</td>
          <td class="paramname"><em>annotation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the annotation with the given name to the given value. The value may be a primitive type or a vector of a primitive type. </p>

</div>
</div>
<a class="anchor" id="a54bcd5d5fc5318bbdbe784f224b906bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AnnotationType , typename Annotated &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::set_annotation </td>
          <td>(</td>
          <td class="paramtype">Annotated &amp;&#160;</td>
          <td class="paramname"><em>annotated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AnnotationType &amp;&#160;</td>
          <td class="paramname"><em>annotation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the annotation with the given name to the given value. The value may be a primitive type or a vector of a primitive type. </p>

</div>
</div>
<a class="anchor" id="a234b2ca417edb50a3c738991fcfc269a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::set_intersection </td>
          <td>(</td>
          <td class="paramtype">const unordered_set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>set_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>set_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_set&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>out_intersection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6821cd887e206752c50c1a7be764d1f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string vg::sha1head </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>head</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0cada7d579d914675f53490e0488ab53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string vg::sha1sum </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2616dde2763b947a15ac562fd631e688"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::signature </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a134fc6762c4b66dd4847078b0ddbfdd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; string, string &gt; vg::signature </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a86653c665afe3c8932f60cc39163e202"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> vg::simplify </td>
          <td>(</td>
          <td class="paramtype">const Path &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trim_internal_deletions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simplify the path for addition as new material in the graph. Remove any mappings that are merely single deletions, merge adjacent edits of the same type, strip leading and trailing deletion edits on mappings, and make sure no mappings have missing positions. </p>

</div>
</div>
<a class="anchor" id="a486054f13a4dc43e37c0f0131f6a51ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::simplify </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trim_internal_deletions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simplifies the <a class="el" href="structvg_1_1Path.html">Path</a> in the <a class="el" href="structvg_1_1Alignment.html">Alignment</a>. Note that this removes deletions at the start and end of Mappings, so code that handles simplified Alignments needs to handle offsets on internal Mappings. </p>

</div>
</div>
<a class="anchor" id="a9514446da89671007ae40e420c1297d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Mapping.html">Mapping</a> vg::simplify </td>
          <td>(</td>
          <td class="paramtype">const Mapping &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trim_internal_deletions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge adjacent edits of the same type, strip leading and trailing deletion edits (while updating positions if necessary), and makes sure position is actually set. </p>

</div>
</div>
<a class="anchor" id="ad477b45059373004136e69022e802e0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::slope </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa84e4c417206a9b3a910dfde0fec3857"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::softclip_end </td>
          <td>(</td>
          <td class="paramtype">const Mapping &amp;&#160;</td>
          <td class="paramname"><em>mapping</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a05d6d0388148a996d9423524fa4bcc91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::softclip_end </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9fe66eebecbc5017b05c9044413b2b4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::softclip_start </td>
          <td>(</td>
          <td class="paramtype">const Mapping &amp;&#160;</td>
          <td class="paramname"><em>mapping</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a90f2af92a34fdf5fb4ddfee8f8880b48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::softclip_start </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af25c227066a422379ff06d81b5990865"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::sort_by_id </td>
          <td>(</td>
          <td class="paramtype">Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>order the nodes and edges in the graph by id </p>

</div>
</div>
<a class="anchor" id="a984c1d2199f90f58677096772b870390"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::sort_by_id_dedup_and_clean </td>
          <td>(</td>
          <td class="paramtype">Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>remove duplicates and sort by id </p>

</div>
</div>
<a class="anchor" id="a90cc117e3ac781c77cf8fdaa7802048b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::sort_edges_by_id </td>
          <td>(</td>
          <td class="paramtype">Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>order the edges in the graph by id pairs </p>

</div>
</div>
<a class="anchor" id="afb37b16823e6e26cfd8571a1bb621651"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::sort_nodes_by_id </td>
          <td>(</td>
          <td class="paramtype">Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>order the nodes in the graph by id </p>

</div>
</div>
<a class="anchor" id="a73740805ee8d4d785c38cb1217807363"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomIt , class Compare , class MakeSeed &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::sort_shuffling_ties </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MakeSeed&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort the items between the two given random-access iterators, as with std::sort. Deterministically shuffle the ties, if any, at the top end, using the given seed generator function. </p>

</div>
</div>
<a class="anchor" id="aa071bccfee3a9078930f2c385e8dda20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomIt , class Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::sort_shuffling_ties </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort the items between the two given random-access iterators, as with std::sort. Deterministically shuffle the ties, if any, at the top end, using automatic seed determination. </p>

</div>
</div>
<a class="anchor" id="a1940ed8d1740511870d3617aa967559a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; &amp; vg::split_delims </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>elems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a261e76d1959c22119b567e59bf4c23ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; vg::split_delims </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8d771862cc44504508267240462cb043"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::stacktrace_manually </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signalNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>bp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a43f061abac718e0386965aa537398e74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::start_backward </td>
          <td>(</td>
          <td class="paramtype">const Chain &amp;&#160;</td>
          <td class="paramname"><em>chain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the first snarl in the given chain is backward relative to the chain. </p>

</div>
</div>
<a class="anchor" id="a0bdb2cdf1d9318f4bce86132244a874d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::stdev </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a11df8bd14dab3c0cfb7ecfa377a362f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double vg::stdev </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab5d681cff3270646ab87c07bbf5a8d72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::stPinchSegment_getBlockOrientationSafe </td>
          <td>(</td>
          <td class="paramtype">stPinchSegment *&#160;</td>
          <td class="paramname"><em>segment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the segment's orientation in its block (false=backward, true=forward), or true (forward) if there is no block. </p>

</div>
</div>
<a class="anchor" id="a5b9c4e83112e55a3862015c55c4fd273"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::strand_bias </td>
          <td>(</td>
          <td class="paramtype">const Support &amp;&#160;</td>
          <td class="paramname"><em>support</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the strand bias of a <a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele. ">Support</a>. </p>

</div>
</div>
<a class="anchor" id="a01985b9f56eb0f7e566bb957cf839a97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::string_quality_char_to_short </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>quality</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac4851c5fbea81739228502a86a0134c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::string_quality_short_to_char </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>quality</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adbe45b79675104ebc36691774d4124c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::strip_from_end </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acd6786ea9551b426f95fba325beff138"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::strip_from_start </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab63c41956b73af429507b469108d1759"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::sub_overlaps_of_first_aln </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; Alignment &gt; &amp;&#160;</td>
          <td class="paramname"><em>alns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>overlap_fraction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a33c8f5153ad0766df2c72bbec623aa19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::subtract_log </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>log_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>log_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa70726366aa31b20debdcac41c89490c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Collection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Collection::value_type vg::sum </td>
          <td>(</td>
          <td class="paramtype">const Collection &amp;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the sum of the values in a collection. Values must be default- constructable (like numbers are). </p>

</div>
</div>
<a class="anchor" id="ac3787b0a7fc02bbfe45dc5eb082d5779"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Support.html">Support</a> vg::support_max </td>
          <td>(</td>
          <td class="paramtype">const Support &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Support &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the maximum support of a pair of Supports, by taking the max in each orientation. </p>

</div>
</div>
<a class="anchor" id="a3c2ae4c37201ebbc6f6d4faaf27fe4de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Support.html">Support</a> vg::support_min </td>
          <td>(</td>
          <td class="paramtype">const Support &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Support &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the minimum support of a pair of Supports, by taking the min in each orientation. </p>

</div>
</div>
<a class="anchor" id="ad3f6522436ea7320bf6728fe47451151"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::thread_to_graph_spanned </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="trace__main_8cpp.html#a563ab679d6ece5cca62b6300d724188d">thread_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Graph &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a84d646b72482de0145745a64414ca5df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> vg::to_left_side </td>
          <td>(</td>
          <td class="paramtype">const Visit &amp;&#160;</td>
          <td class="paramname"><em>visit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> to a node or snarl into a <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> for its left side. </p>

</div>
</div>
<a class="anchor" id="a5ed83dc32e575ae68b591d142eb38912"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::to_length </td>
          <td>(</td>
          <td class="paramtype">const Mapping &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad47f373b3433b3190f9f1c0f5f17274d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::to_length_after_pos </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Position &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa40f0cfd74a9eeaa7b6ffecbc0926a6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::to_length_before_pos </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Position &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a28be7f9898d5ad6e075e25b81df512e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Mapping.html">Mapping</a> vg::to_mapping </td>
          <td>(</td>
          <td class="paramtype">const Visit &amp;&#160;</td>
          <td class="paramname"><em>visit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; size_t(id_t)&gt;&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> to a <a class="el" href="structvg_1_1Mapping.html">Mapping</a>. Throws an exception if the <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> is of a <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> instead of a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a>. Uses a function to get node length. </p>

</div>
</div>
<a class="anchor" id="ace232035b9ab613b2378baa3497b5da7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Mapping.html">Mapping</a> vg::to_mapping </td>
          <td>(</td>
          <td class="paramtype">const Visit &amp;&#160;</td>
          <td class="paramname"><em>visit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VG &amp;&#160;</td>
          <td class="paramname"><em>vg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> to a <a class="el" href="structvg_1_1Mapping.html">Mapping</a>. Throws an exception if the <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> is of a <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> instead of a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a>. Uses a graph to get node length. </p>

</div>
</div>
<a class="anchor" id="a2d4b02bdea78f086b0e207563d7de800"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::to_multipath_alignment </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultipathAlignment &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a <a class="el" href="structvg_1_1Alignment.html">Alignment</a> into a Multipath alignment with one <a class="el" href="structvg_1_1Subpath.html" title="A non-branching path of a MultipathAlignment. ">Subpath</a> and stores it in an object</p>
<p>Args: aln alignment to convert multipath_aln empty multipath alignment to store converted alignment in (data may be be overwritten if not empty) </p>

</div>
</div>
<a class="anchor" id="a5a2e772d69c9e45cbc1c1d1a9e6df842"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> vg::to_node_traversal </td>
          <td>(</td>
          <td class="paramtype">const Visit &amp;&#160;</td>
          <td class="paramname"><em>visit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VG &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> to a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>. Throws an exception if the <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> is of a <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> instead of a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a> </p>

</div>
</div>
<a class="anchor" id="a2c04918053577c402e4f2cab61abd754"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> vg::to_node_traversal </td>
          <td>(</td>
          <td class="paramtype">const Visit &amp;&#160;</td>
          <td class="paramname"><em>visit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VG &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0b4a5c32294bf49aa7f0a6d180cc2832"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> vg::to_rev_node_traversal </td>
          <td>(</td>
          <td class="paramtype">const Visit &amp;&#160;</td>
          <td class="paramname"><em>visit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VG &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> to a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> in the opposite orientation. Throws an exception if the <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> is of a <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> instead of a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a> </p>

</div>
</div>
<a class="anchor" id="ae64d7810e64af7119f1b1b3a2d08d797"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> vg::to_rev_node_traversal </td>
          <td>(</td>
          <td class="paramtype">const Visit &amp;&#160;</td>
          <td class="paramname"><em>visit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VG &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7164ae8636d1ca7783d6202c8ce316ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Visit.html">Visit</a> vg::to_rev_visit </td>
          <td>(</td>
          <td class="paramtype">const NodeTraversal &amp;&#160;</td>
          <td class="paramname"><em>node_traversal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> to a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> in the opposite orientation. </p>

</div>
</div>
<a class="anchor" id="a74fab09b3ae1d9f799742a31b5206a35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> vg::to_right_side </td>
          <td>(</td>
          <td class="paramtype">const Visit &amp;&#160;</td>
          <td class="paramname"><em>visit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> to a node or snarl into a <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> for its right side. </p>

</div>
</div>
<a class="anchor" id="a41c1d798d3d99e95ee8c3fcb7cd3319a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">string vg::to_string_ss </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a420f2fd8ef6d04f1a34a08af2a3dee0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::to_vcf_genotype </td>
          <td>(</td>
          <td class="paramtype">const Genotype &amp;&#160;</td>
          <td class="paramname"><em>gt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a VCF-style 1/2, 1|2|3, etc. string from a <a class="el" href="structvg_1_1Genotype.html" title="Describes a genotype at a particular locus. ">Genotype</a>. </p>

</div>
</div>
<a class="anchor" id="a827ce532cdbd4710e86a21ebd986e1cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Visit.html">Visit</a> vg::to_visit </td>
          <td>(</td>
          <td class="paramtype">const NodeTraversal &amp;&#160;</td>
          <td class="paramname"><em>node_traversal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> to a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a>. </p>

</div>
</div>
<a class="anchor" id="acd53873bb85623cbf5b797f09bf88dc4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Visit.html">Visit</a> vg::to_visit </td>
          <td>(</td>
          <td class="paramtype">const Mapping &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_full_node_match</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts a <a class="el" href="structvg_1_1Mapping.html">Mapping</a> to a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a>. The mapping must represent a full node match. If make_full_node_match is true, the mapping will automatically be made a full node match during the conversion process. </p>

</div>
</div>
<a class="anchor" id="aa76433c3398610bc58b842f2a4b462c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Visit.html">Visit</a> vg::to_visit </td>
          <td>(</td>
          <td class="paramtype">id_t&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> from a node ID and an orientation. </p>

</div>
</div>
<a class="anchor" id="a0a18238f71586af9b3eba2ba1dac2a6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Visit.html">Visit</a> vg::to_visit </td>
          <td>(</td>
          <td class="paramtype">const Snarl &amp;&#160;</td>
          <td class="paramname"><em>snarl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> from a snarl to traverse. </p>

</div>
</div>
<a class="anchor" id="ae03e9d67c4a774a71895ade9f10c6d19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::topologically_order_subpaths </td>
          <td>(</td>
          <td class="paramtype">MultipathAlignment &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put subpaths in topological order (assumed to be true for other algorithms) </p>

</div>
</div>
<a class="anchor" id="a0a064dd8829b2100c6a38780311073f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::total </td>
          <td>(</td>
          <td class="paramtype">const Support &amp;&#160;</td>
          <td class="paramname"><em>support</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the total read support in a <a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele. ">Support</a>. </p>

</div>
</div>
<a class="anchor" id="a35bab41ee9f0370c0b4233acea61658b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1StrandSupport.html">StrandSupport</a> vg::totalSup </td>
          <td>(</td>
          <td class="paramtype">vector&lt; StrandSupport &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a00a949105ae94b18ca72452a442b8ddb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::toUppercase </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2fa834f81743ae8666dd9071ce1b6443"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::trace_haplotypes_and_paths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gbwt::GBWT *&#160;</td>
          <td class="paramname"><em>haplotype_database</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">vg::id_t</a>&#160;</td>
          <td class="paramname"><em>start_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>extend_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Graph &amp;&#160;</td>
          <td class="paramname"><em>out_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; string, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_thread_frequencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>expand_graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a41a22f4c38561e62e9c752b5dbb9ee12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::trace_traversal </td>
          <td>(</td>
          <td class="paramtype">const SnarlTraversal &amp;&#160;</td>
          <td class="paramname"><em>traversal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Snarl &amp;&#160;</td>
          <td class="paramname"><em>site</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(size_t, id_t, bool)&gt;&#160;</td>
          <td class="paramname"><em>handle_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(size_t, NodeSide, NodeSide)&gt;&#160;</td>
          <td class="paramname"><em>handle_edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(size_t, Snarl, bool)&gt;&#160;</td>
          <td class="paramname"><em>handle_child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Trace out the given traversal, handling nodes, child snarls, and edges associated with particular visit numbers. </p>

</div>
</div>
<a class="anchor" id="a82a83d7c54d733abee06d328f91ef5ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::transfer_boundary_info </td>
          <td>(</td>
          <td class="paramtype">const Snarl &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Snarl &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the boundary Visits from one <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> into another. </p>

</div>
</div>
<a class="anchor" id="a741300a76b92c74a269946d7f859646c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::transfer_read_metadata </td>
          <td>(</td>
          <td class="paramtype">const MultipathAlignment &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultipathAlignment &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies metadata from an <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> object and transfers it to another <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a></p>
<p>Args: from copy metadata from this to into this </p>

</div>
</div>
<a class="anchor" id="a43d6f299474100353ddcec9cc68a14b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::transfer_read_metadata </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultipathAlignment &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies metadata from an <a class="el" href="structvg_1_1Alignment.html">Alignment</a> object and transfers it to a <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a></p>
<p>Args: from copy metadata from this to into this </p>

</div>
</div>
<a class="anchor" id="af5a29ae37efd47f324b7d9d50f132271"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::transfer_read_metadata </td>
          <td>(</td>
          <td class="paramtype">const MultipathAlignment &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Alignment &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies metadata from an <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> object and transfers it to a <a class="el" href="structvg_1_1Alignment.html">Alignment</a></p>
<p>Args: from copy metadata from this to into this </p>

</div>
</div>
<a class="anchor" id="a4bc1837d8c1cca33ab223957402b70ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; vg::translate_mems </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; MaximalExactMatch &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; id_t, pair&lt; id_t, bool &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af71770196fc31c2e3c9c2a83f3497177"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::translate_node_ids </td>
          <td>(</td>
          <td class="paramtype">Path &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; id_t, id_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>translator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switches the node ids in the path to the ones indicated by the translator. </p>

</div>
</div>
<a class="anchor" id="aa49e4506c94e5747c88805e39aa18090"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::translate_node_ids </td>
          <td>(</td>
          <td class="paramtype">Path &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; id_t, id_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>translator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">id_t&#160;</td>
          <td class="paramname"><em>cut_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bases_removed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces the node IDs in the path with the ones indicated by the translator. Supports a single cut node in the source graph, where the given number of bases of the given node were removed from its left or right side when making the source graph from the destination graph. </p>

</div>
</div>
<a class="anchor" id="a98dcd16f2a4eae4c223a374dd2ab2da4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::translate_nodes </td>
          <td>(</td>
          <td class="paramtype">Alignment &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; id_t, pair&lt; id_t, bool &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; size_t(int64_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2b0ba7a1d0cf7630b79d03ba0ab65c53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::translate_oriented_node_ids </td>
          <td>(</td>
          <td class="paramtype">Path &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; id_t, pair&lt; id_t, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>translator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switches the node ids and orientations in the path to the ones indicated by the translator. </p>

</div>
</div>
<a class="anchor" id="a94385b32246fc81a0a44ea1b47d994ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::traversal_to_string </td>
          <td>(</td>
          <td class="paramtype">VG &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlTraversal &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> into the string it represents, including notes for nested child snarls. </p>

</div>
</div>
<a class="anchor" id="ad83da8607e104967dd51d9230f4b51bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::trim_alignment </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Position &amp;&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Position &amp;&#160;</td>
          <td class="paramname"><em>pos2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a990f54fb0e09dc439dace1519aff5e9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> vg::trim_hanging_ends </td>
          <td>(</td>
          <td class="paramtype">const Path &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad9d7a5ca192b47b922e17a717774ff66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::unpaired_for_each_parallel </td>
          <td>(</td>
          <td class="paramtype">function&lt; bool(Alignment &amp;)&gt;&#160;</td>
          <td class="paramname"><em>get_read_if_available</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(Alignment &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a89a7010176a6425c2a8183054cc9781f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::validate_multipath_alignment </td>
          <td>(</td>
          <td class="paramtype">const MultipathAlignment &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HandleGraph &amp;&#160;</td>
          <td class="paramname"><em>handle_graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Debugging function to check that multipath alignment meets the formalism's basic invariants. Returns true if multipath alignment is valid, else false. Does not validate alignment score. </p>

</div>
</div>
<a class="anchor" id="a76fc86953f8c080621c080cd35bc9ae0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T vg::value_cast </td>
          <td>(</td>
          <td class="paramtype">const google::protobuf::Value &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast a Protobuf generic Value to any type. </p>

</div>
</div>
<a class="anchor" id="ac84a9621d5108f53976d51f1188e7214"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::protobuf::Value vg::value_cast </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>wrap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast any type to a generic Protobuf value. </p>

</div>
</div>
<a class="anchor" id="a12109d27c9801031e32a408e75af2bd1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Container vg::value_cast </td>
          <td>(</td>
          <td class="paramtype">const google::protobuf::Value &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast a Protobuf generic Value to any type. </p>

</div>
</div>
<a class="anchor" id="aca53457219a2ced000f439df5bd0d71f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::protobuf::Value vg::value_cast </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>wrap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac90d23f22ad3ec78da4e03dc011cabf8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacevg.html#a76fc86953f8c080621c080cd35bc9ae0">vg::value_cast</a>&lt; bool &gt; </td>
          <td>(</td>
          <td class="paramtype">const google::protobuf::Value &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab572dfa4b65db43984f1572d74a94036"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::protobuf::Value <a class="el" href="namespacevg.html#a76fc86953f8c080621c080cd35bc9ae0">vg::value_cast</a>&lt; bool &gt; </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>wrap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a13a0cc45e4277281efeedb821c1444f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="namespacevg.html#a76fc86953f8c080621c080cd35bc9ae0">vg::value_cast</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">const google::protobuf::Value &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac16fdb4078f95e252450a80a1e9e14f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::protobuf::Value <a class="el" href="namespacevg.html#a76fc86953f8c080621c080cd35bc9ae0">vg::value_cast</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>wrap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a16575a017d153499fe4a0976e801be61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string <a class="el" href="namespacevg.html#a76fc86953f8c080621c080cd35bc9ae0">vg::value_cast</a>&lt; string &gt; </td>
          <td>(</td>
          <td class="paramtype">const google::protobuf::Value &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a51e6a112ff1115272420d46ca4316f63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::protobuf::Value <a class="el" href="namespacevg.html#a76fc86953f8c080621c080cd35bc9ae0">vg::value_cast</a>&lt; string &gt; </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>wrap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0c0ad28109d9eb8efa2bf1ff97fe8e92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::variant_recall </td>
          <td>(</td>
          <td class="paramtype">VG *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcflib::VariantCallFile *&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FastaReference *&#160;</td>
          <td class="paramname"><em>ref_genome</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; FastaReference * &gt;&#160;</td>
          <td class="paramname"><em>insertions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>gamfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>run with : vg genotype -L -V v.vcf -I i.fa -R ref.fa </p>

</div>
</div>
<a class="anchor" id="a8fa0776e6865e98b3f7a2e8c6722cfb1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PathType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vg::verify_path </td>
          <td>(</td>
          <td class="paramtype">const PathType &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VG &amp;&#160;</td>
          <td class="paramname"><em>unfolded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hash_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">vg::id_t</a>, std::vector&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">vg::id_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>reverse_mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0b67eeb9262ee4034a35e068e25a26b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::view_multipath_alignment </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultipathAlignment &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HandleGraph &amp;&#160;</td>
          <td class="paramname"><em>handle_graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a formatted string representation of the <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> into the ostream. </p>

</div>
</div>
<a class="anchor" id="a23e5fc95fa04fafdfef347867f7d4aaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::view_multipath_alignment_as_dot </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultipathAlignment &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> to a GraphViz Dot representation, output to the given ostream. </p>

</div>
</div>
<a class="anchor" id="aec4813274fc2af3d83679e128fdeb32f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;T&gt; vg::vpmax </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a38d35bca25e8a6d5fe10f603cb9048c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::wang_hash_64 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a57f111dda471f40192704110bae04a0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::wrap_text </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a81c8bc6d3b973fd1a34c3457a9d2e401"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::write_alignment_to_file </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6d8c71ff9f77ddd4a366119e83122771"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::write_gcsa_kmers </td>
          <td>(</td>
          <td class="paramtype">const HandleGraph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kmer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>size_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">id_t&#160;</td>
          <td class="paramname"><em>head_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">id_t&#160;</td>
          <td class="paramname"><em>tail_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write GCSA2 formatted binary KMers to the given ostream. size_limit is the maximum size of the kmer file in bytes. When the function returns, size_limit is the size of the kmer file in bytes. </p>

</div>
</div>
<a class="anchor" id="a38d9326cbc013aed614bc052c8c224e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::write_gcsa_kmers_to_tmpfile </td>
          <td>(</td>
          <td class="paramtype">const HandleGraph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kmer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>size_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">id_t&#160;</td>
          <td class="paramname"><em>head_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">id_t&#160;</td>
          <td class="paramname"><em>tail_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>base_file_name</em> = <code>&quot;vg-kmers-tmp-&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a tempfile and write the kmers to it. The calling context should remove it with <a class="el" href="namespacevg_1_1temp__file.html#a9885078330e16129fccc5fb6d8717ec5" title="Remove a temporary file. ">temp_file::remove()</a>. </p>

</div>
</div>
<a class="anchor" id="a84ce0743c9a27e8b8ed32de37e4064fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::write_vcf_header </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>sample_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>contig_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>contig_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_mad_for_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_dp_for_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_dp_multiple_for_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_local_dp_multiple_for_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_ad_log_likelihood_for_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>xref_enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a minimal VCF header for a file with the given samples, and the given contigs with the given lengths. </p>

</div>
</div>
<a class="anchor" id="a273ef8a0e90e251a499e12e213b78108"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; string, vector&lt; pair&lt; size_t, bool &gt; &gt; &gt; vg::xg_alignment_path_offsets </td>
          <td>(</td>
          <td class="paramtype">const Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>just_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nearby</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgidx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a map from path name to a list of positions on that path touched by or near to the given <a class="el" href="structvg_1_1Alignment.html">Alignment</a>. If nearby is set, search off the part of the graph actually covered by the alignment, to try and find nearby positions along nearby paths. Otherwise, we only search off the actually touched part of the graph if we can't find any paths on it. If just_min is set, produce only one position per path, which will be the lowest graph position <em>touched</em> by the <a class="el" href="structvg_1_1Alignment.html">Alignment</a> (could be a <a class="el" href="structvg_1_1Mapping.html">Mapping</a> start <em>or</em> end). Otherwise, produces one position per occurrence on the path of the position of each <a class="el" href="structvg_1_1Mapping.html">Mapping</a> in the <a class="el" href="structvg_1_1Alignment.html">Alignment</a>, which will be the position at which the <a class="el" href="structvg_1_1Mapping.html">Mapping</a> <em>starts</em>. </p>

</div>
</div>
<a class="anchor" id="aea8dedb8c4f2db46cfabc83a465f640a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::xg_annotate_with_initial_path_positions </td>
          <td>(</td>
          <td class="paramtype">Alignment &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgidx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Annotate the given <a class="el" href="structvg_1_1Alignment.html">Alignment</a> in place with the earliest touched positions, as produced by xg_alignment_path_offsets, as refpos values. Always uses min positions. Only resorts to nearby positions if no positions on a path are touched. </p>

</div>
</div>
<a class="anchor" id="a33d1e76d40f6ffb18441a58d57d34e0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::xg_cached_distance </td>
          <td>(</td>
          <td class="paramtype">pos_t&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pos_t&#160;</td>
          <td class="paramname"><em>pos2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LRUCache&lt; id_t, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LRUCache&lt; id_t, vector&lt; Edge &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5706d56f6ae537ad6ffe60ae55a16644"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> &gt; vg::xg_cached_edges_of </td>
          <td>(</td>
          <td class="paramtype">id_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LRUCache&lt; id_t, vector&lt; Edge &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afa1fb4fd7cf939c646ca6b14325ca128"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> &gt; vg::xg_cached_edges_on_end </td>
          <td>(</td>
          <td class="paramtype">id_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LRUCache&lt; id_t, vector&lt; Edge &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a280cd654eb74ab3e214cd485d6db0816"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> &gt; vg::xg_cached_edges_on_start </td>
          <td>(</td>
          <td class="paramtype">id_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LRUCache&lt; id_t, vector&lt; Edge &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a223d4edec998d7a1f1ad22c4b4344e1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt; vg::xg_cached_next_pos </td>
          <td>(</td>
          <td class="paramtype">pos_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>whole_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LRUCache&lt; id_t, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LRUCache&lt; id_t, vector&lt; Edge &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab8bc6a314b6acfc67c019060ee1068c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>, char &gt; vg::xg_cached_next_pos_chars </td>
          <td>(</td>
          <td class="paramtype">pos_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LRUCache&lt; id_t, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LRUCache&lt; id_t, vector&lt; Edge &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the characters at positions after the given position from an <a class="el" href="classxg_1_1XG.html">xg::XG</a> index, with cacheing of deserialized nodes. </p>

</div>
</div>
<a class="anchor" id="ade346bce814fece7984fbe841cce8063"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Node.html">Node</a> vg::xg_cached_node </td>
          <td>(</td>
          <td class="paramtype">id_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LRUCache&lt; id_t, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3f867e47afc5277d494355a4be810957"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::xg_cached_node_length </td>
          <td>(</td>
          <td class="paramtype">id_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LRUCache&lt; id_t, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the length of a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a> from an <a class="el" href="classxg_1_1XG.html">xg::XG</a> index, with cacheing of deserialized nodes. </p>

</div>
</div>
<a class="anchor" id="ae0cbe2762b34b22c3752259dc7843b3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::xg_cached_node_sequence </td>
          <td>(</td>
          <td class="paramtype">id_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LRUCache&lt; id_t, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a883b08d376012aafd5653da7d384a859"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::xg_cached_node_start </td>
          <td>(</td>
          <td class="paramtype">id_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LRUCache&lt; id_t, int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_start_cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the node start position in the sequence vector. </p>

</div>
</div>
<a class="anchor" id="a5473152cd3961a2b2a08ec7a294bffe1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char vg::xg_cached_pos_char </td>
          <td>(</td>
          <td class="paramtype">pos_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LRUCache&lt; id_t, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the character at a position in an <a class="el" href="classxg_1_1XG.html">xg::XG</a> index, with cacheing of deserialized nodes. </p>

</div>
</div>
<a class="anchor" id="aa8a907acff2a5f9fbdf66b8373792a2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt; vg::xg_cached_positions_bp_from </td>
          <td>(</td>
          <td class="paramtype">pos_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LRUCache&lt; id_t, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LRUCache&lt; id_t, vector&lt; Edge &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a86028cee0c33d849f37236619f93cf97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::xg_distance </td>
          <td>(</td>
          <td class="paramtype">pos_t&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pos_t&#160;</td>
          <td class="paramname"><em>pos2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgidx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a70ac96a405711a35f96e127bb8c8553e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> &gt; vg::xg_edges_on_end </td>
          <td>(</td>
          <td class="paramtype">id_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgidx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abf9c7332961acdb45c8fcd8b14ebdfce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> &gt; vg::xg_edges_on_start </td>
          <td>(</td>
          <td class="paramtype">id_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgidx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3add5068be75e8c8f5da5d836d0793f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt; vg::xg_next_pos </td>
          <td>(</td>
          <td class="paramtype">pos_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>whole_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgidx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8429876ce03b5b6702a63f8c9f735ab4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>, char &gt; vg::xg_next_pos_chars </td>
          <td>(</td>
          <td class="paramtype">pos_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgidx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the characters at positions after the given position from an <a class="el" href="classxg_1_1XG.html">xg::XG</a> index, with cacheing of deserialized nodes. </p>

</div>
</div>
<a class="anchor" id="ad9dd8ed096a730fcaa60ddd7565db84a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Node.html">Node</a> vg::xg_node </td>
          <td>(</td>
          <td class="paramtype">id_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgidx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af120c0d9ebecd1b3a6da6a66a49f3855"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::xg_node_length </td>
          <td>(</td>
          <td class="paramtype">id_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgidx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the length of a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a> from an <a class="el" href="classxg_1_1XG.html">xg::XG</a> index, with cacheing of deserialized nodes. </p>

</div>
</div>
<a class="anchor" id="a2df5e6b0e351c4c2d89dc95168974642"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::xg_node_sequence </td>
          <td>(</td>
          <td class="paramtype">id_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgidx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af3373ba50df47dd6a5fcebc9a283c61d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::xg_node_start </td>
          <td>(</td>
          <td class="paramtype">id_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgidx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the node start position in the sequence vector. </p>

</div>
</div>
<a class="anchor" id="a4184dd0acd62bd6229a0119734a4914d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char vg::xg_pos_char </td>
          <td>(</td>
          <td class="paramtype">pos_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgidx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the character at a position in an <a class="el" href="classxg_1_1XG.html">xg::XG</a> index, with cacheing of deserialized nodes. </p>

</div>
</div>
<a class="anchor" id="a260823500b0302ed6e8c7baa83f6df3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt; vg::xg_positions_bp_from </td>
          <td>(</td>
          <td class="paramtype">pos_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xgidx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ade7204b42260155b9a98a6d18c24a0b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* const vg::BAM_DNA_LOOKUP = &quot;=ACMGRSVTWYHKDBN&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abd1798abb6fcee86ab5b0539fb764eb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::fullTrace = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afe7fae89b379b5411189ac0ac74b2dd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* vg::var = &quot;VG_FULL_TRACEBACK&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
