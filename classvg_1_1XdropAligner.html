<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::XdropAligner Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1XdropAligner.html">XdropAligner</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classvg_1_1XdropAligner-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::XdropAligner Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;xdrop_aligner.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1XdropAligner_1_1graph__pos__s.html">graph_pos_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acb2c93d2501ced57af141a9dd279b188"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#acb2c93d2501ced57af141a9dd279b188">XdropAligner</a> (const int8_t *_score_matrix, int8_t _gap_open, int8_t _gap_extension, int32_t _full_length_bonus)</td></tr>
<tr class="memdesc:acb2c93d2501ced57af141a9dd279b188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main constructor. Expects a 4 x 4 score matrix.  <a href="#acb2c93d2501ced57af141a9dd279b188">More...</a><br /></td></tr>
<tr class="separator:acb2c93d2501ced57af141a9dd279b188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bd0589c6847bc786c320f5f5d841d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#a76bd0589c6847bc786c320f5f5d841d9">XdropAligner</a> ()</td></tr>
<tr class="separator:a76bd0589c6847bc786c320f5f5d841d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa342dfcc4afb1448b98857fd216044a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#aaa342dfcc4afb1448b98857fd216044a">~XdropAligner</a> (void)</td></tr>
<tr class="separator:aaa342dfcc4afb1448b98857fd216044a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42a02f900600c3c375fa0b6644c97a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#af42a02f900600c3c375fa0b6644c97a9">XdropAligner</a> (const <a class="el" href="classvg_1_1XdropAligner.html">XdropAligner</a> &amp;other)</td></tr>
<tr class="memdesc:af42a02f900600c3c375fa0b6644c97a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#af42a02f900600c3c375fa0b6644c97a9">More...</a><br /></td></tr>
<tr class="separator:af42a02f900600c3c375fa0b6644c97a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb2cfcbd85802990c1386827ac98192"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1XdropAligner.html">XdropAligner</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#a5bb2cfcbd85802990c1386827ac98192">operator=</a> (const <a class="el" href="classvg_1_1XdropAligner.html">XdropAligner</a> &amp;other)</td></tr>
<tr class="memdesc:a5bb2cfcbd85802990c1386827ac98192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment.  <a href="#a5bb2cfcbd85802990c1386827ac98192">More...</a><br /></td></tr>
<tr class="separator:a5bb2cfcbd85802990c1386827ac98192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb9135c8b9e7534b90124968e4d3f48"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#a2eb9135c8b9e7534b90124968e4d3f48">XdropAligner</a> (<a class="el" href="classvg_1_1XdropAligner.html">XdropAligner</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a2eb9135c8b9e7534b90124968e4d3f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#a2eb9135c8b9e7534b90124968e4d3f48">More...</a><br /></td></tr>
<tr class="separator:a2eb9135c8b9e7534b90124968e4d3f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39627c50a6e60a7f065332fbd99fdcba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1XdropAligner.html">XdropAligner</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#a39627c50a6e60a7f065332fbd99fdcba">operator=</a> (<a class="el" href="classvg_1_1XdropAligner.html">XdropAligner</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a39627c50a6e60a7f065332fbd99fdcba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment.  <a href="#a39627c50a6e60a7f065332fbd99fdcba">More...</a><br /></td></tr>
<tr class="separator:a39627c50a6e60a7f065332fbd99fdcba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0deafb832052e4abb4f4498fcf7baf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#ab0deafb832052e4abb4f4498fcf7baf0">align</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, bool reverse_complemented, uint16_t max_gap_length=default_xdrop_max_gap_length)</td></tr>
<tr class="separator:ab0deafb832052e4abb4f4498fcf7baf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d806e813fc3b8a12c1732eabb05ee6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#a99d806e813fc3b8a12c1732eabb05ee6">align_pinned</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;g, bool pin_left, uint16_t max_gap_length=default_xdrop_max_gap_length)</td></tr>
<tr class="separator:a99d806e813fc3b8a12c1732eabb05ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a1a0c54bcbc1acb9d0be1ad615b78f321"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1XdropAligner_1_1graph__pos__s.html">graph_pos_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#a1a0c54bcbc1acb9d0be1ad615b78f321">calculate_seed_position</a> (const <a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> &amp;graph, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, size_t query_length, bool direction) const</td></tr>
<tr class="separator:a1a0c54bcbc1acb9d0be1ad615b78f321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b520c9e0a29ba341f0996e4731b0ff2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1XdropAligner_1_1graph__pos__s.html">graph_pos_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#a3b520c9e0a29ba341f0996e4731b0ff2">calculate_max_position</a> (const <a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> &amp;graph, const <a class="el" href="structvg_1_1XdropAligner_1_1graph__pos__s.html">graph_pos_s</a> &amp;seed_pos, size_t max_node_index, bool direction, const vector&lt; const dz_forefront_s *&gt; &amp;forefronts)</td></tr>
<tr class="separator:a3b520c9e0a29ba341f0996e4731b0ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc0d67b49958ecf5da8513efd51ea13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1XdropAligner_1_1graph__pos__s.html">graph_pos_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#aecc0d67b49958ecf5da8513efd51ea13">scan_seed_position</a> (const <a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> &amp;graph, const string &amp;query_seq, bool direction, vector&lt; const dz_forefront_s *&gt; &amp;forefronts, uint16_t max_gap_length)</td></tr>
<tr class="separator:aecc0d67b49958ecf5da8513efd51ea13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db5e65dc39cde38d86f3e8b2e0fb0df"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#a1db5e65dc39cde38d86f3e8b2e0fb0df">push_edit</a> (<a class="el" href="structvg_1_1Mapping.html">Mapping</a> *mapping, uint8_t op, const char *alt, size_t len) const</td></tr>
<tr class="separator:a1db5e65dc39cde38d86f3e8b2e0fb0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de44201a0a2a3f643c720361faef9d2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#a7de44201a0a2a3f643c720361faef9d2">extend</a> (const <a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> &amp;graph, const dz_query_s *packed_query, const vector&lt; <a class="el" href="structvg_1_1XdropAligner_1_1graph__pos__s.html">graph_pos_s</a> &gt; &amp;seed_positions, bool right_to_left, vector&lt; const dz_forefront_s *&gt; &amp;forefronts, uint16_t)</td></tr>
<tr class="separator:a7de44201a0a2a3f643c720361faef9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e563b6dee99127d291e7d686e63d4c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#a2e563b6dee99127d291e7d686e63d4c6">calculate_and_save_alignment</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> &amp;graph, const vector&lt; <a class="el" href="structvg_1_1XdropAligner_1_1graph__pos__s.html">graph_pos_s</a> &gt; &amp;head_positions, size_t tail_node_index, bool left_to_right, const vector&lt; const dz_forefront_s *&gt; &amp;forefronts)</td></tr>
<tr class="separator:a2e563b6dee99127d291e7d686e63d4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeec3320013f19f546e447b6c5907d96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#adeec3320013f19f546e447b6c5907d96">align_downward</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> &amp;graph, const vector&lt; <a class="el" href="structvg_1_1XdropAligner_1_1graph__pos__s.html">graph_pos_s</a> &gt; &amp;head_positions, bool left_to_right, vector&lt; const dz_forefront_s *&gt; &amp;forefronts, uint16_t max_gap_length)</td></tr>
<tr class="separator:adeec3320013f19f546e447b6c5907d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a295e2d0944a90dc202bcb86e312e63bf"><td class="memItemLeft" align="right" valign="top">dz_s *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#a295e2d0944a90dc202bcb86e312e63bf">dz</a> = nullptr</td></tr>
<tr class="memdesc:a295e2d0944a90dc202bcb86e312e63bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The core dozeu class, which does the alignments.  <a href="#a295e2d0944a90dc202bcb86e312e63bf">More...</a><br /></td></tr>
<tr class="separator:a295e2d0944a90dc202bcb86e312e63bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Align to a graph using the xdrop algorithm, as implemented in dozeu.</p>
<p>The underlying Dozeu library is fundamentally based around semi-global alignment: extending an alignment from a known matching position (what in other parts of vg we call "pinned" alignment).</p>
<p>To simulate non-pinned alignment, we align in two passes in different directions. One from a guess of a pinning position, to get a more accurate "head" pinning position for the other end, and once back from where the previous pass ended up, to get an overall hopefully-optimal alignment.</p>
<p>If the input graph is not reverse-complemented, direction = false (reverse, right to left) on the first pass, and direction = true (forward, left to right) on the second. If it is reverse complemented, we flip them.</p>
<p>This won't actually work in theory to get the optimal local alignment in all cases, but it works well in practice.</p>
<p>This class maintains an internal dz_s, which is <em>NOT THREADSAFE</em>, and non-const during alignments. However, it may be reused for subsequent alignments. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acb2c93d2501ced57af141a9dd279b188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2c93d2501ced57af141a9dd279b188">&#9670;&nbsp;</a></span>XdropAligner() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XdropAligner::XdropAligner </td>
          <td>(</td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>_score_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>_gap_open</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>_gap_extension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>_full_length_bonus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main constructor. Expects a 4 x 4 score matrix. </p>

</div>
</div>
<a id="a76bd0589c6847bc786c320f5f5d841d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76bd0589c6847bc786c320f5f5d841d9">&#9670;&nbsp;</a></span>XdropAligner() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XdropAligner::XdropAligner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa342dfcc4afb1448b98857fd216044a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa342dfcc4afb1448b98857fd216044a">&#9670;&nbsp;</a></span>~XdropAligner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XdropAligner::~XdropAligner </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af42a02f900600c3c375fa0b6644c97a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42a02f900600c3c375fa0b6644c97a9">&#9670;&nbsp;</a></span>XdropAligner() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XdropAligner::XdropAligner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1XdropAligner.html">XdropAligner</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a id="a2eb9135c8b9e7534b90124968e4d3f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb9135c8b9e7534b90124968e4d3f48">&#9670;&nbsp;</a></span>XdropAligner() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XdropAligner::XdropAligner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1XdropAligner.html">XdropAligner</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab0deafb832052e4abb4f4498fcf7baf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0deafb832052e4abb4f4498fcf7baf0">&#9670;&nbsp;</a></span>align()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XdropAligner::align </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse_complemented</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_gap_length</em> = <code>default_xdrop_max_gap_length</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>align query: forward-backward banded alignment</p>
<p>Compute an alignment of the given <a class="el" href="structvg_1_1Alignment.html">Alignment</a>'s sequence against the given DAG, using (one of) the given MEMs to seed the alignment.</p>
<p>reverse_complemented is true if the topologically sorted graph we have was reverse-complemented when extracted from a larger containing graph, and false if it is in the same orientation as it exists in the larger containing graph. The MEMs and the <a class="el" href="structvg_1_1Alignment.html">Alignment</a> are interpreted as being against the forward strand of the passed subgraph no matter the value of this setting.</p>
<p>reverse_complemented true means we will compute the alignment forward in the topologically-sorted order of the given graph (anchoring to the first node if no MEMs are provided) and false if we want to compute the alignment backward in the topological order (anchoring to the last node).</p>
<p>First the head (the most upstream) seed in MEMs is selected and extended downward to detect the downstream breakpoint. Next the alignment path is generated by second upward extension from the downstream breakpoint.</p>
<p>The MEM list may be empty. If MEMs are provided, uses only the begin, end, and nodes fields of the <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> objects. It uses the first occurrence of the last MEM if reverse_complemented is true, and the last occurrence of the first MEM otherwise. </p>

</div>
</div>
<a id="adeec3320013f19f546e447b6c5907d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeec3320013f19f546e447b6c5907d96">&#9670;&nbsp;</a></span>align_downward()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XdropAligner::align_downward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1XdropAligner_1_1graph__pos__s.html">graph_pos_s</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>head_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>left_to_right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; const dz_forefront_s *&gt; &amp;&#160;</td>
          <td class="paramname"><em>forefronts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_gap_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>After doing the upward pass and finding head_pos to anchor from, do the downward alignment pass and traceback. If left_to_right is set, goes left to right and traces back the other way. If it is unset, goes right to left and traces back the other way. </p>

</div>
</div>
<a id="a99d806e813fc3b8a12c1732eabb05ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d806e813fc3b8a12c1732eabb05ee6">&#9670;&nbsp;</a></span>align_pinned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XdropAligner::align_pinned </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_gap_length</em> = <code>default_xdrop_max_gap_length</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute a pinned alignment, where the start (pin_left=true) or end (pin_left=false) end of the <a class="el" href="structvg_1_1Alignment.html">Alignment</a> sequence is pinned to the start of the first (pin_left=true) or end of the last (pin_left=false) node in the graph's topological order.</p>
<p>Does not account for multiple sources/sinks in the topological order; whichever comes first/last ends up being used for the pin. </p>

</div>
</div>
<a id="a2e563b6dee99127d291e7d686e63d4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e563b6dee99127d291e7d686e63d4c6">&#9670;&nbsp;</a></span>calculate_and_save_alignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XdropAligner::calculate_and_save_alignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1XdropAligner_1_1graph__pos__s.html">graph_pos_s</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>head_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tail_node_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>left_to_right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; const dz_forefront_s *&gt; &amp;&#160;</td>
          <td class="paramname"><em>forefronts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>After all the alignment work has been done, do the traceback and save into the given <a class="el" href="structvg_1_1Alignment.html">Alignment</a> object.</p>
<p>If left_to_right is true, the nodes were filled left to right, and the internal traceback will come out in left to right order, so we can emit it as is. If it is false, the nodes were filled right to left, and the internal traceback comes out in right to left order, so we need to flip it. </p>

</div>
</div>
<a id="a3b520c9e0a29ba341f0996e4731b0ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b520c9e0a29ba341f0996e4731b0ff2">&#9670;&nbsp;</a></span>calculate_max_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1XdropAligner_1_1graph__pos__s.html">XdropAligner::graph_pos_s</a> XdropAligner::calculate_max_position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1XdropAligner_1_1graph__pos__s.html">graph_pos_s</a> &amp;&#160;</td>
          <td class="paramname"><em>seed_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_node_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; const dz_forefront_s *&gt; &amp;&#160;</td>
          <td class="paramname"><em>forefronts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given the index of the node at which the winning score occurs, find the position in the node and read sequence at which the winning match is found. </p>

</div>
</div>
<a id="a1a0c54bcbc1acb9d0be1ad615b78f321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a0c54bcbc1acb9d0be1ad615b78f321">&#9670;&nbsp;</a></span>calculate_seed_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1XdropAligner_1_1graph__pos__s.html">XdropAligner::graph_pos_s</a> XdropAligner::calculate_seed_position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>query_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given the subgraph we are aligning to, the MEM hist against it, the length of the query, and the direction we are aligning the query in (true = forward), select a single anchoring match between the graph and the query to align out from.</p>
<p>This replaces scan_seed_position for the case where we have MEMs. </p>

</div>
</div>
<a id="a7de44201a0a2a3f643c720361faef9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de44201a0a2a3f643c720361faef9d2">&#9670;&nbsp;</a></span>extend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t XdropAligner::extend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dz_query_s *&#160;</td>
          <td class="paramname"><em>packed_query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1XdropAligner_1_1graph__pos__s.html">graph_pos_s</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>seed_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>right_to_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; const dz_forefront_s *&gt; &amp;&#160;</td>
          <td class="paramname"><em>forefronts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_gap_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do alignment. Takes the graph, the sorted packed edges in ascending order for a forward pass or descending order for a reverse pass, the packed query sequence, the index of the seed node in the graph, the offset (TODO: in the read?) of the seed position, and the direction to traverse the graph topological order.</p>
<p>Note that we take our direction as right_to_left, whole many other functions take it as left_to_right.</p>
<p>If a MEM seed is provided, this is run in two passes. The first is left to right (right_to_left = false) if align did not have reverse_complement set and the second is right to left (right_to_left = true).</p>
<p>If we have no MEM seed, we only run one pass (the second one).</p>
<p>Returns the index in the topological order of the node with the highest scoring alignment.</p>
<p>Note that if no non-empty local alignment is found, it may not be safe to call dz_calc_max_qpos on the associated forefront! </p>

</div>
</div>
<a id="a5bb2cfcbd85802990c1386827ac98192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb2cfcbd85802990c1386827ac98192">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1XdropAligner.html">XdropAligner</a> &amp; XdropAligner::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1XdropAligner.html">XdropAligner</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment. </p>

</div>
</div>
<a id="a39627c50a6e60a7f065332fbd99fdcba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39627c50a6e60a7f065332fbd99fdcba">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1XdropAligner.html">XdropAligner</a> &amp; XdropAligner::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1XdropAligner.html">XdropAligner</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move assignment. </p>

</div>
</div>
<a id="a1db5e65dc39cde38d86f3e8b2e0fb0df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db5e65dc39cde38d86f3e8b2e0fb0df">&#9670;&nbsp;</a></span>push_edit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t XdropAligner::push_edit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Mapping.html">Mapping</a> *&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>alt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Append an edit at the end of the current mapping array. Returns the length passed in. </p>

</div>
</div>
<a id="aecc0d67b49958ecf5da8513efd51ea13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc0d67b49958ecf5da8513efd51ea13">&#9670;&nbsp;</a></span>scan_seed_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1XdropAligner_1_1graph__pos__s.html">XdropAligner::graph_pos_s</a> XdropAligner::scan_seed_position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>query_seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; const dz_forefront_s *&gt; &amp;&#160;</td>
          <td class="paramname"><em>forefronts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_gap_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If no seeds are provided as alignment input, we need to compute our own starting anchor position. This function does that. Takes the topologically-sorted graph, the query sequence, and the direction. If direction is false, finds a seed hit on the first node of the graph. If it is true, finds a hit on the last node.</p>
<p>This replaces calculate_seed_position for the case where we have no MEMs. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a295e2d0944a90dc202bcb86e312e63bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a295e2d0944a90dc202bcb86e312e63bf">&#9670;&nbsp;</a></span>dz</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dz_s* vg::XdropAligner::dz = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The core dozeu class, which does the alignments. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="xdrop__aligner_8hpp.html">xdrop_aligner.hpp</a></li>
<li>src/<a class="el" href="xdrop__aligner_8cpp.html">xdrop_aligner.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
