<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>vg: vg::XdropAligner Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1XdropAligner.html">XdropAligner</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classvg_1_1XdropAligner-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::XdropAligner Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;xdrop_aligner.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1XdropAligner_1_1graph__pos__s.html">graph_pos_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a76bd0589c6847bc786c320f5f5d841d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#a76bd0589c6847bc786c320f5f5d841d9">XdropAligner</a> ()</td></tr>
<tr class="separator:a76bd0589c6847bc786c320f5f5d841d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605020a268ee52042da27755b773a155"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#a605020a268ee52042da27755b773a155">XdropAligner</a> (<a class="el" href="classvg_1_1XdropAligner.html">XdropAligner</a> const &amp;)</td></tr>
<tr class="separator:a605020a268ee52042da27755b773a155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2195a7231e605e9179f2de889ac71ec4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1XdropAligner.html">XdropAligner</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#a2195a7231e605e9179f2de889ac71ec4">operator=</a> (<a class="el" href="classvg_1_1XdropAligner.html">XdropAligner</a> const &amp;)</td></tr>
<tr class="separator:a2195a7231e605e9179f2de889ac71ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8fca674950eef5af6a9a32aaafd17a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#af8fca674950eef5af6a9a32aaafd17a8">XdropAligner</a> (<a class="el" href="classvg_1_1XdropAligner.html">XdropAligner</a> &amp;&amp;)</td></tr>
<tr class="separator:af8fca674950eef5af6a9a32aaafd17a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa742262d1837a035f149a86bcf8fb9ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1XdropAligner.html">XdropAligner</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#aa742262d1837a035f149a86bcf8fb9ea">operator=</a> (<a class="el" href="classvg_1_1XdropAligner.html">XdropAligner</a> &amp;&amp;)</td></tr>
<tr class="separator:aa742262d1837a035f149a86bcf8fb9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1821b31c8dcadd3e65f2b124bcd11495"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#a1821b31c8dcadd3e65f2b124bcd11495">XdropAligner</a> (int8_t _match, int8_t _mismatch, int8_t _gap_open, int8_t _gap_extension, int32_t _full_length_bonus, uint32_t _max_gap_length)</td></tr>
<tr class="separator:a1821b31c8dcadd3e65f2b124bcd11495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb21351b30a05dc2ef1e2fd61086c6f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#acbb21351b30a05dc2ef1e2fd61086c6f">XdropAligner</a> (int8_t const *_score_matrix, int8_t _gap_open, int8_t _gap_extension, int32_t _full_length_bonus, uint32_t _max_gap_length)</td></tr>
<tr class="separator:acbb21351b30a05dc2ef1e2fd61086c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa342dfcc4afb1448b98857fd216044a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#aaa342dfcc4afb1448b98857fd216044a">~XdropAligner</a> (void)</td></tr>
<tr class="separator:aaa342dfcc4afb1448b98857fd216044a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88510100ea260d4810b3b08bc1b81c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#af88510100ea260d4810b3b08bc1b81c3">align</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, <a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> const &amp;graph, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, bool reverse_complemented)</td></tr>
<tr class="separator:af88510100ea260d4810b3b08bc1b81c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35fafc08e131793d54902853e690b35e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#a35fafc08e131793d54902853e690b35e">align</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, <a class="el" href="structvg_1_1Graph.html">Graph</a> const &amp;graph, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, bool reverse_complemented)</td></tr>
<tr class="memdesc:a35fafc08e131793d54902853e690b35e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="classvg_1_1XdropAligner.html#af88510100ea260d4810b3b08bc1b81c3">align()</a> that automatically wraps up a topologically-ordered Protobuf graph as an <a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a>.  <a href="#a35fafc08e131793d54902853e690b35e">More...</a><br/></td></tr>
<tr class="separator:a35fafc08e131793d54902853e690b35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a30365d55a27e1952f3d53a446b55f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#a43a30365d55a27e1952f3d53a446b55f">align_pinned</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;g, bool pin_left)</td></tr>
<tr class="separator:a43a30365d55a27e1952f3d53a446b55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afbb0c40b9fbb9f454dfb79134769e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#a8afbb0c40b9fbb9f454dfb79134769e5">align_pinned</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;g, const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;topological_order, bool pin_left)</td></tr>
<tr class="separator:a8afbb0c40b9fbb9f454dfb79134769e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a178bf539a4ba417825383caa88a3f5c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#a178bf539a4ba417825383caa88a3f5c2">build_id_index_table</a> (<a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> const &amp;graph)</td></tr>
<tr class="memdesc:a178bf539a4ba417825383caa88a3f5c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill in the id_to_index map.  <a href="#a178bf539a4ba417825383caa88a3f5c2">More...</a><br/></td></tr>
<tr class="separator:a178bf539a4ba417825383caa88a3f5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e119c900c4b48b61f175fd9295cdba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#ab8e119c900c4b48b61f175fd9295cdba">build_index_edge_table</a> (<a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> const &amp;graph, uint32_t const seed_node_index, bool left_to_right)</td></tr>
<tr class="separator:ab8e119c900c4b48b61f175fd9295cdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3362e14abe865e343cf31617d4ff2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1XdropAligner_1_1graph__pos__s.html">graph_pos_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#a9a3362e14abe865e343cf31617d4ff2e">calculate_seed_position</a> (<a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> const &amp;graph, vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; const &amp;mems, size_t query_length, bool direction)</td></tr>
<tr class="separator:a9a3362e14abe865e343cf31617d4ff2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e6c735c74c3de25c5e5d569c03bcc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1XdropAligner_1_1graph__pos__s.html">graph_pos_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#a96e6c735c74c3de25c5e5d569c03bcc6">calculate_max_position</a> (<a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> const &amp;graph, <a class="el" href="structvg_1_1XdropAligner_1_1graph__pos__s.html">graph_pos_s</a> const &amp;seed_pos, size_t max_node_index, bool direction)</td></tr>
<tr class="separator:a96e6c735c74c3de25c5e5d569c03bcc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19f8fe7183fb6e7ec9807db8d472937"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1XdropAligner_1_1graph__pos__s.html">graph_pos_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#aa19f8fe7183fb6e7ec9807db8d472937">scan_seed_position</a> (<a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> const &amp;graph, std::string const &amp;query_seq, bool direction)</td></tr>
<tr class="separator:aa19f8fe7183fb6e7ec9807db8d472937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fdcf4192f3f5045ed4025f2a2dbe8f6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#a0fdcf4192f3f5045ed4025f2a2dbe8f6">push_edit</a> (<a class="el" href="structvg_1_1Mapping.html">Mapping</a> *mapping, uint8_t op, char const *alt, size_t len)</td></tr>
<tr class="separator:a0fdcf4192f3f5045ed4025f2a2dbe8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b498703a9e8e6a6d700a0fef8fb655"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#a65b498703a9e8e6a6d700a0fef8fb655">extend</a> (<a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> const &amp;graph, vector&lt; uint64_t &gt;::const_iterator begin, vector&lt; uint64_t &gt;::const_iterator <a class="el" href="namespacevg.html#ae28509de83b851bdc0d8ff2fa7bd4275">end</a>, dz_query_s const *packed_query, size_t seed_node_index, uint64_t seed_offset, bool right_to_left)</td></tr>
<tr class="separator:a65b498703a9e8e6a6d700a0fef8fb655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a06127b2ab0a8166107b627a7d14bc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#a7a06127b2ab0a8166107b627a7d14bc2">calculate_and_save_alignment</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, <a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> const &amp;graph, <a class="el" href="structvg_1_1XdropAligner_1_1graph__pos__s.html">graph_pos_s</a> const &amp;head_pos, size_t tail_node_index, bool left_to_right)</td></tr>
<tr class="separator:a7a06127b2ab0a8166107b627a7d14bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d6a0e9ad28fb4fd2b20bf675b3c968"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#ae1d6a0e9ad28fb4fd2b20bf675b3c968">align_downward</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, <a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> const &amp;graph, <a class="el" href="structvg_1_1XdropAligner_1_1graph__pos__s.html">graph_pos_s</a> const &amp;head_pos, bool left_to_right)</td></tr>
<tr class="separator:ae1d6a0e9ad28fb4fd2b20bf675b3c968"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a295e2d0944a90dc202bcb86e312e63bf"><td class="memItemLeft" align="right" valign="top">dz_s *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#a295e2d0944a90dc202bcb86e312e63bf">dz</a></td></tr>
<tr class="memdesc:a295e2d0944a90dc202bcb86e312e63bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the backing dozeu library problem instance.  <a href="#a295e2d0944a90dc202bcb86e312e63bf">More...</a><br/></td></tr>
<tr class="separator:a295e2d0944a90dc202bcb86e312e63bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2ced8e428210e6cd9964a309486255"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#a7b2ced8e428210e6cd9964a309486255">aa_match</a></td></tr>
<tr class="separator:a7b2ced8e428210e6cd9964a309486255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f85612e0c2b4ce232f8459ab106da74"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <br class="typebreak"/>
uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#a5f85612e0c2b4ce232f8459ab106da74">id_to_index</a></td></tr>
<tr class="memdesc:a5f85612e0c2b4ce232f8459ab106da74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps from node ID to the index in our internal subgraph storage at which that node occurs.  <a href="#a5f85612e0c2b4ce232f8459ab106da74">More...</a><br/></td></tr>
<tr class="separator:a5f85612e0c2b4ce232f8459ab106da74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d341e5789910c47a7cfd32ae355de4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#ad9d341e5789910c47a7cfd32ae355de4">index_edges</a></td></tr>
<tr class="separator:ad9d341e5789910c47a7cfd32ae355de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2e62b98c5a0dce8b82722891267a17"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#a1c2e62b98c5a0dce8b82722891267a17">index_edges_head</a></td></tr>
<tr class="memdesc:a1c2e62b98c5a0dce8b82722891267a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: what is this?  <a href="#a1c2e62b98c5a0dce8b82722891267a17">More...</a><br/></td></tr>
<tr class="separator:a1c2e62b98c5a0dce8b82722891267a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a4b6a0f8a31895f99ec6e59c2b732c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; struct <br class="typebreak"/>
dz_forefront_s const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#ae3a4b6a0f8a31895f99ec6e59c2b732c">forefronts</a></td></tr>
<tr class="memdesc:ae3a4b6a0f8a31895f99ec6e59c2b732c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores all of the currently outstanding dozeu library forefronts.  <a href="#ae3a4b6a0f8a31895f99ec6e59c2b732c">More...</a><br/></td></tr>
<tr class="separator:ae3a4b6a0f8a31895f99ec6e59c2b732c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5090116005c979770c34703c71c02beb"><td class="memItemLeft" align="right" valign="top">std::function&lt; bool(uint64_t <br class="typebreak"/>
const &amp;, uint64_t const &amp;)&gt;<br class="typebreak"/>
 const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#a5090116005c979770c34703c71c02beb">compare</a> [2]</td></tr>
<tr class="separator:a5090116005c979770c34703c71c02beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8df6d7c151d4585cf01dc0d0962940"><td class="memItemLeft" align="right" valign="top">std::function&lt; uint64_t(uint64_t <br class="typebreak"/>
const &amp;, uint64_t const &amp;)&gt;<br class="typebreak"/>
 const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html#abe8df6d7c151d4585cf01dc0d0962940">edge</a> [2]</td></tr>
<tr class="separator:abe8df6d7c151d4585cf01dc0d0962940"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Align to a graph using the xdrop algorithm, as implemented in dozeu.</p>
<p>Not thread-safe. Each <a class="el" href="classvg_1_1XdropAligner.html#af88510100ea260d4810b3b08bc1b81c3">align()</a> call stores state in the object.</p>
<p><em>Can</em> be re-used for multiple problems in a row.</p>
<p>The underlying Dozeu library is fundamentally based around semi-global alignment: extending an alignment from a known matching position (what in other parts of vg we call "pinned" alignment).</p>
<p>To simulate non-pinned alignment, we align in two passes in different directions. One from a guess of a pinning position, to get a more accurate "head" pinning position for the other end, and once back from where the previous pass ended up, to get an overall hopefully-optimal alignment.</p>
<p>If the input graph is not reverse-complemented, direction = false (reverse, right to left) on the first pass, and direction = true (forward, left to right) on the second. If it is reverse complemented, we flip them.</p>
<p>This won't actually work in theory to get the optimal local alignment in all cases, but it works well in practice. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a76bd0589c6847bc786c320f5f5d841d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XdropAligner::XdropAligner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a605020a268ee52042da27755b773a155"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XdropAligner::XdropAligner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1XdropAligner.html">XdropAligner</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af8fca674950eef5af6a9a32aaafd17a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XdropAligner::XdropAligner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1XdropAligner.html">XdropAligner</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1821b31c8dcadd3e65f2b124bcd11495"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XdropAligner::XdropAligner </td>
          <td>(</td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>_match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>_mismatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>_gap_open</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>_gap_extension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>_full_length_bonus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>_max_gap_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acbb21351b30a05dc2ef1e2fd61086c6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XdropAligner::XdropAligner </td>
          <td>(</td>
          <td class="paramtype">int8_t const *&#160;</td>
          <td class="paramname"><em>_score_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>_gap_open</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>_gap_extension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>_full_length_bonus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>_max_gap_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaa342dfcc4afb1448b98857fd216044a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XdropAligner::~XdropAligner </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af88510100ea260d4810b3b08bc1b81c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XdropAligner::align </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> const &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse_complemented</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>align query: forward-backward banded alignment</p>
<p>Compute an alignment of the given <a class="el" href="structvg_1_1Alignment.html">Alignment</a>'s sequence against the given topologically sorted graph, using (one of) the given MEMs to seed the alignment.</p>
<p>reverse_complemented is true if the topologically sorted graph we have was reverse-complemented when extracted from a larger containing graph, and false if it is in the same orientation as it exists in the larger containing graph. The MEMs and the <a class="el" href="structvg_1_1Alignment.html">Alignment</a> are interpreted as being against the forward strand of the passed subgraph no matter the value of this setting.</p>
<p>reverse_complemented true means we will compute the alignment forward in the topologically-sorted order of the given graph (anchoring to the first node if no MEMs are provided) and false if we want to compute the alignment backward in the topological order (anchoring to the last node).</p>
<p>All the graph edges must go from earlier to later nodes, and from_start and to_end must alsways be false.</p>
<p>First the head (the most upstream) seed in MEMs is selected and extended downward to detect the downstream breakpoint. Next the alignment path is generated by second upward extension from the downstream breakpoint.</p>
<p>The MEM list may be empty. If MEMs are provided, uses only the begin, end, and nodes fields of the <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> objects. It uses the first occurrence of the last MEM if reverse_complemented is true, and the last occurrence of the first MEM otherwise. </p>

</div>
</div>
<a class="anchor" id="a35fafc08e131793d54902853e690b35e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XdropAligner::align </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Graph.html">Graph</a> const &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse_complemented</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of <a class="el" href="classvg_1_1XdropAligner.html#af88510100ea260d4810b3b08bc1b81c3">align()</a> that automatically wraps up a topologically-ordered Protobuf graph as an <a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a>. </p>

</div>
</div>
<a class="anchor" id="ae1d6a0e9ad28fb4fd2b20bf675b3c968"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XdropAligner::align_downward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> const &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1XdropAligner_1_1graph__pos__s.html">graph_pos_s</a> const &amp;&#160;</td>
          <td class="paramname"><em>head_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>left_to_right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>After doing the upward pass and finding head_pos to anchor from, do the downward alignment pass and traceback. If left_to_right is set, goes left to right and traces back the other way. If it is unset, goes right to left and traces back the other way. </p>

</div>
</div>
<a class="anchor" id="a43a30365d55a27e1952f3d53a446b55f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XdropAligner::align_pinned </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute a pinned alignment, where the start (pin_left=true) or end (pin_left=false) end of the <a class="el" href="structvg_1_1Alignment.html">Alignment</a> sequence is pinned to the start of the first (pin_left=true) or end of the last (pin_left=false) node in the graph's topological order.</p>
<p>Does not account for multiple sources/sinks in the topological order; whichever comes first/last ends up being used for the pin.</p>
<p>TODO: This should become const and the class should become thread safe. </p>

</div>
</div>
<a class="anchor" id="a8afbb0c40b9fbb9f454dfb79134769e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XdropAligner::align_pinned </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>topological_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classvg_1_1Version.html" title="Class for holding vg version and build environment information. ">Version</a> of align_pinned that allows you to pass your own topological order. The topological order MUST be left to right, no matter whether you are pinning left or right. If alignment needs to proceed backward, it will be reversed internally. TODO: This should become const and the class should become thread safe. </p>

</div>
</div>
<a class="anchor" id="a178bf539a4ba417825383caa88a3f5c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XdropAligner::build_id_index_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> const &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill in the id_to_index map. </p>

</div>
</div>
<a class="anchor" id="ab8e119c900c4b48b61f175fd9295cdba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XdropAligner::build_index_edge_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> const &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>seed_node_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>left_to_right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fill in index_edges and index_edges_head. Needs to know the index of the "seed node" in our graph's list of nodes, and the direction of the pass we are setting up for (false = right to left, true = left to right) </p>

</div>
</div>
<a class="anchor" id="a7a06127b2ab0a8166107b627a7d14bc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XdropAligner::calculate_and_save_alignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> const &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1XdropAligner_1_1graph__pos__s.html">graph_pos_s</a> const &amp;&#160;</td>
          <td class="paramname"><em>head_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tail_node_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>left_to_right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>After all the alignment work has been done, do the traceback and save into the given <a class="el" href="structvg_1_1Alignment.html">Alignment</a> object.</p>
<p>If left_to_right is true, the nodes were filled left to right, and the internal traceback will come out in left to right order, so we can emit it as is. If it is false, the nodes were filled right to left, and the internal traceback comes out in right to left order, so we need to flip it. </p>

</div>
</div>
<a class="anchor" id="a96e6c735c74c3de25c5e5d569c03bcc6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1XdropAligner_1_1graph__pos__s.html">XdropAligner::graph_pos_s</a> XdropAligner::calculate_max_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> const &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1XdropAligner_1_1graph__pos__s.html">graph_pos_s</a> const &amp;&#160;</td>
          <td class="paramname"><em>seed_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_node_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given the index of the node at which the winning score occurs, find the position in the node and read sequence at which the winning match is found. </p>

</div>
</div>
<a class="anchor" id="a9a3362e14abe865e343cf31617d4ff2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1XdropAligner_1_1graph__pos__s.html">XdropAligner::graph_pos_s</a> XdropAligner::calculate_seed_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> const &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>query_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given the subgraph we are aligning to, the MEM hist against it, the length of the query, and the direction we are aligning the query in (true = forward), select a single anchoring match between the graph and the query to align out from.</p>
<p>This replaces scan_seed_position for the case where we have MEMs. </p>

</div>
</div>
<a class="anchor" id="a65b498703a9e8e6a6d700a0fef8fb655"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t XdropAligner::extend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> const &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; uint64_t &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; uint64_t &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dz_query_s const *&#160;</td>
          <td class="paramname"><em>packed_query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed_node_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>seed_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>right_to_left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do alignment. Takes the graph, the sorted packed edges in ascending order for a forward pass or descending order for a reverse pass, the packed query sequence, the index of the seed node in the graph, the offset (TODO: in the read?) of the seed position, and the direction to traverse the graph topological order.</p>
<p>Note that we take our direction as right_to_left, whole many other functions take it as left_to_right.</p>
<p>If a MEM seed is provided, this is run in two passes. The first is left to right (right_to_left = false) if align did not have reverse_complement set and the second is right to left (right_to_left = true).</p>
<p>If we have no MEM seed, we only run one pass (the second one).</p>
<p>Returns the index in the topological order of the node with the highest scoring alignment.</p>
<p>Note that if no non-empty local alignment is found, it may not be safe to call dz_calc_max_qpos on the associated forefront! </p>

</div>
</div>
<a class="anchor" id="a2195a7231e605e9179f2de889ac71ec4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1XdropAligner.html">XdropAligner</a> &amp; XdropAligner::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1XdropAligner.html">XdropAligner</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa742262d1837a035f149a86bcf8fb9ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1XdropAligner.html">XdropAligner</a> &amp; XdropAligner::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1XdropAligner.html">XdropAligner</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0fdcf4192f3f5045ed4025f2a2dbe8f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t XdropAligner::push_edit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Mapping.html">Mapping</a> *&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>alt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Append an edit at the end of the current mapping array. Returns the length passed in. </p>

</div>
</div>
<a class="anchor" id="aa19f8fe7183fb6e7ec9807db8d472937"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1XdropAligner_1_1graph__pos__s.html">XdropAligner::graph_pos_s</a> XdropAligner::scan_seed_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1XdropAligner_1_1OrderedGraph.html">OrderedGraph</a> const &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>query_seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If no seeds are provided as alignment input, we need to compute our own starting anchor position. This function does that. Takes the topologically-sorted graph, the query sequence, and the direction. If direction is false, finds a seed hit on the first node of the graph. If it is true, finds a hit on the last node.</p>
<p>This replaces calculate_seed_position for the case where we have no MEMs. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a7b2ced8e428210e6cd9964a309486255"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int8_t vg::XdropAligner::aa_match</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5090116005c979770c34703c71c02beb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;bool (uint64_t const &amp;, uint64_t const &amp;)&gt; const vg::XdropAligner::compare[2]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">            [](uint64_t <span class="keyword">const</span> &amp;x, uint64_t <span class="keyword">const</span> &amp;y) -&gt; <span class="keywordtype">bool</span> { <span class="keywordflow">return</span>((int64_t)x &lt; (int64_t)y); },</div>
<div class="line">            [](uint64_t <span class="keyword">const</span> &amp;x, uint64_t <span class="keyword">const</span> &amp;y) -&gt; <span class="keywordtype">bool</span> { <span class="keywordflow">return</span>((int64_t)x &gt; (int64_t)y); }</div>
<div class="line">        }</div>
</div><!-- fragment --><p>Lookup table for forward- and reverse-sorting comparators, interpreting unsigned arguments as signed. Use [0] for forward and [1] for reverse (FIXME: can we embed them in the vtable?) </p>

</div>
</div>
<a class="anchor" id="a295e2d0944a90dc202bcb86e312e63bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dz_s* vg::XdropAligner::dz</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the backing dozeu library problem instance. </p>

</div>
</div>
<a class="anchor" id="abe8df6d7c151d4585cf01dc0d0962940"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;uint64_t (uint64_t const &amp;, uint64_t const &amp;)&gt; const vg::XdropAligner::edge[2]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">            [](uint64_t <span class="keyword">const</span> &amp;from, uint64_t <span class="keyword">const</span> &amp;to) -&gt; uint64_t { <span class="keywordflow">return</span>((to&lt;&lt;32) | from); },</div>
<div class="line">            [](uint64_t <span class="keyword">const</span> &amp;from, uint64_t <span class="keyword">const</span> &amp;to) -&gt; uint64_t { <span class="keywordflow">return</span>((from&lt;&lt;32) | to); }</div>
<div class="line">        }</div>
</div><!-- fragment --><p>Lookup table for functions to compose packed edge uint64_t values from the from and to indexes. Use [0] to put to in the high bits and [1] to put from in the high bits. TODO: When would you use either? </p>

</div>
</div>
<a class="anchor" id="ae3a4b6a0f8a31895f99ec6e59c2b732c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; struct dz_forefront_s const * &gt; vg::XdropAligner::forefronts</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores all of the currently outstanding dozeu library forefronts. </p>

</div>
</div>
<a class="anchor" id="a5f85612e0c2b4ce232f8459ab106da74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, uint64_t &gt; vg::XdropAligner::id_to_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps from node ID to the index in our internal subgraph storage at which that node occurs. </p>

</div>
</div>
<a class="anchor" id="ad9d341e5789910c47a7cfd32ae355de4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; vg::XdropAligner::index_edges</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List of edges. Stored as two int32_ts packed together. TODO: what is the order of packing? </p>

</div>
</div>
<a class="anchor" id="a1c2e62b98c5a0dce8b82722891267a17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; vg::XdropAligner::index_edges_head</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO: what is this? </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="xdrop__aligner_8hpp.html">xdrop_aligner.hpp</a></li>
<li>src/<a class="el" href="xdrop__aligner_8cpp.html">xdrop_aligner.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
