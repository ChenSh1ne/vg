<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>vg: vg::MinimizerMapper Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1MinimizerMapper.html">MinimizerMapper</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classvg_1_1MinimizerMapper-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::MinimizerMapper Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;minimizer_mapper.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vg::MinimizerMapper:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvg_1_1MinimizerMapper.png" usemap="#vg::MinimizerMapper_map" alt=""/>
  <map id="vg::MinimizerMapper_map" name="vg::MinimizerMapper_map">
<area href="classvg_1_1AlignerClient.html" alt="vg::AlignerClient" shape="rect" coords="0,0,130,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afce88fac5fbe020aee8a25a6fbcad381"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#afce88fac5fbe020aee8a25a6fbcad381">MinimizerMapper</a> (const <a class="el" href="classvg_1_1GBWTGraph.html">GBWTGraph</a> &amp;graph, const <a class="el" href="classvg_1_1MinimizerIndex.html">MinimizerIndex</a> &amp;<a class="el" href="classvg_1_1MinimizerMapper.html#a00be60a396f249bf93c8bf1f6cf4b11f">minimizer_index</a>, <a class="el" href="classvg_1_1MinimumDistanceIndex.html">MinimumDistanceIndex</a> &amp;<a class="el" href="classvg_1_1MinimizerMapper.html#aad418f42dd9ed77cd6b09743ebae634b">distance_index</a>, const <a class="el" href="classvg_1_1XG.html">XG</a> *<a class="el" href="classvg_1_1MinimizerMapper.html#a20bdb7e45cbd732d12f9da49832a5ba9">xg_index</a>=nullptr)</td></tr>
<tr class="separator:afce88fac5fbe020aee8a25a6fbcad381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c955e7607a1c07d2ca2b22a065e8b91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a4c955e7607a1c07d2ca2b22a065e8b91">map</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, <a class="el" href="classvg_1_1AlignmentEmitter.html">AlignmentEmitter</a> &amp;alignment_emitter)</td></tr>
<tr class="separator:a4c955e7607a1c07d2ca2b22a065e8b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvg_1_1AlignerClient"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classvg_1_1AlignerClient')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvg_1_1AlignerClient.html">vg::AlignerClient</a></td></tr>
<tr class="memitem:a0ea937755e15062c023d1b97d61814d4 inherit pub_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a0ea937755e15062c023d1b97d61814d4">set_alignment_scores</a> (int8_t match, int8_t mismatch, int8_t gap_open, int8_t gap_extend, int8_t full_length_bonus, uint32_t xdrop_max_gap_length=default_xdrop_max_gap_length)</td></tr>
<tr class="memdesc:a0ea937755e15062c023d1b97d61814d4 inherit pub_methods_classvg_1_1AlignerClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the aligner scoring parameters and create the stored aligner instances.  <a href="#a0ea937755e15062c023d1b97d61814d4">More...</a><br/></td></tr>
<tr class="separator:a0ea937755e15062c023d1b97d61814d4 inherit pub_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef1e755d0886e16328eb9818ae31fb2 inherit pub_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a2ef1e755d0886e16328eb9818ae31fb2">load_scoring_matrix</a> (std::ifstream &amp;matrix_stream)</td></tr>
<tr class="memdesc:a2ef1e755d0886e16328eb9818ae31fb2 inherit pub_methods_classvg_1_1AlignerClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a scoring amtrix from a file to set scores.  <a href="#a2ef1e755d0886e16328eb9818ae31fb2">More...</a><br/></td></tr>
<tr class="separator:a2ef1e755d0886e16328eb9818ae31fb2 inherit pub_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a1097206776713f059fca80f221b8478c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a1097206776713f059fca80f221b8478c">hit_cap</a> = 10</td></tr>
<tr class="memdesc:a1097206776713f059fca80f221b8478c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use all minimizers with at most hit_cap hits.  <a href="#a1097206776713f059fca80f221b8478c">More...</a><br/></td></tr>
<tr class="separator:a1097206776713f059fca80f221b8478c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf577b72776f431ec4dc5faac505322e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#aaf577b72776f431ec4dc5faac505322e">hard_hit_cap</a> = 300</td></tr>
<tr class="memdesc:aaf577b72776f431ec4dc5faac505322e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ignore all minimizers with more than hard_hit_cap hits.  <a href="#aaf577b72776f431ec4dc5faac505322e">More...</a><br/></td></tr>
<tr class="separator:aaf577b72776f431ec4dc5faac505322e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5696bfb7029ca88ec04d0f849365b34f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a5696bfb7029ca88ec04d0f849365b34f">minimizer_score_fraction</a> = 0.6</td></tr>
<tr class="separator:a5696bfb7029ca88ec04d0f849365b34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d03747a37700e9a3f73c308709f70d1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a5d03747a37700e9a3f73c308709f70d1">max_extensions</a> = 48</td></tr>
<tr class="memdesc:a5d03747a37700e9a3f73c308709f70d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many clusters should we align?  <a href="#a5d03747a37700e9a3f73c308709f70d1">More...</a><br/></td></tr>
<tr class="separator:a5d03747a37700e9a3f73c308709f70d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6062b78a7f795cb2a585eb6695bde675"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a6062b78a7f795cb2a585eb6695bde675">max_alignments</a> = 8</td></tr>
<tr class="memdesc:a6062b78a7f795cb2a585eb6695bde675"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many extended clusters should we align, max?  <a href="#a6062b78a7f795cb2a585eb6695bde675">More...</a><br/></td></tr>
<tr class="separator:a6062b78a7f795cb2a585eb6695bde675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10276fc66be2c41c2ebebd78e1f643de"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a10276fc66be2c41c2ebebd78e1f643de">cluster_score_threshold</a> = 0</td></tr>
<tr class="separator:a10276fc66be2c41c2ebebd78e1f643de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa953562a49de5befd8c80ee5e84a22"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a4aa953562a49de5befd8c80ee5e84a22">cluster_coverage_threshold</a> = 0</td></tr>
<tr class="separator:a4aa953562a49de5befd8c80ee5e84a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47b8ebb0479d86727c97e37e7f103ee"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#ac47b8ebb0479d86727c97e37e7f103ee">extension_set_score_threshold</a> = 0</td></tr>
<tr class="separator:ac47b8ebb0479d86727c97e37e7f103ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeff081b3c6a83ddfa7f620245b61fd0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#adeff081b3c6a83ddfa7f620245b61fd0">extension_score_threshold</a> = 0</td></tr>
<tr class="separator:adeff081b3c6a83ddfa7f620245b61fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede601962425752ec75ea1d890505357"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#aede601962425752ec75ea1d890505357">max_multimaps</a> = 1</td></tr>
<tr class="separator:aede601962425752ec75ea1d890505357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa22653d0c63a1d7bf41946f6f62a55"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a2fa22653d0c63a1d7bf41946f6f62a55">distance_limit</a> = 1000</td></tr>
<tr class="separator:a2fa22653d0c63a1d7bf41946f6f62a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb4c5e6e9502672709279b01f94cdef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#accb4c5e6e9502672709279b01f94cdef">do_chaining</a> = true</td></tr>
<tr class="separator:accb4c5e6e9502672709279b01f94cdef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583ee4f255d6e36f6cf9daf3ced05f0a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a583ee4f255d6e36f6cf9daf3ced05f0a">max_tails</a> = numeric_limits&lt;size_t&gt;::max()</td></tr>
<tr class="separator:a583ee4f255d6e36f6cf9daf3ced05f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9901414b3a22bd6fd53c5dca315f8ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#ab9901414b3a22bd6fd53c5dca315f8ff">use_xdrop_for_tails</a> = false</td></tr>
<tr class="separator:ab9901414b3a22bd6fd53c5dca315f8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d44e02a4cbbad030a22355239db61d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a88d44e02a4cbbad030a22355239db61d">linear_tails</a> = false</td></tr>
<tr class="separator:a88d44e02a4cbbad030a22355239db61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f47382b14baf0482c43034e6484d086"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a2f47382b14baf0482c43034e6484d086">sample_name</a></td></tr>
<tr class="separator:a2f47382b14baf0482c43034e6484d086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3e4b7c4e777da6c09f70218481e3d6"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#aee3e4b7c4e777da6c09f70218481e3d6">read_group</a></td></tr>
<tr class="separator:aee3e4b7c4e777da6c09f70218481e3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classvg_1_1AlignerClient"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classvg_1_1AlignerClient')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classvg_1_1AlignerClient.html">vg::AlignerClient</a></td></tr>
<tr class="memitem:a25db3953c246e94a7e08ef59fc31b82f inherit pub_attribs_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a25db3953c246e94a7e08ef59fc31b82f">adjust_alignments_for_base_quality</a> = false</td></tr>
<tr class="separator:a25db3953c246e94a7e08ef59fc31b82f inherit pub_attribs_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:af12f40d8ae25f153fba1dc122fda29f0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#af12f40d8ae25f153fba1dc122fda29f0">ImmutablePath</a> = structures::ImmutableList&lt; <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &gt;</td></tr>
<tr class="separator:af12f40d8ae25f153fba1dc122fda29f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6a485aa968767c54bc47fdff11bcdd76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a6a485aa968767c54bc47fdff11bcdd76">estimate_extension_group_score</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, vector&lt; <a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &gt; &amp;extended_seeds) const </td></tr>
<tr class="separator:a6a485aa968767c54bc47fdff11bcdd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45beb55a9535a9b986506a48703613c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a45beb55a9535a9b986506a48703613c9">score_is_significant</a> (int score_estimate, int best_score, int second_best_score) const </td></tr>
<tr class="separator:a45beb55a9535a9b986506a48703613c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952aab4d7843370b147ddc0617e0b5fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a952aab4d7843370b147ddc0617e0b5fd">chain_extended_seeds</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const vector&lt; <a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &gt; &amp;extended_seeds, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;out) const </td></tr>
<tr class="separator:a952aab4d7843370b147ddc0617e0b5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31fd702d8518308e0cf1f91ed816128"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#ad31fd702d8518308e0cf1f91ed816128">align_to_local_haplotypes</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const vector&lt; <a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &gt; &amp;extended_seeds, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;out) const </td></tr>
<tr class="separator:ad31fd702d8518308e0cf1f91ed816128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6045a66e4c271c4901ad9e539d01a1d6"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; size_t, <br class="typebreak"/>
unordered_map&lt; size_t, vector<br class="typebreak"/>
&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a6045a66e4c271c4901ad9e539d01a1d6">find_connecting_paths</a> (const vector&lt; <a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &gt; &amp;extended_seeds, size_t read_length) const </td></tr>
<tr class="separator:a6045a66e4c271c4901ad9e539d01a1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6afa809e098aaa9ab1bf6064e1431f72"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; size_t, vector<br class="typebreak"/>
&lt; <a class="el" href="classvg_1_1TreeSubgraph.html">TreeSubgraph</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a6afa809e098aaa9ab1bf6064e1431f72">get_tail_forests</a> (const vector&lt; <a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &gt; &amp;extended_seeds, size_t read_length, const unordered_map&lt; size_t, unordered_map&lt; size_t, vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt;&gt;&gt; &amp;connecting_paths, bool left_tails) const </td></tr>
<tr class="separator:a6afa809e098aaa9ab1bf6064e1431f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a9a311f5dad119ef8402e49a90830a"><td class="memItemLeft" align="right" valign="top">pair&lt; <a class="el" href="structvg_1_1Path.html">Path</a>, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a51a9a311f5dad119ef8402e49a90830a">get_best_alignment_against_any_path</a> (const vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;paths, const string &amp;sequence, const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;default_position, bool pinned, bool pin_left) const </td></tr>
<tr class="separator:a51a9a311f5dad119ef8402e49a90830a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf968bd30104207da51aaf9819345af7"><td class="memItemLeft" align="right" valign="top">pair&lt; <a class="el" href="structvg_1_1Path.html">Path</a>, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#aaf968bd30104207da51aaf9819345af7">get_best_alignment_against_any_tree</a> (const vector&lt; <a class="el" href="classvg_1_1TreeSubgraph.html">TreeSubgraph</a> &gt; &amp;trees, const string &amp;sequence, const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;default_position, bool pin_left) const </td></tr>
<tr class="separator:aaf968bd30104207da51aaf9819345af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b209592e4ed47ebb5aecd7ce90223c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a47b209592e4ed47ebb5aecd7ce90223c">explore_gbwt</a> (const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;from, size_t walk_distance, const function&lt; bool(const <a class="el" href="classvg_1_1MinimizerMapper.html#af12f40d8ae25f153fba1dc122fda29f0">ImmutablePath</a> &amp;, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;visit_callback, const function&lt; void(const <a class="el" href="classvg_1_1MinimizerMapper.html#af12f40d8ae25f153fba1dc122fda29f0">ImmutablePath</a> &amp;)&gt; &amp;limit_callback) const </td></tr>
<tr class="separator:a47b209592e4ed47ebb5aecd7ce90223c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9803c198d32e264857c4f8a549c3202d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a9803c198d32e264857c4f8a549c3202d">explore_gbwt</a> (<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> from_handle, size_t from_offset, size_t walk_distance, const function&lt; bool(const <a class="el" href="classvg_1_1MinimizerMapper.html#af12f40d8ae25f153fba1dc122fda29f0">ImmutablePath</a> &amp;, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;visit_callback, const function&lt; void(const <a class="el" href="classvg_1_1MinimizerMapper.html#af12f40d8ae25f153fba1dc122fda29f0">ImmutablePath</a> &amp;)&gt; &amp;limit_callback) const </td></tr>
<tr class="separator:a9803c198d32e264857c4f8a549c3202d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efadba4b15b8f3e5d6ae1279387f529"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a5efadba4b15b8f3e5d6ae1279387f529">dfs_gbwt</a> (const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;from, size_t walk_distance, const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;enter_handle, const function&lt; void(void)&gt; exit_handle) const </td></tr>
<tr class="separator:a5efadba4b15b8f3e5d6ae1279387f529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5978f5b80bc43ea763209eabc48382"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#acd5978f5b80bc43ea763209eabc48382">dfs_gbwt</a> (<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> from_handle, size_t from_offset, size_t walk_distance, const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;enter_handle, const function&lt; void(void)&gt; exit_handle) const </td></tr>
<tr class="separator:acd5978f5b80bc43ea763209eabc48382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classvg_1_1AlignerClient"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classvg_1_1AlignerClient')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classvg_1_1AlignerClient.html">vg::AlignerClient</a></td></tr>
<tr class="memitem:ab180631766b1e787e29dd202ad455d90 inherit pro_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#ab180631766b1e787e29dd202ad455d90">AlignerClient</a> (double <a class="el" href="classvg_1_1AlignerClient.html#a65428f092aaa5d894b709e247cf0121a">gc_content_estimate</a>=vg::default_gc_content)</td></tr>
<tr class="separator:ab180631766b1e787e29dd202ad455d90 inherit pro_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e0c82ed9c61de1dfa7c45d62ac1af3 inherit pro_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a74e0c82ed9c61de1dfa7c45d62ac1af3">get_aligner</a> (bool have_qualities=true) const </td></tr>
<tr class="separator:a74e0c82ed9c61de1dfa7c45d62ac1af3 inherit pro_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39bc1b46f1ee4eb34fea4a207b5649e inherit pro_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#ac39bc1b46f1ee4eb34fea4a207b5649e">get_qual_adj_aligner</a> () const </td></tr>
<tr class="separator:ac39bc1b46f1ee4eb34fea4a207b5649e inherit pro_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fe6d0c3f92c5f69baed5790675725f inherit pro_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#af2fe6d0c3f92c5f69baed5790675725f">get_regular_aligner</a> () const </td></tr>
<tr class="separator:af2fe6d0c3f92c5f69baed5790675725f inherit pro_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ab3008803e2ce57d5bbcd6a077f9dcde6"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#ab3008803e2ce57d5bbcd6a077f9dcde6">immutable_path_from_length</a> (const <a class="el" href="classvg_1_1MinimizerMapper.html#af12f40d8ae25f153fba1dc122fda29f0">ImmutablePath</a> &amp;path)</td></tr>
<tr class="separator:ab3008803e2ce57d5bbcd6a077f9dcde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1565adcd1bdf28aca55134d7482b1af"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structvg_1_1Path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#ae1565adcd1bdf28aca55134d7482b1af">to_path</a> (const <a class="el" href="classvg_1_1MinimizerMapper.html#af12f40d8ae25f153fba1dc122fda29f0">ImmutablePath</a> &amp;path)</td></tr>
<tr class="separator:ae1565adcd1bdf28aca55134d7482b1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a20bdb7e45cbd732d12f9da49832a5ba9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1XG.html">XG</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a20bdb7e45cbd732d12f9da49832a5ba9">xg_index</a></td></tr>
<tr class="separator:a20bdb7e45cbd732d12f9da49832a5ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00be60a396f249bf93c8bf1f6cf4b11f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1MinimizerIndex.html">MinimizerIndex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a00be60a396f249bf93c8bf1f6cf4b11f">minimizer_index</a></td></tr>
<tr class="separator:a00be60a396f249bf93c8bf1f6cf4b11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad418f42dd9ed77cd6b09743ebae634b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1MinimumDistanceIndex.html">MinimumDistanceIndex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#aad418f42dd9ed77cd6b09743ebae634b">distance_index</a></td></tr>
<tr class="separator:aad418f42dd9ed77cd6b09743ebae634b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f28c1dd49f9dce56c03be6b0e8194a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1GBWTGraph.html">GBWTGraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#aa2f28c1dd49f9dce56c03be6b0e8194a">gbwt_graph</a></td></tr>
<tr class="memdesc:aa2f28c1dd49f9dce56c03be6b0e8194a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is our primary graph.  <a href="#aa2f28c1dd49f9dce56c03be6b0e8194a">More...</a><br/></td></tr>
<tr class="separator:aa2f28c1dd49f9dce56c03be6b0e8194a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7384299b6fd570ee8454c6f74c7a6583"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1GaplessExtender.html">GaplessExtender</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a7384299b6fd570ee8454c6f74c7a6583">extender</a></td></tr>
<tr class="memdesc:a7384299b6fd570ee8454c6f74c7a6583"><td class="mdescLeft">&#160;</td><td class="mdescRight">We have a gapless extender to extend seed hits in haplotype space.  <a href="#a7384299b6fd570ee8454c6f74c7a6583">More...</a><br/></td></tr>
<tr class="separator:a7384299b6fd570ee8454c6f74c7a6583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2420d8771bcc824f7e7d36dbe4531fcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1SnarlSeedClusterer.html">SnarlSeedClusterer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a2420d8771bcc824f7e7d36dbe4531fcf">clusterer</a></td></tr>
<tr class="memdesc:a2420d8771bcc824f7e7d36dbe4531fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">We have a clusterer.  <a href="#a2420d8771bcc824f7e7d36dbe4531fcf">More...</a><br/></td></tr>
<tr class="separator:a2420d8771bcc824f7e7d36dbe4531fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="af12f40d8ae25f153fba1dc122fda29f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvg_1_1MinimizerMapper.html#af12f40d8ae25f153fba1dc122fda29f0">vg::MinimizerMapper::ImmutablePath</a> =  structures::ImmutableList&lt;<a class="el" href="structvg_1_1Mapping.html">Mapping</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>We define a type for shared-tail lists of Mappings, to avoid constantly copying <a class="el" href="structvg_1_1Path.html">Path</a> objects. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="afce88fac5fbe020aee8a25a6fbcad381"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::MinimizerMapper::MinimizerMapper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1GBWTGraph.html">GBWTGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1MinimizerIndex.html">MinimizerIndex</a> &amp;&#160;</td>
          <td class="paramname"><em>minimizer_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1MinimumDistanceIndex.html">MinimumDistanceIndex</a> &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1XG.html">XG</a> *&#160;</td>
          <td class="paramname"><em>xg_index</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a new <a class="el" href="classvg_1_1MinimizerMapper.html">MinimizerMapper</a> using the given indexes. The <a class="el" href="classvg_1_1XG.html">XG</a> index can be nullptr, as we only use it for correctness tracking. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad31fd702d8518308e0cf1f91ed816128"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MinimizerMapper::align_to_local_haplotypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>extended_seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Operating on the given input alignment, extract the haplotypes around the given extended perfect-match seeds and produce the best haplotype-consistent alignment into the given output <a class="el" href="structvg_1_1Alignment.html">Alignment</a> object. </p>

</div>
</div>
<a class="anchor" id="a952aab4d7843370b147ddc0617e0b5fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MinimizerMapper::chain_extended_seeds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>extended_seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Operating on the given input alignment, chain together the given extended perfect-match seeds and produce an alignment into the given output <a class="el" href="structvg_1_1Alignment.html">Alignment</a> object.</p>
<p>Returns true if successful, or false if too much DP work would be involved and a fallback approach should be used. </p>

</div>
</div>
<a class="anchor" id="a5efadba4b15b8f3e5d6ae1279387f529"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MinimizerMapper::dfs_gbwt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>walk_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>enter_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(void)&gt;&#160;</td>
          <td class="paramname"><em>exit_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Run a DFS on valid haplotypes in the GBWT starting from the given <a class="el" href="structvg_1_1Position.html">Position</a>, and continuing up to the given number of bases.</p>
<p>Calls enter_handle when the DFS enters a haplotype visit to a particular handle, and exit_handle when it exits a visit. These let the caller maintain a stack and track the traversals.</p>
<p>The starting node is only entered if its offset isn't equal to its length (i.e. bases remain to be visited).</p>
<p>Stopping early is not permitted. </p>

</div>
</div>
<a class="anchor" id="acd5978f5b80bc43ea763209eabc48382"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MinimizerMapper::dfs_gbwt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>from_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>from_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>walk_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>enter_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(void)&gt;&#160;</td>
          <td class="paramname"><em>exit_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The same as dfs_gbwt on a <a class="el" href="structvg_1_1Position.html">Position</a>, but takes a handle in the backing gbwt_graph and an offset from the start of the handle instead. </p>

</div>
</div>
<a class="anchor" id="a6a485aa968767c54bc47fdff11bcdd76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int vg::MinimizerMapper::estimate_extension_group_score </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>extended_seeds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Estimate the score it may be possible to achieve using the given group of GaplessExtensions. Supports single full-length extensions and groups that need chaining. May reorder the input extended_seeds vector if it is not sorted in read space. Is not always an overestimate of the actual score. </p>

</div>
</div>
<a class="anchor" id="a47b209592e4ed47ebb5aecd7ce90223c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MinimizerMapper::explore_gbwt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>walk_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(const <a class="el" href="classvg_1_1MinimizerMapper.html#af12f40d8ae25f153fba1dc122fda29f0">ImmutablePath</a> &amp;, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>visit_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="classvg_1_1MinimizerMapper.html#af12f40d8ae25f153fba1dc122fda29f0">ImmutablePath</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>limit_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a <a class="el" href="structvg_1_1Position.html">Position</a>, explore the GBWT graph out to the given maximum walk distance.</p>
<p>Calls the visit callback with the list of Mappings being extended (in reverse order) and the handle it is being extended with.</p>
<p>Only considers paths that visit at least one node after the node the from <a class="el" href="structvg_1_1Position.html">Position</a> is on. The from <a class="el" href="structvg_1_1Position.html">Position</a> cuts immediately before the first included base.</p>
<p>If the callback returns false, that GBWT search state is not extended further.</p>
<p>If the walk_distance limit is exceeded, or a dead end in the graph is hit, calls the limit callback with the list of Mappings (in reverse order) that passed the limit or hit the dead end. </p>

</div>
</div>
<a class="anchor" id="a9803c198d32e264857c4f8a549c3202d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MinimizerMapper::explore_gbwt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>from_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>from_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>walk_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(const <a class="el" href="classvg_1_1MinimizerMapper.html#af12f40d8ae25f153fba1dc122fda29f0">ImmutablePath</a> &amp;, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>visit_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="classvg_1_1MinimizerMapper.html#af12f40d8ae25f153fba1dc122fda29f0">ImmutablePath</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>limit_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The same as explore_gbwt on a <a class="el" href="structvg_1_1Position.html">Position</a>, but takes a handle in the backing gbwt_graph and an offset from the start of the handle instead. </p>

</div>
</div>
<a class="anchor" id="a6045a66e4c271c4901ad9e539d01a1d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; size_t, unordered_map&lt; size_t, vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &gt; &gt; vg::MinimizerMapper::find_connecting_paths </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>extended_seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>read_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find for each pair of extended seeds all the haplotype-consistent graph paths against which the intervening read sequence needs to be aligned.</p>
<p>Limits walks from each extended seed end to the longest detectable gap plus the remaining to-be-alinged sequence, both computed using the read length.</p>
<p>extended_seeds must be sorted by read start position. Any extended seeds that overlap in the read will be precluded from connecting.</p>
<p>numeric_limits&lt;size_t&gt;::max() is used to store sufficiently long <a class="el" href="classvg_1_1Paths.html">Paths</a> ending before sources (which cannot be reached from other extended seeds) and starting after sinks (which cannot reach any other extended seeds). Only sources and sinks have these "tail" paths.</p>
<p>Tail paths are only calculated if the <a class="el" href="classvg_1_1MinimizerMapper.html">MinimizerMapper</a> has linear_tails set to true. </p>

</div>
</div>
<a class="anchor" id="a51a9a311f5dad119ef8402e49a90830a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="structvg_1_1Path.html">Path</a>, size_t &gt; vg::MinimizerMapper::get_best_alignment_against_any_path </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>default_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find the best alignment of the given sequence against any of the paths defined in paths.</p>
<p>If no mapping is possible, produce a pure insert at default_position.</p>
<p>If pinned is true, pin the alignment on one end to the start or end of each path.</p>
<p>When pinning, if pin_left is true, pin it on the left to the start of each path. Otherwise pin it on the right to the end.</p>
<p>Returns alingments in gbwt_graph space. </p>

</div>
</div>
<a class="anchor" id="aaf968bd30104207da51aaf9819345af7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="structvg_1_1Path.html">Path</a>, size_t &gt; vg::MinimizerMapper::get_best_alignment_against_any_tree </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1TreeSubgraph.html">TreeSubgraph</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>trees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>default_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find the best alignment of the given sequence against any of the trees provided in trees, where each tree is a <a class="el" href="classvg_1_1TreeSubgraph.html">TreeSubgraph</a> over the GBWT graph. Each tree subgraph is rooted at the left in its own local coordinate space, even if we are pinning on the right.</p>
<p>If no mapping is possible (for example, because there are no trees), produce a pure insert at default_position.</p>
<p><a class="el" href="structvg_1_1Alignment.html">Alignment</a> is always pinned.</p>
<p>If pin_left is true, pin the alignment on the left to the root of each tree. Otherwise pin it on the right to the root of each tree.</p>
<p>Returns alingments in gbwt_graph space. </p>

</div>
</div>
<a class="anchor" id="a6afa809e098aaa9ab1bf6064e1431f72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; size_t, vector&lt; <a class="el" href="classvg_1_1TreeSubgraph.html">TreeSubgraph</a> &gt; &gt; vg::MinimizerMapper::get_tail_forests </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>extended_seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>read_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; size_t, unordered_map&lt; size_t, vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>connecting_paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>left_tails</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For gapless extensions that can't reach/be reached by anything in connecting_paths, get all the trees defining tails off the specified side of the gapless extension. Assumes that connecting_paths contains no tail entries itself (i.e. that linear_tails was false on the <a class="el" href="classvg_1_1MinimizerMapper.html">MinimizerMapper</a> when find_connecting_paths computed it), but uses it to identify the source or sink extensions.</p>
<p>If the gapless extension starts or ends at a node boundary, there may be multiple trees produced, each with a distinct root.</p>
<p>If the gapless extension abuts the edge of the read, no forests will be produced for it.</p>
<p>Each tree is represented as a <a class="el" href="classvg_1_1TreeSubgraph.html">TreeSubgraph</a> over our gbwt_graph.</p>
<p>If left_tails is true, the trees read out of the left sides of the gapless extensions. Otherwise they read out of the right sides.</p>
<p>Gapless extensions that are not sources or sinks get no map entries. Gapless extensions with dangling read sequence but no viable paths in the graph will at least get map entries with empty forests. Sources or sinks with no dangling sequence don't necessarily get map entries at all. </p>

</div>
</div>
<a class="anchor" id="ab3008803e2ce57d5bbcd6a077f9dcde6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MinimizerMapper::immutable_path_from_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1MinimizerMapper.html#af12f40d8ae25f153fba1dc122fda29f0">ImmutablePath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the from length of an ImmutabelPath.</p>
<p>Can't be called path_from_length or it will shadow the one for <a class="el" href="classvg_1_1Paths.html">Paths</a> instead of overloading. </p>

</div>
</div>
<a class="anchor" id="a4c955e7607a1c07d2ca2b22a065e8b91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MinimizerMapper::map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1AlignmentEmitter.html">AlignmentEmitter</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment_emitter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map the given read, and send output to the given <a class="el" href="classvg_1_1AlignmentEmitter.html">AlignmentEmitter</a>. May be run from any thread. TODO: Can't be const because the clusterer's cluster_seeds isn't const. </p>

</div>
</div>
<a class="anchor" id="a45beb55a9535a9b986506a48703613c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MinimizerMapper::score_is_significant </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>score_estimate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>best_score</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>second_best_score</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine if a score estimate is significant enough to justify computing the real <a class="el" href="structvg_1_1Alignment.html">Alignment</a>. Returns true if it might win or affect mapping quality, and false otherwise. </p>

</div>
</div>
<a class="anchor" id="ae1565adcd1bdf28aca55134d7482b1af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> vg::MinimizerMapper::to_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1MinimizerMapper.html#af12f40d8ae25f153fba1dc122fda29f0">ImmutablePath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert an ImmutablePath to a <a class="el" href="structvg_1_1Path.html">Path</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a4aa953562a49de5befd8c80ee5e84a22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::MinimizerMapper::cluster_coverage_threshold = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a10276fc66be2c41c2ebebd78e1f643de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::MinimizerMapper::cluster_score_threshold = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2420d8771bcc824f7e7d36dbe4531fcf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1SnarlSeedClusterer.html">SnarlSeedClusterer</a> vg::MinimizerMapper::clusterer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We have a clusterer. </p>

</div>
</div>
<a class="anchor" id="aad418f42dd9ed77cd6b09743ebae634b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1MinimumDistanceIndex.html">MinimumDistanceIndex</a>&amp; vg::MinimizerMapper::distance_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2fa22653d0c63a1d7bf41946f6f62a55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MinimizerMapper::distance_limit = 1000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="accb4c5e6e9502672709279b01f94cdef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MinimizerMapper::do_chaining = true</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7384299b6fd570ee8454c6f74c7a6583"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1GaplessExtender.html">GaplessExtender</a> vg::MinimizerMapper::extender</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We have a gapless extender to extend seed hits in haplotype space. </p>

</div>
</div>
<a class="anchor" id="adeff081b3c6a83ddfa7f620245b61fd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::MinimizerMapper::extension_score_threshold = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac47b8ebb0479d86727c97e37e7f103ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::MinimizerMapper::extension_set_score_threshold = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa2f28c1dd49f9dce56c03be6b0e8194a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvg_1_1GBWTGraph.html">GBWTGraph</a>&amp; vg::MinimizerMapper::gbwt_graph</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is our primary graph. </p>

</div>
</div>
<a class="anchor" id="aaf577b72776f431ec4dc5faac505322e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MinimizerMapper::hard_hit_cap = 300</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ignore all minimizers with more than hard_hit_cap hits. </p>

</div>
</div>
<a class="anchor" id="a1097206776713f059fca80f221b8478c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MinimizerMapper::hit_cap = 10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use all minimizers with at most hit_cap hits. </p>

</div>
</div>
<a class="anchor" id="a88d44e02a4cbbad030a22355239db61d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MinimizerMapper::linear_tails = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6062b78a7f795cb2a585eb6695bde675"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MinimizerMapper::max_alignments = 8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How many extended clusters should we align, max? </p>

</div>
</div>
<a class="anchor" id="a5d03747a37700e9a3f73c308709f70d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MinimizerMapper::max_extensions = 48</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How many clusters should we align? </p>

</div>
</div>
<a class="anchor" id="aede601962425752ec75ea1d890505357"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MinimizerMapper::max_multimaps = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a583ee4f255d6e36f6cf9daf3ced05f0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MinimizerMapper::max_tails = numeric_limits&lt;size_t&gt;::max()</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a00be60a396f249bf93c8bf1f6cf4b11f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvg_1_1MinimizerIndex.html">MinimizerIndex</a>&amp; vg::MinimizerMapper::minimizer_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5696bfb7029ca88ec04d0f849365b34f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::MinimizerMapper::minimizer_score_fraction = 0.6</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take minimizers between hit_cap and hard_hit_cap hits until this fraction of total score </p>

</div>
</div>
<a class="anchor" id="aee3e4b7c4e777da6c09f70218481e3d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::MinimizerMapper::read_group</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2f47382b14baf0482c43034e6484d086"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::MinimizerMapper::sample_name</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab9901414b3a22bd6fd53c5dca315f8ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MinimizerMapper::use_xdrop_for_tails = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a20bdb7e45cbd732d12f9da49832a5ba9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvg_1_1XG.html">XG</a>* vg::MinimizerMapper::xg_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="minimizer__mapper_8hpp.html">minimizer_mapper.hpp</a></li>
<li>src/<a class="el" href="minimizer__mapper_8cpp.html">minimizer_mapper.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
