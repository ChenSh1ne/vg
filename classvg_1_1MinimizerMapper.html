<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::MinimizerMapper Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1MinimizerMapper.html">MinimizerMapper</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classvg_1_1MinimizerMapper-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::MinimizerMapper Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;minimizer_mapper.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vg::MinimizerMapper:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvg_1_1MinimizerMapper.png" usemap="#vg::MinimizerMapper_map" alt=""/>
  <map id="vg::MinimizerMapper_map" name="vg::MinimizerMapper_map">
<area href="classvg_1_1AlignerClient.html" alt="vg::AlignerClient" shape="rect" coords="0,0,130,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1MinimizerMapper_1_1Minimizer.html">Minimizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4133862618010a5b1c54b1dd94732b21"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a4133862618010a5b1c54b1dd94732b21">MinimizerMapper</a> (const gbwtgraph::GBWTGraph &amp;graph, const std::vector&lt; gbwtgraph::DefaultMinimizerIndex *&gt; &amp;<a class="el" href="classvg_1_1MinimizerMapper.html#a8158d7661a52252dd77e2ec0dcaa1964">minimizer_indexes</a>, <a class="el" href="classvg_1_1MinimumDistanceIndex.html">MinimumDistanceIndex</a> &amp;<a class="el" href="classvg_1_1MinimizerMapper.html#aad418f42dd9ed77cd6b09743ebae634b">distance_index</a>, const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *<a class="el" href="classvg_1_1MinimizerMapper.html#aa75ca7504db85f1ba5d340b8213036de">path_graph</a>=nullptr)</td></tr>
<tr class="separator:a4133862618010a5b1c54b1dd94732b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c955e7607a1c07d2ca2b22a065e8b91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a4c955e7607a1c07d2ca2b22a065e8b91">map</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, <a class="el" href="classvg_1_1AlignmentEmitter.html">AlignmentEmitter</a> &amp;alignment_emitter)</td></tr>
<tr class="separator:a4c955e7607a1c07d2ca2b22a065e8b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182c026fcc4e3a8dea5de373d1a79bbb"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a182c026fcc4e3a8dea5de373d1a79bbb">map</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln)</td></tr>
<tr class="separator:a182c026fcc4e3a8dea5de373d1a79bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c90ef4f961998cc7904e78225b36f50"><td class="memItemLeft" align="right" valign="top">pair&lt; vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;, vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a5c90ef4f961998cc7904e78225b36f50">map_paired</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln1, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln2, vector&lt; pair&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a>, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&gt; &amp;ambiguous_pair_buffer)</td></tr>
<tr class="separator:a5c90ef4f961998cc7904e78225b36f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f4c707ec44ba8f742c79bb0153c157"><td class="memItemLeft" align="right" valign="top">pair&lt; vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;, vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#ab5f4c707ec44ba8f742c79bb0153c157">map_paired</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln1, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln2)</td></tr>
<tr class="separator:ab5f4c707ec44ba8f742c79bb0153c157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692470c7551c4966126aa7bf357e60a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a692470c7551c4966126aa7bf357e60a4">fragment_distr_is_finalized</a> ()</td></tr>
<tr class="separator:a692470c7551c4966126aa7bf357e60a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae627a418357792cd5b9f6d6b9cc19c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a4ae627a418357792cd5b9f6d6b9cc19c">finalize_fragment_length_distr</a> ()</td></tr>
<tr class="separator:a4ae627a418357792cd5b9f6d6b9cc19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9605b1ef714df2c8f07b7bcd4afd0882"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a9605b1ef714df2c8f07b7bcd4afd0882">attempt_rescue</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aligned_read, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;rescued_alignment, bool rescue_forward)</td></tr>
<tr class="separator:a9605b1ef714df2c8f07b7bcd4afd0882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac116853daed562fc9bbef6c55503d078"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#ac116853daed562fc9bbef6c55503d078">attempt_rescue_haplotypes</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aligned_read, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;rescued_alignment, bool rescue_forward)</td></tr>
<tr class="separator:ac116853daed562fc9bbef6c55503d078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68add551501e3b58c9329d9297d620d"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#ae68add551501e3b58c9329d9297d620d">distance_between</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln1, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln2)</td></tr>
<tr class="separator:ae68add551501e3b58c9329d9297d620d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvg_1_1AlignerClient"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classvg_1_1AlignerClient')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvg_1_1AlignerClient.html">vg::AlignerClient</a></td></tr>
<tr class="memitem:ab74784d7320b1c33c7bf6e75259d4cea inherit pub_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#ab74784d7320b1c33c7bf6e75259d4cea">set_alignment_scores</a> (int8_t match, int8_t mismatch, int8_t gap_open, int8_t gap_extend, int8_t full_length_bonus)</td></tr>
<tr class="memdesc:ab74784d7320b1c33c7bf6e75259d4cea inherit pub_methods_classvg_1_1AlignerClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the aligner scoring parameters and create the stored aligner instances.  <a href="classvg_1_1AlignerClient.html#ab74784d7320b1c33c7bf6e75259d4cea">More...</a><br /></td></tr>
<tr class="separator:ab74784d7320b1c33c7bf6e75259d4cea inherit pub_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5378f4e2b41a64a3bb51ba67e85d82bc inherit pub_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a5378f4e2b41a64a3bb51ba67e85d82bc">set_alignment_scores</a> (std::istream &amp;matrix_stream, int8_t gap_open, int8_t gap_extend, int8_t full_length_bonus)</td></tr>
<tr class="separator:a5378f4e2b41a64a3bb51ba67e85d82bc inherit pub_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51310b7599508c91bcf5dd5cb25a175 inherit pub_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#aa51310b7599508c91bcf5dd5cb25a175">set_alignment_scores</a> (const int8_t *score_matrix, int8_t gap_open, int8_t gap_extend, int8_t full_length_bonus)</td></tr>
<tr class="separator:aa51310b7599508c91bcf5dd5cb25a175 inherit pub_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a1097206776713f059fca80f221b8478c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a1097206776713f059fca80f221b8478c">hit_cap</a> = 10</td></tr>
<tr class="memdesc:a1097206776713f059fca80f221b8478c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use all minimizers with at most hit_cap hits.  <a href="#a1097206776713f059fca80f221b8478c">More...</a><br /></td></tr>
<tr class="separator:a1097206776713f059fca80f221b8478c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf577b72776f431ec4dc5faac505322e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#aaf577b72776f431ec4dc5faac505322e">hard_hit_cap</a> = 300</td></tr>
<tr class="memdesc:aaf577b72776f431ec4dc5faac505322e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ignore all minimizers with more than hard_hit_cap hits.  <a href="#aaf577b72776f431ec4dc5faac505322e">More...</a><br /></td></tr>
<tr class="separator:aaf577b72776f431ec4dc5faac505322e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5696bfb7029ca88ec04d0f849365b34f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a5696bfb7029ca88ec04d0f849365b34f">minimizer_score_fraction</a> = 0.6</td></tr>
<tr class="separator:a5696bfb7029ca88ec04d0f849365b34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d03747a37700e9a3f73c308709f70d1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a5d03747a37700e9a3f73c308709f70d1">max_extensions</a> = 48</td></tr>
<tr class="memdesc:a5d03747a37700e9a3f73c308709f70d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many clusters should we align?  <a href="#a5d03747a37700e9a3f73c308709f70d1">More...</a><br /></td></tr>
<tr class="separator:a5d03747a37700e9a3f73c308709f70d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6062b78a7f795cb2a585eb6695bde675"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a6062b78a7f795cb2a585eb6695bde675">max_alignments</a> = 8</td></tr>
<tr class="memdesc:a6062b78a7f795cb2a585eb6695bde675"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many extended clusters should we align, max?  <a href="#a6062b78a7f795cb2a585eb6695bde675">More...</a><br /></td></tr>
<tr class="separator:a6062b78a7f795cb2a585eb6695bde675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6142c1ccdde28230769e5a8b629d9f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a4e6142c1ccdde28230769e5a8b629d9f">max_local_extensions</a> = numeric_limits&lt;size_t&gt;::max()</td></tr>
<tr class="memdesc:a4e6142c1ccdde28230769e5a8b629d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many extensions should we try as seeds within a mapping location?  <a href="#a4e6142c1ccdde28230769e5a8b629d9f">More...</a><br /></td></tr>
<tr class="separator:a4e6142c1ccdde28230769e5a8b629d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10276fc66be2c41c2ebebd78e1f643de"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a10276fc66be2c41c2ebebd78e1f643de">cluster_score_threshold</a> = 50</td></tr>
<tr class="separator:a10276fc66be2c41c2ebebd78e1f643de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b206dc58a148a69657303ff292199f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a70b206dc58a148a69657303ff292199f">pad_cluster_score_threshold</a> = 20</td></tr>
<tr class="separator:a70b206dc58a148a69657303ff292199f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa953562a49de5befd8c80ee5e84a22"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a4aa953562a49de5befd8c80ee5e84a22">cluster_coverage_threshold</a> = 0.4</td></tr>
<tr class="separator:a4aa953562a49de5befd8c80ee5e84a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47b8ebb0479d86727c97e37e7f103ee"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#ac47b8ebb0479d86727c97e37e7f103ee">extension_set_score_threshold</a> = 20</td></tr>
<tr class="separator:ac47b8ebb0479d86727c97e37e7f103ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeff081b3c6a83ddfa7f620245b61fd0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#adeff081b3c6a83ddfa7f620245b61fd0">extension_score_threshold</a> = 1</td></tr>
<tr class="separator:adeff081b3c6a83ddfa7f620245b61fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede601962425752ec75ea1d890505357"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#aede601962425752ec75ea1d890505357">max_multimaps</a> = 1</td></tr>
<tr class="separator:aede601962425752ec75ea1d890505357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa22653d0c63a1d7bf41946f6f62a55"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a2fa22653d0c63a1d7bf41946f6f62a55">distance_limit</a> = 200</td></tr>
<tr class="separator:a2fa22653d0c63a1d7bf41946f6f62a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80efe32334434e2121f45d9683e2b53b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a80efe32334434e2121f45d9683e2b53b">do_dp</a> = true</td></tr>
<tr class="separator:a80efe32334434e2121f45d9683e2b53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f47382b14baf0482c43034e6484d086"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a2f47382b14baf0482c43034e6484d086">sample_name</a></td></tr>
<tr class="separator:a2f47382b14baf0482c43034e6484d086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3e4b7c4e777da6c09f70218481e3d6"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#aee3e4b7c4e777da6c09f70218481e3d6">read_group</a></td></tr>
<tr class="separator:aee3e4b7c4e777da6c09f70218481e3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeabec85347521c1f42ef51e0453c4e5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#aeabec85347521c1f42ef51e0453c4e5f">track_provenance</a> = false</td></tr>
<tr class="separator:aeabec85347521c1f42ef51e0453c4e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7896c6cccfa011c4fbad1b916d30052e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a7896c6cccfa011c4fbad1b916d30052e">track_correctness</a> = false</td></tr>
<tr class="separator:a7896c6cccfa011c4fbad1b916d30052e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0985bcf3a1ed28098bf0271b251dd6e2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a0985bcf3a1ed28098bf0271b251dd6e2">max_rescue_attempts</a> = 0</td></tr>
<tr class="separator:a0985bcf3a1ed28098bf0271b251dd6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classvg_1_1AlignerClient"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classvg_1_1AlignerClient')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classvg_1_1AlignerClient.html">vg::AlignerClient</a></td></tr>
<tr class="memitem:a25db3953c246e94a7e08ef59fc31b82f inherit pub_attribs_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a25db3953c246e94a7e08ef59fc31b82f">adjust_alignments_for_base_quality</a> = false</td></tr>
<tr class="separator:a25db3953c246e94a7e08ef59fc31b82f inherit pub_attribs_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a72644e4df554de0f0a2d3b50a9a3094a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structvg_1_1SnarlSeedClusterer_1_1Seed.html">SnarlSeedClusterer::Seed</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a72644e4df554de0f0a2d3b50a9a3094a">Seed</a></td></tr>
<tr class="memdesc:a72644e4df554de0f0a2d3b50a9a3094a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The information we store for each seed.  <a href="#a72644e4df554de0f0a2d3b50a9a3094a">More...</a><br /></td></tr>
<tr class="separator:a72644e4df554de0f0a2d3b50a9a3094a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339fbfcd026d074287148843b42c646d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structvg_1_1SnarlSeedClusterer_1_1Cluster.html">SnarlSeedClusterer::Cluster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a339fbfcd026d074287148843b42c646d">Cluster</a></td></tr>
<tr class="memdesc:a339fbfcd026d074287148843b42c646d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The information we store for each cluster.  <a href="#a339fbfcd026d074287148843b42c646d">More...</a><br /></td></tr>
<tr class="separator:a339fbfcd026d074287148843b42c646d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12f40d8ae25f153fba1dc122fda29f0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#af12f40d8ae25f153fba1dc122fda29f0">ImmutablePath</a> = structures::ImmutableList&lt; <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &gt;</td></tr>
<tr class="separator:af12f40d8ae25f153fba1dc122fda29f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af3e5c53b0250173b6d0eb097cf884986"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structvg_1_1MinimizerMapper_1_1Minimizer.html">Minimizer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#af3e5c53b0250173b6d0eb097cf884986">find_minimizers</a> (const std::string &amp;sequence, <a class="el" href="classvg_1_1Funnel.html">Funnel</a> &amp;funnel) const</td></tr>
<tr class="separator:af3e5c53b0250173b6d0eb097cf884986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e0a0ad996ae2011c90e2a6d6dd4b4a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classvg_1_1MinimizerMapper.html#a72644e4df554de0f0a2d3b50a9a3094a">Seed</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#ab9e0a0ad996ae2011c90e2a6d6dd4b4a">find_seeds</a> (const std::vector&lt; <a class="el" href="structvg_1_1MinimizerMapper_1_1Minimizer.html">Minimizer</a> &gt; &amp;minimizers, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, <a class="el" href="classvg_1_1Funnel.html">Funnel</a> &amp;funnel) const</td></tr>
<tr class="separator:ab9e0a0ad996ae2011c90e2a6d6dd4b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1559493a4faca3189a5dd18ea08f87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#aaa1559493a4faca3189a5dd18ea08f87">score_cluster</a> (<a class="el" href="classvg_1_1MinimizerMapper.html#a339fbfcd026d074287148843b42c646d">Cluster</a> &amp;cluster, size_t i, const std::vector&lt; <a class="el" href="structvg_1_1MinimizerMapper_1_1Minimizer.html">Minimizer</a> &gt; &amp;minimizers, const std::vector&lt; <a class="el" href="classvg_1_1MinimizerMapper.html#a72644e4df554de0f0a2d3b50a9a3094a">Seed</a> &gt; &amp;seeds, size_t seq_length, <a class="el" href="classvg_1_1Funnel.html">Funnel</a> &amp;funnel) const</td></tr>
<tr class="separator:aaa1559493a4faca3189a5dd18ea08f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ff5e0a1b8c7925ccdb8a23d29872ef"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#af9ff5e0a1b8c7925ccdb8a23d29872ef">score_extensions</a> (const std::vector&lt; std::vector&lt; <a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &gt;&gt; &amp;extensions, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, <a class="el" href="classvg_1_1Funnel.html">Funnel</a> &amp;funnel) const</td></tr>
<tr class="separator:af9ff5e0a1b8c7925ccdb8a23d29872ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421cdd65bac59fac39fd3b87cce0f3ae"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a421cdd65bac59fac39fd3b87cce0f3ae">score_extensions</a> (const std::vector&lt; std::pair&lt; std::vector&lt; <a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &gt;, size_t &gt;&gt; &amp;extensions, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, <a class="el" href="classvg_1_1Funnel.html">Funnel</a> &amp;funnel) const</td></tr>
<tr class="separator:a421cdd65bac59fac39fd3b87cce0f3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a67380a95608145839617f3a3193a6c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a0a67380a95608145839617f3a3193a6c">phred_for_at_least_one</a> (size_t p, size_t n) const</td></tr>
<tr class="separator:a0a67380a95608145839617f3a3193a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b20fa6da14da0a38f2bdfe21c3f67c9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a2b20fa6da14da0a38f2bdfe21c3f67c9">compute_mapq_caps</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const std::vector&lt; <a class="el" href="structvg_1_1MinimizerMapper_1_1Minimizer.html">Minimizer</a> &gt; &amp;minimizers, const sdsl::bit_vector &amp;present_in_any_extended_cluster)</td></tr>
<tr class="separator:a2b20fa6da14da0a38f2bdfe21c3f67c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19502481af491af1d623da3ed16a766"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#aa19502481af491af1d623da3ed16a766">window_breaking_quality</a> (const vector&lt; <a class="el" href="structvg_1_1MinimizerMapper_1_1Minimizer.html">Minimizer</a> &gt; &amp;minimizers, vector&lt; size_t &gt; &amp;broken, const string &amp;sequence, const string &amp;quality_bytes) const</td></tr>
<tr class="separator:aa19502481af491af1d623da3ed16a766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3ec6685f98622b35391ae0d8bac180"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a6e3ec6685f98622b35391ae0d8bac180">find_optimal_tail_alignments</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const vector&lt; <a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &gt; &amp;extended_seeds, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;best, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;second_best) const</td></tr>
<tr class="separator:a6e3ec6685f98622b35391ae0d8bac180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3256c8c0ebc49ff72af298684580fa4"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; size_t, unordered_map&lt; size_t, vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#ab3256c8c0ebc49ff72af298684580fa4">find_connecting_paths</a> (const vector&lt; <a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &gt; &amp;extended_seeds, size_t read_length) const</td></tr>
<tr class="separator:ab3256c8c0ebc49ff72af298684580fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ffe043bb4a0f598e0fe76f3f7ca301"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classvg_1_1TreeSubgraph.html">TreeSubgraph</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a52ffe043bb4a0f598e0fe76f3f7ca301">get_tail_forest</a> (const <a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &amp;extended_seed, size_t read_length, bool left_tails) const</td></tr>
<tr class="separator:a52ffe043bb4a0f598e0fe76f3f7ca301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5520caca736306020df277dc3293eec8"><td class="memItemLeft" align="right" valign="top">pair&lt; <a class="el" href="structvg_1_1Path.html">Path</a>, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a5520caca736306020df277dc3293eec8">get_best_alignment_against_any_tree</a> (const vector&lt; <a class="el" href="classvg_1_1TreeSubgraph.html">TreeSubgraph</a> &gt; &amp;trees, const string &amp;sequence, const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;default_position, bool pin_left) const</td></tr>
<tr class="separator:a5520caca736306020df277dc3293eec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4355a2ecfe99c02410f92093efc77ce4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a4355a2ecfe99c02410f92093efc77ce4">dfs_gbwt</a> (const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;from, size_t walk_distance, const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;enter_handle, const function&lt; void(void)&gt; exit_handle) const</td></tr>
<tr class="separator:a4355a2ecfe99c02410f92093efc77ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657e584de6e57a3f6f15616f245e39ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a657e584de6e57a3f6f15616f245e39ef">dfs_gbwt</a> (<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> from_handle, size_t from_offset, size_t walk_distance, const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;enter_handle, const function&lt; void(void)&gt; exit_handle) const</td></tr>
<tr class="separator:a657e584de6e57a3f6f15616f245e39ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759504362bfa77a4eb8428e1b2be1ccf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a759504362bfa77a4eb8428e1b2be1ccf">dfs_gbwt</a> (const gbwt::SearchState &amp;start_state, size_t from_offset, size_t walk_distance, const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;enter_handle, const function&lt; void(void)&gt; exit_handle) const</td></tr>
<tr class="separator:a759504362bfa77a4eb8428e1b2be1ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7aa198a608d38eda2d3c593416b7849"><td class="memTemplParams" colspan="2">template&lt;typename Item , typename Score  = double&gt; </td></tr>
<tr class="memitem:ab7aa198a608d38eda2d3c593416b7849"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#ab7aa198a608d38eda2d3c593416b7849">process_until_threshold_a</a> (const vector&lt; Item &gt; &amp;items, const function&lt; Score(size_t)&gt; &amp;get_score, double threshold, size_t min_count, size_t max_count, const function&lt; bool(size_t)&gt; &amp;process_item, const function&lt; void(size_t)&gt; &amp;discard_item_by_count, const function&lt; void(size_t)&gt; &amp;discard_item_by_score) const</td></tr>
<tr class="separator:ab7aa198a608d38eda2d3c593416b7849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d38b2d6536a660031f962da6c6c5ed"><td class="memTemplParams" colspan="2">template&lt;typename Item , typename Score  = double&gt; </td></tr>
<tr class="memitem:a00d38b2d6536a660031f962da6c6c5ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a00d38b2d6536a660031f962da6c6c5ed">process_until_threshold_b</a> (const vector&lt; Item &gt; &amp;items, const vector&lt; Score &gt; &amp;scores, double threshold, size_t min_count, size_t max_count, const function&lt; bool(size_t)&gt; &amp;process_item, const function&lt; void(size_t)&gt; &amp;discard_item_by_count, const function&lt; void(size_t)&gt; &amp;discard_item_by_score) const</td></tr>
<tr class="separator:a00d38b2d6536a660031f962da6c6c5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bfda3338de367a1ef13202d8ce9542"><td class="memTemplParams" colspan="2">template&lt;typename Item , typename Score  = double&gt; </td></tr>
<tr class="memitem:a64bfda3338de367a1ef13202d8ce9542"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a64bfda3338de367a1ef13202d8ce9542">process_until_threshold_c</a> (const vector&lt; Item &gt; &amp;items, const function&lt; Score(size_t)&gt; &amp;get_score, const function&lt; bool(size_t, size_t)&gt; &amp;comparator, double threshold, size_t min_count, size_t max_count, const function&lt; bool(size_t)&gt; &amp;process_item, const function&lt; void(size_t)&gt; &amp;discard_item_by_count, const function&lt; void(size_t)&gt; &amp;discard_item_by_score) const</td></tr>
<tr class="separator:a64bfda3338de367a1ef13202d8ce9542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classvg_1_1AlignerClient"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classvg_1_1AlignerClient')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classvg_1_1AlignerClient.html">vg::AlignerClient</a></td></tr>
<tr class="memitem:ab180631766b1e787e29dd202ad455d90 inherit pro_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#ab180631766b1e787e29dd202ad455d90">AlignerClient</a> (double <a class="el" href="classvg_1_1AlignerClient.html#a65428f092aaa5d894b709e247cf0121a">gc_content_estimate</a>=vg::default_gc_content)</td></tr>
<tr class="separator:ab180631766b1e787e29dd202ad455d90 inherit pro_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50649d9b2fc24254a8ac002486cd4dbb inherit pro_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a50649d9b2fc24254a8ac002486cd4dbb">get_aligner</a> (bool have_qualities=true) const</td></tr>
<tr class="separator:a50649d9b2fc24254a8ac002486cd4dbb inherit pro_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79071998ffe8ea584e2b6c70487ceb67 inherit pro_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a79071998ffe8ea584e2b6c70487ceb67">get_qual_adj_aligner</a> () const</td></tr>
<tr class="separator:a79071998ffe8ea584e2b6c70487ceb67 inherit pro_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981d1611f55817d7c375a5665666e408 inherit pro_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a981d1611f55817d7c375a5665666e408">get_regular_aligner</a> () const</td></tr>
<tr class="separator:a981d1611f55817d7c375a5665666e408 inherit pro_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a2c8ab02743227cb2550fcfd295043253"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a2c8ab02743227cb2550fcfd295043253">score_extension_group</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const vector&lt; <a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &gt; &amp;extended_seeds, int gap_open_penalty, int gap_extend_penalty)</td></tr>
<tr class="separator:a2c8ab02743227cb2550fcfd295043253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3008803e2ce57d5bbcd6a077f9dcde6"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#ab3008803e2ce57d5bbcd6a077f9dcde6">immutable_path_from_length</a> (const <a class="el" href="classvg_1_1MinimizerMapper.html#af12f40d8ae25f153fba1dc122fda29f0">ImmutablePath</a> &amp;path)</td></tr>
<tr class="separator:ab3008803e2ce57d5bbcd6a077f9dcde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1565adcd1bdf28aca55134d7482b1af"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structvg_1_1Path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#ae1565adcd1bdf28aca55134d7482b1af">to_path</a> (const <a class="el" href="classvg_1_1MinimizerMapper.html#af12f40d8ae25f153fba1dc122fda29f0">ImmutablePath</a> &amp;path)</td></tr>
<tr class="separator:ae1565adcd1bdf28aca55134d7482b1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aa75ca7504db85f1ba5d340b8213036de"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#aa75ca7504db85f1ba5d340b8213036de">path_graph</a></td></tr>
<tr class="separator:aa75ca7504db85f1ba5d340b8213036de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8158d7661a52252dd77e2ec0dcaa1964"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; gbwtgraph::DefaultMinimizerIndex * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a8158d7661a52252dd77e2ec0dcaa1964">minimizer_indexes</a></td></tr>
<tr class="separator:a8158d7661a52252dd77e2ec0dcaa1964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad418f42dd9ed77cd6b09743ebae634b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1MinimumDistanceIndex.html">MinimumDistanceIndex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#aad418f42dd9ed77cd6b09743ebae634b">distance_index</a></td></tr>
<tr class="separator:aad418f42dd9ed77cd6b09743ebae634b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb94c27ed347a36fb38f91cf23a582fb"><td class="memItemLeft" align="right" valign="top">const gbwtgraph::GBWTGraph &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#abb94c27ed347a36fb38f91cf23a582fb">gbwt_graph</a></td></tr>
<tr class="memdesc:abb94c27ed347a36fb38f91cf23a582fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is our primary graph.  <a href="#abb94c27ed347a36fb38f91cf23a582fb">More...</a><br /></td></tr>
<tr class="separator:abb94c27ed347a36fb38f91cf23a582fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7384299b6fd570ee8454c6f74c7a6583"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1GaplessExtender.html">GaplessExtender</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a7384299b6fd570ee8454c6f74c7a6583">extender</a></td></tr>
<tr class="memdesc:a7384299b6fd570ee8454c6f74c7a6583"><td class="mdescLeft">&#160;</td><td class="mdescRight">We have a gapless extender to extend seed hits in haplotype space.  <a href="#a7384299b6fd570ee8454c6f74c7a6583">More...</a><br /></td></tr>
<tr class="separator:a7384299b6fd570ee8454c6f74c7a6583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2420d8771bcc824f7e7d36dbe4531fcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1SnarlSeedClusterer.html">SnarlSeedClusterer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a2420d8771bcc824f7e7d36dbe4531fcf">clusterer</a></td></tr>
<tr class="memdesc:a2420d8771bcc824f7e7d36dbe4531fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">We have a clusterer.  <a href="#a2420d8771bcc824f7e7d36dbe4531fcf">More...</a><br /></td></tr>
<tr class="separator:a2420d8771bcc824f7e7d36dbe4531fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab019d5888d75bbe36d8eb444d148ac50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1FragmentLengthDistribution.html">FragmentLengthDistribution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#ab019d5888d75bbe36d8eb444d148ac50">fragment_length_distr</a></td></tr>
<tr class="separator:ab019d5888d75bbe36d8eb444d148ac50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8101808199bf23e00a6f1a091acf3370"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a8101808199bf23e00a6f1a091acf3370">phred_at_least_one</a></td></tr>
<tr class="separator:a8101808199bf23e00a6f1a091acf3370"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a54be3b97a663fcdcafea5553b598add0"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html#a54be3b97a663fcdcafea5553b598add0">PRECISION</a> = 8</td></tr>
<tr class="memdesc:a54be3b97a663fcdcafea5553b598add0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this many bits for approximate probabilities.  <a href="#a54be3b97a663fcdcafea5553b598add0">More...</a><br /></td></tr>
<tr class="separator:a54be3b97a663fcdcafea5553b598add0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classvg_1_1AlignerClient"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classvg_1_1AlignerClient')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classvg_1_1AlignerClient.html">vg::AlignerClient</a></td></tr>
<tr class="memitem:afe30f7cbea293a0fe369c21e22bf7881 inherit pub_static_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">static int8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#afe30f7cbea293a0fe369c21e22bf7881">parse_matrix</a> (std::istream &amp;matrix_stream)</td></tr>
<tr class="memdesc:afe30f7cbea293a0fe369c21e22bf7881 inherit pub_static_methods_classvg_1_1AlignerClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an array to hold a 4x4 substitution matrix and returns it.  <a href="classvg_1_1AlignerClient.html#afe30f7cbea293a0fe369c21e22bf7881">More...</a><br /></td></tr>
<tr class="separator:afe30f7cbea293a0fe369c21e22bf7881 inherit pub_static_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a339fbfcd026d074287148843b42c646d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a339fbfcd026d074287148843b42c646d">&#9670;&nbsp;</a></span>Cluster</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structvg_1_1SnarlSeedClusterer_1_1Cluster.html">SnarlSeedClusterer::Cluster</a> <a class="el" href="classvg_1_1MinimizerMapper.html#a339fbfcd026d074287148843b42c646d">vg::MinimizerMapper::Cluster</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The information we store for each cluster. </p>

</div>
</div>
<a id="af12f40d8ae25f153fba1dc122fda29f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12f40d8ae25f153fba1dc122fda29f0">&#9670;&nbsp;</a></span>ImmutablePath</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvg_1_1MinimizerMapper.html#af12f40d8ae25f153fba1dc122fda29f0">vg::MinimizerMapper::ImmutablePath</a> =  structures::ImmutableList&lt;<a class="el" href="structvg_1_1Mapping.html">Mapping</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>We define a type for shared-tail lists of Mappings, to avoid constantly copying <a class="el" href="structvg_1_1Path.html">Path</a> objects. </p>

</div>
</div>
<a id="a72644e4df554de0f0a2d3b50a9a3094a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72644e4df554de0f0a2d3b50a9a3094a">&#9670;&nbsp;</a></span>Seed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structvg_1_1SnarlSeedClusterer_1_1Seed.html">SnarlSeedClusterer::Seed</a> <a class="el" href="classvg_1_1MinimizerMapper.html#a72644e4df554de0f0a2d3b50a9a3094a">vg::MinimizerMapper::Seed</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The information we store for each seed. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4133862618010a5b1c54b1dd94732b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4133862618010a5b1c54b1dd94732b21">&#9670;&nbsp;</a></span>MinimizerMapper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::MinimizerMapper::MinimizerMapper </td>
          <td>(</td>
          <td class="paramtype">const gbwtgraph::GBWTGraph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; gbwtgraph::DefaultMinimizerIndex *&gt; &amp;&#160;</td>
          <td class="paramname"><em>minimizer_indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1MinimumDistanceIndex.html">MinimumDistanceIndex</a> &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>path_graph</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a new <a class="el" href="classvg_1_1MinimizerMapper.html">MinimizerMapper</a> using the given indexes. The PathPositionhandleGraph can be nullptr, as we only use it for correctness tracking. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9605b1ef714df2c8f07b7bcd4afd0882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9605b1ef714df2c8f07b7bcd4afd0882">&#9670;&nbsp;</a></span>attempt_rescue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MinimizerMapper::attempt_rescue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aligned_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>rescued_alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rescue_forward</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an aligned read, extract a subgraph of the graph within a distance range based on the fragment length distribution and attempt to align the unaligned read to it. Rescue_forward is true if the aligned read is the first and false otherwise. Assumes that both reads are facing the same direction. TODO: This should be const, but some of the function calls are not. </p>

</div>
</div>
<a id="ac116853daed562fc9bbef6c55503d078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac116853daed562fc9bbef6c55503d078">&#9670;&nbsp;</a></span>attempt_rescue_haplotypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MinimizerMapper::attempt_rescue_haplotypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aligned_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>rescued_alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rescue_forward</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an aligned read, extract all haplotypes within a distance range based on the fragment length distribution and attempt to align the unaligned read to it. Rescue_forward is true if the aligned read is the first and false otherwise. Assumes that both reads are facing the same direction. NOTE: Using this in a graph with small variants is generally a bad idea, because the number of local haplotypes is probably too large. TODO: This should be const, but some of the function calls are not. </p>

</div>
</div>
<a id="a2b20fa6da14da0a38f2bdfe21c3f67c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b20fa6da14da0a38f2bdfe21c3f67c9">&#9670;&nbsp;</a></span>compute_mapq_caps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::MinimizerMapper::compute_mapq_caps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structvg_1_1MinimizerMapper_1_1Minimizer.html">Minimizer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>minimizers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sdsl::bit_vector &amp;&#160;</td>
          <td class="paramname"><em>present_in_any_extended_cluster</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute MAPQ caps based on all minimizers present in extended clusters.</p>
<p>Needs access to the input alignment for sequence and quality information.</p>
<p>Returns only an "extended" cap at the moment. </p>

</div>
</div>
<a id="a4355a2ecfe99c02410f92093efc77ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4355a2ecfe99c02410f92093efc77ce4">&#9670;&nbsp;</a></span>dfs_gbwt() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MinimizerMapper::dfs_gbwt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>walk_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>enter_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(void)&gt;&#160;</td>
          <td class="paramname"><em>exit_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Run a DFS on valid haplotypes in the GBWT starting from the given <a class="el" href="structvg_1_1Position.html">Position</a>, and continuing up to the given number of bases.</p>
<p>Calls enter_handle when the DFS enters a haplotype visit to a particular handle, and exit_handle when it exits a visit. These let the caller maintain a stack and track the traversals.</p>
<p>The starting node is only entered if its offset isn't equal to its length (i.e. bases remain to be visited).</p>
<p>Stopping early is not permitted. </p>

</div>
</div>
<a id="a657e584de6e57a3f6f15616f245e39ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657e584de6e57a3f6f15616f245e39ef">&#9670;&nbsp;</a></span>dfs_gbwt() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MinimizerMapper::dfs_gbwt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>from_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>from_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>walk_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>enter_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(void)&gt;&#160;</td>
          <td class="paramname"><em>exit_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The same as dfs_gbwt on a <a class="el" href="structvg_1_1Position.html">Position</a>, but takes a handle in the backing gbwt_graph and an offset from the start of the handle instead. </p>

</div>
</div>
<a id="a759504362bfa77a4eb8428e1b2be1ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759504362bfa77a4eb8428e1b2be1ccf">&#9670;&nbsp;</a></span>dfs_gbwt() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MinimizerMapper::dfs_gbwt </td>
          <td>(</td>
          <td class="paramtype">const gbwt::SearchState &amp;&#160;</td>
          <td class="paramname"><em>start_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>from_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>walk_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>enter_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(void)&gt;&#160;</td>
          <td class="paramname"><em>exit_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The same as dfs_gbwt on a handle and an offset, but takes a gbwt::SearchState that defines only some haplotypes on a handle to start with. </p>

</div>
</div>
<a id="ae68add551501e3b58c9329d9297d620d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae68add551501e3b58c9329d9297d620d">&#9670;&nbsp;</a></span>distance_between()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::MinimizerMapper::distance_between </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the distance between a pair of read alignments </p>

</div>
</div>
<a id="a4ae627a418357792cd5b9f6d6b9cc19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ae627a418357792cd5b9f6d6b9cc19c">&#9670;&nbsp;</a></span>finalize_fragment_length_distr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MinimizerMapper::finalize_fragment_length_distr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3256c8c0ebc49ff72af298684580fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3256c8c0ebc49ff72af298684580fa4">&#9670;&nbsp;</a></span>find_connecting_paths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt;size_t, unordered_map&lt;size_t, vector&lt;<a class="el" href="structvg_1_1Path.html">Path</a>&gt; &gt; &gt; vg::MinimizerMapper::find_connecting_paths </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>extended_seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>read_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find for each pair of extended seeds all the haplotype-consistent graph paths against which the intervening read sequence needs to be aligned.</p>
<p>Limits walks from each extended seed end to the longest detectable gap plus the remaining to-be-alinged sequence, both computed using the read length.</p>
<p>extended_seeds must be sorted by read start position. Any extended seeds that overlap in the read will be precluded from connecting.</p>
<p>numeric_limits&lt;size_t&gt;::max() is used to store sufficiently long <a class="el" href="classvg_1_1Paths.html">Paths</a> ending before sources (which cannot be reached from other extended seeds) and starting after sinks (which cannot reach any other extended seeds). Only sources and sinks have these "tail" paths.</p>
<p>Tail paths are only calculated if the <a class="el" href="classvg_1_1MinimizerMapper.html">MinimizerMapper</a> has linear_tails set to true. </p>

</div>
</div>
<a id="af3e5c53b0250173b6d0eb097cf884986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e5c53b0250173b6d0eb097cf884986">&#9670;&nbsp;</a></span>find_minimizers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structvg_1_1MinimizerMapper_1_1Minimizer.html">MinimizerMapper::Minimizer</a> &gt; vg::MinimizerMapper::find_minimizers </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1Funnel.html">Funnel</a> &amp;&#160;</td>
          <td class="paramname"><em>funnel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find the minimizers in the sequence using all minimizer indexes and return them sorted in descending order by score. </p>

</div>
</div>
<a id="a6e3ec6685f98622b35391ae0d8bac180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3ec6685f98622b35391ae0d8bac180">&#9670;&nbsp;</a></span>find_optimal_tail_alignments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MinimizerMapper::find_optimal_tail_alignments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>extended_seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>best</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>second_best</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Operating on the given input alignment, align the tails dangling off the given extended perfect-match seeds and produce an optimal alignment into the given output <a class="el" href="structvg_1_1Alignment.html">Alignment</a> object, best, and the second best alignment into second_best. </p>

</div>
</div>
<a id="ab9e0a0ad996ae2011c90e2a6d6dd4b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e0a0ad996ae2011c90e2a6d6dd4b4a">&#9670;&nbsp;</a></span>find_seeds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classvg_1_1MinimizerMapper.html#a72644e4df554de0f0a2d3b50a9a3094a">MinimizerMapper::Seed</a> &gt; vg::MinimizerMapper::find_seeds </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structvg_1_1MinimizerMapper_1_1Minimizer.html">Minimizer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>minimizers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1Funnel.html">Funnel</a> &amp;&#160;</td>
          <td class="paramname"><em>funnel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find seeds for all minimizers passing the filters. </p>

</div>
</div>
<a id="a692470c7551c4966126aa7bf357e60a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692470c7551c4966126aa7bf357e60a4">&#9670;&nbsp;</a></span>fragment_distr_is_finalized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MinimizerMapper::fragment_distr_is_finalized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5520caca736306020df277dc3293eec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5520caca736306020df277dc3293eec8">&#9670;&nbsp;</a></span>get_best_alignment_against_any_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="structvg_1_1Path.html">Path</a>, size_t &gt; vg::MinimizerMapper::get_best_alignment_against_any_tree </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1TreeSubgraph.html">TreeSubgraph</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>trees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>default_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find the best alignment of the given sequence against any of the trees provided in trees, where each tree is a <a class="el" href="classvg_1_1TreeSubgraph.html">TreeSubgraph</a> over the GBWT graph. Each tree subgraph is rooted at the left in its own local coordinate space, even if we are pinning on the right.</p>
<p>If no mapping is possible (for example, because there are no trees), produce a pure insert at default_position.</p>
<p><a class="el" href="structvg_1_1Alignment.html">Alignment</a> is always pinned.</p>
<p>If pin_left is true, pin the alignment on the left to the root of each tree. Otherwise pin it on the right to the root of each tree.</p>
<p>Returns alingments in gbwt_graph space. </p>

</div>
</div>
<a id="a52ffe043bb4a0f598e0fe76f3f7ca301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ffe043bb4a0f598e0fe76f3f7ca301">&#9670;&nbsp;</a></span>get_tail_forest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classvg_1_1TreeSubgraph.html">TreeSubgraph</a> &gt; vg::MinimizerMapper::get_tail_forest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &amp;&#160;</td>
          <td class="paramname"><em>extended_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>read_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>left_tails</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get all the trees defining tails off the specified side of the specified gapless extension. Should only be called if a tail on that side exists, or this is a waste of time.</p>
<p>If the gapless extension starts or ends at a node boundary, there may be multiple trees produced, each with a distinct root.</p>
<p>If the gapless extension abuts the edge of the read, an empty forest will be produced.</p>
<p>Each tree is represented as a <a class="el" href="classvg_1_1TreeSubgraph.html">TreeSubgraph</a> over our gbwt_graph.</p>
<p>If left_tails is true, the trees read out of the left sides of the gapless extension. Otherwise they read out of the right side. </p>

</div>
</div>
<a id="ab3008803e2ce57d5bbcd6a077f9dcde6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3008803e2ce57d5bbcd6a077f9dcde6">&#9670;&nbsp;</a></span>immutable_path_from_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MinimizerMapper::immutable_path_from_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1MinimizerMapper.html#af12f40d8ae25f153fba1dc122fda29f0">ImmutablePath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the from length of an ImmutabelPath.</p>
<p>Can't be called path_from_length or it will shadow the one for <a class="el" href="classvg_1_1Paths.html">Paths</a> instead of overloading. </p>

</div>
</div>
<a id="a4c955e7607a1c07d2ca2b22a065e8b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c955e7607a1c07d2ca2b22a065e8b91">&#9670;&nbsp;</a></span>map() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MinimizerMapper::map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1AlignmentEmitter.html">AlignmentEmitter</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment_emitter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map the given read, and send output to the given <a class="el" href="classvg_1_1AlignmentEmitter.html">AlignmentEmitter</a>. May be run from any thread. TODO: Can't be const because the clusterer's cluster_seeds isn't const. </p>

</div>
</div>
<a id="a182c026fcc4e3a8dea5de373d1a79bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182c026fcc4e3a8dea5de373d1a79bbb">&#9670;&nbsp;</a></span>map() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; vg::MinimizerMapper::map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map the given read. Return a vector of alignments that it maps to, winner first. </p>

</div>
</div>
<a id="a5c90ef4f961998cc7904e78225b36f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c90ef4f961998cc7904e78225b36f50">&#9670;&nbsp;</a></span>map_paired() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;, vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &gt; vg::MinimizerMapper::map_paired </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a>, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ambiguous_pair_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map the given pair of reads, where aln1 is upstream of aln2 and they are oriented towards each other in the graph.</p>
<p>If the reads are ambiguous and there's no fragment length distribution fixed yet, they will be dropped into ambiguous_pair_buffer.</p>
<p>Otherwise, at least one result will be returned for them (although it may be the unmapped alignment). </p>

</div>
</div>
<a id="ab5f4c707ec44ba8f742c79bb0153c157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f4c707ec44ba8f742c79bb0153c157">&#9670;&nbsp;</a></span>map_paired() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;, vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &gt; vg::MinimizerMapper::map_paired </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map the given pair of reads, where aln1 is upstream of aln2 and they are oriented towards each other in the graph.</p>
<p>If the fragment length distribution is not yet fixed, reads will be mapped independently. Otherwise, they will be mapped according to the fragment length distribution. </p>

</div>
</div>
<a id="a0a67380a95608145839617f3a3193a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a67380a95608145839617f3a3193a6c">&#9670;&nbsp;</a></span>phred_for_at_least_one()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::MinimizerMapper::phred_for_at_least_one </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assume that we have n &lt;= max_k independent random events that occur with probability p each (p is interpreted as a real number between 0 and 1 and max_k is the largest k in the minimizer indexes). Return an approximate probability for at least one event occurring as a phred score. </p>

</div>
</div>
<a id="ab7aa198a608d38eda2d3c593416b7849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7aa198a608d38eda2d3c593416b7849">&#9670;&nbsp;</a></span>process_until_threshold_a()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Item , typename Score &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MinimizerMapper::process_until_threshold_a </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; Item &gt; &amp;&#160;</td>
          <td class="paramname"><em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; Score(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>get_score</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>process_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>discard_item_by_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>discard_item_by_score</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a vector of items, a function to get the score of each, a score-difference-from-the-best cutoff, and a min and max processed item count, process items in descending score order by calling process_item with the item's number, until min_count items are processed and either max_count items are processed or the score difference threshold is hit (or we run out of items).</p>
<p>If process_item returns false, the item is skipped and does not count against min_count or max_count.</p>
<p>Call discard_item_by_count with the item's number for all remaining items that would pass the score threshold.</p>
<p>Call discard_item_by_score with the item's number for all remaining items that would fail the score threshold. </p>

</div>
</div>
<a id="a00d38b2d6536a660031f962da6c6c5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d38b2d6536a660031f962da6c6c5ed">&#9670;&nbsp;</a></span>process_until_threshold_b()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Item , typename Score &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MinimizerMapper::process_until_threshold_b </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; Item &gt; &amp;&#160;</td>
          <td class="paramname"><em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; Score &gt; &amp;&#160;</td>
          <td class="paramname"><em>scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>process_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>discard_item_by_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>discard_item_by_score</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as the other process_until_threshold functions, except using a vector to supply scores. </p>

</div>
</div>
<a id="a64bfda3338de367a1ef13202d8ce9542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64bfda3338de367a1ef13202d8ce9542">&#9670;&nbsp;</a></span>process_until_threshold_c()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Item , typename Score &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MinimizerMapper::process_until_threshold_c </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; Item &gt; &amp;&#160;</td>
          <td class="paramname"><em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; Score(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>get_score</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(size_t, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>comparator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>process_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>discard_item_by_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>discard_item_by_score</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as the other process_until_threshold functions, except user supplies comparator to sort the items (must still be sorted by score). </p>

</div>
</div>
<a id="aaa1559493a4faca3189a5dd18ea08f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa1559493a4faca3189a5dd18ea08f87">&#9670;&nbsp;</a></span>score_cluster()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MinimizerMapper::score_cluster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1MinimizerMapper.html#a339fbfcd026d074287148843b42c646d">Cluster</a> &amp;&#160;</td>
          <td class="paramname"><em>cluster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structvg_1_1MinimizerMapper_1_1Minimizer.html">Minimizer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>minimizers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classvg_1_1MinimizerMapper.html#a72644e4df554de0f0a2d3b50a9a3094a">Seed</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seq_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1Funnel.html">Funnel</a> &amp;&#160;</td>
          <td class="paramname"><em>funnel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine cluster score, read coverage, and a vector of flags for the minimizers present in the cluster. Score is the sum of the scores of distinct minimizers in the cluster, while read coverage is the fraction of the read covered by seeds in the cluster. </p>

</div>
</div>
<a id="a2c8ab02743227cb2550fcfd295043253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8ab02743227cb2550fcfd295043253">&#9670;&nbsp;</a></span>score_extension_group()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int vg::MinimizerMapper::score_extension_group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>extended_seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gap_open_penalty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gap_extend_penalty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Score the given group of gapless extensions. Determines the best score that can be obtained by chaining extensions together, using the given gap open and gap extend penalties to charge for either overlaps or gaps in coverage of the read.</p>
<p>Enforces that overlaps cannot result in containment.</p>
<p>Input extended seeds must be sorted by start position. </p>

</div>
</div>
<a id="af9ff5e0a1b8c7925ccdb8a23d29872ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ff5e0a1b8c7925ccdb8a23d29872ef">&#9670;&nbsp;</a></span>score_extensions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; vg::MinimizerMapper::score_extensions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>extensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1Funnel.html">Funnel</a> &amp;&#160;</td>
          <td class="paramname"><em>funnel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Score the set of extensions for each cluster using <a class="el" href="classvg_1_1MinimizerMapper.html#a2c8ab02743227cb2550fcfd295043253">score_extension_group()</a>. Return the scores in the same order as the extensions. </p>

</div>
</div>
<a id="a421cdd65bac59fac39fd3b87cce0f3ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421cdd65bac59fac39fd3b87cce0f3ae">&#9670;&nbsp;</a></span>score_extensions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; vg::MinimizerMapper::score_extensions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; std::vector&lt; <a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &gt;, size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>extensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1Funnel.html">Funnel</a> &amp;&#160;</td>
          <td class="paramname"><em>funnel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Score the set of extensions for each cluster using <a class="el" href="classvg_1_1MinimizerMapper.html#a2c8ab02743227cb2550fcfd295043253">score_extension_group()</a>. Return the scores in the same order as the extensions. </p>

</div>
</div>
<a id="ae1565adcd1bdf28aca55134d7482b1af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1565adcd1bdf28aca55134d7482b1af">&#9670;&nbsp;</a></span>to_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> vg::MinimizerMapper::to_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1MinimizerMapper.html#af12f40d8ae25f153fba1dc122fda29f0">ImmutablePath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert an ImmutablePath to a <a class="el" href="structvg_1_1Path.html">Path</a>. </p>

</div>
</div>
<a id="aa19502481af491af1d623da3ed16a766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19502481af491af1d623da3ed16a766">&#9670;&nbsp;</a></span>window_breaking_quality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::MinimizerMapper::window_breaking_quality </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1MinimizerMapper_1_1Minimizer.html">Minimizer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>minimizers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>broken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>quality_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute a bound on the Phred score probability of having created the agglomerations of the specified minimizers by base errors from the given sequence, which was sequenced with the given qualities.</p>
<p>No limit is imposed if broken is empty.</p>
<p>Takes the collection of all minimizers found, and a vector of the indices of minimizers we are interested in the agglomerations of. May modify the order of that index vector.</p>
<p>Also takes the sequence of the read (to avoid Ns) and the quality string (interpreted as a byte array).</p>
<p>Currently computes a lower-score-bound, upper-probability-bound, suitable for use as a mapping quality cap, by assuming the easiest-to-disrupt possible layout of the windows, and the lowest possible qualities for the disrupting bases. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4aa953562a49de5befd8c80ee5e84a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aa953562a49de5befd8c80ee5e84a22">&#9670;&nbsp;</a></span>cluster_coverage_threshold</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::MinimizerMapper::cluster_coverage_threshold = 0.4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a10276fc66be2c41c2ebebd78e1f643de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10276fc66be2c41c2ebebd78e1f643de">&#9670;&nbsp;</a></span>cluster_score_threshold</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::MinimizerMapper::cluster_score_threshold = 50</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2420d8771bcc824f7e7d36dbe4531fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2420d8771bcc824f7e7d36dbe4531fcf">&#9670;&nbsp;</a></span>clusterer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1SnarlSeedClusterer.html">SnarlSeedClusterer</a> vg::MinimizerMapper::clusterer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We have a clusterer. </p>

</div>
</div>
<a id="aad418f42dd9ed77cd6b09743ebae634b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad418f42dd9ed77cd6b09743ebae634b">&#9670;&nbsp;</a></span>distance_index</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1MinimumDistanceIndex.html">MinimumDistanceIndex</a>&amp; vg::MinimizerMapper::distance_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2fa22653d0c63a1d7bf41946f6f62a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa22653d0c63a1d7bf41946f6f62a55">&#9670;&nbsp;</a></span>distance_limit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MinimizerMapper::distance_limit = 200</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a80efe32334434e2121f45d9683e2b53b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80efe32334434e2121f45d9683e2b53b">&#9670;&nbsp;</a></span>do_dp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MinimizerMapper::do_dp = true</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7384299b6fd570ee8454c6f74c7a6583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7384299b6fd570ee8454c6f74c7a6583">&#9670;&nbsp;</a></span>extender</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1GaplessExtender.html">GaplessExtender</a> vg::MinimizerMapper::extender</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We have a gapless extender to extend seed hits in haplotype space. </p>

</div>
</div>
<a id="adeff081b3c6a83ddfa7f620245b61fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeff081b3c6a83ddfa7f620245b61fd0">&#9670;&nbsp;</a></span>extension_score_threshold</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::MinimizerMapper::extension_score_threshold = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac47b8ebb0479d86727c97e37e7f103ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac47b8ebb0479d86727c97e37e7f103ee">&#9670;&nbsp;</a></span>extension_set_score_threshold</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::MinimizerMapper::extension_set_score_threshold = 20</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab019d5888d75bbe36d8eb444d148ac50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab019d5888d75bbe36d8eb444d148ac50">&#9670;&nbsp;</a></span>fragment_length_distr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1FragmentLengthDistribution.html">FragmentLengthDistribution</a> vg::MinimizerMapper::fragment_length_distr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abb94c27ed347a36fb38f91cf23a582fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb94c27ed347a36fb38f91cf23a582fb">&#9670;&nbsp;</a></span>gbwt_graph</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const gbwtgraph::GBWTGraph&amp; vg::MinimizerMapper::gbwt_graph</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is our primary graph. </p>

</div>
</div>
<a id="aaf577b72776f431ec4dc5faac505322e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf577b72776f431ec4dc5faac505322e">&#9670;&nbsp;</a></span>hard_hit_cap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MinimizerMapper::hard_hit_cap = 300</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ignore all minimizers with more than hard_hit_cap hits. </p>

</div>
</div>
<a id="a1097206776713f059fca80f221b8478c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1097206776713f059fca80f221b8478c">&#9670;&nbsp;</a></span>hit_cap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MinimizerMapper::hit_cap = 10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use all minimizers with at most hit_cap hits. </p>

</div>
</div>
<a id="a6062b78a7f795cb2a585eb6695bde675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6062b78a7f795cb2a585eb6695bde675">&#9670;&nbsp;</a></span>max_alignments</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MinimizerMapper::max_alignments = 8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How many extended clusters should we align, max? </p>

</div>
</div>
<a id="a5d03747a37700e9a3f73c308709f70d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d03747a37700e9a3f73c308709f70d1">&#9670;&nbsp;</a></span>max_extensions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MinimizerMapper::max_extensions = 48</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How many clusters should we align? </p>

</div>
</div>
<a id="a4e6142c1ccdde28230769e5a8b629d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e6142c1ccdde28230769e5a8b629d9f">&#9670;&nbsp;</a></span>max_local_extensions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MinimizerMapper::max_local_extensions = numeric_limits&lt;size_t&gt;::max()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How many extensions should we try as seeds within a mapping location? </p>

</div>
</div>
<a id="aede601962425752ec75ea1d890505357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede601962425752ec75ea1d890505357">&#9670;&nbsp;</a></span>max_multimaps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MinimizerMapper::max_multimaps = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0985bcf3a1ed28098bf0271b251dd6e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0985bcf3a1ed28098bf0271b251dd6e2">&#9670;&nbsp;</a></span>max_rescue_attempts</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MinimizerMapper::max_rescue_attempts = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8158d7661a52252dd77e2ec0dcaa1964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8158d7661a52252dd77e2ec0dcaa1964">&#9670;&nbsp;</a></span>minimizer_indexes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;gbwtgraph::DefaultMinimizerIndex*&gt;&amp; vg::MinimizerMapper::minimizer_indexes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5696bfb7029ca88ec04d0f849365b34f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5696bfb7029ca88ec04d0f849365b34f">&#9670;&nbsp;</a></span>minimizer_score_fraction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::MinimizerMapper::minimizer_score_fraction = 0.6</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take minimizers between hit_cap and hard_hit_cap hits until this fraction of total score </p>

</div>
</div>
<a id="a70b206dc58a148a69657303ff292199f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b206dc58a148a69657303ff292199f">&#9670;&nbsp;</a></span>pad_cluster_score_threshold</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::MinimizerMapper::pad_cluster_score_threshold = 20</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa75ca7504db85f1ba5d340b8213036de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75ca7504db85f1ba5d340b8213036de">&#9670;&nbsp;</a></span>path_graph</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a>* vg::MinimizerMapper::path_graph</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8101808199bf23e00a6f1a091acf3370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8101808199bf23e00a6f1a091acf3370">&#9670;&nbsp;</a></span>phred_at_least_one</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; vg::MinimizerMapper::phred_at_least_one</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assume that we have n &lt;= max_k independent events with probability p each. Let x be the PRECISION most significant bits of p. Then</p>
<p>phred_at_least_one[(n &lt;&lt; PRECISION) + x]</p>
<p>is an approximate phred score of at least one event occurring. </p>

</div>
</div>
<a id="a54be3b97a663fcdcafea5553b598add0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54be3b97a663fcdcafea5553b598add0">&#9670;&nbsp;</a></span>PRECISION</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t vg::MinimizerMapper::PRECISION = 8</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use this many bits for approximate probabilities. </p>

</div>
</div>
<a id="aee3e4b7c4e777da6c09f70218481e3d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3e4b7c4e777da6c09f70218481e3d6">&#9670;&nbsp;</a></span>read_group</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::MinimizerMapper::read_group</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f47382b14baf0482c43034e6484d086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f47382b14baf0482c43034e6484d086">&#9670;&nbsp;</a></span>sample_name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::MinimizerMapper::sample_name</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7896c6cccfa011c4fbad1b916d30052e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7896c6cccfa011c4fbad1b916d30052e">&#9670;&nbsp;</a></span>track_correctness</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MinimizerMapper::track_correctness = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Guess which seed hits are correct by location in the linear reference and track if/when their descendants make it through stages of the algorithm. Only works if track_provenance is true. </p>

</div>
</div>
<a id="aeabec85347521c1f42ef51e0453c4e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeabec85347521c1f42ef51e0453c4e5f">&#9670;&nbsp;</a></span>track_provenance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MinimizerMapper::track_provenance = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Track which internal work items came from which others during each stage of the mapping algorithm. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="minimizer__mapper_8hpp.html">minimizer_mapper.hpp</a></li>
<li>src/<a class="el" href="minimizer__mapper_8cpp.html">minimizer_mapper.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
