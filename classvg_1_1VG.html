<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>vg: vg::VG Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1VG.html">VG</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classvg_1_1VG-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::VG Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;vg.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vg::VG:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvg_1_1VG.png" usemap="#vg::VG_map" alt=""/>
  <map id="vg::VG_map" name="vg::VG_map">
<area href="classvg_1_1Progressive.html" alt="vg::Progressive" shape="rect" coords="0,224,287,248"/>
<area href="classhandlegraph_1_1MutablePathDeletableHandleGraph.html" alt="handlegraph::MutablePathDeletableHandleGraph" shape="rect" coords="371,224,658,248"/>
<area href="classhandlegraph_1_1SerializableHandleGraph.html" alt="handlegraph::SerializableHandleGraph" shape="rect" coords="668,224,955,248"/>
<area href="classhandlegraph_1_1MutablePathMutableHandleGraph.html" alt="handlegraph::MutablePathMutableHandleGraph" shape="rect" coords="148,168,435,192"/>
<area href="classhandlegraph_1_1DeletableHandleGraph.html" alt="handlegraph::DeletableHandleGraph" shape="rect" coords="594,168,881,192"/>
<area href="classhandlegraph_1_1MutablePathHandleGraph.html" alt="handlegraph::MutablePathHandleGraph" shape="rect" coords="0,112,287,136"/>
<area href="classhandlegraph_1_1MutableHandleGraph.html" alt="handlegraph::MutableHandleGraph" shape="rect" coords="297,112,584,136"/>
<area href="classhandlegraph_1_1MutableHandleGraph.html" alt="handlegraph::MutableHandleGraph" shape="rect" coords="594,112,881,136"/>
<area href="classhandlegraph_1_1PathHandleGraph.html" alt="handlegraph::PathHandleGraph" shape="rect" coords="0,56,287,80"/>
<area href="classhandlegraph_1_1HandleGraph.html" alt="handlegraph::HandleGraph" shape="rect" coords="297,56,584,80"/>
<area href="classhandlegraph_1_1HandleGraph.html" alt="handlegraph::HandleGraph" shape="rect" coords="594,56,881,80"/>
<area href="classhandlegraph_1_1HandleGraph.html" alt="handlegraph::HandleGraph" shape="rect" coords="0,0,287,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1VG_1_1Plan.html">Plan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for managing parallel construction of a graph.  <a href="structvg_1_1VG_1_1Plan.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a97a0549f64f6a8a3e7dbe8f1e4767fd5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a97a0549f64f6a8a3e7dbe8f1e4767fd5">serialize</a> (ostream &amp;out) const </td></tr>
<tr class="memdesc:a97a0549f64f6a8a3e7dbe8f1e4767fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the contents of this graph to an ostream.  <a href="#a97a0549f64f6a8a3e7dbe8f1e4767fd5">More...</a><br/></td></tr>
<tr class="separator:a97a0549f64f6a8a3e7dbe8f1e4767fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24359ba8e4ecbbd692bba5a517456659"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a24359ba8e4ecbbd692bba5a517456659">deserialize</a> (istream &amp;in)</td></tr>
<tr class="separator:a24359ba8e4ecbbd692bba5a517456659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a218b188035e086a5625170cfcf23c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a26a218b188035e086a5625170cfcf23c">get_handle</a> (const <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &amp;node_id, bool is_reverse=false) const </td></tr>
<tr class="memdesc:a26a218b188035e086a5625170cfcf23c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the handle for the node with the given ID in the given orientation.  <a href="#a26a218b188035e086a5625170cfcf23c">More...</a><br/></td></tr>
<tr class="separator:a26a218b188035e086a5625170cfcf23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275f9a67d357980049ff3a6cb475a0a6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a275f9a67d357980049ff3a6cb475a0a6">get_id</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const </td></tr>
<tr class="memdesc:a275f9a67d357980049ff3a6cb475a0a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID from a handle.  <a href="#a275f9a67d357980049ff3a6cb475a0a6">More...</a><br/></td></tr>
<tr class="separator:a275f9a67d357980049ff3a6cb475a0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101b575652f006b09c33ba271806e721"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a101b575652f006b09c33ba271806e721">get_is_reverse</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const </td></tr>
<tr class="memdesc:a101b575652f006b09c33ba271806e721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the orientation of a handle.  <a href="#a101b575652f006b09c33ba271806e721">More...</a><br/></td></tr>
<tr class="separator:a101b575652f006b09c33ba271806e721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47afbf1369e36d541a0ebddfc707d934"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a47afbf1369e36d541a0ebddfc707d934">flip</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const </td></tr>
<tr class="memdesc:a47afbf1369e36d541a0ebddfc707d934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the orientation of a handle (potentially without getting its ID)  <a href="#a47afbf1369e36d541a0ebddfc707d934">More...</a><br/></td></tr>
<tr class="separator:a47afbf1369e36d541a0ebddfc707d934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8816a7244ebad64663a1af13f5244c"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7f8816a7244ebad64663a1af13f5244c">get_length</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const </td></tr>
<tr class="memdesc:a7f8816a7244ebad64663a1af13f5244c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of a node.  <a href="#a7f8816a7244ebad64663a1af13f5244c">More...</a><br/></td></tr>
<tr class="separator:a7f8816a7244ebad64663a1af13f5244c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7382f9cc8ef44b358495d021a0a0f80b"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7382f9cc8ef44b358495d021a0a0f80b">get_sequence</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const </td></tr>
<tr class="separator:a7382f9cc8ef44b358495d021a0a0f80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fb41930976d8d19f85e61638a7d6d1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ae8fb41930976d8d19f85e61638a7d6d1">follow_edges_impl</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left, const function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;iteratee) const </td></tr>
<tr class="separator:ae8fb41930976d8d19f85e61638a7d6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd959c93ee2d6addc727b47164a6be8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5cd959c93ee2d6addc727b47164a6be8">for_each_handle_impl</a> (const function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;iteratee, bool parallel=false) const </td></tr>
<tr class="separator:a5cd959c93ee2d6addc727b47164a6be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c33ebd670cbcc46a8950512663fbe0"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad4c33ebd670cbcc46a8950512663fbe0">get_node_count</a> () const </td></tr>
<tr class="memdesc:ad4c33ebd670cbcc46a8950512663fbe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of nodes in the graph.  <a href="#ad4c33ebd670cbcc46a8950512663fbe0">More...</a><br/></td></tr>
<tr class="separator:ad4c33ebd670cbcc46a8950512663fbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f9c36b6c3f7cbe933f705e9e9ba782"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a78f9c36b6c3f7cbe933f705e9e9ba782">min_node_id</a> () const </td></tr>
<tr class="memdesc:a78f9c36b6c3f7cbe933f705e9e9ba782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum node ID used in the graph, if any are used.  <a href="#a78f9c36b6c3f7cbe933f705e9e9ba782">More...</a><br/></td></tr>
<tr class="separator:a78f9c36b6c3f7cbe933f705e9e9ba782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3751016fff6e1e38d154515a13949e74"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3751016fff6e1e38d154515a13949e74">max_node_id</a> () const </td></tr>
<tr class="memdesc:a3751016fff6e1e38d154515a13949e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum node ID used in the graph, if any are used.  <a href="#a3751016fff6e1e38d154515a13949e74">More...</a><br/></td></tr>
<tr class="separator:a3751016fff6e1e38d154515a13949e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a8a09a49ea348f3714377b893319f6"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac1a8a09a49ea348f3714377b893319f6">get_degree</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left) const </td></tr>
<tr class="separator:ac1a8a09a49ea348f3714377b893319f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150b452102319b93490e53b2dc62e920"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a150b452102319b93490e53b2dc62e920">has_edge</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right) const </td></tr>
<tr class="separator:a150b452102319b93490e53b2dc62e920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1546dff9dc144260cb40050bf8dcfa2"><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac1546dff9dc144260cb40050bf8dcfa2">get_base</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, size_t index) const </td></tr>
<tr class="separator:ac1546dff9dc144260cb40050bf8dcfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8a010d477eb8e1e2cfd91efa8a29e6"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aae8a010d477eb8e1e2cfd91efa8a29e6">get_subsequence</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, size_t index, size_t <a class="el" href="classvg_1_1VG.html#a9e3720ce267c8167ce679a015063dab6">size</a>) const </td></tr>
<tr class="separator:aae8a010d477eb8e1e2cfd91efa8a29e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20417af67e14d7800b20df8b0ac763f9"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a20417af67e14d7800b20df8b0ac763f9">get_path_count</a> () const </td></tr>
<tr class="memdesc:a20417af67e14d7800b20df8b0ac763f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of paths stored in the graph.  <a href="#a20417af67e14d7800b20df8b0ac763f9">More...</a><br/></td></tr>
<tr class="separator:a20417af67e14d7800b20df8b0ac763f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86daea8c9c2ff784598512fff740bd2c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a86daea8c9c2ff784598512fff740bd2c">has_path</a> (const string &amp;path_name) const </td></tr>
<tr class="memdesc:a86daea8c9c2ff784598512fff740bd2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a path name exists and is legal to get a path handle for.  <a href="#a86daea8c9c2ff784598512fff740bd2c">More...</a><br/></td></tr>
<tr class="separator:a86daea8c9c2ff784598512fff740bd2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0789f1df0078dff5849a97f60ca4d51e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0789f1df0078dff5849a97f60ca4d51e">get_path_handle</a> (const string &amp;path_name) const </td></tr>
<tr class="memdesc:a0789f1df0078dff5849a97f60ca4d51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the path handle for the given path name.  <a href="#a0789f1df0078dff5849a97f60ca4d51e">More...</a><br/></td></tr>
<tr class="separator:a0789f1df0078dff5849a97f60ca4d51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71b9547040f0d8ae430d564aa897d97"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac71b9547040f0d8ae430d564aa897d97">get_path_name</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const </td></tr>
<tr class="memdesc:ac71b9547040f0d8ae430d564aa897d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the name of a path from a handle to it.  <a href="#ac71b9547040f0d8ae430d564aa897d97">More...</a><br/></td></tr>
<tr class="separator:ac71b9547040f0d8ae430d564aa897d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b36247a6ca74800a80d83170948fee9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5b36247a6ca74800a80d83170948fee9">get_is_circular</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const </td></tr>
<tr class="memdesc:a5b36247a6ca74800a80d83170948fee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up whether a path is circular.  <a href="#a5b36247a6ca74800a80d83170948fee9">More...</a><br/></td></tr>
<tr class="separator:a5b36247a6ca74800a80d83170948fee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212238ea52a6c8f542bb3c6b866cb040"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a212238ea52a6c8f542bb3c6b866cb040">get_step_count</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const </td></tr>
<tr class="memdesc:a212238ea52a6c8f542bb3c6b866cb040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of node steps in the path.  <a href="#a212238ea52a6c8f542bb3c6b866cb040">More...</a><br/></td></tr>
<tr class="separator:a212238ea52a6c8f542bb3c6b866cb040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e9b71f9dd2cbfb1881b830ae4654b6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a80e9b71f9dd2cbfb1881b830ae4654b6">get_handle_of_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const </td></tr>
<tr class="memdesc:a80e9b71f9dd2cbfb1881b830ae4654b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a node handle (node ID and orientation) from a handle to an step on a path.  <a href="#a80e9b71f9dd2cbfb1881b830ae4654b6">More...</a><br/></td></tr>
<tr class="separator:a80e9b71f9dd2cbfb1881b830ae4654b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8b0de9776e2f4ee0b1185ba59485c0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5c8b0de9776e2f4ee0b1185ba59485c0">get_path_handle_of_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const </td></tr>
<tr class="memdesc:a5c8b0de9776e2f4ee0b1185ba59485c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a handle to the path that an step is on.  <a href="#a5c8b0de9776e2f4ee0b1185ba59485c0">More...</a><br/></td></tr>
<tr class="separator:a5c8b0de9776e2f4ee0b1185ba59485c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba115ffda674c76e8956a8057545b25"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8ba115ffda674c76e8956a8057545b25">path_begin</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const </td></tr>
<tr class="separator:a8ba115ffda674c76e8956a8057545b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eaa8a920a65428b70b7b77142805208"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a6eaa8a920a65428b70b7b77142805208">path_end</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const </td></tr>
<tr class="separator:a6eaa8a920a65428b70b7b77142805208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868379db6918fd879eb5da7e6f9bc798"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a868379db6918fd879eb5da7e6f9bc798">path_back</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const </td></tr>
<tr class="separator:a868379db6918fd879eb5da7e6f9bc798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe330c38f9bd036838e4e5d133b1657"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#acfe330c38f9bd036838e4e5d133b1657">path_front_end</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const </td></tr>
<tr class="separator:acfe330c38f9bd036838e4e5d133b1657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94c162ade42415f7defe7677e5bae53"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa94c162ade42415f7defe7677e5bae53">get_next_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const </td></tr>
<tr class="separator:aa94c162ade42415f7defe7677e5bae53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1723ce56da21a5f6953464d03e4849ac"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1723ce56da21a5f6953464d03e4849ac">get_previous_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const </td></tr>
<tr class="separator:a1723ce56da21a5f6953464d03e4849ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c0e39a4a3f4df40c3a460b92a4a484"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a76c0e39a4a3f4df40c3a460b92a4a484">has_next_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const </td></tr>
<tr class="memdesc:a76c0e39a4a3f4df40c3a460b92a4a484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the step is not the last step in a non-circular path.  <a href="#a76c0e39a4a3f4df40c3a460b92a4a484">More...</a><br/></td></tr>
<tr class="separator:a76c0e39a4a3f4df40c3a460b92a4a484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ff80d377e97f67e98b75d6e64f3dbc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a07ff80d377e97f67e98b75d6e64f3dbc">has_previous_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const </td></tr>
<tr class="memdesc:a07ff80d377e97f67e98b75d6e64f3dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the step is not the first step in a non-circular path.  <a href="#a07ff80d377e97f67e98b75d6e64f3dbc">More...</a><br/></td></tr>
<tr class="separator:a07ff80d377e97f67e98b75d6e64f3dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d0976ab79947044eec399698299777"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad8d0976ab79947044eec399698299777">for_each_path_handle_impl</a> (const function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; &amp;iteratee) const </td></tr>
<tr class="memdesc:ad8d0976ab79947044eec399698299777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a function on each path in the graph.  <a href="#ad8d0976ab79947044eec399698299777">More...</a><br/></td></tr>
<tr class="separator:ad8d0976ab79947044eec399698299777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c6f800abfa14fdca58936e97907004"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af1c6f800abfa14fdca58936e97907004">for_each_step_on_handle_impl</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const function&lt; bool(const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;)&gt; &amp;iteratee) const </td></tr>
<tr class="memdesc:af1c6f800abfa14fdca58936e97907004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop over the steps of a handle in paths.  <a href="#af1c6f800abfa14fdca58936e97907004">More...</a><br/></td></tr>
<tr class="separator:af1c6f800abfa14fdca58936e97907004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ad97e46dc1297b1a65a32697e2d37e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a54ad97e46dc1297b1a65a32697e2d37e">create_handle</a> (const string &amp;sequence)</td></tr>
<tr class="memdesc:a54ad97e46dc1297b1a65a32697e2d37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new node with the given sequence and return the handle.  <a href="#a54ad97e46dc1297b1a65a32697e2d37e">More...</a><br/></td></tr>
<tr class="separator:a54ad97e46dc1297b1a65a32697e2d37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae968a71f586b6cc3876f2e9452f4c576"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ae968a71f586b6cc3876f2e9452f4c576">create_handle</a> (const string &amp;sequence, const <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &amp;<a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:ae968a71f586b6cc3876f2e9452f4c576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new node with the given id and sequence, then return the handle.  <a href="#ae968a71f586b6cc3876f2e9452f4c576">More...</a><br/></td></tr>
<tr class="separator:ae968a71f586b6cc3876f2e9452f4c576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e52875d37f046daeaf9e7b301ad59ff"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3e52875d37f046daeaf9e7b301ad59ff">destroy_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle)</td></tr>
<tr class="memdesc:a3e52875d37f046daeaf9e7b301ad59ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the node belonging to the given handle and all of its edges.  <a href="#a3e52875d37f046daeaf9e7b301ad59ff">More...</a><br/></td></tr>
<tr class="separator:a3e52875d37f046daeaf9e7b301ad59ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8922810d5228ab5c4619eb2ddc16e78b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8922810d5228ab5c4619eb2ddc16e78b">create_edge</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right)</td></tr>
<tr class="memdesc:a8922810d5228ab5c4619eb2ddc16e78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an edge connecting the given handles in the given order and orientations.  <a href="#a8922810d5228ab5c4619eb2ddc16e78b">More...</a><br/></td></tr>
<tr class="separator:a8922810d5228ab5c4619eb2ddc16e78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4264e39e3826ded714992361ab879e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a9d4264e39e3826ded714992361ab879e">destroy_edge</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right)</td></tr>
<tr class="memdesc:a9d4264e39e3826ded714992361ab879e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the edge connecting the given handles in the given order and orientations.  <a href="#a9d4264e39e3826ded714992361ab879e">More...</a><br/></td></tr>
<tr class="separator:a9d4264e39e3826ded714992361ab879e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1eb3332c0a99a25c75681da485297e5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa1eb3332c0a99a25c75681da485297e5">clear</a> ()</td></tr>
<tr class="memdesc:aa1eb3332c0a99a25c75681da485297e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all nodes and edges. Does not update any stored paths.  <a href="#aa1eb3332c0a99a25c75681da485297e5">More...</a><br/></td></tr>
<tr class="separator:aa1eb3332c0a99a25c75681da485297e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4db6ea2a99bda9a48411491aa6ed4e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3d4db6ea2a99bda9a48411491aa6ed4e">swap_handles</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;a, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;b)</td></tr>
<tr class="separator:a3d4db6ea2a99bda9a48411491aa6ed4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ee06ac168f037f2cff3b332079b49c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab5ee06ac168f037f2cff3b332079b49c">apply_orientation</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle)</td></tr>
<tr class="separator:ab5ee06ac168f037f2cff3b332079b49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5dbc95fa80e7fe3dc04d62ac6d7b3c"><td class="memItemLeft" align="right" valign="top">virtual vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7a5dbc95fa80e7fe3dc04d62ac6d7b3c">divide_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const vector&lt; size_t &gt; &amp;offsets)</td></tr>
<tr class="separator:a7a5dbc95fa80e7fe3dc04d62ac6d7b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4fa1970f08f3e4d0cf2f8c33a967a5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0b4fa1970f08f3e4d0cf2f8c33a967a5">optimize</a> (bool allow_id_reassignment=true)</td></tr>
<tr class="separator:a0b4fa1970f08f3e4d0cf2f8c33a967a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c07df5ff863bab2c096cd58a8350f37"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7c07df5ff863bab2c096cd58a8350f37">apply_ordering</a> (const std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;order, bool <a class="el" href="classvg_1_1VG.html#a161ef56bd0eeee937602f60b8617f24d">compact_ids</a>=false)</td></tr>
<tr class="separator:a7c07df5ff863bab2c096cd58a8350f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb25bd1fdb9e36c55157c5be864ca403"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#adb25bd1fdb9e36c55157c5be864ca403">destroy_path</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path)</td></tr>
<tr class="memdesc:adb25bd1fdb9e36c55157c5be864ca403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the given path. Invalidates handles to the path and its node steps.  <a href="#adb25bd1fdb9e36c55157c5be864ca403">More...</a><br/></td></tr>
<tr class="separator:adb25bd1fdb9e36c55157c5be864ca403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c99e48723b360eb2b1315b2c5af7cc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af7c99e48723b360eb2b1315b2c5af7cc">create_path_handle</a> (const string &amp;<a class="el" href="classvg_1_1VG.html#a1f6fcd5a907e9bee524cf37a62ad5be2">name</a>, bool is_circular=false)</td></tr>
<tr class="memdesc:af7c99e48723b360eb2b1315b2c5af7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a path with the given name.  <a href="#af7c99e48723b360eb2b1315b2c5af7cc">More...</a><br/></td></tr>
<tr class="separator:af7c99e48723b360eb2b1315b2c5af7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11c8a716733fce2aa9dab94b42286bd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad11c8a716733fce2aa9dab94b42286bd">append_step</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;to_append)</td></tr>
<tr class="memdesc:ad11c8a716733fce2aa9dab94b42286bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a visit to a node to the given path.  <a href="#ad11c8a716733fce2aa9dab94b42286bd">More...</a><br/></td></tr>
<tr class="separator:ad11c8a716733fce2aa9dab94b42286bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c2858dc8e80ba160359ccf5e1508d2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a43c2858dc8e80ba160359ccf5e1508d2">prepend_step</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;to_prepend)</td></tr>
<tr class="memdesc:a43c2858dc8e80ba160359ccf5e1508d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a visit to a node to the given path.  <a href="#a43c2858dc8e80ba160359ccf5e1508d2">More...</a><br/></td></tr>
<tr class="separator:a43c2858dc8e80ba160359ccf5e1508d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2dc75f200cfb7480e671fd55207410"><td class="memItemLeft" align="right" valign="top">virtual pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <br class="typebreak"/>
<a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#abb2dc75f200cfb7480e671fd55207410">rewrite_segment</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;segment_begin, const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;segment_end, const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;new_segment)</td></tr>
<tr class="separator:abb2dc75f200cfb7480e671fd55207410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c97ce0157b90f95b888e4b6983f5c8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a73c97ce0157b90f95b888e4b6983f5c8">set_circularity</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path, bool circular)</td></tr>
<tr class="separator:a73c97ce0157b90f95b888e4b6983f5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1131c1ff0a94ed2ec9ef35cb678801b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ae1131c1ff0a94ed2ec9ef35cb678801b">set_edge</a> (<a class="el" href="structvg_1_1Edge.html">Edge</a> *)</td></tr>
<tr class="separator:ae1131c1ff0a94ed2ec9ef35cb678801b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b659686076f3d6b7b63ec9678d76a93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a2b659686076f3d6b7b63ec9678d76a93">print_edges</a> (void)</td></tr>
<tr class="separator:a2b659686076f3d6b7b63ec9678d76a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eaedf10280d72862aa6f0b65a3d383e"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5eaedf10280d72862aa6f0b65a3d383e">edges_start</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a5eaedf10280d72862aa6f0b65a3d383e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get nodes and backward flags following edges that attach to this node's start.  <a href="#a5eaedf10280d72862aa6f0b65a3d383e">More...</a><br/></td></tr>
<tr class="separator:a5eaedf10280d72862aa6f0b65a3d383e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a9f315e43b96496fb5674df52623f7"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad9a9f315e43b96496fb5674df52623f7">edges_start</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:ad9a9f315e43b96496fb5674df52623f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get nodes and backward flags following edges that attach to this node's start.  <a href="#ad9a9f315e43b96496fb5674df52623f7">More...</a><br/></td></tr>
<tr class="separator:ad9a9f315e43b96496fb5674df52623f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdabb41079406d955795f2cfb72b496d"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#acdabb41079406d955795f2cfb72b496d">edges_end</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:acdabb41079406d955795f2cfb72b496d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get nodes and backward flags following edges that attach to this node's end.  <a href="#acdabb41079406d955795f2cfb72b496d">More...</a><br/></td></tr>
<tr class="separator:acdabb41079406d955795f2cfb72b496d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec901943e03aeae91638bce6952efc14"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aec901943e03aeae91638bce6952efc14">edges_end</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:aec901943e03aeae91638bce6952efc14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get nodes and backward flags following edges that attach to this node's end.  <a href="#aec901943e03aeae91638bce6952efc14">More...</a><br/></td></tr>
<tr class="separator:aec901943e03aeae91638bce6952efc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3720ce267c8167ce679a015063dab6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a9e3720ce267c8167ce679a015063dab6">size</a> (void)</td></tr>
<tr class="memdesc:a9e3720ce267c8167ce679a015063dab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes.  <a href="#a9e3720ce267c8167ce679a015063dab6">More...</a><br/></td></tr>
<tr class="separator:a9e3720ce267c8167ce679a015063dab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23641dedefa2b6d573939515fcf5974c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a23641dedefa2b6d573939515fcf5974c">length</a> (void)</td></tr>
<tr class="memdesc:a23641dedefa2b6d573939515fcf5974c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total sequence length.  <a href="#a23641dedefa2b6d573939515fcf5974c">More...</a><br/></td></tr>
<tr class="separator:a23641dedefa2b6d573939515fcf5974c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2399de59931e282fb1f4d3da9a8dcb1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac2399de59931e282fb1f4d3da9a8dcb1">VG</a> (void)</td></tr>
<tr class="memdesc:ac2399de59931e282fb1f4d3da9a8dcb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#ac2399de59931e282fb1f4d3da9a8dcb1">More...</a><br/></td></tr>
<tr class="separator:ac2399de59931e282fb1f4d3da9a8dcb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc9648985454d3aedd9a477ff0c52b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a2dc9648985454d3aedd9a477ff0c52b2">VG</a> (istream &amp;in, bool showp=false, bool warn_on_duplicates=true)</td></tr>
<tr class="memdesc:a2dc9648985454d3aedd9a477ff0c52b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from <a class="el" href="structvg_1_1Graph.html">Graph</a> objects serialized in a tagged group stream.  <a href="#a2dc9648985454d3aedd9a477ff0c52b2">More...</a><br/></td></tr>
<tr class="separator:a2dc9648985454d3aedd9a477ff0c52b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c22829197fc65ced4dd2e0f53cb20ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3c22829197fc65ced4dd2e0f53cb20ff">from_istream</a> (istream &amp;in, bool showp=false, bool warn_on_duplicates=true)</td></tr>
<tr class="separator:a3c22829197fc65ced4dd2e0f53cb20ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbb777fd8ab6050124a6eaf9eca9133"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0fbb777fd8ab6050124a6eaf9eca9133">VG</a> (const function&lt; void(const function&lt; void(<a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;)&gt; &amp;)&gt; &amp;send_graphs, bool showp=false, bool warn_on_duplicates=true)</td></tr>
<tr class="separator:a0fbb777fd8ab6050124a6eaf9eca9133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d321b31b873153431c261090d052af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af4d321b31b873153431c261090d052af">VG</a> (const <a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;from, bool showp=false, bool warn_on_duplicates=true)</td></tr>
<tr class="memdesc:af4d321b31b873153431c261090d052af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a single Protobuf graph. The same as making an empty <a class="el" href="classvg_1_1VG.html">VG</a> and using <a class="el" href="classvg_1_1VG.html#a2519c3b939f48bca226e6fdea4c91f9d">extend()</a>.  <a href="#af4d321b31b873153431c261090d052af">More...</a><br/></td></tr>
<tr class="separator:af4d321b31b873153431c261090d052af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeafee2d3bc6e0039e99fccdea10f4f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#abeafee2d3bc6e0039e99fccdea10f4f9">VG</a> (set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;nodes, set&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;edges)</td></tr>
<tr class="separator:abeafee2d3bc6e0039e99fccdea10f4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f5208ae9a2f22a31658dfaad28229b"><td class="memItemLeft" align="right" valign="top">map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, vcflib::Variant &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a12f5208ae9a2f22a31658dfaad28229b">get_node_id_to_variant</a> (vcflib::VariantCallFile vfile)</td></tr>
<tr class="separator:a12f5208ae9a2f22a31658dfaad28229b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c8fe573ad9ea52634a7e7421c143de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a40c8fe573ad9ea52634a7e7421c143de">dice_nodes</a> (int max_node_size)</td></tr>
<tr class="memdesc:a40c8fe573ad9ea52634a7e7421c143de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chop up the nodes.  <a href="#a40c8fe573ad9ea52634a7e7421c143de">More...</a><br/></td></tr>
<tr class="separator:a40c8fe573ad9ea52634a7e7421c143de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998cfb17a4433f05a1579f0d704208a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a998cfb17a4433f05a1579f0d704208a6">unchop</a> (void)</td></tr>
<tr class="memdesc:a998cfb17a4433f05a1579f0d704208a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the reverse &mdash; combines nodes by removing edges where doing so has no effect on the graph labels.  <a href="#a998cfb17a4433f05a1579f0d704208a6">More...</a><br/></td></tr>
<tr class="separator:a998cfb17a4433f05a1579f0d704208a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0dcdbceae7ad22b60e4966e9644b612"><td class="memItemLeft" align="right" valign="top">set&lt; list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad0dcdbceae7ad22b60e4966e9644b612">simple_components</a> (int min_size=1)</td></tr>
<tr class="separator:ad0dcdbceae7ad22b60e4966e9644b612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff96e1df8d63362f110efa996d817e1"><td class="memItemLeft" align="right" valign="top">set&lt; list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#adff96e1df8d63362f110efa996d817e1">simple_multinode_components</a> (void)</td></tr>
<tr class="memdesc:adff96e1df8d63362f110efa996d817e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the simple components of multiple nodes.  <a href="#adff96e1df8d63362f110efa996d817e1">More...</a><br/></td></tr>
<tr class="separator:adff96e1df8d63362f110efa996d817e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab447b1c70f7c4dc6576bfabc1990c337"><td class="memItemLeft" align="right" valign="top">set&lt; set&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab447b1c70f7c4dc6576bfabc1990c337">strongly_connected_components</a> (void)</td></tr>
<tr class="memdesc:ab447b1c70f7c4dc6576bfabc1990c337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the strongly connected components of the graph.  <a href="#ab447b1c70f7c4dc6576bfabc1990c337">More...</a><br/></td></tr>
<tr class="separator:ab447b1c70f7c4dc6576bfabc1990c337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c034f10ebf2555f8a69564368be8f7"><td class="memItemLeft" align="right" valign="top">set&lt; set&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a21c034f10ebf2555f8a69564368be8f7">multinode_strongly_connected_components</a> (void)</td></tr>
<tr class="memdesc:a21c034f10ebf2555f8a69564368be8f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get only multi-node strongly connected components.  <a href="#a21c034f10ebf2555f8a69564368be8f7">More...</a><br/></td></tr>
<tr class="separator:a21c034f10ebf2555f8a69564368be8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71388f637b255bf16a940e735a12aacd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a71388f637b255bf16a940e735a12aacd">is_acyclic</a> (void)</td></tr>
<tr class="memdesc:a71388f637b255bf16a940e735a12aacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the graph does not contain cycles.  <a href="#a71388f637b255bf16a940e735a12aacd">More...</a><br/></td></tr>
<tr class="separator:a71388f637b255bf16a940e735a12aacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049393f32addf4071a14de2e874e94ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a049393f32addf4071a14de2e874e94ac">keep_multinode_strongly_connected_components</a> (void)</td></tr>
<tr class="memdesc:a049393f32addf4071a14de2e874e94ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all elements which are not in a strongly connected component.  <a href="#a049393f32addf4071a14de2e874e94ac">More...</a><br/></td></tr>
<tr class="separator:a049393f32addf4071a14de2e874e94ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09549b6cfab8e1097dd207e01e57812"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad09549b6cfab8e1097dd207e01e57812">is_self_looping</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:ad09549b6cfab8e1097dd207e01e57812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the specified node have any self-loops?  <a href="#ad09549b6cfab8e1097dd207e01e57812">More...</a><br/></td></tr>
<tr class="separator:ad09549b6cfab8e1097dd207e01e57812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310f10ff59e15468e8350844465f15e7"><td class="memItemLeft" align="right" valign="top">set&lt; list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a310f10ff59e15468e8350844465f15e7">elementary_cycles</a> (void)</td></tr>
<tr class="memdesc:a310f10ff59e15468e8350844465f15e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get simple cycles following Johnson's elementary cycles algorithm.  <a href="#a310f10ff59e15468e8350844465f15e7">More...</a><br/></td></tr>
<tr class="separator:a310f10ff59e15468e8350844465f15e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d37ff935d8881dcf03010187e1ceb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a64d37ff935d8881dcf03010187e1ceb3">concat_nodes</a> (const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;nodes)</td></tr>
<tr class="separator:a64d37ff935d8881dcf03010187e1ceb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9aa921b25ba77f37366768b4b090ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1f9aa921b25ba77f37366768b4b090ec">merge_nodes</a> (const list&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;nodes)</td></tr>
<tr class="separator:a1f9aa921b25ba77f37366768b4b090ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217f8b5abd62bcdb256cf15926c9fe5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a217f8b5abd62bcdb256cf15926c9fe5c">normalize</a> (int max_iter=1, bool debug=false)</td></tr>
<tr class="memdesc:a217f8b5abd62bcdb256cf15926c9fe5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use unchop and sibling merging to simplify the graph into a normalized form.  <a href="#a217f8b5abd62bcdb256cf15926c9fe5c">More...</a><br/></td></tr>
<tr class="separator:a217f8b5abd62bcdb256cf15926c9fe5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7604b2833cf3e0855c5c29619f4a270"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad7604b2833cf3e0855c5c29619f4a270">bluntify</a> (void)</td></tr>
<tr class="memdesc:ad7604b2833cf3e0855c5c29619f4a270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove redundant overlaps.  <a href="#ad7604b2833cf3e0855c5c29619f4a270">More...</a><br/></td></tr>
<tr class="separator:ad7604b2833cf3e0855c5c29619f4a270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7958e987d875acb903acabf9903a8a88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1VG.html">VG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7958e987d875acb903acabf9903a8a88">dagify</a> (uint32_t expand_scc_steps, unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;node_translation, size_t target_min_walk_length=0, size_t component_length_max=0)</td></tr>
<tr class="separator:a7958e987d875acb903acabf9903a8a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f838bd143f7909838bf2139b15576ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1VG.html">VG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a6f838bd143f7909838bf2139b15576ac">backtracking_unroll</a> (uint32_t max_length, uint32_t max_depth, unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;node_translation)</td></tr>
<tr class="memdesc:a6f838bd143f7909838bf2139b15576ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a new graph that unrolls the current one using backtracking. Caution: exponential in branching.  <a href="#a6f838bd143f7909838bf2139b15576ac">More...</a><br/></td></tr>
<tr class="separator:a6f838bd143f7909838bf2139b15576ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc568712b6d4aa3b6dc965f37cc769a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1VG.html">VG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#afc568712b6d4aa3b6dc965f37cc769a7">unfold</a> (uint32_t max_length, unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;node_translation)</td></tr>
<tr class="separator:afc568712b6d4aa3b6dc965f37cc769a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00287a092635fc711de1f0a82f66ae77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1VG.html">VG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a00287a092635fc711de1f0a82f66ae77">reverse_complement_graph</a> (unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;node_translation)</td></tr>
<tr class="memdesc:a00287a092635fc711de1f0a82f66ae77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the reverse complemented graph with topology preserved. Record translation in provided map.  <a href="#a00287a092635fc711de1f0a82f66ae77">More...</a><br/></td></tr>
<tr class="separator:a00287a092635fc711de1f0a82f66ae77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd7b9f01799a351e0e5ba420fa06679"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#abbd7b9f01799a351e0e5ba420fa06679">identity_translation</a> (unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;node_translation)</td></tr>
<tr class="memdesc:abbd7b9f01799a351e0e5ba420fa06679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record the translation of this graph into itself in the provided map.  <a href="#abbd7b9f01799a351e0e5ba420fa06679">More...</a><br/></td></tr>
<tr class="separator:abbd7b9f01799a351e0e5ba420fa06679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc72119c835adc52a935efca0bdda0b"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair<br class="typebreak"/>
&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7fc72119c835adc52a935efca0bdda0b">overlay_node_translations</a> (const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;over, const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;under)</td></tr>
<tr class="memdesc:a7fc72119c835adc52a935efca0bdda0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assume two node translations, the over is based on the under; merge them.  <a href="#a7fc72119c835adc52a935efca0bdda0b">More...</a><br/></td></tr>
<tr class="separator:a7fc72119c835adc52a935efca0bdda0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93cb2d6686e0bb92d7f0b632fc813702"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a93cb2d6686e0bb92d7f0b632fc813702">break_cycles</a> (void)</td></tr>
<tr class="separator:a93cb2d6686e0bb92d7f0b632fc813702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad517da731d2bf9c81cc28e0a1367af33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad517da731d2bf9c81cc28e0a1367af33">remove_non_path</a> (void)</td></tr>
<tr class="memdesc:ad517da731d2bf9c81cc28e0a1367af33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove pieces of the graph which are not part of any path.  <a href="#ad517da731d2bf9c81cc28e0a1367af33">More...</a><br/></td></tr>
<tr class="separator:ad517da731d2bf9c81cc28e0a1367af33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c369b4c1b0dfa4e9fbc0d3bce82648"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a30c369b4c1b0dfa4e9fbc0d3bce82648">remove_path</a> (void)</td></tr>
<tr class="memdesc:a30c369b4c1b0dfa4e9fbc0d3bce82648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove pieces of the graph which are part of some path.  <a href="#a30c369b4c1b0dfa4e9fbc0d3bce82648">More...</a><br/></td></tr>
<tr class="separator:a30c369b4c1b0dfa4e9fbc0d3bce82648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f160750dfed33c16a257bd5cbecddf"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a26f160750dfed33c16a257bd5cbecddf">get_path_edges</a> (void)</td></tr>
<tr class="memdesc:a26f160750dfed33c16a257bd5cbecddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all of the edges that are on any path.  <a href="#a26f160750dfed33c16a257bd5cbecddf">More...</a><br/></td></tr>
<tr class="separator:a26f160750dfed33c16a257bd5cbecddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5079416ab826cbc8a5eea3869eb892"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8e5079416ab826cbc8a5eea3869eb892">flip_doubly_reversed_edges</a> (void)</td></tr>
<tr class="memdesc:a8e5079416ab826cbc8a5eea3869eb892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert edges that are both from_start and to_end to "regular" ones from end to start.  <a href="#a8e5079416ab826cbc8a5eea3869eb892">More...</a><br/></td></tr>
<tr class="separator:a8e5079416ab826cbc8a5eea3869eb892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aef48163c0dd4267d24b629de8a04c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8aef48163c0dd4267d24b629de8a04c8">from_turtle</a> (string filename, string baseuri, bool showp=false)</td></tr>
<tr class="memdesc:a8aef48163c0dd4267d24b629de8a04c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a graph from a Turtle stream.  <a href="#a8aef48163c0dd4267d24b629de8a04c8">More...</a><br/></td></tr>
<tr class="separator:a8aef48163c0dd4267d24b629de8a04c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7513ddb88aeb58bd85a810c2a2ccdf67"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7513ddb88aeb58bd85a810c2a2ccdf67">~VG</a> (void)</td></tr>
<tr class="memdesc:a7513ddb88aeb58bd85a810c2a2ccdf67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a7513ddb88aeb58bd85a810c2a2ccdf67">More...</a><br/></td></tr>
<tr class="separator:a7513ddb88aeb58bd85a810c2a2ccdf67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3148455330df9ac055c6bd1eb7da3167"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3148455330df9ac055c6bd1eb7da3167">VG</a> (const <a class="el" href="classvg_1_1VG.html">VG</a> &amp;other)</td></tr>
<tr class="memdesc:a3148455330df9ac055c6bd1eb7da3167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a3148455330df9ac055c6bd1eb7da3167">More...</a><br/></td></tr>
<tr class="separator:a3148455330df9ac055c6bd1eb7da3167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8365ccd6a093ec50f7d54b1c7a7c672"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab8365ccd6a093ec50f7d54b1c7a7c672">VG</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:ab8365ccd6a093ec50f7d54b1c7a7c672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#ab8365ccd6a093ec50f7d54b1c7a7c672">More...</a><br/></td></tr>
<tr class="separator:ab8365ccd6a093ec50f7d54b1c7a7c672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f1fe88897cfe4d62625cffd3db5ebb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a46f1fe88897cfe4d62625cffd3db5ebb">operator=</a> (const <a class="el" href="classvg_1_1VG.html">VG</a> &amp;other)</td></tr>
<tr class="memdesc:a46f1fe88897cfe4d62625cffd3db5ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#a46f1fe88897cfe4d62625cffd3db5ebb">More...</a><br/></td></tr>
<tr class="separator:a46f1fe88897cfe4d62625cffd3db5ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3efbadb9fd3923bbc7e8f0b73c524f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3b3efbadb9fd3923bbc7e8f0b73c524f">operator=</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a3b3efbadb9fd3923bbc7e8f0b73c524f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="#a3b3efbadb9fd3923bbc7e8f0b73c524f">More...</a><br/></td></tr>
<tr class="separator:a3b3efbadb9fd3923bbc7e8f0b73c524f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f71911fe2c652dc11aec0a0d705b1e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7f71911fe2c652dc11aec0a0d705b1e4">build_indexes</a> (void)</td></tr>
<tr class="separator:a7f71911fe2c652dc11aec0a0d705b1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5156da43d4175597d7a8b1d88b5179af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5156da43d4175597d7a8b1d88b5179af">build_node_indexes</a> (void)</td></tr>
<tr class="separator:a5156da43d4175597d7a8b1d88b5179af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb2cb59474393ac822847033f185d17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3fb2cb59474393ac822847033f185d17">build_edge_indexes</a> (void)</td></tr>
<tr class="separator:a3fb2cb59474393ac822847033f185d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78095fb5d27e182c5cc4d5c10d3da39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa78095fb5d27e182c5cc4d5c10d3da39">build_indexes_no_init_size</a> (void)</td></tr>
<tr class="separator:aa78095fb5d27e182c5cc4d5c10d3da39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca442744267b08609887cd842ca543d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0ca442744267b08609887cd842ca543d">build_node_indexes_no_init_size</a> (void)</td></tr>
<tr class="separator:a0ca442744267b08609887cd842ca543d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63d4a22a3baa5b21623128b81a14872"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af63d4a22a3baa5b21623128b81a14872">build_edge_indexes_no_init_size</a> (void)</td></tr>
<tr class="separator:af63d4a22a3baa5b21623128b81a14872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212a2d1028f28046088a86e128b40559"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a212a2d1028f28046088a86e128b40559">clear_node_indexes</a> (void)</td></tr>
<tr class="separator:a212a2d1028f28046088a86e128b40559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51220e88887adf92d7cff25dad5cd91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af51220e88887adf92d7cff25dad5cd91">clear_node_indexes_no_resize</a> (void)</td></tr>
<tr class="separator:af51220e88887adf92d7cff25dad5cd91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d4b49633db2aef463e0070e0af64a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a10d4b49633db2aef463e0070e0af64a0">clear_edge_indexes</a> (void)</td></tr>
<tr class="separator:a10d4b49633db2aef463e0070e0af64a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5195712f8aa650417d93324ff1c89ecf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5195712f8aa650417d93324ff1c89ecf">clear_edge_indexes_no_resize</a> (void)</td></tr>
<tr class="separator:a5195712f8aa650417d93324ff1c89ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae960ce1d640fadc4772795f6d0ff5b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aae960ce1d640fadc4772795f6d0ff5b5">clear_indexes</a> (void)</td></tr>
<tr class="separator:aae960ce1d640fadc4772795f6d0ff5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103c69bad02121590779530338861374"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a103c69bad02121590779530338861374">clear_indexes_no_resize</a> (void)</td></tr>
<tr class="separator:a103c69bad02121590779530338861374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8879b1e6aab38b9a246deba0f05ccfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af8879b1e6aab38b9a246deba0f05ccfe">resize_indexes</a> (void)</td></tr>
<tr class="separator:af8879b1e6aab38b9a246deba0f05ccfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d4e45a9a410c451b1cad44ef7068ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a63d4e45a9a410c451b1cad44ef7068ad">rebuild_indexes</a> (void)</td></tr>
<tr class="separator:a63d4e45a9a410c451b1cad44ef7068ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6541146b6410cec4be3e2a7379ea3bcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a6541146b6410cec4be3e2a7379ea3bcf">rebuild_edge_indexes</a> (void)</td></tr>
<tr class="separator:a6541146b6410cec4be3e2a7379ea3bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0abc84684faea29b49032ec254d5e13b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0abc84684faea29b49032ec254d5e13b">merge</a> (<a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:a0abc84684faea29b49032ec254d5e13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Literally merge protobufs.  <a href="#a0abc84684faea29b49032ec254d5e13b">More...</a><br/></td></tr>
<tr class="separator:a0abc84684faea29b49032ec254d5e13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f22f6bb4a3e7a2aea7b3887237faec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a40f22f6bb4a3e7a2aea7b3887237faec">merge</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;g)</td></tr>
<tr class="memdesc:a40f22f6bb4a3e7a2aea7b3887237faec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Literally merge protobufs.  <a href="#a40f22f6bb4a3e7a2aea7b3887237faec">More...</a><br/></td></tr>
<tr class="separator:a40f22f6bb4a3e7a2aea7b3887237faec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e534461834b2937b7f0b0c2420b899"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa4e534461834b2937b7f0b0c2420b899">clear_paths</a> (void)</td></tr>
<tr class="memdesc:aa4e534461834b2937b7f0b0c2420b899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the paths object (which indexes the graph.paths) and the graph paths themselves.  <a href="#aa4e534461834b2937b7f0b0c2420b899">More...</a><br/></td></tr>
<tr class="separator:aa4e534461834b2937b7f0b0c2420b899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124188a9e0cd68c87c2bc009ea7bd799"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a124188a9e0cd68c87c2bc009ea7bd799">sync_paths</a> (void)</td></tr>
<tr class="memdesc:a124188a9e0cd68c87c2bc009ea7bd799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize in-memory indexes and protobuf graph.  <a href="#a124188a9e0cd68c87c2bc009ea7bd799">More...</a><br/></td></tr>
<tr class="separator:a124188a9e0cd68c87c2bc009ea7bd799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aff716eee0bf720b3836caa761d48be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5aff716eee0bf720b3836caa761d48be">merge_union</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;g)</td></tr>
<tr class="separator:a5aff716eee0bf720b3836caa761d48be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33424c3be8c3e088631dfb37c48773d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a33424c3be8c3e088631dfb37c48773d3">remove_duplicated_in</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;g)</td></tr>
<tr class="memdesc:a33424c3be8c3e088631dfb37c48773d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to merge_union.  <a href="#a33424c3be8c3e088631dfb37c48773d3">More...</a><br/></td></tr>
<tr class="separator:a33424c3be8c3e088631dfb37c48773d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9fb73c326ecfab70e35e44dff6a937"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aba9fb73c326ecfab70e35e44dff6a937">remove_duplicates</a> (void)</td></tr>
<tr class="memdesc:aba9fb73c326ecfab70e35e44dff6a937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove duplicated nodes and edges.  <a href="#aba9fb73c326ecfab70e35e44dff6a937">More...</a><br/></td></tr>
<tr class="separator:aba9fb73c326ecfab70e35e44dff6a937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea2fe244a857ff24d0176449bedd4ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a4ea2fe244a857ff24d0176449bedd4ad">prune_complex_paths</a> (int <a class="el" href="classvg_1_1VG.html#a23641dedefa2b6d573939515fcf5974c">length</a>, int edge_max, <a class="el" href="structvg_1_1Node.html">Node</a> *head_node, <a class="el" href="structvg_1_1Node.html">Node</a> *tail_node)</td></tr>
<tr class="separator:a4ea2fe244a857ff24d0176449bedd4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590703c2954a2a15d735995c2007a879"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a590703c2954a2a15d735995c2007a879">prune_short_subgraphs</a> (size_t min_size)</td></tr>
<tr class="separator:a590703c2954a2a15d735995c2007a879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95718abe48e846e03a845724b37a4622"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a95718abe48e846e03a845724b37a4622">serialize_to_function</a> (const function&lt; void(<a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;)&gt; &amp;emit, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> chunk_size=1000)</td></tr>
<tr class="separator:a95718abe48e846e03a845724b37a4622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21895abf98522a767df2fbee56824c72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a21895abf98522a767df2fbee56824c72">serialize_to_emitter</a> (<a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">vg::io::ProtobufEmitter</a>&lt; <a class="el" href="structvg_1_1Graph.html">Graph</a> &gt; &amp;emitter, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> chunk_size=1000)</td></tr>
<tr class="separator:a21895abf98522a767df2fbee56824c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab217740a8290f9706c260172f19ef221"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab217740a8290f9706c260172f19ef221">serialize_to_ostream</a> (ostream &amp;out, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> chunk_size=1000)</td></tr>
<tr class="separator:ab217740a8290f9706c260172f19ef221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8841bfa5a6c888820e6a29c8010e72fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8841bfa5a6c888820e6a29c8010e72fc">serialize_to_file</a> (const string &amp;file_name, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> chunk_size=1000)</td></tr>
<tr class="separator:a8841bfa5a6c888820e6a29c8010e72fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161ef56bd0eeee937602f60b8617f24d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a161ef56bd0eeee937602f60b8617f24d">compact_ids</a> (void)</td></tr>
<tr class="memdesc:a161ef56bd0eeee937602f60b8617f24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squish the node IDs down into as small a space as possible. Fixes up paths itself.  <a href="#a161ef56bd0eeee937602f60b8617f24d">More...</a><br/></td></tr>
<tr class="separator:a161ef56bd0eeee937602f60b8617f24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9faa901ab4d768d607454ffbfeac0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1d9faa901ab4d768d607454ffbfeac0f">compact_ids</a> (<a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &amp;new_id)</td></tr>
<tr class="separator:a1d9faa901ab4d768d607454ffbfeac0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522cc6a9721f305ab01ce823d843662d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a522cc6a9721f305ab01ce823d843662d">increment_node_ids</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> increment)</td></tr>
<tr class="memdesc:a522cc6a9721f305ab01ce823d843662d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the given value to all node IDs. Preserves the paths.  <a href="#a522cc6a9721f305ab01ce823d843662d">More...</a><br/></td></tr>
<tr class="separator:a522cc6a9721f305ab01ce823d843662d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356612f42ba60fe5895f3abe7501173a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a356612f42ba60fe5895f3abe7501173a">decrement_node_ids</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> decrement)</td></tr>
<tr class="memdesc:a356612f42ba60fe5895f3abe7501173a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract the given value from all the node IDs. Must not create a node with 0 or negative IDs. Invalidates the paths.  <a href="#a356612f42ba60fe5895f3abe7501173a">More...</a><br/></td></tr>
<tr class="separator:a356612f42ba60fe5895f3abe7501173a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8c9051591df60d405a8dc1006aa6d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0f8c9051591df60d405a8dc1006aa6d5">swap_node_id</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> node_id, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> new_id)</td></tr>
<tr class="separator:a0f8c9051591df60d405a8dc1006aa6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa906c5779ea372eb4dd0d9b8cc224be3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa906c5779ea372eb4dd0d9b8cc224be3">swap_node_id</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> new_id)</td></tr>
<tr class="separator:aa906c5779ea372eb4dd0d9b8cc224be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902d516631c77d074aa2a11ae70a6957"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a902d516631c77d074aa2a11ae70a6957">sort</a> ()</td></tr>
<tr class="separator:a902d516631c77d074aa2a11ae70a6957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1aecdffe7759a1e14248e00f2866b84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab1aecdffe7759a1e14248e00f2866b84">id_sort</a> ()</td></tr>
<tr class="memdesc:ab1aecdffe7759a1e14248e00f2866b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Order the backing graph data structure by node ID.  <a href="#ab1aecdffe7759a1e14248e00f2866b84">More...</a><br/></td></tr>
<tr class="separator:ab1aecdffe7759a1e14248e00f2866b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2519c3b939f48bca226e6fdea4c91f9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a2519c3b939f48bca226e6fdea4c91f9d">extend</a> (const <a class="el" href="classvg_1_1VG.html">VG</a> &amp;g, bool warn_on_duplicates=false)</td></tr>
<tr class="separator:a2519c3b939f48bca226e6fdea4c91f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e517214b33812b16f195a1f87841c0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5e517214b33812b16f195a1f87841c0d">extend</a> (const <a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;<a class="el" href="classvg_1_1VG.html#a4772c77ed932bfed4d21e247918381a4">graph</a>, bool warn_on_duplicates=false)</td></tr>
<tr class="separator:a5e517214b33812b16f195a1f87841c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5272032c1e57d839176fc8e39bd87e18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5272032c1e57d839176fc8e39bd87e18">append</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;g)</td></tr>
<tr class="separator:a5272032c1e57d839176fc8e39bd87e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d06218f137184c366de80df755ae001"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7d06218f137184c366de80df755ae001">combine</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;g)</td></tr>
<tr class="separator:a7d06218f137184c366de80df755ae001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e4dac76edcf0218f9749352c19acae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a66e4dac76edcf0218f9749352c19acae">include</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="memdesc:a66e4dac76edcf0218f9749352c19acae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit the graph to include the path.  <a href="#a66e4dac76edcf0218f9749352c19acae">More...</a><br/></td></tr>
<tr class="separator:a66e4dac76edcf0218f9749352c19acae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5962aa939727f27cb7c62b2ce2706fe9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5962aa939727f27cb7c62b2ce2706fe9">edit</a> (vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;paths_to_add, vector&lt; <a class="el" href="structvg_1_1Translation.html">Translation</a> &gt; *out_translations=nullptr, bool save_paths=false, bool update_paths=false, bool break_at_ends=false)</td></tr>
<tr class="separator:a5962aa939727f27cb7c62b2ce2706fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7818ca048287143e2b0e79136e453845"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7818ca048287143e2b0e79136e453845">edit</a> (istream &amp;paths_to_add, vector&lt; <a class="el" href="structvg_1_1Translation.html">Translation</a> &gt; *out_translations=nullptr, bool save_paths=false, ostream *out_path_stream=nullptr, bool break_at_ends=false, bool remove_softclips=false)</td></tr>
<tr class="separator:a7818ca048287143e2b0e79136e453845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f70eb7eddb0245be7cdfc048616638"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Translation.html">Translation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a78f70eb7eddb0245be7cdfc048616638">edit_fast</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;dangling, size_t max_node_size=1024)</td></tr>
<tr class="separator:a78f70eb7eddb0245be7cdfc048616638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e265ee441758d81fdb7c038e2fa8cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad3e265ee441758d81fdb7c038e2fa8cc">add_node</a> (const <a class="el" href="structvg_1_1Node.html">Node</a> &amp;node)</td></tr>
<tr class="memdesc:ad3e265ee441758d81fdb7c038e2fa8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in the given node, by value.  <a href="#ad3e265ee441758d81fdb7c038e2fa8cc">More...</a><br/></td></tr>
<tr class="separator:ad3e265ee441758d81fdb7c038e2fa8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71d30b767f067a874c933f13f6c34e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ae71d30b767f067a874c933f13f6c34e5">add_nodes</a> (const vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> &gt; &amp;nodes)</td></tr>
<tr class="memdesc:ae71d30b767f067a874c933f13f6c34e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in the given nodes, by value.  <a href="#ae71d30b767f067a874c933f13f6c34e5">More...</a><br/></td></tr>
<tr class="separator:ae71d30b767f067a874c933f13f6c34e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613c931c81518212917053d07e9bf8a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a613c931c81518212917053d07e9bf8a8">add_edge</a> (const <a class="el" href="structvg_1_1Edge.html">Edge</a> &amp;edge)</td></tr>
<tr class="memdesc:a613c931c81518212917053d07e9bf8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in the given edge, by value.  <a href="#a613c931c81518212917053d07e9bf8a8">More...</a><br/></td></tr>
<tr class="separator:a613c931c81518212917053d07e9bf8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f23cdd532ca7b8d3c0bb9cceff3d378"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7f23cdd532ca7b8d3c0bb9cceff3d378">add_edges</a> (const vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> &gt; &amp;edges)</td></tr>
<tr class="memdesc:a7f23cdd532ca7b8d3c0bb9cceff3d378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in the given edges, by value.  <a href="#a7f23cdd532ca7b8d3c0bb9cceff3d378">More...</a><br/></td></tr>
<tr class="separator:a7f23cdd532ca7b8d3c0bb9cceff3d378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679e39a7c1771c3ecc7204bd3b999583"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a679e39a7c1771c3ecc7204bd3b999583">add_edges</a> (const vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;edges)</td></tr>
<tr class="memdesc:a679e39a7c1771c3ecc7204bd3b999583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in the given edges, by value.  <a href="#a679e39a7c1771c3ecc7204bd3b999583">More...</a><br/></td></tr>
<tr class="separator:a679e39a7c1771c3ecc7204bd3b999583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab796330d50fdff47f5c080e251efea68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab796330d50fdff47f5c080e251efea68">add_nodes</a> (const set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;nodes)</td></tr>
<tr class="memdesc:ab796330d50fdff47f5c080e251efea68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in the given nodes, by value.  <a href="#ab796330d50fdff47f5c080e251efea68">More...</a><br/></td></tr>
<tr class="separator:ab796330d50fdff47f5c080e251efea68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8712eefbfd373c45f54d6bac8188c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#acb8712eefbfd373c45f54d6bac8188c6">add_edges</a> (const set&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;edges)</td></tr>
<tr class="memdesc:acb8712eefbfd373c45f54d6bac8188c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in the given edges, by value.  <a href="#acb8712eefbfd373c45f54d6bac8188c6">More...</a><br/></td></tr>
<tr class="separator:acb8712eefbfd373c45f54d6bac8188c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a94aeff38cf579243532fde605260a2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8a94aeff38cf579243532fde605260a2">node_count</a> (void) const </td></tr>
<tr class="memdesc:a8a94aeff38cf579243532fde605260a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of nodes in the graph.  <a href="#a8a94aeff38cf579243532fde605260a2">More...</a><br/></td></tr>
<tr class="separator:a8a94aeff38cf579243532fde605260a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe56e78d2178e689e623a35fcbdff2f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7fe56e78d2178e689e623a35fcbdff2f">edge_count</a> (void) const </td></tr>
<tr class="memdesc:a7fe56e78d2178e689e623a35fcbdff2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of edges in the graph.  <a href="#a7fe56e78d2178e689e623a35fcbdff2f">More...</a><br/></td></tr>
<tr class="separator:a7fe56e78d2178e689e623a35fcbdff2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab928179a1a4c5a535aefab8cda99c591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab928179a1a4c5a535aefab8cda99c591">total_length_of_nodes</a> (void)</td></tr>
<tr class="separator:ab928179a1a4c5a535aefab8cda99c591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0202180fa7153f464c3b1d3ff70dc9cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0202180fa7153f464c3b1d3ff70dc9cb">node_rank</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a0202180fa7153f464c3b1d3ff70dc9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the rank of the node in the protobuf array that backs the graph.  <a href="#a0202180fa7153f464c3b1d3ff70dc9cb">More...</a><br/></td></tr>
<tr class="separator:a0202180fa7153f464c3b1d3ff70dc9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa564542c73b2b800a4fa42e591c1879f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa564542c73b2b800a4fa42e591c1879f">node_rank</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:aa564542c73b2b800a4fa42e591c1879f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the rank of the node in the protobuf array that backs the graph.  <a href="#aa564542c73b2b800a4fa42e591c1879f">More...</a><br/></td></tr>
<tr class="separator:aa564542c73b2b800a4fa42e591c1879f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff00edd627e3445eee7f43927bb1518"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1ff00edd627e3445eee7f43927bb1518">start_degree</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a1ff00edd627e3445eee7f43927bb1518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges attached to the start of a node.  <a href="#a1ff00edd627e3445eee7f43927bb1518">More...</a><br/></td></tr>
<tr class="separator:a1ff00edd627e3445eee7f43927bb1518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cf82dca43799a03d93b199133f1d4b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af3cf82dca43799a03d93b199133f1d4b">end_degree</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:af3cf82dca43799a03d93b199133f1d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges attached to the end of a node.  <a href="#af3cf82dca43799a03d93b199133f1d4b">More...</a><br/></td></tr>
<tr class="separator:af3cf82dca43799a03d93b199133f1d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ac6e61dfa9350459dbb9586088c4a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af9ac6e61dfa9350459dbb9586088c4a5">left_degree</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> node)</td></tr>
<tr class="memdesc:af9ac6e61dfa9350459dbb9586088c4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges attached to the left side of a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>.  <a href="#af9ac6e61dfa9350459dbb9586088c4a5">More...</a><br/></td></tr>
<tr class="separator:af9ac6e61dfa9350459dbb9586088c4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23622195177dff4c7c8416edffb7fc93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a23622195177dff4c7c8416edffb7fc93">right_degree</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> node)</td></tr>
<tr class="memdesc:a23622195177dff4c7c8416edffb7fc93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges attached to the right side of a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>.  <a href="#a23622195177dff4c7c8416edffb7fc93">More...</a><br/></td></tr>
<tr class="separator:a23622195177dff4c7c8416edffb7fc93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6a5e92afb1a70d9c63a1848a01f241"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5b6a5e92afb1a70d9c63a1848a01f241">edges_of_node</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;edges)</td></tr>
<tr class="separator:a5b6a5e92afb1a70d9c63a1848a01f241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bf5492e5c6d586cd266d2a48f792df"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa1bf5492e5c6d586cd266d2a48f792df">edges_of</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:aa1bf5492e5c6d586cd266d2a48f792df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edges of the specified node.  <a href="#aa1bf5492e5c6d586cd266d2a48f792df">More...</a><br/></td></tr>
<tr class="separator:aa1bf5492e5c6d586cd266d2a48f792df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a7e0aa663eadc0ebdaaf13b667323e"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ae1a7e0aa663eadc0ebdaaf13b667323e">edges_from</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:ae1a7e0aa663eadc0ebdaaf13b667323e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edges from the specified node.  <a href="#ae1a7e0aa663eadc0ebdaaf13b667323e">More...</a><br/></td></tr>
<tr class="separator:ae1a7e0aa663eadc0ebdaaf13b667323e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3789cf6561f2d3da5ef85f23b5c6454f"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3789cf6561f2d3da5ef85f23b5c6454f">edges_to</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a3789cf6561f2d3da5ef85f23b5c6454f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edges to the specified node.  <a href="#a3789cf6561f2d3da5ef85f23b5c6454f">More...</a><br/></td></tr>
<tr class="separator:a3789cf6561f2d3da5ef85f23b5c6454f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2d900fc42cffe079c3ba3897717eae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3b2d900fc42cffe079c3ba3897717eae">edges_of_nodes</a> (set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;nodes, set&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;edges)</td></tr>
<tr class="memdesc:a3b2d900fc42cffe079c3ba3897717eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edges of the specified set of nodes, and add them to the given set of edge pointers.  <a href="#a3b2d900fc42cffe079c3ba3897717eae">More...</a><br/></td></tr>
<tr class="separator:a3b2d900fc42cffe079c3ba3897717eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a156ac1e1fde520bae82850105c6c66"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1a156ac1e1fde520bae82850105c6c66">sides_to</a> (<a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> side)</td></tr>
<tr class="memdesc:a1a156ac1e1fde520bae82850105c6c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sides on the other side of edges to this side of the node.  <a href="#a1a156ac1e1fde520bae82850105c6c66">More...</a><br/></td></tr>
<tr class="separator:a1a156ac1e1fde520bae82850105c6c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac670f3c729f93ebaa7c8bd5063225597"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac670f3c729f93ebaa7c8bd5063225597">sides_from</a> (<a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> side)</td></tr>
<tr class="memdesc:ac670f3c729f93ebaa7c8bd5063225597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sides on the other side of edges from this side of the node.  <a href="#ac670f3c729f93ebaa7c8bd5063225597">More...</a><br/></td></tr>
<tr class="separator:ac670f3c729f93ebaa7c8bd5063225597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63aa329381f85cffbb793d19a8b17b52"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a63aa329381f85cffbb793d19a8b17b52">sides_from</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:a63aa329381f85cffbb793d19a8b17b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sides from both sides of the node.  <a href="#a63aa329381f85cffbb793d19a8b17b52">More...</a><br/></td></tr>
<tr class="separator:a63aa329381f85cffbb793d19a8b17b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2b9b646282c9a466a531916213e867"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aee2b9b646282c9a466a531916213e867">sides_to</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:aee2b9b646282c9a466a531916213e867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sides to both sides of the node.  <a href="#aee2b9b646282c9a466a531916213e867">More...</a><br/></td></tr>
<tr class="separator:aee2b9b646282c9a466a531916213e867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030b75d2ad50905cc01fe4b7223cbb83"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a030b75d2ad50905cc01fe4b7223cbb83">sides_of</a> (<a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> side)</td></tr>
<tr class="memdesc:a030b75d2ad50905cc01fe4b7223cbb83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union of sides_to and sides_from.  <a href="#a030b75d2ad50905cc01fe4b7223cbb83">More...</a><br/></td></tr>
<tr class="separator:a030b75d2ad50905cc01fe4b7223cbb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a20098d0a29a1f3f0e9f932fcce462"><td class="memItemLeft" align="right" valign="top">set&lt; pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a21a20098d0a29a1f3f0e9f932fcce462">sides_context</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> node_id)</td></tr>
<tr class="memdesc:a21a20098d0a29a1f3f0e9f932fcce462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all sides connecting to this node.  <a href="#a21a20098d0a29a1f3f0e9f932fcce462">More...</a><br/></td></tr>
<tr class="separator:a21a20098d0a29a1f3f0e9f932fcce462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b7b580164861c1ced0b660bd4fa4c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a38b7b580164861c1ced0b660bd4fa4c4">same_context</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> id1, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> id2)</td></tr>
<tr class="memdesc:a38b7b580164861c1ced0b660bd4fa4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use sides_from an sides_to to determine if both nodes have the same context.  <a href="#a38b7b580164861c1ced0b660bd4fa4c4">More...</a><br/></td></tr>
<tr class="separator:a38b7b580164861c1ced0b660bd4fa4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7237af28b6fd3159ce048ec66679935c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7237af28b6fd3159ce048ec66679935c">is_ancestor_prev</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> node_id, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> candidate_id)</td></tr>
<tr class="memdesc:a7237af28b6fd3159ce048ec66679935c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the node is a prev ancestor of this one.  <a href="#a7237af28b6fd3159ce048ec66679935c">More...</a><br/></td></tr>
<tr class="separator:a7237af28b6fd3159ce048ec66679935c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9353f02748091b04439a26fda57f9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aec9353f02748091b04439a26fda57f9b">is_ancestor_prev</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> node_id, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> candidate_id, set&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &amp;seen, size_t steps=64)</td></tr>
<tr class="memdesc:aec9353f02748091b04439a26fda57f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the node is a prev ancestor of this one by trying to find it in a given number of steps.  <a href="#aec9353f02748091b04439a26fda57f9b">More...</a><br/></td></tr>
<tr class="separator:aec9353f02748091b04439a26fda57f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e98e20589f3f63de75f4dc63526562"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a65e98e20589f3f63de75f4dc63526562">is_ancestor_next</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> node_id, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> candidate_id)</td></tr>
<tr class="memdesc:a65e98e20589f3f63de75f4dc63526562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the node is a next ancestor of this one.  <a href="#a65e98e20589f3f63de75f4dc63526562">More...</a><br/></td></tr>
<tr class="separator:a65e98e20589f3f63de75f4dc63526562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837620e82b388581d91300a53c099574"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a837620e82b388581d91300a53c099574">is_ancestor_next</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> node_id, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> candidate_id, set&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &amp;seen, size_t steps=64)</td></tr>
<tr class="memdesc:a837620e82b388581d91300a53c099574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the node is a next ancestor of this one by trying to find it in a given number of steps.  <a href="#a837620e82b388581d91300a53c099574">More...</a><br/></td></tr>
<tr class="separator:a837620e82b388581d91300a53c099574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156ee8c5d3650f08ab4d806980d6926a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a156ee8c5d3650f08ab4d806980d6926a">common_ancestor_prev</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> id1, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> id2, size_t steps=64)</td></tr>
<tr class="memdesc:a156ee8c5d3650f08ab4d806980d6926a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find a common ancestor by walking back up to steps from the first node.  <a href="#a156ee8c5d3650f08ab4d806980d6926a">More...</a><br/></td></tr>
<tr class="separator:a156ee8c5d3650f08ab4d806980d6926a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d087adcf01ebfa68541bc6f487278e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a95d087adcf01ebfa68541bc6f487278e">common_ancestor_next</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> id1, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> id2, size_t steps=64)</td></tr>
<tr class="memdesc:a95d087adcf01ebfa68541bc6f487278e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find a common ancestor by walking forward up to steps from the first node.  <a href="#a95d087adcf01ebfa68541bc6f487278e">More...</a><br/></td></tr>
<tr class="separator:a95d087adcf01ebfa68541bc6f487278e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac7d4642b9bcc25bc5299af18f523bc"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#abac7d4642b9bcc25bc5299af18f523bc">siblings_to</a> (const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;traversal)</td></tr>
<tr class="memdesc:abac7d4642b9bcc25bc5299af18f523bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">To-siblings are nodes which also have edges to them from the same nodes as this one.  <a href="#abac7d4642b9bcc25bc5299af18f523bc">More...</a><br/></td></tr>
<tr class="separator:abac7d4642b9bcc25bc5299af18f523bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac684d17ffe4c85ce74a4677fdfaf7672"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac684d17ffe4c85ce74a4677fdfaf7672">siblings_from</a> (const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;traversal)</td></tr>
<tr class="memdesc:ac684d17ffe4c85ce74a4677fdfaf7672"><td class="mdescLeft">&#160;</td><td class="mdescRight">From-siblings are nodes which also have edges to them from the same nodes as this one.  <a href="#ac684d17ffe4c85ce74a4677fdfaf7672">More...</a><br/></td></tr>
<tr class="separator:ac684d17ffe4c85ce74a4677fdfaf7672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a79ae3ab132b28cf72b6c18644fcf2f"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0a79ae3ab132b28cf72b6c18644fcf2f">full_siblings_to</a> (const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;trav)</td></tr>
<tr class="memdesc:a0a79ae3ab132b28cf72b6c18644fcf2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full to-siblings are nodes traversals which share exactly the same upstream <code><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a></code>s.  <a href="#a0a79ae3ab132b28cf72b6c18644fcf2f">More...</a><br/></td></tr>
<tr class="separator:a0a79ae3ab132b28cf72b6c18644fcf2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2eb11662200dc88ef8397a1b2232056"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ae2eb11662200dc88ef8397a1b2232056">full_siblings_from</a> (const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;trav)</td></tr>
<tr class="memdesc:ae2eb11662200dc88ef8397a1b2232056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full from-siblings are nodes traversals which share exactly the same downstream <code><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a></code>s.  <a href="#ae2eb11662200dc88ef8397a1b2232056">More...</a><br/></td></tr>
<tr class="separator:ae2eb11662200dc88ef8397a1b2232056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f202743732e5335bb1b15413914eaa6"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5f202743732e5335bb1b15413914eaa6">siblings_of</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a5f202743732e5335bb1b15413914eaa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get general siblings of a node.  <a href="#a5f202743732e5335bb1b15413914eaa6">More...</a><br/></td></tr>
<tr class="separator:a5f202743732e5335bb1b15413914eaa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e90bd47ffc24a55b1588be8f5328717"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3e90bd47ffc24a55b1588be8f5328717">simplify_siblings</a> (void)</td></tr>
<tr class="separator:a3e90bd47ffc24a55b1588be8f5328717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c037db7f5ec45293ac6650d46040237"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5c037db7f5ec45293ac6650d46040237">simplify_to_siblings</a> (const set&lt; set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&gt; &amp;to_sibs)</td></tr>
<tr class="memdesc:a5c037db7f5ec45293ac6650d46040237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove easily-resolvable redundancy in the graph for all provided to-sibling sets.  <a href="#a5c037db7f5ec45293ac6650d46040237">More...</a><br/></td></tr>
<tr class="separator:a5c037db7f5ec45293ac6650d46040237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171c17f06d7bb0645776f466fe3d3a1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a171c17f06d7bb0645776f466fe3d3a1d">simplify_from_siblings</a> (const set&lt; set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&gt; &amp;from_sibs)</td></tr>
<tr class="memdesc:a171c17f06d7bb0645776f466fe3d3a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove easily-resolvable redundancy in the graph for all provided from-sibling sets.  <a href="#a171c17f06d7bb0645776f466fe3d3a1d">More...</a><br/></td></tr>
<tr class="separator:a171c17f06d7bb0645776f466fe3d3a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce50214291804f0d9bdf9bcd39125a4"><td class="memItemLeft" align="right" valign="top">set&lt; set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#afce50214291804f0d9bdf9bcd39125a4">transitive_sibling_sets</a> (const set&lt; set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&gt; &amp;sibs)</td></tr>
<tr class="memdesc:afce50214291804f0d9bdf9bcd39125a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove intransitive sibling sets, such as where (A, B, C) = S1 but C ∊ S2.  <a href="#afce50214291804f0d9bdf9bcd39125a4">More...</a><br/></td></tr>
<tr class="separator:afce50214291804f0d9bdf9bcd39125a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb33bdc43954b8acd955bb4425a48df1"><td class="memItemLeft" align="right" valign="top">set&lt; set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#acb33bdc43954b8acd955bb4425a48df1">identically_oriented_sibling_sets</a> (const set&lt; set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&gt; &amp;sibs)</td></tr>
<tr class="memdesc:acb33bdc43954b8acd955bb4425a48df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove sibling sets which don't have identical orientation.  <a href="#acb33bdc43954b8acd955bb4425a48df1">More...</a><br/></td></tr>
<tr class="separator:acb33bdc43954b8acd955bb4425a48df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab213a64c6240d08603530982c0b75047"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab213a64c6240d08603530982c0b75047">adjacent</a> (const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;pos1, const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;pos2)</td></tr>
<tr class="memdesc:ab213a64c6240d08603530982c0b75047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if pos1 occurs directly before pos2.  <a href="#ab213a64c6240d08603530982c0b75047">More...</a><br/></td></tr>
<tr class="separator:ab213a64c6240d08603530982c0b75047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb95ac1c24c5263a962c13f3d6bc0c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8cb95ac1c24c5263a962c13f3d6bc0c3">create_node</a> (const string &amp;seq)</td></tr>
<tr class="memdesc:a8cb95ac1c24c5263a962c13f3d6bc0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a node. Use the <a class="el" href="classvg_1_1VG.html">VG</a> class to generate ids.  <a href="#a8cb95ac1c24c5263a962c13f3d6bc0c3">More...</a><br/></td></tr>
<tr class="separator:a8cb95ac1c24c5263a962c13f3d6bc0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5736bb79bf9bcb96ea21c6945c61dcfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5736bb79bf9bcb96ea21c6945c61dcfb">create_node</a> (const string &amp;seq, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:a5736bb79bf9bcb96ea21c6945c61dcfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a node. Use a specified, nonzero node ID.  <a href="#a5736bb79bf9bcb96ea21c6945c61dcfb">More...</a><br/></td></tr>
<tr class="separator:a5736bb79bf9bcb96ea21c6945c61dcfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c1cef3ec020f0f494dbb0fd24deb7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a49c1cef3ec020f0f494dbb0fd24deb7c">get_node</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:a49c1cef3ec020f0f494dbb0fd24deb7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a particular node.  <a href="#a49c1cef3ec020f0f494dbb0fd24deb7c">More...</a><br/></td></tr>
<tr class="separator:a49c1cef3ec020f0f494dbb0fd24deb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceed581863f873d9b18e9a158e85e1f9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aceed581863f873d9b18e9a158e85e1f9">get_node</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>) const </td></tr>
<tr class="separator:aceed581863f873d9b18e9a158e85e1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44edad9ba2a6df332234b43715dd71db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a44edad9ba2a6df332234b43715dd71db">nonoverlapping_node_context_without_paths</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, <a class="el" href="classvg_1_1VG.html">VG</a> &amp;g)</td></tr>
<tr class="separator:a44edad9ba2a6df332234b43715dd71db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a525e3290d6968c79314c2500f13cc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a6a525e3290d6968c79314c2500f13cc3">expand_context</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;g, size_t distance, bool add_paths=true, bool use_steps=true)</td></tr>
<tr class="separator:a6a525e3290d6968c79314c2500f13cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4ead561b46cd1cde77ada1f611befa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aca4ead561b46cd1cde77ada1f611befa">expand_context_by_steps</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;g, size_t steps, bool add_paths=true)</td></tr>
<tr class="memdesc:aca4ead561b46cd1cde77ada1f611befa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand the context of the given graph by the given number of steps.  <a href="#aca4ead561b46cd1cde77ada1f611befa">More...</a><br/></td></tr>
<tr class="separator:aca4ead561b46cd1cde77ada1f611befa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba5a5416ee9eaf67c7ae5607fc7ae1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5ba5a5416ee9eaf67c7ae5607fc7ae1f">expand_context_by_length</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;g, size_t <a class="el" href="classvg_1_1VG.html#a23641dedefa2b6d573939515fcf5974c">length</a>, bool add_paths=true, bool reflect=false, const set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;barriers=set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt;())</td></tr>
<tr class="separator:a5ba5a5416ee9eaf67c7ae5607fc7ae1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9cd34f3c968f90370c42e8692222619"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab9cd34f3c968f90370c42e8692222619">destroy_node</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:ab9cd34f3c968f90370c42e8692222619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the node at the given pointer. This pointer must point to a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a> owned by the graph.  <a href="#ab9cd34f3c968f90370c42e8692222619">More...</a><br/></td></tr>
<tr class="separator:ab9cd34f3c968f90370c42e8692222619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9f662f9241f12249331c878ade136e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#acb9f662f9241f12249331c878ade136e">destroy_node</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:acb9f662f9241f12249331c878ade136e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the node with the given ID.  <a href="#acb9f662f9241f12249331c878ade136e">More...</a><br/></td></tr>
<tr class="separator:acb9f662f9241f12249331c878ade136e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c72c4989c1bebcec7e98115041b501"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a37c72c4989c1bebcec7e98115041b501">has_node</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>) const </td></tr>
<tr class="memdesc:a37c72c4989c1bebcec7e98115041b501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has a node with the given ID.  <a href="#a37c72c4989c1bebcec7e98115041b501">More...</a><br/></td></tr>
<tr class="separator:a37c72c4989c1bebcec7e98115041b501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9fb90202c77a6d104c634e2d2a3e62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aec9fb90202c77a6d104c634e2d2a3e62">has_node</a> (const <a class="el" href="structvg_1_1Node.html">Node</a> *node) const </td></tr>
<tr class="memdesc:aec9fb90202c77a6d104c634e2d2a3e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph contains the given node.  <a href="#aec9fb90202c77a6d104c634e2d2a3e62">More...</a><br/></td></tr>
<tr class="separator:aec9fb90202c77a6d104c634e2d2a3e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907734904cd304ecee0b432ed598d106"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a907734904cd304ecee0b432ed598d106">has_node</a> (const <a class="el" href="structvg_1_1Node.html">Node</a> &amp;node) const </td></tr>
<tr class="memdesc:a907734904cd304ecee0b432ed598d106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph contains the given node.  <a href="#a907734904cd304ecee0b432ed598d106">More...</a><br/></td></tr>
<tr class="separator:a907734904cd304ecee0b432ed598d106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04774a86b07508e9e5955abfba2171ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a04774a86b07508e9e5955abfba2171ff">find_node_by_name_or_add_new</a> (string <a class="el" href="classvg_1_1VG.html#a1f6fcd5a907e9bee524cf37a62ad5be2">name</a>)</td></tr>
<tr class="memdesc:a04774a86b07508e9e5955abfba2171ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a node with the given name, or create a new one if none is found.  <a href="#a04774a86b07508e9e5955abfba2171ff">More...</a><br/></td></tr>
<tr class="separator:a04774a86b07508e9e5955abfba2171ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af585f2161de09403d197e05fbcfb9a07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af585f2161de09403d197e05fbcfb9a07">for_each_node</a> (function&lt; void(<a class="el" href="structvg_1_1Node.html">Node</a> *)&gt; lambda)</td></tr>
<tr class="memdesc:af585f2161de09403d197e05fbcfb9a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the given function on every node.  <a href="#af585f2161de09403d197e05fbcfb9a07">More...</a><br/></td></tr>
<tr class="separator:af585f2161de09403d197e05fbcfb9a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8815f6165628d04e4dade8987aeeb22a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8815f6165628d04e4dade8987aeeb22a">for_each_node</a> (function&lt; void(const <a class="el" href="structvg_1_1Node.html">Node</a> *)&gt; lambda) const </td></tr>
<tr class="separator:a8815f6165628d04e4dade8987aeeb22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39790d52fe4c09804086d58164258fcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a39790d52fe4c09804086d58164258fcf">for_each_node_parallel</a> (function&lt; void(<a class="el" href="structvg_1_1Node.html">Node</a> *)&gt; lambda)</td></tr>
<tr class="memdesc:a39790d52fe4c09804086d58164258fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the given function on every node in parallel.  <a href="#a39790d52fe4c09804086d58164258fcf">More...</a><br/></td></tr>
<tr class="separator:a39790d52fe4c09804086d58164258fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892abc4056e30044ae9ce0db9e4871f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a892abc4056e30044ae9ce0db9e4871f0">for_each_connected_node</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, function&lt; void(<a class="el" href="structvg_1_1Node.html">Node</a> *)&gt; lambda)</td></tr>
<tr class="memdesc:a892abc4056e30044ae9ce0db9e4871f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Go through all the nodes in the same connected component as the given node. Ignores relative orientation.  <a href="#a892abc4056e30044ae9ce0db9e4871f0">More...</a><br/></td></tr>
<tr class="separator:a892abc4056e30044ae9ce0db9e4871f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0db609d022b3c3183403600970238f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aec0db609d022b3c3183403600970238f">dfs</a> (const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;node_begin_fn, const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;node_end_fn, const function&lt; bool(void)&gt; &amp;break_fn, const function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; &amp;edge_fn, const function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; &amp;tree_fn, const function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; &amp;edge_curr_fn, const function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; &amp;edge_cross_fn, const vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; *sources, const unordered_set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; *sinks)</td></tr>
<tr class="separator:aec0db609d022b3c3183403600970238f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287e5d12ba0bc0823d1b6e0fa56af3d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a287e5d12ba0bc0823d1b6e0fa56af3d6">dfs</a> (const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;node_begin_fn, const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;node_end_fn, const vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; *sources=NULL, const unordered_set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; *sinks=NULL)</td></tr>
<tr class="memdesc:a287e5d12ba0bc0823d1b6e0fa56af3d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of dfs for only handling nodes.  <a href="#a287e5d12ba0bc0823d1b6e0fa56af3d6">More...</a><br/></td></tr>
<tr class="separator:a287e5d12ba0bc0823d1b6e0fa56af3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee80f3ce939643d59157e1a1d707068"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8ee80f3ce939643d59157e1a1d707068">dfs</a> (const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;node_begin_fn, const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;node_end_fn, const function&lt; bool(void)&gt; &amp;break_fn)</td></tr>
<tr class="memdesc:a8ee80f3ce939643d59157e1a1d707068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of dfs for only handling nodes + break function.  <a href="#a8ee80f3ce939643d59157e1a1d707068">More...</a><br/></td></tr>
<tr class="separator:a8ee80f3ce939643d59157e1a1d707068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa778c3d1697c79aa924c5e4d1179a646"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa778c3d1697c79aa924c5e4d1179a646">empty</a> (void) const </td></tr>
<tr class="memdesc:aa778c3d1697c79aa924c5e4d1179a646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the graph empty?  <a href="#aa778c3d1697c79aa924c5e4d1179a646">More...</a><br/></td></tr>
<tr class="separator:aa778c3d1697c79aa924c5e4d1179a646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b75ca400f858be77b0716ab7c68dfcb"><td class="memItemLeft" align="right" valign="top">const string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a2b75ca400f858be77b0716ab7c68dfcb">hash</a> (void)</td></tr>
<tr class="memdesc:a2b75ca400f858be77b0716ab7c68dfcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a digest of the serialized graph.  <a href="#a2b75ca400f858be77b0716ab7c68dfcb">More...</a><br/></td></tr>
<tr class="separator:a2b75ca400f858be77b0716ab7c68dfcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b107027697644d771eb529037201f71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a9b107027697644d771eb529037201f71">remove_null_nodes</a> (void)</td></tr>
<tr class="separator:a9b107027697644d771eb529037201f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92694e7fd89275603c967739e60e0d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab92694e7fd89275603c967739e60e0d2">remove_node_forwarding_edges</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:ab92694e7fd89275603c967739e60e0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a node but connect all of its predecessor and successor nodes with new edges.  <a href="#ab92694e7fd89275603c967739e60e0d2">More...</a><br/></td></tr>
<tr class="separator:ab92694e7fd89275603c967739e60e0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e887a7b2cfc666f2210889a2dec791b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0e887a7b2cfc666f2210889a2dec791b">remove_null_nodes_forwarding_edges</a> (void)</td></tr>
<tr class="memdesc:a0e887a7b2cfc666f2210889a2dec791b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove null nodes but connect predecessors and successors, preserving structure.  <a href="#a0e887a7b2cfc666f2210889a2dec791b">More...</a><br/></td></tr>
<tr class="separator:a0e887a7b2cfc666f2210889a2dec791b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40dd9bc0458a4948afd676374ae8d1f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a40dd9bc0458a4948afd676374ae8d1f0">remove_orphan_edges</a> (void)</td></tr>
<tr class="memdesc:a40dd9bc0458a4948afd676374ae8d1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove edges for which one of the nodes is not present.  <a href="#a40dd9bc0458a4948afd676374ae8d1f0">More...</a><br/></td></tr>
<tr class="separator:a40dd9bc0458a4948afd676374ae8d1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76005ed499eea217c9f778028751137c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a76005ed499eea217c9f778028751137c">remove_inverting_edges</a> (void)</td></tr>
<tr class="memdesc:a76005ed499eea217c9f778028751137c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove edges representing an inversion and edges on the reverse complement.  <a href="#a76005ed499eea217c9f778028751137c">More...</a><br/></td></tr>
<tr class="separator:a76005ed499eea217c9f778028751137c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1dbb49df52e016746829776ca0f952"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8d1dbb49df52e016746829776ca0f952">has_inverting_edges</a> (void)</td></tr>
<tr class="memdesc:a8d1dbb49df52e016746829776ca0f952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has inversions.  <a href="#a8d1dbb49df52e016746829776ca0f952">More...</a><br/></td></tr>
<tr class="separator:a8d1dbb49df52e016746829776ca0f952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2aa9d438bcec4d7facbfcc44abea8fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac2aa9d438bcec4d7facbfcc44abea8fd">keep_paths</a> (const set&lt; string &gt; &amp;path_names, set&lt; string &gt; &amp;kept_names)</td></tr>
<tr class="separator:ac2aa9d438bcec4d7facbfcc44abea8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cc16f52f478a25e84c6f1fc2805915"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a65cc16f52f478a25e84c6f1fc2805915">keep_path</a> (const string &amp;path_name)</td></tr>
<tr class="separator:a65cc16f52f478a25e84c6f1fc2805915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1df72d85d8a72524b76abca972f33d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5f1df72d85d8a72524b76abca972f33d">path_edge_count</a> (list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;path, int32_t <a class="el" href="namespacevg.html#a416939020600ce2996331c350f1fe68c">offset</a>, int path_length)</td></tr>
<tr class="separator:a5f1df72d85d8a72524b76abca972f33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f45b42614f4ac36c8060634ec0d9805"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8f45b42614f4ac36c8060634ec0d9805">path_end_node_offset</a> (list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;path, int32_t <a class="el" href="namespacevg.html#a416939020600ce2996331c350f1fe68c">offset</a>, int path_length)</td></tr>
<tr class="separator:a8f45b42614f4ac36c8060634ec0d9805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871d05e0a2d0b76092e20fe86bd12e2b"><td class="memItemLeft" align="right" valign="top">const vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a871d05e0a2d0b76092e20fe86bd12e2b">paths_as_alignments</a> (void)</td></tr>
<tr class="memdesc:a871d05e0a2d0b76092e20fe86bd12e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the stored paths in this graph to alignments.  <a href="#a871d05e0a2d0b76092e20fe86bd12e2b">More...</a><br/></td></tr>
<tr class="separator:a871d05e0a2d0b76092e20fe86bd12e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce6fe02b243b4f0f82bbf801fd507fa"><td class="memItemLeft" align="right" valign="top">const string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a4ce6fe02b243b4f0f82bbf801fd507fa">path_sequence</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="memdesc:a4ce6fe02b243b4f0f82bbf801fd507fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return sequence string of path.  <a href="#a4ce6fe02b243b4f0f82bbf801fd507fa">More...</a><br/></td></tr>
<tr class="separator:a4ce6fe02b243b4f0f82bbf801fd507fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9bd4133841d1d781fb0df4171773139"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad9bd4133841d1d781fb0df4171773139">path_identity</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path1, const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path2)</td></tr>
<tr class="separator:ad9bd4133841d1d781fb0df4171773139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57296ecbcfce10f95b86233e10c35d7d"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a57296ecbcfce10f95b86233e10c35d7d">trav_sequence</a> (const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;trav)</td></tr>
<tr class="memdesc:a57296ecbcfce10f95b86233e10c35d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sequence of a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>.  <a href="#a57296ecbcfce10f95b86233e10c35d7d">More...</a><br/></td></tr>
<tr class="separator:a57296ecbcfce10f95b86233e10c35d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8d1d0b977473d9c5b1b0ffa304a338"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1f8d1d0b977473d9c5b1b0ffa304a338">get_node_at_nucleotide</a> (string pathname, int nuc)</td></tr>
<tr class="separator:a1f8d1d0b977473d9c5b1b0ffa304a338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecb9833a1b3e7d5ca41fcaa96000976"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8ecb9833a1b3e7d5ca41fcaa96000976">create_edge</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *from, <a class="el" href="structvg_1_1Node.html">Node</a> *to, bool from_start=false, bool to_end=false)</td></tr>
<tr class="separator:a8ecb9833a1b3e7d5ca41fcaa96000976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea0ac806a69899322f10155d5def595"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aaea0ac806a69899322f10155d5def595">create_edge</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> from, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> to, bool from_start=false, bool to_end=false)</td></tr>
<tr class="separator:aaea0ac806a69899322f10155d5def595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd0565d5133a239856444049783edcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8fd0565d5133a239856444049783edcd">create_edge</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> left, <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> right)</td></tr>
<tr class="separator:a8fd0565d5133a239856444049783edcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2cd4705aa5b919f349d02089c97cbc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac2cd4705aa5b919f349d02089c97cbc2">create_edge</a> (<a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> side1, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> side2)</td></tr>
<tr class="separator:ac2cd4705aa5b919f349d02089c97cbc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8668ddc84b9abe4fe9cb5acb3efd877b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8668ddc84b9abe4fe9cb5acb3efd877b">get_edge</a> (const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;side1, const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;side2)</td></tr>
<tr class="separator:a8668ddc84b9abe4fe9cb5acb3efd877b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227023072262f46f7c423d30cf8bc443"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a227023072262f46f7c423d30cf8bc443">get_edge</a> (const pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;sides)</td></tr>
<tr class="separator:a227023072262f46f7c423d30cf8bc443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63d7ba7b69594ee99f3ad99dd394171"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af63d7ba7b69594ee99f3ad99dd394171">get_edge</a> (const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;left, const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;right)</td></tr>
<tr class="memdesc:af63d7ba7b69594ee99f3ad99dd394171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edge connecting the given oriented nodes in the given order.  <a href="#af63d7ba7b69594ee99f3ad99dd394171">More...</a><br/></td></tr>
<tr class="separator:af63d7ba7b69594ee99f3ad99dd394171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284327157f9d4b82224fc856179a668d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a284327157f9d4b82224fc856179a668d">destroy_edge</a> (<a class="el" href="structvg_1_1Edge.html">Edge</a> *edge)</td></tr>
<tr class="memdesc:a284327157f9d4b82224fc856179a668d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the edge at the given pointer. This pointer must point to an edge owned by the graph.  <a href="#a284327157f9d4b82224fc856179a668d">More...</a><br/></td></tr>
<tr class="separator:a284327157f9d4b82224fc856179a668d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6b91020abf39815d28995eceac4e2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#abe6b91020abf39815d28995eceac4e2d">destroy_edge</a> (const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;side1, const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;side2)</td></tr>
<tr class="memdesc:abe6b91020abf39815d28995eceac4e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the edge between the given sides of nodes. These can be in either order.  <a href="#abe6b91020abf39815d28995eceac4e2d">More...</a><br/></td></tr>
<tr class="separator:abe6b91020abf39815d28995eceac4e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd2744b37b62862df68e82cbe7b6b59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7fd2744b37b62862df68e82cbe7b6b59">destroy_edge</a> (const pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;sides)</td></tr>
<tr class="memdesc:a7fd2744b37b62862df68e82cbe7b6b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the edge between the given sides of nodes. This can take sides in any order.  <a href="#a7fd2744b37b62862df68e82cbe7b6b59">More...</a><br/></td></tr>
<tr class="separator:a7fd2744b37b62862df68e82cbe7b6b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0b7db8d3043747e8b9a44cba4eaac9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1c0b7db8d3043747e8b9a44cba4eaac9">unindex_edge_by_node_sides</a> (const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;side1, const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;side2)</td></tr>
<tr class="separator:a1c0b7db8d3043747e8b9a44cba4eaac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5677da9ff22052f6c6a85bfe66e1256d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5677da9ff22052f6c6a85bfe66e1256d">unindex_edge_by_node_sides</a> (<a class="el" href="structvg_1_1Edge.html">Edge</a> *edge)</td></tr>
<tr class="separator:a5677da9ff22052f6c6a85bfe66e1256d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ff7033966852f5fb3852716cab21a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a53ff7033966852f5fb3852716cab21a9">index_edge_by_node_sides</a> (<a class="el" href="structvg_1_1Edge.html">Edge</a> *edge)</td></tr>
<tr class="separator:a53ff7033966852f5fb3852716cab21a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f57fbc3cca245bce36c7bb1321333c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a78f57fbc3cca245bce36c7bb1321333c">has_edge</a> (const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;side1, const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;side2) const </td></tr>
<tr class="memdesc:a78f57fbc3cca245bce36c7bb1321333c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edge between the given node sides, which can be in either order.  <a href="#a78f57fbc3cca245bce36c7bb1321333c">More...</a><br/></td></tr>
<tr class="separator:a78f57fbc3cca245bce36c7bb1321333c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19fd9594b3b8092070ebe1b0ab430863"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a19fd9594b3b8092070ebe1b0ab430863">has_edge</a> (const pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;sides) const </td></tr>
<tr class="memdesc:a19fd9594b3b8092070ebe1b0ab430863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has an edge. This can take sides in any order.  <a href="#a19fd9594b3b8092070ebe1b0ab430863">More...</a><br/></td></tr>
<tr class="separator:a19fd9594b3b8092070ebe1b0ab430863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cccef0336502dcefd497b63a0e9f545"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a6cccef0336502dcefd497b63a0e9f545">has_edge</a> (<a class="el" href="structvg_1_1Edge.html">Edge</a> *edge) const </td></tr>
<tr class="memdesc:a6cccef0336502dcefd497b63a0e9f545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has an edge. This can take sides in any order.  <a href="#a6cccef0336502dcefd497b63a0e9f545">More...</a><br/></td></tr>
<tr class="separator:a6cccef0336502dcefd497b63a0e9f545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a8d5301a328b3046570bdf134b9194"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a04a8d5301a328b3046570bdf134b9194">has_edge</a> (const <a class="el" href="structvg_1_1Edge.html">Edge</a> &amp;edge) const </td></tr>
<tr class="memdesc:a04a8d5301a328b3046570bdf134b9194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has an edge. This can take sides in any order.  <a href="#a04a8d5301a328b3046570bdf134b9194">More...</a><br/></td></tr>
<tr class="separator:a04a8d5301a328b3046570bdf134b9194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49fb4de3494407b800c3efda254851cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a49fb4de3494407b800c3efda254851cf">has_inverting_edge</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *n)</td></tr>
<tr class="memdesc:a49fb4de3494407b800c3efda254851cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has an inverting edge on the given node.  <a href="#a49fb4de3494407b800c3efda254851cf">More...</a><br/></td></tr>
<tr class="separator:a49fb4de3494407b800c3efda254851cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7bbf066c6608211e7527ba50b23e48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7b7bbf066c6608211e7527ba50b23e48">has_inverting_edge_from</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *n)</td></tr>
<tr class="memdesc:a7b7bbf066c6608211e7527ba50b23e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has an inverting edge from the given node.  <a href="#a7b7bbf066c6608211e7527ba50b23e48">More...</a><br/></td></tr>
<tr class="separator:a7b7bbf066c6608211e7527ba50b23e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63088ee0039a8e1f5cf6b5a3b23f745a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a63088ee0039a8e1f5cf6b5a3b23f745a">has_inverting_edge_to</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *n)</td></tr>
<tr class="memdesc:a63088ee0039a8e1f5cf6b5a3b23f745a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has an inverting edge to the given node.  <a href="#a63088ee0039a8e1f5cf6b5a3b23f745a">More...</a><br/></td></tr>
<tr class="separator:a63088ee0039a8e1f5cf6b5a3b23f745a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7fdd8c951cbf8b25e116435b5e1e0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3d7fdd8c951cbf8b25e116435b5e1e0e">for_each_edge</a> (function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; lambda)</td></tr>
<tr class="memdesc:a3d7fdd8c951cbf8b25e116435b5e1e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the given function for each edge.  <a href="#a3d7fdd8c951cbf8b25e116435b5e1e0e">More...</a><br/></td></tr>
<tr class="separator:a3d7fdd8c951cbf8b25e116435b5e1e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd448b5f9115c64efdd6514cbf05ae0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0bd448b5f9115c64efdd6514cbf05ae0">for_each_edge</a> (function&lt; void(const <a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; lambda) const </td></tr>
<tr class="separator:a0bd448b5f9115c64efdd6514cbf05ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a20aa427767a27fd15d181ccca8c42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a46a20aa427767a27fd15d181ccca8c42">for_each_edge_parallel</a> (function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; lambda)</td></tr>
<tr class="memdesc:a46a20aa427767a27fd15d181ccca8c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the given function for each edge, in parallel.  <a href="#a46a20aa427767a27fd15d181ccca8c42">More...</a><br/></td></tr>
<tr class="separator:a46a20aa427767a27fd15d181ccca8c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeabcaa5e19486dbab418184a312d9777"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aeabcaa5e19486dbab418184a312d9777">circularize</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> head, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> tail)</td></tr>
<tr class="memdesc:aeabcaa5e19486dbab418184a312d9777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Circularize a subgraph / path using the head / tail nodes.  <a href="#aeabcaa5e19486dbab418184a312d9777">More...</a><br/></td></tr>
<tr class="separator:aeabcaa5e19486dbab418184a312d9777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96ff883534a13b28b18cd84dd094e72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad96ff883534a13b28b18cd84dd094e72">circularize</a> (vector&lt; string &gt; pathnames)</td></tr>
<tr class="separator:ad96ff883534a13b28b18cd84dd094e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68d2bfaa6627686967add4ca7fb5f4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad68d2bfaa6627686967add4ca7fb5f4c">connect_node_to_nodes</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> node, vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;nodes)</td></tr>
<tr class="separator:ad68d2bfaa6627686967add4ca7fb5f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8189716ecbb9eeeefec8be64e34a9e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab8189716ecbb9eeeefec8be64e34a9e3">connect_node_to_nodes</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;nodes, bool from_start=false)</td></tr>
<tr class="separator:ab8189716ecbb9eeeefec8be64e34a9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee6066424793dfcda9097419f03b568"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7ee6066424793dfcda9097419f03b568">connect_nodes_to_node</a> (vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;nodes, <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> node)</td></tr>
<tr class="separator:a7ee6066424793dfcda9097419f03b568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4db5878a40e8dc7d2d2b25ff62ff1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#acc4db5878a40e8dc7d2d2b25ff62ff1e">connect_nodes_to_node</a> (vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;nodes, <a class="el" href="structvg_1_1Node.html">Node</a> *node, bool to_end=false)</td></tr>
<tr class="memdesc:acc4db5878a40e8dc7d2d2b25ff62ff1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">connect nodes -&gt; node.  <a href="#acc4db5878a40e8dc7d2d2b25ff62ff1e">More...</a><br/></td></tr>
<tr class="separator:acc4db5878a40e8dc7d2d2b25ff62ff1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06f0fcad4bf5b1c29cf937a870a58b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad06f0fcad4bf5b1c29cf937a870a58b4">divide_node</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, int pos, <a class="el" href="structvg_1_1Node.html">Node</a> *&amp;left, <a class="el" href="structvg_1_1Node.html">Node</a> *&amp;right)</td></tr>
<tr class="separator:ad06f0fcad4bf5b1c29cf937a870a58b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bee7317e4f7e42d85d8e7ef8d07273a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7bee7317e4f7e42d85d8e7ef8d07273a">divide_node</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, vector&lt; int &gt; &amp;positions, vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;parts)</td></tr>
<tr class="memdesc:a7bee7317e4f7e42d85d8e7ef8d07273a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a node at a given internal position. This version works on a collection of internal positions, in linear time.  <a href="#a7bee7317e4f7e42d85d8e7ef8d07273a">More...</a><br/></td></tr>
<tr class="separator:a7bee7317e4f7e42d85d8e7ef8d07273a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce3b7afc274a50cd7b1296e64ca2f01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1ce3b7afc274a50cd7b1296e64ca2f01">divide_path</a> (map&lt; long, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &amp;path, long pos, <a class="el" href="structvg_1_1Node.html">Node</a> *&amp;left, <a class="el" href="structvg_1_1Node.html">Node</a> *&amp;right)</td></tr>
<tr class="memdesc:a1ce3b7afc274a50cd7b1296e64ca2f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a path at a position. Also invalidates stored rank information.  <a href="#a1ce3b7afc274a50cd7b1296e64ca2f01">More...</a><br/></td></tr>
<tr class="separator:a1ce3b7afc274a50cd7b1296e64ca2f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4e14a60334c2ba3ce3bed0e3fd0b91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5a4e14a60334c2ba3ce3bed0e3fd0b91">to_dot</a> (ostream &amp;out, vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; alignments={}, vector&lt; <a class="el" href="structvg_1_1Locus.html">Locus</a> &gt; loci={}, bool show_paths=false, bool walk_paths=false, bool annotate_paths=false, bool show_mappings=false, bool simple_mode=false, bool invert_edge_ports=false, bool color_variants=false, bool ultrabubble_labeling=false, bool skip_missing_nodes=false, bool ascii_labels=false, int random_seed=0)</td></tr>
<tr class="memdesc:a5a4e14a60334c2ba3ce3bed0e3fd0b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the graph to Dot format.  <a href="#a5a4e14a60334c2ba3ce3bed0e3fd0b91">More...</a><br/></td></tr>
<tr class="separator:a5a4e14a60334c2ba3ce3bed0e3fd0b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582500a3d49fe231faa49a5c2e467cc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a582500a3d49fe231faa49a5c2e467cc8">to_turtle</a> (ostream &amp;out, const string &amp;rdf_base_uri, bool precompress)</td></tr>
<tr class="memdesc:a582500a3d49fe231faa49a5c2e467cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the graph to Turtle format.  <a href="#a582500a3d49fe231faa49a5c2e467cc8">More...</a><br/></td></tr>
<tr class="separator:a582500a3d49fe231faa49a5c2e467cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77d93fdf76698460ce509ea5dcde954"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa77d93fdf76698460ce509ea5dcde954">is_valid</a> (bool check_nodes=true, bool check_edges=true, bool check_paths=true, bool check_orphans=true)</td></tr>
<tr class="memdesc:aa77d93fdf76698460ce509ea5dcde954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph is valid or not, according to the specified criteria.  <a href="#aa77d93fdf76698460ce509ea5dcde954">More...</a><br/></td></tr>
<tr class="separator:aa77d93fdf76698460ce509ea5dcde954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa402d1cf817f83ca44f72f6112b6a2e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa402d1cf817f83ca44f72f6112b6a2e3">swap_nodes</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *a, <a class="el" href="structvg_1_1Node.html">Node</a> *b)</td></tr>
<tr class="memdesc:aa402d1cf817f83ca44f72f6112b6a2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the given nodes. TODO: what does that mean?  <a href="#aa402d1cf817f83ca44f72f6112b6a2e3">More...</a><br/></td></tr>
<tr class="separator:aa402d1cf817f83ca44f72f6112b6a2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f24b80d7ed79ad7a9809ac3f7b4082d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8f24b80d7ed79ad7a9809ac3f7b4082d">align</a> (const string &amp;sequence, const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *aligner, bool traceback=true, bool acyclic_and_sorted=false, size_t max_query_graph_ratio=0, bool pinned_alignment=false, bool pin_left=false, bool banded_global=false, size_t band_padding_override=0, size_t max_span=0, size_t unroll_length=0, int xdrop_alignment=0, bool print_score_matrices=false)</td></tr>
<tr class="separator:a8f24b80d7ed79ad7a9809ac3f7b4082d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e58e78f2c3d5033ffc02b5d5389c46d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5e58e78f2c3d5033ffc02b5d5389c46d">align</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *aligner, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, bool traceback=true, bool acyclic_and_sorted=false, size_t max_query_graph_ratio=0, bool pinned_alignment=false, bool pin_left=false, bool banded_global=false, size_t band_padding_override=0, size_t max_span=0, size_t unroll_length=0, int xdrop_alignment=0, bool print_score_matrices=false)</td></tr>
<tr class="separator:a5e58e78f2c3d5033ffc02b5d5389c46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1947220a8a504f0e6fad4fdcde7e89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a4a1947220a8a504f0e6fad4fdcde7e89">align</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *aligner, bool traceback=true, bool acyclic_and_sorted=false, size_t max_query_graph_ratio=0, bool pinned_alignment=false, bool pin_left=false, bool banded_global=false, size_t band_padding_override=0, size_t max_span=0, size_t unroll_length=0, int xdrop_alignment=0, bool print_score_matrices=false)</td></tr>
<tr class="separator:a4a1947220a8a504f0e6fad4fdcde7e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d06935a63b52f2fea5246fde4dd8eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab3d06935a63b52f2fea5246fde4dd8eb">align</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, bool traceback=true, bool acyclic_and_sorted=false, size_t max_query_graph_ratio=0, bool pinned_alignment=false, bool pin_left=false, bool banded_global=false, size_t band_padding_override=0, size_t max_span=0, size_t unroll_length=0, int xdrop_alignment=0, bool print_score_matrices=false)</td></tr>
<tr class="separator:ab3d06935a63b52f2fea5246fde4dd8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb76637f82e514ee554fc998e4e827c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0bb76637f82e514ee554fc998e4e827c">align</a> (const string &amp;sequence, bool traceback=true, bool acyclic_and_sorted=false, size_t max_query_graph_ratio=0, bool pinned_alignment=false, bool pin_left=false, bool banded_global=false, size_t band_padding_override=0, size_t max_span=0, size_t unroll_length=0, int xdrop_alignment=0, bool print_score_matrices=false)</td></tr>
<tr class="separator:a0bb76637f82e514ee554fc998e4e827c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58925d956fd726d5cbac6a3f0106dd9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a58925d956fd726d5cbac6a3f0106dd9f">align_qual_adjusted</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *qual_adj_aligner, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, bool traceback=true, bool acyclic_and_sorted=false, size_t max_query_graph_ratio=0, bool pinned_alignment=false, bool pin_left=false, bool banded_global=false, size_t band_padding_override=0, size_t max_span=0, size_t unroll_length=0, int xdrop_alignment=0, bool print_score_matrices=false)</td></tr>
<tr class="separator:a58925d956fd726d5cbac6a3f0106dd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf8bcbe1bac3e98422d36bf6a59b742"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#afbf8bcbe1bac3e98422d36bf6a59b742">align_qual_adjusted</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *qual_adj_aligner, bool traceback=true, bool acyclic_and_sorted=false, size_t max_query_graph_ratio=0, bool pinned_alignment=false, bool pin_left=false, bool banded_global=false, size_t band_padding_override=0, size_t max_span=0, size_t unroll_length=0, int xdrop_alignment=0, bool print_score_matrices=false)</td></tr>
<tr class="separator:afbf8bcbe1bac3e98422d36bf6a59b742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac13deb51cd8e7a47ea817ef12a2a3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aaac13deb51cd8e7a47ea817ef12a2a3a">align_qual_adjusted</a> (const string &amp;sequence, const <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *qual_adj_aligner, bool traceback=true, bool acyclic_and_sorted=false, size_t max_query_graph_ratio=0, bool pinned_alignment=false, bool pin_left=false, bool banded_global=false, size_t band_padding_override=0, size_t max_span=0, size_t unroll_length=0, int xdrop_alignment=0, bool print_score_matrices=false)</td></tr>
<tr class="separator:aaac13deb51cd8e7a47ea817ef12a2a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc8d762d07088089247b632c835a19d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8dc8d762d07088089247b632c835a19d">paths_between</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *from, <a class="el" href="structvg_1_1Node.html">Node</a> *to, vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;<a class="el" href="classvg_1_1VG.html#a7c5150aba84e7ed2bde7986462a79989">paths</a>)</td></tr>
<tr class="separator:a8dc8d762d07088089247b632c835a19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39a51572be3a442165d50e555e325ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af39a51572be3a442165d50e555e325ce">paths_between</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> from, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> to, vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;<a class="el" href="classvg_1_1VG.html#a7c5150aba84e7ed2bde7986462a79989">paths</a>)</td></tr>
<tr class="separator:af39a51572be3a442165d50e555e325ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5821862279a350885f5368a54a5cba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ada5821862279a350885f5368a54a5cba">likelihoods</a> (vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;alignments, vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;<a class="el" href="classvg_1_1VG.html#a7c5150aba84e7ed2bde7986462a79989">paths</a>, vector&lt; long double &gt; &amp;likelihoods)</td></tr>
<tr class="separator:ada5821862279a350885f5368a54a5cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08e778396904ad3b3f20f605f54628d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac08e778396904ad3b3f20f605f54628d">nodes_prev</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> n, vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;nodes)</td></tr>
<tr class="memdesc:ac08e778396904ad3b3f20f605f54628d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nodes attached to the left side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>, in their proper orientations.  <a href="#ac08e778396904ad3b3f20f605f54628d">More...</a><br/></td></tr>
<tr class="separator:ac08e778396904ad3b3f20f605f54628d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3e69ced0c3135f3f363c14bf752aad"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0f3e69ced0c3135f3f363c14bf752aad">nodes_prev</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> n)</td></tr>
<tr class="memdesc:a0f3e69ced0c3135f3f363c14bf752aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nodes attached to the left side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>, in their proper orientations.  <a href="#a0f3e69ced0c3135f3f363c14bf752aad">More...</a><br/></td></tr>
<tr class="separator:a0f3e69ced0c3135f3f363c14bf752aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a962957210c079fa242b383d5c65de3"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0a962957210c079fa242b383d5c65de3">travs_to</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> node)</td></tr>
<tr class="memdesc:a0a962957210c079fa242b383d5c65de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get traversals before this node on the same strand. Same as nodes_prev but using set.  <a href="#a0a962957210c079fa242b383d5c65de3">More...</a><br/></td></tr>
<tr class="separator:a0a962957210c079fa242b383d5c65de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b084d958fd8069839884dc3a01ed745"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0b084d958fd8069839884dc3a01ed745">nodes_next</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> n, vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;nodes)</td></tr>
<tr class="memdesc:a0b084d958fd8069839884dc3a01ed745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nodes attached to the right side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>, in their proper orientations.  <a href="#a0b084d958fd8069839884dc3a01ed745">More...</a><br/></td></tr>
<tr class="separator:a0b084d958fd8069839884dc3a01ed745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f1bb7fa27d4d4312017b113aab099a"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a62f1bb7fa27d4d4312017b113aab099a">nodes_next</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> n)</td></tr>
<tr class="memdesc:a62f1bb7fa27d4d4312017b113aab099a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nodes attached to the right side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>, in their proper orientations.  <a href="#a62f1bb7fa27d4d4312017b113aab099a">More...</a><br/></td></tr>
<tr class="separator:a62f1bb7fa27d4d4312017b113aab099a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a493a0628857a3bfae181295ba541d"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a34a493a0628857a3bfae181295ba541d">travs_from</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> node)</td></tr>
<tr class="memdesc:a34a493a0628857a3bfae181295ba541d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get traversals after this node on the same strand. Same as nodes_next but using set.  <a href="#a34a493a0628857a3bfae181295ba541d">More...</a><br/></td></tr>
<tr class="separator:a34a493a0628857a3bfae181295ba541d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae065082f817e9bc0e278cf71f31af1e2"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ae065082f817e9bc0e278cf71f31af1e2">travs_of</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> node)</td></tr>
<tr class="memdesc:ae065082f817e9bc0e278cf71f31af1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get traversals either before or after this node on the same strand.  <a href="#ae065082f817e9bc0e278cf71f31af1e2">More...</a><br/></td></tr>
<tr class="separator:ae065082f817e9bc0e278cf71f31af1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1091113608fae5b9cbafc87cf4cf82a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1091113608fae5b9cbafc87cf4cf82a2">node_count_prev</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> n)</td></tr>
<tr class="memdesc:a1091113608fae5b9cbafc87cf4cf82a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the nodes attached to the left side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>.  <a href="#a1091113608fae5b9cbafc87cf4cf82a2">More...</a><br/></td></tr>
<tr class="separator:a1091113608fae5b9cbafc87cf4cf82a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c614759c77b4b0a95b25360c2fa1fa0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a4c614759c77b4b0a95b25360c2fa1fa0">node_count_next</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> n)</td></tr>
<tr class="memdesc:a4c614759c77b4b0a95b25360c2fa1fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the nodes attached to the right side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>.  <a href="#a4c614759c77b4b0a95b25360c2fa1fa0">More...</a><br/></td></tr>
<tr class="separator:a4c614759c77b4b0a95b25360c2fa1fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3195bfadb7e65e4952c4b98d51e862f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3195bfadb7e65e4952c4b98d51e862f1">create_path</a> (const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;nodes)</td></tr>
<tr class="memdesc:a3195bfadb7e65e4952c4b98d51e862f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a path.  <a href="#a3195bfadb7e65e4952c4b98d51e862f1">More...</a><br/></td></tr>
<tr class="separator:a3195bfadb7e65e4952c4b98d51e862f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc07ec73a57485a700e621517c962b8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#adc07ec73a57485a700e621517c962b8b">create_path</a> (const vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;nodes)</td></tr>
<tr class="memdesc:adc07ec73a57485a700e621517c962b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a path.  <a href="#adc07ec73a57485a700e621517c962b8b">More...</a><br/></td></tr>
<tr class="separator:adc07ec73a57485a700e621517c962b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f4e2ab506f4ef673836b5901bb3809"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af8f4e2ab506f4ef673836b5901bb3809">path_string</a> (const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;nodes)</td></tr>
<tr class="memdesc:af8f4e2ab506f4ef673836b5901bb3809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string sequence for all the NodeTraversals on the given path.  <a href="#af8f4e2ab506f4ef673836b5901bb3809">More...</a><br/></td></tr>
<tr class="separator:af8f4e2ab506f4ef673836b5901bb3809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927b79f3f4c9582b0f8e988bb4ef1aa1"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a927b79f3f4c9582b0f8e988bb4ef1aa1">path_string</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:a927b79f3f4c9582b0f8e988bb4ef1aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9273361525befc57536dc96a762c29d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa9273361525befc57536dc96a762c29d">expand_path</a> (const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;path, vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;expanded)</td></tr>
<tr class="memdesc:aa9273361525befc57536dc96a762c29d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a path. TODO: what does that mean?  <a href="#aa9273361525befc57536dc96a762c29d">More...</a><br/></td></tr>
<tr class="separator:aa9273361525befc57536dc96a762c29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093f4e4dffe0d03806df32edc33cdb9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a093f4e4dffe0d03806df32edc33cdb9a">node_starts_in_path</a> (const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;path, map&lt; <a class="el" href="structvg_1_1Node.html">Node</a> *, int &gt; &amp;<a class="el" href="namespacevg.html#a30f5b0dc3732e48a6d9b8d1c895cd8d1">node_start</a>)</td></tr>
<tr class="separator:a093f4e4dffe0d03806df32edc33cdb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf8c0e391c1a6c027ed26b991d8cad0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a9bf8c0e391c1a6c027ed26b991d8cad0">nodes_are_perfect_path_neighbors</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> left, <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> right)</td></tr>
<tr class="separator:a9bf8c0e391c1a6c027ed26b991d8cad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd555e66c8fa99984c8cb24aef0ab6f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#acd555e66c8fa99984c8cb24aef0ab6f9">mapping_is_total_match</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m)</td></tr>
<tr class="memdesc:acd555e66c8fa99984c8cb24aef0ab6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the mapping completely covers the node it maps to and is a perfect match.  <a href="#acd555e66c8fa99984c8cb24aef0ab6f9">More...</a><br/></td></tr>
<tr class="separator:acd555e66c8fa99984c8cb24aef0ab6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153260c1839238abff26b2e989d8799d"><td class="memItemLeft" align="right" valign="top">map&lt; string, vector&lt; <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a153260c1839238abff26b2e989d8799d">concat_mappings_for_node_pair</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> id1, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> id2)</td></tr>
<tr class="memdesc:a153260c1839238abff26b2e989d8799d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate the mappings for a pair of nodes; handles multiple mappings per path.  <a href="#a153260c1839238abff26b2e989d8799d">More...</a><br/></td></tr>
<tr class="separator:a153260c1839238abff26b2e989d8799d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2367b4d49cca4c57a2529d92512cba59"><td class="memItemLeft" align="right" valign="top">map&lt; string, vector&lt; <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a2367b4d49cca4c57a2529d92512cba59">concat_mappings_for_nodes</a> (const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;nodes)</td></tr>
<tr class="separator:a2367b4d49cca4c57a2529d92512cba59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae151983cac753c02ce3852274798f8d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ae151983cac753c02ce3852274798f8d5">expand_path</a> (list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;path, vector&lt; list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;::iterator &gt; &amp;expanded)</td></tr>
<tr class="separator:ae151983cac753c02ce3852274798f8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27c591957478a17605c2453749f7d20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac27c591957478a17605c2453749f7d20">node_starts_in_path</a> (list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;path, map&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> *, int &gt; &amp;<a class="el" href="namespacevg.html#a30f5b0dc3732e48a6d9b8d1c895cd8d1">node_start</a>)</td></tr>
<tr class="separator:ac27c591957478a17605c2453749f7d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4878ca3ebc2c14d008e57c7ae8d5845"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad4878ca3ebc2c14d008e57c7ae8d5845">prune_complex</a> (int path_length, int edge_max, <a class="el" href="structvg_1_1Node.html">Node</a> *head_node, <a class="el" href="structvg_1_1Node.html">Node</a> *tail_node)</td></tr>
<tr class="separator:ad4878ca3ebc2c14d008e57c7ae8d5845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0765f466db760a9a450f4d4115a59bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ae0765f466db760a9a450f4d4115a59bd">prune_complex_with_head_tail</a> (int path_length, int edge_max)</td></tr>
<tr class="separator:ae0765f466db760a9a450f4d4115a59bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec84f7813f59a16b2d0c1bd72904ae5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aec84f7813f59a16b2d0c1bd72904ae5b">random_read</a> (size_t read_len, mt19937 &amp;rng, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> min_id, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> max_id, bool either_strand)</td></tr>
<tr class="separator:aec84f7813f59a16b2d0c1bd72904ae5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31e90fe77a1d30244011dd8dbbf5f25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af31e90fe77a1d30244011dd8dbbf5f25">disjoint_subgraphs</a> (list&lt; <a class="el" href="classvg_1_1VG.html">VG</a> &gt; &amp;subgraphs)</td></tr>
<tr class="memdesc:af31e90fe77a1d30244011dd8dbbf5f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find subgraphs.  <a href="#af31e90fe77a1d30244011dd8dbbf5f25">More...</a><br/></td></tr>
<tr class="separator:af31e90fe77a1d30244011dd8dbbf5f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eecc0bd555c31d1c541c3ce44b421c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7eecc0bd555c31d1c541c3ce44b421c3">head_nodes</a> (vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;nodes)</td></tr>
<tr class="memdesc:a7eecc0bd555c31d1c541c3ce44b421c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the head nodes (nodes with edges only to their right sides). These are required to be oriented forward.  <a href="#a7eecc0bd555c31d1c541c3ce44b421c3">More...</a><br/></td></tr>
<tr class="separator:a7eecc0bd555c31d1c541c3ce44b421c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a44c415fb5882c184e2f35bb3999700"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3a44c415fb5882c184e2f35bb3999700">head_nodes</a> (void)</td></tr>
<tr class="memdesc:a3a44c415fb5882c184e2f35bb3999700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the head nodes (nodes with edges only to their right sides). These are required to be oriented forward.  <a href="#a3a44c415fb5882c184e2f35bb3999700">More...</a><br/></td></tr>
<tr class="separator:a3a44c415fb5882c184e2f35bb3999700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cdd8d94bcfce1302ba9e2cbfb5e412"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ae5cdd8d94bcfce1302ba9e2cbfb5e412">is_head_node</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:ae5cdd8d94bcfce1302ba9e2cbfb5e412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a node is a head node.  <a href="#ae5cdd8d94bcfce1302ba9e2cbfb5e412">More...</a><br/></td></tr>
<tr class="separator:ae5cdd8d94bcfce1302ba9e2cbfb5e412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc3866468d5eb941fa6ba010ccce2ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1bc3866468d5eb941fa6ba010ccce2ec">is_head_node</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a1bc3866468d5eb941fa6ba010ccce2ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a node is a head node.  <a href="#a1bc3866468d5eb941fa6ba010ccce2ec">More...</a><br/></td></tr>
<tr class="separator:a1bc3866468d5eb941fa6ba010ccce2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25bd74b77e139691555c8d48ecf67d9f"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a25bd74b77e139691555c8d48ecf67d9f">tail_nodes</a> (void)</td></tr>
<tr class="memdesc:a25bd74b77e139691555c8d48ecf67d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the tail nodes (nodes with edges only to their left sides). These are required to be oriented forward.  <a href="#a25bd74b77e139691555c8d48ecf67d9f">More...</a><br/></td></tr>
<tr class="separator:a25bd74b77e139691555c8d48ecf67d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fbc525ed5e9f2a7b00c333f03fe6c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a47fbc525ed5e9f2a7b00c333f03fe6c8">tail_nodes</a> (vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;nodes)</td></tr>
<tr class="memdesc:a47fbc525ed5e9f2a7b00c333f03fe6c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the tail nodes (nodes with edges only to their left sides). These are required to be oriented forward.  <a href="#a47fbc525ed5e9f2a7b00c333f03fe6c8">More...</a><br/></td></tr>
<tr class="separator:a47fbc525ed5e9f2a7b00c333f03fe6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b412ca09b09b3c0e07bcd5bd9ee03b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a40b412ca09b09b3c0e07bcd5bd9ee03b">is_tail_node</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:a40b412ca09b09b3c0e07bcd5bd9ee03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a node is a tail node.  <a href="#a40b412ca09b09b3c0e07bcd5bd9ee03b">More...</a><br/></td></tr>
<tr class="separator:a40b412ca09b09b3c0e07bcd5bd9ee03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58b227f21324d30be531088ed49b0f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af58b227f21324d30be531088ed49b0f1">is_tail_node</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:af58b227f21324d30be531088ed49b0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a node is a tail node.  <a href="#af58b227f21324d30be531088ed49b0f1">More...</a><br/></td></tr>
<tr class="separator:af58b227f21324d30be531088ed49b0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688cbe42750d98695114ad4ad640c1d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a688cbe42750d98695114ad4ad640c1d3">collect_subgraph</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;subgraph)</td></tr>
<tr class="memdesc:a688cbe42750d98695114ad4ad640c1d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the subgraph of a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a>. TODO: what does that mean?  <a href="#a688cbe42750d98695114ad4ad640c1d3">More...</a><br/></td></tr>
<tr class="separator:a688cbe42750d98695114ad4ad640c1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817384b8d147371448ad60e1db097b52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a817384b8d147371448ad60e1db097b52">join_heads</a> (void)</td></tr>
<tr class="memdesc:a817384b8d147371448ad60e1db097b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join head nodes of graph to common null node, creating a new single head.  <a href="#a817384b8d147371448ad60e1db097b52">More...</a><br/></td></tr>
<tr class="separator:a817384b8d147371448ad60e1db097b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc40377520118436b729cd68be16d0ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#adc40377520118436b729cd68be16d0ba">join_heads</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, bool from_start=false)</td></tr>
<tr class="memdesc:adc40377520118436b729cd68be16d0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join head nodes of graph to specified node. Optionally from the start/to the end of the new node.  <a href="#adc40377520118436b729cd68be16d0ba">More...</a><br/></td></tr>
<tr class="separator:adc40377520118436b729cd68be16d0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e3f7942afd3ca82bfb78083c245146"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a33e3f7942afd3ca82bfb78083c245146">join_tails</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, bool to_end=false)</td></tr>
<tr class="memdesc:a33e3f7942afd3ca82bfb78083c245146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join tail nodes of graph to specified node. Optionally from the start/to the end of the new node.  <a href="#a33e3f7942afd3ca82bfb78083c245146">More...</a><br/></td></tr>
<tr class="separator:a33e3f7942afd3ca82bfb78083c245146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2239c89d6ac7e9dec0d76325c2a68f97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a2239c89d6ac7e9dec0d76325c2a68f97">wrap_with_null_nodes</a> (void)</td></tr>
<tr class="memdesc:a2239c89d6ac7e9dec0d76325c2a68f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add singular head and tail null nodes to graph.  <a href="#a2239c89d6ac7e9dec0d76325c2a68f97">More...</a><br/></td></tr>
<tr class="separator:a2239c89d6ac7e9dec0d76325c2a68f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27730f354959a95c892c5ea5787fb687"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a27730f354959a95c892c5ea5787fb687">add_start_end_markers</a> (int <a class="el" href="classvg_1_1VG.html#a23641dedefa2b6d573939515fcf5974c">length</a>, char start_char, char end_char, <a class="el" href="structvg_1_1Node.html">Node</a> *&amp;start_node, <a class="el" href="structvg_1_1Node.html">Node</a> *&amp;end_node, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &amp;start_id, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &amp;end_id)</td></tr>
<tr class="separator:a27730f354959a95c892c5ea5787fb687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvg_1_1Progressive"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classvg_1_1Progressive')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvg_1_1Progressive.html">vg::Progressive</a></td></tr>
<tr class="memitem:a4eb5050eb36ed519cbfa398748ef183b inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#a4eb5050eb36ed519cbfa398748ef183b">preload_progress</a> (const string &amp;message)</td></tr>
<tr class="separator:a4eb5050eb36ed519cbfa398748ef183b inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cce3f715516ed2bbb4ce3a312b01e02 inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#a1cce3f715516ed2bbb4ce3a312b01e02">create_progress</a> (const string &amp;message, long count)</td></tr>
<tr class="separator:a1cce3f715516ed2bbb4ce3a312b01e02 inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d4e92a36a277be5bc0cee5d01f5ca1 inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#a75d4e92a36a277be5bc0cee5d01f5ca1">create_progress</a> (long count)</td></tr>
<tr class="separator:a75d4e92a36a277be5bc0cee5d01f5ca1 inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d64e6aa69bc094c163f4827602a302c inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#a0d64e6aa69bc094c163f4827602a302c">update_progress</a> (long i)</td></tr>
<tr class="separator:a0d64e6aa69bc094c163f4827602a302c inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1de11917caf25974a02e2f5c3946280 inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#ab1de11917caf25974a02e2f5c3946280">increment_progress</a> ()</td></tr>
<tr class="separator:ab1de11917caf25974a02e2f5c3946280 inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab8c6ae92870077bb59f86a15c8d18f inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#aaab8c6ae92870077bb59f86a15c8d18f">destroy_progress</a> (void)</td></tr>
<tr class="separator:aaab8c6ae92870077bb59f86a15c8d18f inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1MutablePathHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html">handlegraph::MutablePathHandleGraph</a></td></tr>
<tr class="memitem:a0873a6eb776bb2557a5b8453dbf13824 inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#a0873a6eb776bb2557a5b8453dbf13824">create_path_handle</a> (const std::string &amp;name, bool is_circular=false)=0</td></tr>
<tr class="separator:a0873a6eb776bb2557a5b8453dbf13824 inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28f1372aa6dad2654a22eb8463e2a07 inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual std::pair<br class="typebreak"/>
&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#af28f1372aa6dad2654a22eb8463e2a07">rewrite_segment</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;segment_begin, const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;segment_end, const std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;new_segment)=0</td></tr>
<tr class="separator:af28f1372aa6dad2654a22eb8463e2a07 inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1PathHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1PathHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">handlegraph::PathHandleGraph</a></td></tr>
<tr class="memitem:ab7de11c1e994bc104378c4b798013430 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#ab7de11c1e994bc104378c4b798013430">has_path</a> (const std::string &amp;path_name) const =0</td></tr>
<tr class="memdesc:ab7de11c1e994bc104378c4b798013430 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a path name exists and is legal to get a path handle for.  <a href="#ab7de11c1e994bc104378c4b798013430">More...</a><br/></td></tr>
<tr class="separator:ab7de11c1e994bc104378c4b798013430 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6059d716882a80e3982de17011866e inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a5d6059d716882a80e3982de17011866e">get_path_handle</a> (const std::string &amp;path_name) const =0</td></tr>
<tr class="separator:a5d6059d716882a80e3982de17011866e inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3313c420e4cf77baf157af2732848850 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a3313c420e4cf77baf157af2732848850 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a3313c420e4cf77baf157af2732848850">for_each_path_handle</a> (const Iteratee &amp;iteratee) const </td></tr>
<tr class="separator:a3313c420e4cf77baf157af2732848850 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63696ee6a047a75505c6096c635c16b inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:ae63696ee6a047a75505c6096c635c16b inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#ae63696ee6a047a75505c6096c635c16b">for_each_step_on_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const Iteratee &amp;iteratee) const </td></tr>
<tr class="separator:ae63696ee6a047a75505c6096c635c16b inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac121fdcefdeffba0a88b6bd3a2789471 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual std::vector<br class="typebreak"/>
&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#ac121fdcefdeffba0a88b6bd3a2789471">steps_of_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool match_orientation=false) const </td></tr>
<tr class="separator:ac121fdcefdeffba0a88b6bd3a2789471 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed6b61e10e5ad54812cf8bac2d56e9f inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a0ed6b61e10e5ad54812cf8bac2d56e9f">is_empty</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const </td></tr>
<tr class="memdesc:a0ed6b61e10e5ad54812cf8bac2d56e9f inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given path is empty, and false otherwise.  <a href="#a0ed6b61e10e5ad54812cf8bac2d56e9f">More...</a><br/></td></tr>
<tr class="separator:a0ed6b61e10e5ad54812cf8bac2d56e9f inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade32a59c445376a454c9a2526c5260cc inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhandlegraph_1_1PathForEachSocket.html">PathForEachSocket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#ade32a59c445376a454c9a2526c5260cc">scan_path</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path) const </td></tr>
<tr class="separator:ade32a59c445376a454c9a2526c5260cc inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c085eb8590fff9d4035a9bf87cf7a7 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a31c085eb8590fff9d4035a9bf87cf7a7 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a31c085eb8590fff9d4035a9bf87cf7a7">for_each_step_in_path</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path, const Iteratee &amp;iteratee) const </td></tr>
<tr class="separator:a31c085eb8590fff9d4035a9bf87cf7a7 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1HandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1HandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1HandleGraph.html">handlegraph::HandleGraph</a></td></tr>
<tr class="memitem:a5dcea1610fac82460ff304e07b4dd6e0 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a5dcea1610fac82460ff304e07b4dd6e0 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a5dcea1610fac82460ff304e07b4dd6e0">follow_edges</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left, const Iteratee &amp;iteratee) const </td></tr>
<tr class="separator:a5dcea1610fac82460ff304e07b4dd6e0 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19cbfb7cccb8b05d3952b0c7a0e60c1c inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a19cbfb7cccb8b05d3952b0c7a0e60c1c inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a19cbfb7cccb8b05d3952b0c7a0e60c1c">for_each_handle</a> (const Iteratee &amp;iteratee, bool parallel=false) const </td></tr>
<tr class="separator:a19cbfb7cccb8b05d3952b0c7a0e60c1c inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6828fde4d2a0063efef7e421a4118c inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a6f6828fde4d2a0063efef7e421a4118c">has_edge</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge)</td></tr>
<tr class="memdesc:a6f6828fde4d2a0063efef7e421a4118c inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient wrapper of has_edge for edge_t argument.  <a href="#a6f6828fde4d2a0063efef7e421a4118c">More...</a><br/></td></tr>
<tr class="separator:a6f6828fde4d2a0063efef7e421a4118c inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996223319f59bf614a02a78a3038bd89 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a996223319f59bf614a02a78a3038bd89">forward</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const </td></tr>
<tr class="memdesc:a996223319f59bf614a02a78a3038bd89 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the locally forward version of a handle.  <a href="#a996223319f59bf614a02a78a3038bd89">More...</a><br/></td></tr>
<tr class="separator:a996223319f59bf614a02a78a3038bd89 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e807b8d982fe8d55166c1685a1d4918 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a3e807b8d982fe8d55166c1685a1d4918">edge_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right) const </td></tr>
<tr class="separator:a3e807b8d982fe8d55166c1685a1d4918 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b2c0307f4fafb0acd3a0c02fe578b9 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#ad4b2c0307f4fafb0acd3a0c02fe578b9">traverse_edge_handle</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left) const </td></tr>
<tr class="separator:ad4b2c0307f4fafb0acd3a0c02fe578b9 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a10d13e6e403d64221c0b2f3566b78f inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a6a10d13e6e403d64221c0b2f3566b78f inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a6a10d13e6e403d64221c0b2f3566b78f">for_each_edge</a> (const Iteratee &amp;iteratee, bool parallel=false) const </td></tr>
<tr class="separator:a6a10d13e6e403d64221c0b2f3566b78f inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1MutableHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1MutableHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">handlegraph::MutableHandleGraph</a></td></tr>
<tr class="memitem:a8c9d8ca8160a9b94a57000eab3e97aaa inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a8c9d8ca8160a9b94a57000eab3e97aaa">create_handle</a> (const std::string &amp;sequence)=0</td></tr>
<tr class="memdesc:a8c9d8ca8160a9b94a57000eab3e97aaa inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new node with the given sequence and return the handle.  <a href="#a8c9d8ca8160a9b94a57000eab3e97aaa">More...</a><br/></td></tr>
<tr class="separator:a8c9d8ca8160a9b94a57000eab3e97aaa inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae844fce457858cd2dc54dde786f79e5c inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#ae844fce457858cd2dc54dde786f79e5c">create_handle</a> (const std::string &amp;sequence, const <a class="el" href="namespacehandlegraph.html#acfee0df419f087fab4a5cbf2cabff734">nid_t</a> &amp;id)=0</td></tr>
<tr class="memdesc:ae844fce457858cd2dc54dde786f79e5c inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new node with the given id and sequence, then return the handle.  <a href="#ae844fce457858cd2dc54dde786f79e5c">More...</a><br/></td></tr>
<tr class="separator:ae844fce457858cd2dc54dde786f79e5c inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff0a0f9497da3498170fdfc2ce97797 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a3ff0a0f9497da3498170fdfc2ce97797">create_edge</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge)</td></tr>
<tr class="memdesc:a3ff0a0f9497da3498170fdfc2ce97797 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient wrapper for create_edge.  <a href="#a3ff0a0f9497da3498170fdfc2ce97797">More...</a><br/></td></tr>
<tr class="separator:a3ff0a0f9497da3498170fdfc2ce97797 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca166406fa2000778552ed77c41a5e4c inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#aca166406fa2000778552ed77c41a5e4c">divide_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const std::vector&lt; size_t &gt; &amp;offsets)=0</td></tr>
<tr class="separator:aca166406fa2000778552ed77c41a5e4c inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c38787f0ff4a2695e61d98cb402175 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a05c38787f0ff4a2695e61d98cb402175">divide_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, size_t offset)</td></tr>
<tr class="memdesc:a05c38787f0ff4a2695e61d98cb402175 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of divide_handle for a single division point.  <a href="#a05c38787f0ff4a2695e61d98cb402175">More...</a><br/></td></tr>
<tr class="separator:a05c38787f0ff4a2695e61d98cb402175 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1DeletableHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">handlegraph::DeletableHandleGraph</a></td></tr>
<tr class="memitem:aec2b397c1b4ec7f9c75ccc5b9ce06564 inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#aec2b397c1b4ec7f9c75ccc5b9ce06564">destroy_edge</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge)</td></tr>
<tr class="memdesc:aec2b397c1b4ec7f9c75ccc5b9ce06564 inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient wrapper for destroy_edge.  <a href="#aec2b397c1b4ec7f9c75ccc5b9ce06564">More...</a><br/></td></tr>
<tr class="separator:aec2b397c1b4ec7f9c75ccc5b9ce06564 inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a4772c77ed932bfed4d21e247918381a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a4772c77ed932bfed4d21e247918381a4">graph</a></td></tr>
<tr class="memdesc:a4772c77ed932bfed4d21e247918381a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protobuf-based representation.  <a href="#a4772c77ed932bfed4d21e247918381a4">More...</a><br/></td></tr>
<tr class="separator:a4772c77ed932bfed4d21e247918381a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5150aba84e7ed2bde7986462a79989"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Paths.html">Paths</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7c5150aba84e7ed2bde7986462a79989">paths</a></td></tr>
<tr class="separator:a7c5150aba84e7ed2bde7986462a79989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6fcd5a907e9bee524cf37a62ad5be2"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1f6fcd5a907e9bee524cf37a62ad5be2">name</a></td></tr>
<tr class="memdesc:a1f6fcd5a907e9bee524cf37a62ad5be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the graph.  <a href="#a1f6fcd5a907e9bee524cf37a62ad5be2">More...</a><br/></td></tr>
<tr class="separator:a1f6fcd5a907e9bee524cf37a62ad5be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f069b1a683a86ff2981a7f340ac009"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a93f069b1a683a86ff2981a7f340ac009">current_id</a></td></tr>
<tr class="memdesc:a93f069b1a683a86ff2981a7f340ac009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current id for <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a> to be added next.  <a href="#a93f069b1a683a86ff2981a7f340ac009">More...</a><br/></td></tr>
<tr class="separator:a93f069b1a683a86ff2981a7f340ac009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9360fb7acb595296f55cb445f87543"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, <a class="el" href="structvg_1_1Node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aaf9360fb7acb595296f55cb445f87543">node_by_id</a></td></tr>
<tr class="memdesc:aaf9360fb7acb595296f55cb445f87543"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a></code>s by id.  <a href="#aaf9360fb7acb595296f55cb445f87543">More...</a><br/></td></tr>
<tr class="separator:aaf9360fb7acb595296f55cb445f87543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab754d45647580a21216bd010b72c6815"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1pair__hash__map.html">pair_hash_map</a>&lt; pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <br class="typebreak"/>
<a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt;, <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab754d45647580a21216bd010b72c6815">edge_by_sides</a></td></tr>
<tr class="separator:ab754d45647580a21216bd010b72c6815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce9aecf57e0684821ee277d983eb248"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; <a class="el" href="structvg_1_1Node.html">Node</a> *, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a2ce9aecf57e0684821ee277d983eb248">node_index</a></td></tr>
<tr class="separator:a2ce9aecf57e0684821ee277d983eb248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2c02a8216f0bb9b3a78e985845ea1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> *, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a2e2c02a8216f0bb9b3a78e985845ea1b">edge_index</a></td></tr>
<tr class="separator:a2e2c02a8216f0bb9b3a78e985845ea1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eda797a26ee9d8c217527d77554e2ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, vector&lt; pair<br class="typebreak"/>
&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5eda797a26ee9d8c217527d77554e2ab">edges_on_start</a></td></tr>
<tr class="memdesc:a5eda797a26ee9d8c217527d77554e2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the destinations and backward flags for edges attached to the starts of nodes (whether that node is "from" or "to").  <a href="#a5eda797a26ee9d8c217527d77554e2ab">More...</a><br/></td></tr>
<tr class="separator:a5eda797a26ee9d8c217527d77554e2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947ad1a02ca5be020879d56976a00e2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, vector&lt; pair<br class="typebreak"/>
&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a947ad1a02ca5be020879d56976a00e2a">edges_on_end</a></td></tr>
<tr class="memdesc:a947ad1a02ca5be020879d56976a00e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the destinations and backward flags for edges attached to the ends of nodes (whether that node is "from" or "to").  <a href="#a947ad1a02ca5be020879d56976a00e2a">More...</a><br/></td></tr>
<tr class="separator:a947ad1a02ca5be020879d56976a00e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac697184acf2edadca58ddc776f9f4e7e"><td class="memItemLeft" align="right" valign="top">map&lt; string, <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac697184acf2edadca58ddc776f9f4e7e">variant_to_traversal</a></td></tr>
<tr class="separator:ac697184acf2edadca58ddc776f9f4e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classvg_1_1Progressive"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classvg_1_1Progressive')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classvg_1_1Progressive.html">vg::Progressive</a></td></tr>
<tr class="memitem:a6653625f496832c4cb8711185d5e04cb inherit pub_attribs_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#a6653625f496832c4cb8711185d5e04cb">show_progress</a> = false</td></tr>
<tr class="separator:a6653625f496832c4cb8711185d5e04cb inherit pub_attribs_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aaf5016c5e5d28db6db32aa7626440238"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aaf5016c5e5d28db6db32aa7626440238">_for_each_kmer</a> (int kmer_size, bool path_only, int edge_max, function&lt; void(string &amp;, list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;::iterator, int, list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;, <a class="el" href="classvg_1_1VG.html">VG</a> &amp;)&gt; lambda, bool parallel, int stride, bool allow_dups, bool allow_negatives, <a class="el" href="structvg_1_1Node.html">Node</a> *node=nullptr)</td></tr>
<tr class="separator:aaf5016c5e5d28db6db32aa7626440238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af1194bf406d433a5f46f5aff6f24ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3af1194bf406d433a5f46f5aff6f24ab">align</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *aligner, const <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *qual_adj_aligner, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, bool traceback=true, bool acyclic_and_sorted=false, size_t max_query_graph_ratio=0, bool pinned_alignment=false, bool pin_left=false, bool banded_global=false, size_t band_padding_override=0, size_t max_span=0, size_t unroll_length=0, int xdrop_alignment=0, bool print_score_matrices=false)</td></tr>
<tr class="separator:a3af1194bf406d433a5f46f5aff6f24ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd0f191fe33bd4590f15f309d0fd89c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aafd0f191fe33bd4590f15f309d0fd89c">init</a> (void)</td></tr>
<tr class="separator:aafd0f191fe33bd4590f15f309d0fd89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a5c70121b4a8463c118b9c90c7090b28f"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5c70121b4a8463c118b9c90c7090b28f">empty_ids</a></td></tr>
<tr class="memdesc:a5c70121b4a8463c118b9c90c7090b28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placeholder for functions that sometimes need to be passed an empty vector.  <a href="#a5c70121b4a8463c118b9c90c7090b28f">More...</a><br/></td></tr>
<tr class="separator:a5c70121b4a8463c118b9c90c7090b28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f32ef3d653601d2fcac5c1b31de0abb"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a9f32ef3d653601d2fcac5c1b31de0abb">empty_edge_ends</a></td></tr>
<tr class="memdesc:a9f32ef3d653601d2fcac5c1b31de0abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placeholder for functions that sometimes need to be passed an empty vector.  <a href="#a9f32ef3d653601d2fcac5c1b31de0abb">More...</a><br/></td></tr>
<tr class="separator:a9f32ef3d653601d2fcac5c1b31de0abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0519dc706937b8b593f803f3d8eac4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8f0519dc706937b8b593f803f3d8eac4">warned_about_rewrites</a> = false</td></tr>
<tr class="separator:a8f0519dc706937b8b593f803f3d8eac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classhandlegraph_1_1PathHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classhandlegraph_1_1PathHandleGraph')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">handlegraph::PathHandleGraph</a></td></tr>
<tr class="memitem:a79f48793555f6be311f6df6603324e7b inherit pro_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a79f48793555f6be311f6df6603324e7b">for_each_path_handle_impl</a> (const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; &amp;iteratee) const =0</td></tr>
<tr class="separator:a79f48793555f6be311f6df6603324e7b inherit pro_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbdf56b268001c629cf000f5bd8bb9a inherit pro_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a2bbdf56b268001c629cf000f5bd8bb9a">for_each_step_on_handle_impl</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;)&gt; &amp;iteratee) const =0</td></tr>
<tr class="separator:a2bbdf56b268001c629cf000f5bd8bb9a inherit pro_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classhandlegraph_1_1HandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classhandlegraph_1_1HandleGraph')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classhandlegraph_1_1HandleGraph.html">handlegraph::HandleGraph</a></td></tr>
<tr class="memitem:a89bbc118fe1e8e1acb162c14be33e8b5 inherit pro_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a89bbc118fe1e8e1acb162c14be33e8b5">follow_edges_impl</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;iteratee) const =0</td></tr>
<tr class="separator:a89bbc118fe1e8e1acb162c14be33e8b5 inherit pro_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48ba081fcb810267dc50e3a3e7ad391 inherit pro_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#af48ba081fcb810267dc50e3a3e7ad391">for_each_handle_impl</a> (const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;iteratee, bool parallel=false) const =0</td></tr>
<tr class="separator:af48ba081fcb810267dc50e3a3e7ad391 inherit pro_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a variation graph. Graphs consist of nodes, connected by edges. Graphs are bidirected and may be cyclic. Nodes carry forward-oriented sequences. Edges are directed, with a "from" and to" node, and are generally
used to connect the end of the "from" node to the start of the "to" node. However, edges can connect to either the start or end of either node. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac2399de59931e282fb1f4d3da9a8dcb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::VG::VG </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a class="anchor" id="a2dc9648985454d3aedd9a477ff0c52b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::VG::VG </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showp</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>warn_on_duplicates</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct from <a class="el" href="structvg_1_1Graph.html">Graph</a> objects serialized in a tagged group stream. </p>

</div>
</div>
<a class="anchor" id="a0fbb777fd8ab6050124a6eaf9eca9133"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::VG::VG </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(const function&lt; void(<a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;)&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>send_graphs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showp</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>warn_on_duplicates</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct from an arbitrary source of <a class="el" href="structvg_1_1Graph.html">Graph</a> protobuf messages, with the message source in control of execution. Takes a function that takes a callback to call with each <a class="el" href="structvg_1_1Graph.html">Graph</a> object to incorporate. The <a class="el" href="structvg_1_1Graph.html">Graph</a> object may be moved by the <a class="el" href="classvg_1_1VG.html">VG</a>. </p>

</div>
</div>
<a class="anchor" id="af4d321b31b873153431c261090d052af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::VG::VG </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showp</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>warn_on_duplicates</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct from a single Protobuf graph. The same as making an empty <a class="el" href="classvg_1_1VG.html">VG</a> and using <a class="el" href="classvg_1_1VG.html#a2519c3b939f48bca226e6fdea4c91f9d">extend()</a>. </p>

</div>
</div>
<a class="anchor" id="abeafee2d3bc6e0039e99fccdea10f4f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::VG::VG </td>
          <td>(</td>
          <td class="paramtype">set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct from sets of nodes and edges. For example, from a subgraph of another graph. </p>

</div>
</div>
<a class="anchor" id="a7513ddb88aeb58bd85a810c2a2ccdf67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::VG::~VG </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<a class="anchor" id="a3148455330df9ac055c6bd1eb7da3167"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::VG::VG </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a class="anchor" id="ab8365ccd6a093ec50f7d54b1c7a7c672"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::VG::VG </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aaf5016c5e5d28db6db32aa7626440238"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::_for_each_kmer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kmer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>path_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edge_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(string &amp;, list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;::iterator, int, list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;, <a class="el" href="classvg_1_1VG.html">VG</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_dups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negatives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call the given function on each kmer. If parallel is specified, goes through nodes one per thread. If node is not null, looks only at kmers of that specific node. </p>

</div>
</div>
<a class="anchor" id="a613c931c81518212917053d07e9bf8a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::add_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Edge.html">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add in the given edge, by value. </p>

</div>
</div>
<a class="anchor" id="a7f23cdd532ca7b8d3c0bb9cceff3d378"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::add_edges </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add in the given edges, by value. </p>

</div>
</div>
<a class="anchor" id="a679e39a7c1771c3ecc7204bd3b999583"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::add_edges </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add in the given edges, by value. </p>

</div>
</div>
<a class="anchor" id="acb8712eefbfd373c45f54d6bac8188c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::add_edges </td>
          <td>(</td>
          <td class="paramtype">const set&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add in the given edges, by value. </p>

</div>
</div>
<a class="anchor" id="ad3e265ee441758d81fdb7c038e2fa8cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::add_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add in the given node, by value. </p>

</div>
</div>
<a class="anchor" id="ae71d30b767f067a874c933f13f6c34e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::add_nodes </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add in the given nodes, by value. </p>

</div>
</div>
<a class="anchor" id="ab796330d50fdff47f5c080e251efea68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::add_nodes </td>
          <td>(</td>
          <td class="paramtype">const set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add in the given nodes, by value. </p>

</div>
</div>
<a class="anchor" id="a27730f354959a95c892c5ea5787fb687"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::add_start_end_markers </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>start_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>end_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&amp;&#160;</td>
          <td class="paramname"><em>start_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&amp;&#160;</td>
          <td class="paramname"><em>end_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>start_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>end_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a start node and an end node, where all existing heads in the graph are connected to the start node, and all existing tails in the graph are connected to the end node. Any connected components in the graph which do not have either are connected to the start at an arbitrary point, and the end node from nodes going to that arbitrary point. If start_node or end_node is null, a new node will be created. Otherwise, the passed node will be used. Note that this visits every node, to make sure it is attached to all connected components. Note that if a graph has, say, heads but no tails, the start node will be attached buut the end node will be free-floating. </p>

</div>
</div>
<a class="anchor" id="ab213a64c6240d08603530982c0b75047"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::adjacent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>pos2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if pos1 occurs directly before pos2. </p>

</div>
</div>
<a class="anchor" id="a8f24b80d7ed79ad7a9809ac3f7b4082d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::align </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *&#160;</td>
          <td class="paramname"><em>aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceback</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acyclic_and_sorted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_query_graph_ratio</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned_alignment</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>banded_global</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_override</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_span</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unroll_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xdrop_alignment</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_score_matrices</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Align without base quality adjusted scores. Align to the graph. May modify the graph by re-ordering the nodes. May add nodes to the graph, but cleans them up afterward. </p>

</div>
</div>
<a class="anchor" id="a5e58e78f2c3d5033ffc02b5d5389c46d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::align </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *&#160;</td>
          <td class="paramname"><em>aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceback</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acyclic_and_sorted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_query_graph_ratio</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned_alignment</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>banded_global</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_override</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_span</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unroll_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xdrop_alignment</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_score_matrices</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Align without base quality adjusted scores. Align to the graph. May modify the graph by re-ordering the nodes. May add nodes to the graph, but cleans them up afterward. </p>

</div>
</div>
<a class="anchor" id="a4a1947220a8a504f0e6fad4fdcde7e89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::align </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *&#160;</td>
          <td class="paramname"><em>aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceback</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acyclic_and_sorted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_query_graph_ratio</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned_alignment</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>banded_global</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_override</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_span</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unroll_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xdrop_alignment</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_score_matrices</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab3d06935a63b52f2fea5246fde4dd8eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::align </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceback</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acyclic_and_sorted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_query_graph_ratio</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned_alignment</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>banded_global</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_override</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_span</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unroll_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xdrop_alignment</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_score_matrices</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Align with default <a class="el" href="classvg_1_1Aligner.html">Aligner</a>. Align to the graph. May modify the graph by re-ordering the nodes. May add nodes to the graph, but cleans them up afterward. </p>

</div>
</div>
<a class="anchor" id="a0bb76637f82e514ee554fc998e4e827c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::align </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceback</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acyclic_and_sorted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_query_graph_ratio</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned_alignment</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>banded_global</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_override</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_span</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unroll_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xdrop_alignment</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_score_matrices</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Align with default <a class="el" href="classvg_1_1Aligner.html">Aligner</a>. Align to the graph. May modify the graph by re-ordering the nodes. May add nodes to the graph, but cleans them up afterward. </p>

</div>
</div>
<a class="anchor" id="a3af1194bf406d433a5f46f5aff6f24ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::align </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *&#160;</td>
          <td class="paramname"><em>aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *&#160;</td>
          <td class="paramname"><em>qual_adj_aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceback</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acyclic_and_sorted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_query_graph_ratio</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned_alignment</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>banded_global</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_override</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_span</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unroll_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xdrop_alignment</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_score_matrices</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Private method to funnel other align functions into. max_span specifies the min distance to unfold the graph to, and is meant to be the longest path that the specified sequence could cover, accounting for deletions. If it's less than the sequence's length, the sequence's length is used. band_padding_override gives the band padding to use for banded global alignment. In banded global mode, if the band padding override is nonzero, permissive banding is not used, and instead the given band padding is provided. If the band padding override is not provided, the max span is used as the band padding and permissive banding is enabled. </p>

</div>
</div>
<a class="anchor" id="a58925d956fd726d5cbac6a3f0106dd9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::align_qual_adjusted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *&#160;</td>
          <td class="paramname"><em>qual_adj_aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceback</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acyclic_and_sorted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_query_graph_ratio</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned_alignment</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>banded_global</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_override</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_span</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unroll_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xdrop_alignment</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_score_matrices</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Align with base quality adjusted scores. Align to the graph. May modify the graph by re-ordering the nodes. May add nodes to the graph, but cleans them up afterward. </p>

</div>
</div>
<a class="anchor" id="afbf8bcbe1bac3e98422d36bf6a59b742"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::align_qual_adjusted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *&#160;</td>
          <td class="paramname"><em>qual_adj_aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceback</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acyclic_and_sorted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_query_graph_ratio</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned_alignment</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>banded_global</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_override</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_span</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unroll_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xdrop_alignment</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_score_matrices</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaac13deb51cd8e7a47ea817ef12a2a3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::align_qual_adjusted </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *&#160;</td>
          <td class="paramname"><em>qual_adj_aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceback</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acyclic_and_sorted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_query_graph_ratio</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned_alignment</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>banded_global</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_override</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_span</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unroll_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xdrop_alignment</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_score_matrices</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Align with base quality adjusted scores. Align to the graph. May modify the graph by re-ordering the nodes. May add nodes to the graph, but cleans them up afterward. </p>

</div>
</div>
<a class="anchor" id="a5272032c1e57d839176fc8e39bd87e18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add another graph into this graph, attaching tails to heads. Modify ids of the second graph to ensure we don't have conflicts. Then attach tails of this graph to the heads of the other, and extend(g). </p>

</div>
</div>
<a class="anchor" id="ad11c8a716733fce2aa9dab94b42286bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> vg::VG::append_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to_append</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a visit to a node to the given path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#a83a4a14a629cde03d33e4eb3f6bb192d">handlegraph::MutablePathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a7c07df5ff863bab2c096cd58a8350f37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::apply_ordering </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compact_ids</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reorder the graph's internal structure to match that given. This sets the order that is used for iteration in functions like for_each_handle. Optionally compact the id space of the graph to match the ordering, from 1-&gt;|ordering|. This may be a no-op in the case of graph implementations that do not have any mechanism to maintain an ordering. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a7e14ea0ae201ba87934559ecbd3a2981">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="ab5ee06ac168f037f2cff3b332079b49c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::VG::apply_orientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alter the node that the given handle corresponds to so the orientation indicated by the handle becomes the node's local forward orientation. Rewrites all edges pointing to the node and the node's sequence to reflect this. Invalidates all handles to the node (including the one passed). Returns a new, valid handle to the node in its new forward orientation. Note that it is possible for the node's ID to change. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a71433449cb13e22dc19caaf544b6d7bc">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a6f838bd143f7909838bf2139b15576ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1VG.html">VG</a> vg::VG::backtracking_unroll </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_translation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a new graph that unrolls the current one using backtracking. Caution: exponential in branching. </p>

</div>
</div>
<a class="anchor" id="ad7604b2833cf3e0855c5c29619f4a270"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::bluntify </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove redundant overlaps. </p>

</div>
</div>
<a class="anchor" id="a93cb2d6686e0bb92d7f0b632fc813702"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> &gt; vg::VG::break_cycles </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use our topological sort to quickly break cycles in the graph, return the edges which are removed. Very non-optimal, but fast. </p>

</div>
</div>
<a class="anchor" id="a3fb2cb59474393ac822847033f185d17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::build_edge_indexes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af63d4a22a3baa5b21623128b81a14872"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::build_edge_indexes_no_init_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7f71911fe2c652dc11aec0a0d705b1e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::build_indexes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa78095fb5d27e182c5cc4d5c10d3da39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::build_indexes_no_init_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5156da43d4175597d7a8b1d88b5179af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::build_node_indexes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0ca442744267b08609887cd842ca543d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::build_node_indexes_no_init_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aeabcaa5e19486dbab418184a312d9777"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::circularize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Circularize a subgraph / path using the head / tail nodes. </p>

</div>
</div>
<a class="anchor" id="ad96ff883534a13b28b18cd84dd094e72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::circularize </td>
          <td>(</td>
          <td class="paramtype">vector&lt; string &gt;&#160;</td>
          <td class="paramname"><em>pathnames</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa1eb3332c0a99a25c75681da485297e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all nodes and edges. Does not update any stored paths. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#a6e1a83e72b47643e43c6176f39d8db5e">handlegraph::DeletableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a10d4b49633db2aef463e0070e0af64a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::clear_edge_indexes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5195712f8aa650417d93324ff1c89ecf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::clear_edge_indexes_no_resize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aae960ce1d640fadc4772795f6d0ff5b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::clear_indexes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a103c69bad02121590779530338861374"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::clear_indexes_no_resize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a212a2d1028f28046088a86e128b40559"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::clear_node_indexes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af51220e88887adf92d7cff25dad5cd91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::clear_node_indexes_no_resize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa4e534461834b2937b7f0b0c2420b899"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::clear_paths </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the paths object (which indexes the graph.paths) and the graph paths themselves. </p>

</div>
</div>
<a class="anchor" id="a688cbe42750d98695114ad4ad640c1d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::collect_subgraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the subgraph of a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a>. TODO: what does that mean? </p>

</div>
</div>
<a class="anchor" id="a7d06218f137184c366de80df755ae001"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::combine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add another graph into this graph. Don't append or join the nodes in the graphs; just ensure that ids are unique, then apply extend. </p>

</div>
</div>
<a class="anchor" id="a95d087adcf01ebfa68541bc6f487278e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> vg::VG::common_ancestor_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>steps</em> = <code>64</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to find a common ancestor by walking forward up to steps from the first node. </p>

</div>
</div>
<a class="anchor" id="a156ee8c5d3650f08ab4d806980d6926a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> vg::VG::common_ancestor_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>steps</em> = <code>64</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to find a common ancestor by walking back up to steps from the first node. </p>

</div>
</div>
<a class="anchor" id="a161ef56bd0eeee937602f60b8617f24d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::compact_ids </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Squish the node IDs down into as small a space as possible. Fixes up paths itself. </p>

</div>
</div>
<a class="anchor" id="a1d9faa901ab4d768d607454ffbfeac0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::compact_ids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Squish the node IDs down into as small a space as possible. Fixes up paths itself. Record translation in provided map. </p>

</div>
</div>
<a class="anchor" id="a153260c1839238abff26b2e989d8799d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;string, vector&lt;<a class="el" href="classvg_1_1mapping__t.html">mapping_t</a>&gt; &gt; vg::VG::concat_mappings_for_node_pair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate the mappings for a pair of nodes; handles multiple mappings per path. </p>

</div>
</div>
<a class="anchor" id="a2367b4d49cca4c57a2529d92512cba59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; string, vector&lt; <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &gt; &gt; vg::VG::concat_mappings_for_nodes </td>
          <td>(</td>
          <td class="paramtype">const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Concatenate mappings for a list of nodes that we want to concatenate. Returns, for each path name, a vector of merged mappings, once per path traversal of the run of nodes. Those merged mappings are in the orientation of the merged node (so mappings to nodes that are traversed in reverse will have their flags toggled). We assume that all mappings on the given nodes are full-length perfect matches, and that all the nodes are perfect path neighbors. </p>

</div>
</div>
<a class="anchor" id="a64d37ff935d8881dcf03010187e1ceb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Node.html">Node</a> * vg::VG::concat_nodes </td>
          <td>(</td>
          <td class="paramtype">const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Concatenates the nodes into a new node with the same external linkage as the provided component. After calling this, paths will be invalid until <a class="el" href="classvg_1_1Paths.html#aaf065b12a8a942c96f6d88a2c6db7c8e">Paths::compact_ranks()</a> is called. </p>

</div>
</div>
<a class="anchor" id="ad68d2bfaa6627686967add4ca7fb5f4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::connect_node_to_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect node -&gt; nodes. Connects from the right side of the first to the left side of the second. </p>

</div>
</div>
<a class="anchor" id="ab8189716ecbb9eeeefec8be64e34a9e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::connect_node_to_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_start</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect node -&gt; nodes. You can optionally use the start of the first node instead of the end. </p>

</div>
</div>
<a class="anchor" id="a7ee6066424793dfcda9097419f03b568"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::connect_nodes_to_node </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>connect nodes -&gt; node. Connects from the right side of the first to the left side of the second. </p>

</div>
</div>
<a class="anchor" id="acc4db5878a40e8dc7d2d2b25ff62ff1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::connect_nodes_to_node </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_end</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>connect nodes -&gt; node. </p>

</div>
</div>
<a class="anchor" id="a8922810d5228ab5c4619eb2ddc16e78b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::create_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an edge connecting the given handles in the given order and orientations. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a34a5e01f270713ba856a93c55039faf0">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a8ecb9833a1b3e7d5ca41fcaa96000976"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Edge.html">Edge</a> * vg::VG::create_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_start</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_end</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an edge. If the given edge cannot be created, returns null. If the given edge already exists, returns the existing edge. </p>

</div>
</div>
<a class="anchor" id="aaea0ac806a69899322f10155d5def595"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Edge.html">Edge</a> * vg::VG::create_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_start</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_end</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an edge. If the given edge cannot be created, returns null. If the given edge already exists, returns the existing edge. </p>

</div>
</div>
<a class="anchor" id="a8fd0565d5133a239856444049783edcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Edge.html">Edge</a> * vg::VG::create_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a left-to-right edge from the left <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> to the right one, respecting orientations. If the given edge cannot be created, returns null. If the given edge already exists, returns the existing edge. </p>

</div>
</div>
<a class="anchor" id="ac2cd4705aa5b919f349d02089c97cbc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Edge.html">Edge</a> * vg::VG::create_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&#160;</td>
          <td class="paramname"><em>side1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&#160;</td>
          <td class="paramname"><em>side2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make an edge connecting the given sides of nodes. If the given edge cannot be created, returns null. If the given edge already exists, returns the existing edge. </p>

</div>
</div>
<a class="anchor" id="a54ad97e46dc1297b1a65a32697e2d37e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::VG::create_handle </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new node with the given sequence and return the handle. </p>

</div>
</div>
<a class="anchor" id="ae968a71f586b6cc3876f2e9452f4c576"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::VG::create_handle </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new node with the given id and sequence, then return the handle. </p>

</div>
</div>
<a class="anchor" id="a8cb95ac1c24c5263a962c13f3d6bc0c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Node.html">Node</a> * vg::VG::create_node </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a node. Use the <a class="el" href="classvg_1_1VG.html">VG</a> class to generate ids. </p>

</div>
</div>
<a class="anchor" id="a5736bb79bf9bcb96ea21c6945c61dcfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Node.html">Node</a> * vg::VG::create_node </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a node. Use a specified, nonzero node ID. </p>

</div>
</div>
<a class="anchor" id="a3195bfadb7e65e4952c4b98d51e862f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> vg::VG::create_path </td>
          <td>(</td>
          <td class="paramtype">const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a path. </p>

</div>
</div>
<a class="anchor" id="adc07ec73a57485a700e621517c962b8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> vg::VG::create_path </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a path. </p>

</div>
</div>
<a class="anchor" id="af7c99e48723b360eb2b1315b2c5af7cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> vg::VG::create_path_handle </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_circular</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a path with the given name. </p>

</div>
</div>
<a class="anchor" id="a7958e987d875acb903acabf9903a8a88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1VG.html">VG</a> vg::VG::dagify </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>expand_scc_steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>target_min_walk_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>component_length_max</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Turn the graph into a dag by copying strongly connected components expand_scc_steps times and translating the edges in the component to flow through the copies in one direction. Assumes that all nodes in the graph are articulated on one consistent strand. Tolerates doubly-reversing edges in the input graph. </p>

</div>
</div>
<a class="anchor" id="a356612f42ba60fe5895f3abe7501173a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::decrement_node_ids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>decrement</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract the given value from all the node IDs. Must not create a node with 0 or negative IDs. Invalidates the paths. </p>

</div>
</div>
<a class="anchor" id="a24359ba8e4ecbbd692bba5a517456659"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::deserialize </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the contents of this graph to the contents of a serialized graph from an istream. The serialized graph must be from the same implementation of the HandleGraph interface as is calling <a class="el" href="classvg_1_1VG.html#a24359ba8e4ecbbd692bba5a517456659">deserialize()</a>. Can only be called by an empty graph. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1SerializableHandleGraph.html#ab48afce25d93bf5ee91fe84f36a56452">handlegraph::SerializableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a9d4264e39e3826ded714992361ab879e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::destroy_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the edge connecting the given handles in the given order and orientations. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#a285ac35e805eab548c4106ee534d79f2">handlegraph::DeletableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a284327157f9d4b82224fc856179a668d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::destroy_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the edge at the given pointer. This pointer must point to an edge owned by the graph. </p>

</div>
</div>
<a class="anchor" id="abe6b91020abf39815d28995eceac4e2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::destroy_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;&#160;</td>
          <td class="paramname"><em>side1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;&#160;</td>
          <td class="paramname"><em>side2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the edge between the given sides of nodes. These can be in either order. </p>

</div>
</div>
<a class="anchor" id="a7fd2744b37b62862df68e82cbe7b6b59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::destroy_edge </td>
          <td>(</td>
          <td class="paramtype">const pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sides</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the edge between the given sides of nodes. This can take sides in any order. </p>

</div>
</div>
<a class="anchor" id="a3e52875d37f046daeaf9e7b301ad59ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::destroy_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the node belonging to the given handle and all of its edges. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#a06d4d3ecda0694d5045c457f3eecd8e3">handlegraph::DeletableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="ab9cd34f3c968f90370c42e8692222619"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::destroy_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the node at the given pointer. This pointer must point to a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a> owned by the graph. </p>

</div>
</div>
<a class="anchor" id="acb9f662f9241f12249331c878ade136e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::destroy_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the node with the given ID. </p>

</div>
</div>
<a class="anchor" id="adb25bd1fdb9e36c55157c5be864ca403"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::destroy_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the given path. Invalidates handles to the path and its node steps. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#a05a7303ef2f259c6384b0b9b1f9d3f56">handlegraph::MutablePathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="aec0db609d022b3c3183403600970238f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::dfs </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_begin_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_end_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>break_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>tree_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_curr_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_cross_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; *&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; *&#160;</td>
          <td class="paramname"><em>sinks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do a DFS search of the bidirected graph. A bidirected DFS starts at some root node, and traverses first all the nodes found reading out the right of that node in their appropriate relative orientations (including the root), and then all the nodes found reading left out of that node in their appropriate orientations (including the root). If any unvisited nodes are left in other connected components, the process will repeat from one such node, until all nodes have been visited in each orientation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_begin_fn</td><td>Called when node orientattion is first encountered. </td></tr>
    <tr><td class="paramname">node_end_fn</td><td>Called when node orientation goes out of scope. </td></tr>
    <tr><td class="paramname">break_fn</td><td>Called to check if we should stop the DFS. </td></tr>
    <tr><td class="paramname">edge_fn</td><td>Called when an edge is encountered. </td></tr>
    <tr><td class="paramname">tree_fn</td><td>Called when an edge forms part of the DFS spanning tree. </td></tr>
    <tr><td class="paramname">edge_curr_fn</td><td>Called when we meet an edge in the current tree component. </td></tr>
    <tr><td class="paramname">edge_cross_fn</td><td>Called when we meet an edge in an already-traversed tree component. </td></tr>
    <tr><td class="paramname">sources</td><td>Start only at these node traversals. </td></tr>
    <tr><td class="paramname">sinks</td><td>When hitting a sink, don't keep walking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a287e5d12ba0bc0823d1b6e0fa56af3d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::dfs </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_begin_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_end_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; *&#160;</td>
          <td class="paramname"><em>sources</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; *&#160;</td>
          <td class="paramname"><em>sinks</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialization of dfs for only handling nodes. </p>

</div>
</div>
<a class="anchor" id="a8ee80f3ce939643d59157e1a1d707068"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::dfs </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_begin_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_end_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>break_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialization of dfs for only handling nodes + break function. </p>

</div>
</div>
<a class="anchor" id="a40c8fe573ad9ea52634a7e7421c143de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::dice_nodes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_node_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chop up the nodes. </p>

</div>
</div>
<a class="anchor" id="af31e90fe77a1d30244011dd8dbbf5f25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::disjoint_subgraphs </td>
          <td>(</td>
          <td class="paramtype">list&lt; <a class="el" href="classvg_1_1VG.html">VG</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subgraphs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find subgraphs. </p>

</div>
</div>
<a class="anchor" id="a7a5dbc95fa80e7fe3dc04d62ac6d7b3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; vg::VG::divide_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a handle's underlying node at the given offsets in the handle's orientation. Returns all of the handles to the parts. Other handles to the node being split may be invalidated. The split pieces stay in the same local forward orientation as the original node, but the returned handles come in the order and orientation appropriate for the handle passed in. </p>

</div>
</div>
<a class="anchor" id="ad06f0fcad4bf5b1c29cf937a870a58b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::divide_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide a node at a given internal position. Inserts the new nodes in the correct paths, but can't update the ranks, so they need to be cleared and re-calculated by the caller. </p>

</div>
</div>
<a class="anchor" id="a7bee7317e4f7e42d85d8e7ef8d07273a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::divide_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide a node at a given internal position. This version works on a collection of internal positions, in linear time. </p>

</div>
</div>
<a class="anchor" id="a1ce3b7afc274a50cd7b1296e64ca2f01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::divide_path </td>
          <td>(</td>
          <td class="paramtype">map&lt; long, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide a path at a position. Also invalidates stored rank information. </p>

</div>
</div>
<a class="anchor" id="a7fe56e78d2178e689e623a35fcbdff2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::VG::edge_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of edges in the graph. </p>

</div>
</div>
<a class="anchor" id="acdabb41079406d955795f2cfb72b496d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp; vg::VG::edges_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get nodes and backward flags following edges that attach to this node's end. </p>

</div>
</div>
<a class="anchor" id="aec901943e03aeae91638bce6952efc14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp; vg::VG::edges_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get nodes and backward flags following edges that attach to this node's end. </p>

</div>
</div>
<a class="anchor" id="ae1a7e0aa663eadc0ebdaaf13b667323e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; vg::VG::edges_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the edges from the specified node. </p>

</div>
</div>
<a class="anchor" id="aa1bf5492e5c6d586cd266d2a48f792df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; vg::VG::edges_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the edges of the specified node. </p>

</div>
</div>
<a class="anchor" id="a5b6a5e92afb1a70d9c63a1848a01f241"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::edges_of_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the edges of the specified node, and add them to the given vector. Guaranteed to add each edge only once per call. </p>

</div>
</div>
<a class="anchor" id="a3b2d900fc42cffe079c3ba3897717eae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::edges_of_nodes </td>
          <td>(</td>
          <td class="paramtype">set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the edges of the specified set of nodes, and add them to the given set of edge pointers. </p>

</div>
</div>
<a class="anchor" id="a5eaedf10280d72862aa6f0b65a3d383e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp; vg::VG::edges_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get nodes and backward flags following edges that attach to this node's start. </p>

</div>
</div>
<a class="anchor" id="ad9a9f315e43b96496fb5674df52623f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp; vg::VG::edges_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get nodes and backward flags following edges that attach to this node's start. </p>

</div>
</div>
<a class="anchor" id="a3789cf6561f2d3da5ef85f23b5c6454f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; vg::VG::edges_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the edges to the specified node. </p>

</div>
</div>
<a class="anchor" id="a5962aa939727f27cb7c62b2ce2706fe9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::edit </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths_to_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Translation.html">Translation</a> &gt; *&#160;</td>
          <td class="paramname"><em>out_translations</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>save_paths</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update_paths</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>break_at_ends</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Edit the graph to include all the sequence and edges added by the given paths. Can handle paths that visit nodes in any orientation. If out_translations is given, a vector of Translations will be written to it, one per node existing after the edit, describing how each new or conserved node is embedded in the old graph. Note that this method sorts the graph and rebuilds the path index, so it should not be called in a loop.</p>
<p>If update_paths is true, the paths will be modified to reflect their embedding in the modified graph. If save_paths is true, the paths as embedded in the graph will be added to the graph's set of paths. If break_at_ends is true (or save_paths is true), nodes will be broken at the ends of paths that start/end woth perfect matches, so the paths can be added to the vg graph's paths object. </p>

</div>
</div>
<a class="anchor" id="a7818ca048287143e2b0e79136e453845"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::edit </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>paths_to_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Translation.html">Translation</a> &gt; *&#160;</td>
          <td class="paramname"><em>out_translations</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>save_paths</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostream *&#160;</td>
          <td class="paramname"><em>out_path_stream</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>break_at_ends</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove_softclips</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Streaming version of above. Instead of reading a list of paths into memory all at once, a stream is used to go one-by-one. Instead of an option to updtate the in-memory list, an optional output stream is used</p>
<p>todo: duplicate less code between the two versions. </p>

</div>
</div>
<a class="anchor" id="a78f70eb7eddb0245be7cdfc048616638"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Translation.html">Translation</a> &gt; vg::VG::edit_fast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dangling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_node_size</em> = <code>1024</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Edit the graph to include all the sequences and edges added by the given path. Returns a vector of Translations, one per original-node fragment. Completely novel nodes are not mentioned, and nodes with no Translations are assumed to be carried through unchanged. Invalidates the rank-based <a class="el" href="classvg_1_1Paths.html">Paths</a> index. Does not sort the graph. Suitable for calling in a loop.</p>
<p>Can attach newly created nodes on the left of the path to the given set of dangling NodeSides, and populates the set at the end with the <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> corresponding to the end of the path. This mechanism allows edits that hit the end of a node to be attached to what comes before/after the node by the caller, as this function doesn't handle that. </p>

</div>
</div>
<a class="anchor" id="a310f10ff59e15468e8350844465f15e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt;list&lt;<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&gt; &gt; vg::VG::elementary_cycles </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get simple cycles following Johnson's elementary cycles algorithm. </p>

</div>
</div>
<a class="anchor" id="aa778c3d1697c79aa924c5e4d1179a646"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the graph empty? </p>

</div>
</div>
<a class="anchor" id="af3cf82dca43799a03d93b199133f1d4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::end_degree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of edges attached to the end of a node. </p>

</div>
</div>
<a class="anchor" id="a6a525e3290d6968c79314c2500f13cc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::expand_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>add_paths</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_steps</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expand the context of what's already in the given graph by the given distance, either in nodes or in bases. Pulls material from this graph. </p>

</div>
</div>
<a class="anchor" id="a5ba5a5416ee9eaf67c7ae5607fc7ae1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::expand_context_by_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>add_paths</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reflect</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>barriers</em> = <code>set&lt;<a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expand the context of the given graph by the given number of bases. If reflect is true, bounce off the ends of nodes to get siblings of nodes you came from. Can take a set of NodeSides not to look out from, that act as barriers to context expansion. These barriers will have no edges attached to them in the final graph. </p>

</div>
</div>
<a class="anchor" id="aca4ead561b46cd1cde77ada1f611befa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::expand_context_by_steps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>add_paths</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand the context of the given graph by the given number of steps. </p>

</div>
</div>
<a class="anchor" id="aa9273361525befc57536dc96a762c29d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::expand_path </td>
          <td>(</td>
          <td class="paramtype">const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expanded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand a path. TODO: what does that mean? </p>

</div>
</div>
<a class="anchor" id="ae151983cac753c02ce3852274798f8d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::expand_path </td>
          <td>(</td>
          <td class="paramtype">list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;::iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>expanded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expand a path. TODO: what does that mean? These versions handle paths in which nodes can be traversed multiple times. Unfortunately since we're throwing non-const iterators around, we can't take the input path as const. </p>

</div>
</div>
<a class="anchor" id="a2519c3b939f48bca226e6fdea4c91f9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::extend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>warn_on_duplicates</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iteratively add when nodes and edges are novel. Good when there are very many overlaps. TODO: If you are using this with warn on duplicates on, and you know there shouldn't be any duplicates, maybe you should use merge instead. This version sorts paths on rank after adding in the path mappings from the other graph. </p>

</div>
</div>
<a class="anchor" id="a5e517214b33812b16f195a1f87841c0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::extend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>warn_on_duplicates</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This version does not sort path mappings by rank. In order to preserve paths, call <a class="el" href="classvg_1_1Paths.html#a2970302cae3a54ef7f4296dbf49266fd">Paths::sort_by_mapping_rank()</a> and <a class="el" href="classvg_1_1Paths.html#a5f80df5846bdac0b502a70af97dc65de" title="Reassign ranks and rebuild indexes, treating the mapping lists in _paths as the truth. ">Paths::rebuild_mapping_aux()</a> after you are done adding in graphs to this graph. </p>

</div>
</div>
<a class="anchor" id="a04774a86b07508e9e5955abfba2171ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Node.html">Node</a> * vg::VG::find_node_by_name_or_add_new </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a node with the given name, or create a new one if none is found. </p>

</div>
</div>
<a class="anchor" id="a47afbf1369e36d541a0ebddfc707d934"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::VG::flip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invert the orientation of a handle (potentially without getting its ID) </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#aaa3f94ae7e884408ef6e8ca8fd45c7d7">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a8e5079416ab826cbc8a5eea3869eb892"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::flip_doubly_reversed_edges </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert edges that are both from_start and to_end to "regular" ones from end to start. </p>

</div>
</div>
<a class="anchor" id="ae8fb41930976d8d19f85e61638a7d6d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::follow_edges_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>go_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loop over all the handles to next/previous (right/left) nodes. Passes them to a callback which returns false to stop iterating and true to continue. Returns true if we finished and false if we stopped early. </p>

</div>
</div>
<a class="anchor" id="a892abc4056e30044ae9ce0db9e4871f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::for_each_connected_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Node.html">Node</a> *)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Go through all the nodes in the same connected component as the given node. Ignores relative orientation. </p>

</div>
</div>
<a class="anchor" id="a3d7fdd8c951cbf8b25e116435b5e1e0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::for_each_edge </td>
          <td>(</td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the given function for each edge. </p>

</div>
</div>
<a class="anchor" id="a0bd448b5f9115c64efdd6514cbf05ae0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::for_each_edge </td>
          <td>(</td>
          <td class="paramtype">function&lt; void(const <a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a46a20aa427767a27fd15d181ccca8c42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::for_each_edge_parallel </td>
          <td>(</td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the given function for each edge, in parallel. </p>

</div>
</div>
<a class="anchor" id="a5cd959c93ee2d6addc727b47164a6be8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::for_each_handle_impl </td>
          <td>(</td>
          <td class="paramtype">const function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loop over all the nodes in the graph in their local forward orientations, in their internal stored order. Stop if the iteratee returns false. </p>

</div>
</div>
<a class="anchor" id="af585f2161de09403d197e05fbcfb9a07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::for_each_node </td>
          <td>(</td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Node.html">Node</a> *)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the given function on every node. </p>

</div>
</div>
<a class="anchor" id="a8815f6165628d04e4dade8987aeeb22a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::for_each_node </td>
          <td>(</td>
          <td class="paramtype">function&lt; void(const <a class="el" href="structvg_1_1Node.html">Node</a> *)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a39790d52fe4c09804086d58164258fcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::for_each_node_parallel </td>
          <td>(</td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Node.html">Node</a> *)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the given function on every node in parallel. </p>

</div>
</div>
<a class="anchor" id="ad8d0976ab79947044eec399698299777"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::for_each_path_handle_impl </td>
          <td>(</td>
          <td class="paramtype">const function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a function on each path in the graph. </p>

</div>
</div>
<a class="anchor" id="af1c6f800abfa14fdca58936e97907004"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::for_each_step_on_handle_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loop over the steps of a handle in paths. </p>

</div>
</div>
<a class="anchor" id="a3c22829197fc65ced4dd2e0f53cb20ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::from_istream </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showp</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>warn_on_duplicates</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8aef48163c0dd4267d24b629de8a04c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::from_turtle </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>baseuri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showp</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a graph from a Turtle stream. </p>
<p>Add the paths that we parsed into the vg object </p>

</div>
</div>
<a class="anchor" id="ae2eb11662200dc88ef8397a1b2232056"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; vg::VG::full_siblings_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>trav</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Full from-siblings are nodes traversals which share exactly the same downstream <code><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a></code>s. </p>

</div>
</div>
<a class="anchor" id="a0a79ae3ab132b28cf72b6c18644fcf2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; vg::VG::full_siblings_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>trav</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Full to-siblings are nodes traversals which share exactly the same upstream <code><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a></code>s. </p>

</div>
</div>
<a class="anchor" id="ac1546dff9dc144260cb40050bf8dcfa2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char vg::VG::get_base </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns one base of a handle's sequence, in the orientation of the handle. </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1HandleGraph.html#ab81250d605ef63546d70475432633aed">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="ac1a8a09a49ea348f3714377b893319f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::VG::get_degree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>go_left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Efficiently get the number of edges attached to one side of a handle. Uses the <a class="el" href="classvg_1_1VG.html">VG</a> graph's internal degree index. </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1HandleGraph.html#a8800aafcd81470ba313839138f608a39">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a8668ddc84b9abe4fe9cb5acb3efd877b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Edge.html">Edge</a> * vg::VG::get_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;&#160;</td>
          <td class="paramname"><em>side1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;&#160;</td>
          <td class="paramname"><em>side2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a pointer to the specified edge. This can take sides in any order. </p>

</div>
</div>
<a class="anchor" id="a227023072262f46f7c423d30cf8bc443"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Edge.html">Edge</a> * vg::VG::get_edge </td>
          <td>(</td>
          <td class="paramtype">const pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sides</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a pointer to the specified edge. This can take sides in any order. </p>

</div>
</div>
<a class="anchor" id="af63d7ba7b69594ee99f3ad99dd394171"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Edge.html">Edge</a> * vg::VG::get_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the edge connecting the given oriented nodes in the given order. </p>

</div>
</div>
<a class="anchor" id="a26a218b188035e086a5625170cfcf23c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::VG::get_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up the handle for the node with the given ID in the given orientation. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a6dd9d70931835f5c75518b23a780b744">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a80e9b71f9dd2cbfb1881b830ae4654b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::VG::get_handle_of_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a node handle (node ID and orientation) from a handle to an step on a path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a339e690ce3e2bb8280dd1f3ea45abe42">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a275f9a67d357980049ff3a6cb475a0a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> vg::VG::get_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ID from a handle. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#adb7f6e144bf2a59679f7b2eddad934eb">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a5b36247a6ca74800a80d83170948fee9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::get_is_circular </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up whether a path is circular. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a9391c34d9f0c16b21d5bb3bb7ec772e4">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a101b575652f006b09c33ba271806e721"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::get_is_reverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the orientation of a handle. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a92773f90eb58f18adb9418a4440223c1">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a7f8816a7244ebad64663a1af13f5244c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::VG::get_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of a node. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a569ff35fb85c725b0b6b6933ed303e49">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="aa94c162ade42415f7defe7677e5bae53"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> vg::VG::get_next_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a handle to the next step on the path. If the given step is the final step of a non-circular path, returns the past-the-last step that is also returned by path_end. In a circular path, the "last" step will loop around to the "first" (i.e. the one returned by path_begin). Note: to iterate over each step one time, even in a circular path, consider for_each_step_in_path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a209786f5c9e2c0210b383f2022ee221f">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a49c1cef3ec020f0f494dbb0fd24deb7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Node.html">Node</a> * vg::VG::get_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a particular node. </p>

</div>
</div>
<a class="anchor" id="aceed581863f873d9b18e9a158e85e1f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvg_1_1Node.html">Node</a> * vg::VG::get_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1f8d1d0b977473d9c5b1b0ffa304a338"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> vg::VG::get_node_at_nucleotide </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>pathname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nuc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes in a pathname and the nucleotide position (like from a vcf) and returns the node id which contains that position. </p>

</div>
</div>
<a class="anchor" id="ad4c33ebd670cbcc46a8950512663fbe0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::VG::get_node_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of nodes in the graph. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a9f95108e6c3f68f404fa93bd3306e4c6">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a12f5208ae9a2f22a31658dfaad28229b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, vcflib::Variant &gt; vg::VG::get_node_id_to_variant </td>
          <td>(</td>
          <td class="paramtype">vcflib::VariantCallFile&#160;</td>
          <td class="paramname"><em>vfile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes in a VCF file and returns a map [node] = vcflib::variant. Unfortunately this is specific to a given graph and VCF.</p>
<p>It will need to throw warnings if the node or variant is not in the graph.</p>
<p>This is useful for VCF masking: </p>
<pre class="fragment">if map.find(node) then mask variant
</pre><p>It's also useful for calling known variants </p>
<pre class="fragment">for m in alignment.mappings:
   node = m.Pos.nodeID
   if node in node_to_vcf:
       return (alignment supports variant)
</pre><p>It would be nice if this also supported edges (e.g. for inversions/transversions/breakpoints?). </p>

</div>
</div>
<a class="anchor" id="a20417af67e14d7800b20df8b0ac763f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::VG::get_path_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of paths stored in the graph. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#acd5df753593ecdfb7aa8c411b98ebad9">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a26f160750dfed33c16a257bd5cbecddf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; vg::VG::get_path_edges </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all of the edges that are on any path. </p>

</div>
</div>
<a class="anchor" id="a0789f1df0078dff5849a97f60ca4d51e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> vg::VG::get_path_handle </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up the path handle for the given path name. </p>

</div>
</div>
<a class="anchor" id="a5c8b0de9776e2f4ee0b1185ba59485c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> vg::VG::get_path_handle_of_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a handle to the path that an step is on. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a1d1ca9865da585257709f54769f5d6a9">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="ac71b9547040f0d8ae430d564aa897d97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::VG::get_path_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up the name of a path from a handle to it. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a565f4312a42dfe77ae14c1ee9ed9f2ba">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a1723ce56da21a5f6953464d03e4849ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> vg::VG::get_previous_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a handle to the previous step on the path. If the given step is the first step of a non-circular path, this method has undefined behavior. In a circular path, it will loop around from the "first" step (i.e. the one returned by path_begin) to the "last" step. Note: to iterate over each step one time, even in a circular path, consider for_each_step_in_path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a71040226b29aa5046f4cc04c8c9aa9fb">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a7382f9cc8ef44b358495d021a0a0f80b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::VG::get_sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the sequence of a node, presented in the handle's local forward orientation. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a8cc2ab8a1292e30ba5e167a823f66d92">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a212238ea52a6c8f542bb3c6b866cb040"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::VG::get_step_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of node steps in the path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#add91075c3490f8dc5acf667f2b26832c">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="aae8a010d477eb8e1e2cfd91efa8a29e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::VG::get_subsequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a substring of a handle's sequence, in the orientation of the handle. If the indicated substring would extend beyond the end of the handle's sequence, the return value is truncated to the sequence's end. </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1HandleGraph.html#a98ee3b143ad6a5a1d259122386ce6556">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a150b452102319b93490e53b2dc62e920"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Efficiently check for the existence of an edge using <a class="el" href="classvg_1_1VG.html">VG</a> graph's internal index of node sides. </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1HandleGraph.html#adda410641b362f9530c62dd503a7abec">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a78f57fbc3cca245bce36c7bb1321333c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;&#160;</td>
          <td class="paramname"><em>side1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;&#160;</td>
          <td class="paramname"><em>side2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the edge between the given node sides, which can be in either order. </p>

</div>
</div>
<a class="anchor" id="a19fd9594b3b8092070ebe1b0ab430863"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_edge </td>
          <td>(</td>
          <td class="paramtype">const pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sides</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph has an edge. This can take sides in any order. </p>

</div>
</div>
<a class="anchor" id="a6cccef0336502dcefd497b63a0e9f545"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph has an edge. This can take sides in any order. </p>

</div>
</div>
<a class="anchor" id="a04a8d5301a328b3046570bdf134b9194"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Edge.html">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph has an edge. This can take sides in any order. </p>

</div>
</div>
<a class="anchor" id="a49fb4de3494407b800c3efda254851cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_inverting_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph has an inverting edge on the given node. </p>

</div>
</div>
<a class="anchor" id="a7b7bbf066c6608211e7527ba50b23e48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_inverting_edge_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph has an inverting edge from the given node. </p>

</div>
</div>
<a class="anchor" id="a63088ee0039a8e1f5cf6b5a3b23f745a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_inverting_edge_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph has an inverting edge to the given node. </p>

</div>
</div>
<a class="anchor" id="a8d1dbb49df52e016746829776ca0f952"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_inverting_edges </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph has inversions. </p>

</div>
</div>
<a class="anchor" id="a76c0e39a4a3f4df40c3a460b92a4a484"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_next_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the step is not the last step in a non-circular path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a81bf54cb4d07a0d47c84862ecebc349d">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a37c72c4989c1bebcec7e98115041b501"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the graph has a node with the given ID. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a6e58a79001cd7d839ac1f1adaff34dfb">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="aec9fb90202c77a6d104c634e2d2a3e62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph contains the given node. </p>

</div>
</div>
<a class="anchor" id="a907734904cd304ecee0b432ed598d106"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph contains the given node. </p>

</div>
</div>
<a class="anchor" id="a86daea8c9c2ff784598512fff740bd2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_path </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if a path name exists and is legal to get a path handle for. </p>

</div>
</div>
<a class="anchor" id="a07ff80d377e97f67e98b75d6e64f3dbc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_previous_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the step is not the first step in a non-circular path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a93a1ee451e750cb82f1711fd6c3db8cc">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a2b75ca400f858be77b0716ab7c68dfcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string vg::VG::hash </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a digest of the serialized graph. </p>

</div>
</div>
<a class="anchor" id="a7eecc0bd555c31d1c541c3ce44b421c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::head_nodes </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the head nodes (nodes with edges only to their right sides). These are required to be oriented forward. </p>

</div>
</div>
<a class="anchor" id="a3a44c415fb5882c184e2f35bb3999700"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; vg::VG::head_nodes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the head nodes (nodes with edges only to their right sides). These are required to be oriented forward. </p>

</div>
</div>
<a class="anchor" id="ab1aecdffe7759a1e14248e00f2866b84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::id_sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Order the backing graph data structure by node ID. </p>

</div>
</div>
<a class="anchor" id="acb33bdc43954b8acd955bb4425a48df1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &gt; vg::VG::identically_oriented_sibling_sets </td>
          <td>(</td>
          <td class="paramtype">const set&lt; set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>sibs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove sibling sets which don't have identical orientation. </p>

</div>
</div>
<a class="anchor" id="abbd7b9f01799a351e0e5ba420fa06679"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::identity_translation </td>
          <td>(</td>
          <td class="paramtype">unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_translation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record the translation of this graph into itself in the provided map. </p>

</div>
</div>
<a class="anchor" id="a66e4dac76edcf0218f9749352c19acae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::include </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit the graph to include the path. </p>

</div>
</div>
<a class="anchor" id="a522cc6a9721f305ab01ce823d843662d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::increment_node_ids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>increment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the given value to all node IDs. Preserves the paths. </p>

</div>
</div>
<a class="anchor" id="a53ff7033966852f5fb3852716cab21a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::index_edge_by_node_sides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an edge to the node side indexes. Doesn't touch the index of edges by node pairs or the graph; those must be updated seperately. </p>

</div>
</div>
<a class="anchor" id="aafd0f191fe33bd4590f15f309d0fd89c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>setup, ensures that gssw == NULL on startup </p>

</div>
</div>
<a class="anchor" id="a71388f637b255bf16a940e735a12aacd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_acyclic </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the graph does not contain cycles. </p>

</div>
</div>
<a class="anchor" id="a65e98e20589f3f63de75f4dc63526562"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_ancestor_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>candidate_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the node is a next ancestor of this one. </p>

</div>
</div>
<a class="anchor" id="a837620e82b388581d91300a53c099574"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_ancestor_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>candidate_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>seen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>steps</em> = <code>64</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the node is a next ancestor of this one by trying to find it in a given number of steps. </p>

</div>
</div>
<a class="anchor" id="a7237af28b6fd3159ce048ec66679935c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_ancestor_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>candidate_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the node is a prev ancestor of this one. </p>

</div>
</div>
<a class="anchor" id="aec9353f02748091b04439a26fda57f9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_ancestor_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>candidate_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>seen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>steps</em> = <code>64</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the node is a prev ancestor of this one by trying to find it in a given number of steps. </p>

</div>
</div>
<a class="anchor" id="ae5cdd8d94bcfce1302ba9e2cbfb5e412"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_head_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a node is a head node. </p>

</div>
</div>
<a class="anchor" id="a1bc3866468d5eb941fa6ba010ccce2ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_head_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a node is a head node. </p>

</div>
</div>
<a class="anchor" id="ad09549b6cfab8e1097dd207e01e57812"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_self_looping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does the specified node have any self-loops? </p>

</div>
</div>
<a class="anchor" id="a40b412ca09b09b3c0e07bcd5bd9ee03b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_tail_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a node is a tail node. </p>

</div>
</div>
<a class="anchor" id="af58b227f21324d30be531088ed49b0f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_tail_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a node is a tail node. </p>

</div>
</div>
<a class="anchor" id="aa77d93fdf76698460ce509ea5dcde954"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_valid </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_nodes</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_edges</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_paths</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_orphans</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph is valid or not, according to the specified criteria. </p>

</div>
</div>
<a class="anchor" id="a817384b8d147371448ad60e1db097b52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Node.html">Node</a> * vg::VG::join_heads </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join head nodes of graph to common null node, creating a new single head. </p>

</div>
</div>
<a class="anchor" id="adc40377520118436b729cd68be16d0ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::join_heads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_start</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join head nodes of graph to specified node. Optionally from the start/to the end of the new node. </p>

</div>
</div>
<a class="anchor" id="a33e3f7942afd3ca82bfb78083c245146"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::join_tails </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_end</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join tail nodes of graph to specified node. Optionally from the start/to the end of the new node. </p>

</div>
</div>
<a class="anchor" id="a049393f32addf4071a14de2e874e94ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::keep_multinode_strongly_connected_components </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all elements which are not in a strongly connected component. </p>

</div>
</div>
<a class="anchor" id="a65cc16f52f478a25e84c6f1fc2805915"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::keep_path </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac2aa9d438bcec4d7facbfcc44abea8fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::keep_paths </td>
          <td>(</td>
          <td class="paramtype">const set&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>kept_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Keep paths in the given set of path names. Populates kept_names with the names of the paths it actually found to keep. The paths specified may not overlap. Removes all nodes and edges not used by one of the specified paths. </p>

</div>
</div>
<a class="anchor" id="af9ac6e61dfa9350459dbb9586088c4a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::left_degree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of edges attached to the left side of a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>. </p>

</div>
</div>
<a class="anchor" id="a23641dedefa2b6d573939515fcf5974c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::VG::length </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total sequence length. </p>

</div>
</div>
<a class="anchor" id="ada5821862279a350885f5368a54a5cba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::likelihoods </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>alignments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; long double &gt; &amp;&#160;</td>
          <td class="paramname"><em>likelihoods</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acd555e66c8fa99984c8cb24aef0ab6f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::mapping_is_total_match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the mapping completely covers the node it maps to and is a perfect match. </p>

</div>
</div>
<a class="anchor" id="a3751016fff6e1e38d154515a13949e74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> vg::VG::max_node_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum node ID used in the graph, if any are used. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a5a2e2b1ea6a29b3f4b34a6abcb6dbc50">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a0abc84684faea29b49032ec254d5e13b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Literally merge protobufs. </p>

</div>
</div>
<a class="anchor" id="a40f22f6bb4a3e7a2aea7b3887237faec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Literally merge protobufs. </p>

</div>
</div>
<a class="anchor" id="a1f9aa921b25ba77f37366768b4b090ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Node.html">Node</a> * vg::VG::merge_nodes </td>
          <td>(</td>
          <td class="paramtype">const list&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge the nodes into a single node, preserving external linkages. Use the orientation of the first node as the basis. </p>

</div>
</div>
<a class="anchor" id="a5aff716eee0bf720b3836caa761d48be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::merge_union </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge protobufs after removing overlaps. Good when there aren't many overlaps. </p>

</div>
</div>
<a class="anchor" id="a78f9c36b6c3f7cbe933f705e9e9ba782"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> vg::VG::min_node_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the minimum node ID used in the graph, if any are used. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a85c52fe4b5f483504ed142d0ad94a969">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a21c034f10ebf2555f8a69564368be8f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; set&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &gt; vg::VG::multinode_strongly_connected_components </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get only multi-node strongly connected components. </p>

</div>
</div>
<a class="anchor" id="a8a94aeff38cf579243532fde605260a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::VG::node_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of nodes in the graph. </p>

</div>
</div>
<a class="anchor" id="a4c614759c77b4b0a95b25360c2fa1fa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::node_count_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the nodes attached to the right side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>. </p>

</div>
</div>
<a class="anchor" id="a1091113608fae5b9cbafc87cf4cf82a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::node_count_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the nodes attached to the left side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>. </p>

</div>
</div>
<a class="anchor" id="a0202180fa7153f464c3b1d3ff70dc9cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::node_rank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the rank of the node in the protobuf array that backs the graph. </p>

</div>
</div>
<a class="anchor" id="aa564542c73b2b800a4fa42e591c1879f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::node_rank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the rank of the node in the protobuf array that backs the graph. </p>

</div>
</div>
<a class="anchor" id="a093f4e4dffe0d03806df32edc33cdb9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::node_starts_in_path </td>
          <td>(</td>
          <td class="paramtype">const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; <a class="el" href="structvg_1_1Node.html">Node</a> *, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill in the node_start map with the first index along the path at which each node appears. Caller is responsible for dealing with orientations. </p>

</div>
</div>
<a class="anchor" id="ac27c591957478a17605c2453749f7d20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::node_starts_in_path </td>
          <td>(</td>
          <td class="paramtype">list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> *, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find node starts in a path. TODO: what does that mean? To get the starts out of the map this produces, you need to dereference the iterator and then get the address of the <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> (stored in the list) that you are talking about. </p>

</div>
</div>
<a class="anchor" id="a9bf8c0e391c1a6c027ed26b991d8cad0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::nodes_are_perfect_path_neighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if nodes share all paths and the mappings they share in these paths are adjacent, in the specified relative order and orientation. </p>

</div>
</div>
<a class="anchor" id="a0b084d958fd8069839884dc3a01ed745"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::nodes_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nodes attached to the right side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>, in their proper orientations. </p>

</div>
</div>
<a class="anchor" id="a62f1bb7fa27d4d4312017b113aab099a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; vg::VG::nodes_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nodes attached to the right side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>, in their proper orientations. </p>

</div>
</div>
<a class="anchor" id="ac08e778396904ad3b3f20f605f54628d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::nodes_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nodes attached to the left side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>, in their proper orientations. </p>

</div>
</div>
<a class="anchor" id="a0f3e69ced0c3135f3f363c14bf752aad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; vg::VG::nodes_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nodes attached to the left side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>, in their proper orientations. </p>

</div>
</div>
<a class="anchor" id="a44edad9ba2a6df332234b43715dd71db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::nonoverlapping_node_context_without_paths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the subgraph of a node and all the edges it is responsible for (where it has the minimal ID) and add it into the given <a class="el" href="classvg_1_1VG.html">VG</a>. </p>

</div>
</div>
<a class="anchor" id="a217f8b5abd62bcdb256cf15926c9fe5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::normalize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use unchop and sibling merging to simplify the graph into a normalized form. </p>

</div>
</div>
<a class="anchor" id="a46f1fe88897cfe4d62625cffd3db5ebb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1VG.html">VG</a> &amp; vg::VG::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>

</div>
</div>
<a class="anchor" id="a3b3efbadb9fd3923bbc7e8f0b73c524f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1VG.html">VG</a> &amp; vg::VG::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>

</div>
</div>
<a class="anchor" id="a0b4fa1970f08f3e4d0cf2f8c33a967a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::optimize </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_id_reassignment</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adjust the representation of the graph in memory to improve performance. Optionally, allow the node IDs to be reassigned to further improve performance. Note: Ideally, this method is called one time once there is expected to be few graph modifications in the future. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a195c81fa446b62d94fda8841eaa3bb85">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a7fc72119c835adc52a935efca0bdda0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; vg::VG::overlay_node_translations </td>
          <td>(</td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>over</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>under</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assume two node translations, the over is based on the under; merge them. </p>

</div>
</div>
<a class="anchor" id="a868379db6918fd879eb5da7e6f9bc798"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> vg::VG::path_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a handle to the last step, which will be an arbitrary step in a circular path that we consider "last" based on our construction of the path. If the path is empty then the implementation must return the same value as <a class="el" href="classvg_1_1VG.html#acfe330c38f9bd036838e4e5d133b1657">path_front_end()</a>. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a31bb33a87ad8efd68876fc5ae1deeb09">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a8ba115ffda674c76e8956a8057545b25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> vg::VG::path_begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a handle to the first step, or in a circular path to an arbitrary step considered "first". If the path is empty, returns the past-the-last step returned by path_end. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a815759484087ed92214c2c1c6b9d1a11">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a5f1df72d85d8a72524b76abca972f33d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::path_edge_count </td>
          <td>(</td>
          <td class="paramtype">list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>path_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="structvg_1_1Path.html">Path</a> stats. Starting from offset in the first node, how many edges do we cross? path must be nonempty and longer than the given length. offset is interpreted as relative to the first node in its on-path orientation, and is inclusive. </p>

</div>
</div>
<a class="anchor" id="a6eaa8a920a65428b70b7b77142805208"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> vg::VG::path_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a handle to a fictitious position past the end of a path. This position is return by get_next_step for the final step in a path in a non-circular path. Note that get_next_step will <em>NEVER</em> return this value for a circular path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a5c3a5e04838d9e4a0a0ddf574c4de827">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a8f45b42614f4ac36c8060634ec0d9805"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::path_end_node_offset </td>
          <td>(</td>
          <td class="paramtype">list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>path_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine the offset in its last node at which the path starting at this offset in its first node ends. path must be nonempty and longer than the given length. offset is interpreted as relative to the first node in its on-path orientation, and is inclusive. Returned offset is remaining unused length in the last node touched. </p>

</div>
</div>
<a class="anchor" id="acfe330c38f9bd036838e4e5d133b1657"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> vg::VG::path_front_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a handle to a fictitious position before the beginning of a path. This position is return by get_previous_step for the first step in a path in a non-circular path. Note: get_previous_step will <em>NEVER</em> return this value for a circular path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#ad7412bf19084f2b38ffec42517a6a9e9">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="ad9bd4133841d1d781fb0df4171773139"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::VG::path_identity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return percent identity between two paths (# matches / (#matches + #mismatches)). Note: uses ssw aligner, so will only work on small paths. </p>

</div>
</div>
<a class="anchor" id="a4ce6fe02b243b4f0f82bbf801fd507fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string vg::VG::path_sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return sequence string of path. </p>

</div>
</div>
<a class="anchor" id="af8f4e2ab506f4ef673836b5901bb3809"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::VG::path_string </td>
          <td>(</td>
          <td class="paramtype">const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the string sequence for all the NodeTraversals on the given path. </p>

</div>
</div>
<a class="anchor" id="a927b79f3f4c9582b0f8e988bb4ef1aa1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::VG::path_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the string sequence for traversing the given path. Assumes the path covers the entirety of any nodes visited. Handles backward nodes. </p>

</div>
</div>
<a class="anchor" id="a871d05e0a2d0b76092e20fe86bd12e2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; vg::VG::paths_as_alignments </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the stored paths in this graph to alignments. </p>

</div>
</div>
<a class="anchor" id="a8dc8d762d07088089247b632c835a19d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::paths_between </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af39a51572be3a442165d50e555e325ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::paths_between </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a43c2858dc8e80ba160359ccf5e1508d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> vg::VG::prepend_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to_prepend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a visit to a node to the given path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#aed17038a0104017d37ff74e15f7f436a">handlegraph::MutablePathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a2b659686076f3d6b7b63ec9678d76a93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::print_edges </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad4878ca3ebc2c14d008e57c7ae8d5845"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::prune_complex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>path_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edge_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>head_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>tail_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take all nodes that would introduce paths of &gt; edge_max edge crossings, remove them, and link their neighbors to head_node or tail_node depending on which direction the path extension was stopped. Optionally preserve edges on the embedded paths. For pruning graph prior to indexing with gcsa2. </p>

</div>
</div>
<a class="anchor" id="a4ea2fe244a857ff24d0176449bedd4ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::prune_complex_paths </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edge_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>head_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>tail_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Limit the local complexity of the graph, connecting pruned components to a head and tail node depending on the direction which we come into the node when the edge_max is passed. </p>

</div>
</div>
<a class="anchor" id="ae0765f466db760a9a450f4d4115a59bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::prune_complex_with_head_tail </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>path_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edge_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrap the graph with heads and tails before doing the prune. Utility function for preparing for indexing. </p>

</div>
</div>
<a class="anchor" id="a590703c2954a2a15d735995c2007a879"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::prune_short_subgraphs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aec84f7813f59a16b2d0c1bd72904ae5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::random_read </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>read_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mt19937 &amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>min_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>max_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>either_strand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate random reads. Note that even if either_strand is false, having backward nodes in the graph will result in some reads from the global reverse strand. </p>

</div>
</div>
<a class="anchor" id="a6541146b6410cec4be3e2a7379ea3bcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::rebuild_edge_indexes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a63d4e45a9a410c451b1cad44ef7068ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::rebuild_indexes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a33424c3be8c3e088631dfb37c48773d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::remove_duplicated_in </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper to merge_union. </p>

</div>
</div>
<a class="anchor" id="aba9fb73c326ecfab70e35e44dff6a937"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::remove_duplicates </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove duplicated nodes and edges. </p>

</div>
</div>
<a class="anchor" id="a76005ed499eea217c9f778028751137c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::remove_inverting_edges </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove edges representing an inversion and edges on the reverse complement. </p>

</div>
</div>
<a class="anchor" id="ab92694e7fd89275603c967739e60e0d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::remove_node_forwarding_edges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a node but connect all of its predecessor and successor nodes with new edges. </p>

</div>
</div>
<a class="anchor" id="ad517da731d2bf9c81cc28e0a1367af33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::remove_non_path </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove pieces of the graph which are not part of any path. </p>

</div>
</div>
<a class="anchor" id="a9b107027697644d771eb529037201f71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::remove_null_nodes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove nodes with no sequence. These are created in some cases during the process of graph construction. </p>

</div>
</div>
<a class="anchor" id="a0e887a7b2cfc666f2210889a2dec791b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::remove_null_nodes_forwarding_edges </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove null nodes but connect predecessors and successors, preserving structure. </p>

</div>
</div>
<a class="anchor" id="a40dd9bc0458a4948afd676374ae8d1f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::remove_orphan_edges </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove edges for which one of the nodes is not present. </p>

</div>
</div>
<a class="anchor" id="a30c369b4c1b0dfa4e9fbc0d3bce82648"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::remove_path </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove pieces of the graph which are part of some path. </p>

</div>
</div>
<a class="anchor" id="af8879b1e6aab38b9a246deba0f05ccfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::resize_indexes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a00287a092635fc711de1f0a82f66ae77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1VG.html">VG</a> vg::VG::reverse_complement_graph </td>
          <td>(</td>
          <td class="paramtype">unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_translation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the reverse complemented graph with topology preserved. Record translation in provided map. </p>

</div>
</div>
<a class="anchor" id="abb2dc75f200cfb7480e671fd55207410"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; vg::VG::rewrite_segment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>segment_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>segment_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_segment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Delete a segment of a path and rewrite it as some other sequence of steps. Returns a pair of step_handle_t's that indicate the range of the new segment in the path. </p>

</div>
</div>
<a class="anchor" id="a23622195177dff4c7c8416edffb7fc93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::right_degree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of edges attached to the right side of a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>. </p>

</div>
</div>
<a class="anchor" id="a38b7b580164861c1ced0b660bd4fa4c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::same_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use sides_from an sides_to to determine if both nodes have the same context. </p>

</div>
</div>
<a class="anchor" id="a97a0549f64f6a8a3e7dbe8f1e4767fd5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::serialize </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the contents of this graph to an ostream. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1SerializableHandleGraph.html#a7ab06a8c1224d3289ff24065c62c642a">handlegraph::SerializableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a21895abf98522a767df2fbee56824c72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::serialize_to_emitter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">vg::io::ProtobufEmitter</a>&lt; <a class="el" href="structvg_1_1Graph.html">Graph</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>emitter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write chunked graphs to a ProtobufEmitter that will write them to a stream. Use when combining multiple <a class="el" href="classvg_1_1VG.html">VG</a> objects in a stream. <a class="el" href="structvg_1_1Graph.html">Graph</a> will be serialized in internal storage order. </p>

</div>
</div>
<a class="anchor" id="a8841bfa5a6c888820e6a29c8010e72fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::serialize_to_file </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the graph to a file, with an EOF marker. <a class="el" href="structvg_1_1Graph.html">Graph</a> will be serialized in internal storage order. </p>

</div>
</div>
<a class="anchor" id="a95718abe48e846e03a845724b37a4622"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::serialize_to_function </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(<a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>emit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send chunked graphs to a function that will write them somewhere. Used to internally implement saving to many destinations. <a class="el" href="structvg_1_1Graph.html">Graph</a> will be serialized in internal storage order. This is NOT const because it synchronizes path ranks before saving! We allow the emitted <a class="el" href="structvg_1_1Graph.html">Graph</a> to move. </p>

</div>
</div>
<a class="anchor" id="ab217740a8290f9706c260172f19ef221"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::serialize_to_ostream </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write to a stream in chunked graphs. Adds an EOF marker. Use when this <a class="el" href="classvg_1_1VG.html">VG</a> will be the only thing in the stream. <a class="el" href="structvg_1_1Graph.html">Graph</a> will be serialized in internal storage order. </p>

</div>
</div>
<a class="anchor" id="a73c97ce0157b90f95b888e4b6983f5c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::set_circularity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>circular</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a path circular or non-circular. If the path is becoming circular, the last step is joined to the first step. If the path is becoming linear, the step considered "last" is unjoined from the step considered "first" according to the method path_begin. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#a9172694447503e35d50093d55e845eb8">handlegraph::MutablePathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="ae1131c1ff0a94ed2ec9ef35cb678801b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::set_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the edge indexes through this function. Picks up the sides being connected by the edge automatically, and silently drops the edge if they are already connected. </p>

</div>
</div>
<a class="anchor" id="ac684d17ffe4c85ce74a4677fdfaf7672"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; vg::VG::siblings_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>traversal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>From-siblings are nodes which also have edges to them from the same nodes as this one. </p>

</div>
</div>
<a class="anchor" id="a5f202743732e5335bb1b15413914eaa6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; vg::VG::siblings_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get general siblings of a node. </p>

</div>
</div>
<a class="anchor" id="abac7d4642b9bcc25bc5299af18f523bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; vg::VG::siblings_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>traversal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To-siblings are nodes which also have edges to them from the same nodes as this one. </p>

</div>
</div>
<a class="anchor" id="a21a20098d0a29a1f3f0e9f932fcce462"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, bool &gt; &gt; vg::VG::sides_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all sides connecting to this node. </p>

</div>
</div>
<a class="anchor" id="ac670f3c729f93ebaa7c8bd5063225597"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; vg::VG::sides_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&#160;</td>
          <td class="paramname"><em>side</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sides on the other side of edges from this side of the node. </p>

</div>
</div>
<a class="anchor" id="a63aa329381f85cffbb793d19a8b17b52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; vg::VG::sides_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sides from both sides of the node. </p>

</div>
</div>
<a class="anchor" id="a030b75d2ad50905cc01fe4b7223cbb83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; vg::VG::sides_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&#160;</td>
          <td class="paramname"><em>side</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Union of sides_to and sides_from. </p>

</div>
</div>
<a class="anchor" id="a1a156ac1e1fde520bae82850105c6c66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; vg::VG::sides_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&#160;</td>
          <td class="paramname"><em>side</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sides on the other side of edges to this side of the node. </p>

</div>
</div>
<a class="anchor" id="aee2b9b646282c9a466a531916213e867"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; vg::VG::sides_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sides to both sides of the node. </p>

</div>
</div>
<a class="anchor" id="ad0dcdbceae7ad22b60e4966e9644b612"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &gt; vg::VG::simple_components </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_size</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the set of components that could be merged into single nodes without changing the path space of the graph. Emits oriented traversals of nodes, in the order and orientation in which they are to be merged. </p>

</div>
</div>
<a class="anchor" id="adff96e1df8d63362f110efa996d817e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &gt; vg::VG::simple_multinode_components </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the simple components of multiple nodes. </p>

</div>
</div>
<a class="anchor" id="a171c17f06d7bb0645776f466fe3d3a1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::simplify_from_siblings </td>
          <td>(</td>
          <td class="paramtype">const set&lt; set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>from_sibs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove easily-resolvable redundancy in the graph for all provided from-sibling sets. </p>

</div>
</div>
<a class="anchor" id="a3e90bd47ffc24a55b1588be8f5328717"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::simplify_siblings </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove easily-resolvable redundancy in the graph. TODO: Cannot yet handle reversing edges! They will prevent the identification of siblings. </p>

</div>
</div>
<a class="anchor" id="a5c037db7f5ec45293ac6650d46040237"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::simplify_to_siblings </td>
          <td>(</td>
          <td class="paramtype">const set&lt; set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>to_sibs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove easily-resolvable redundancy in the graph for all provided to-sibling sets. </p>

</div>
</div>
<a class="anchor" id="a9e3720ce267c8167ce679a015063dab6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::VG::size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of nodes. </p>

</div>
</div>
<a class="anchor" id="a902d516631c77d074aa2a11ae70a6957"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Topologically sort the graph, and then apply that sort to re- order the nodes in the backing data structure. The sort is guaranteed to be stable. This sort is well-defined on graphs that are not DAGs, but instead of finding a topological sort it does a heuristic sort to minimize a feedback arc set. </p>

</div>
</div>
<a class="anchor" id="a1ff00edd627e3445eee7f43927bb1518"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::start_degree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of edges attached to the start of a node. </p>

</div>
</div>
<a class="anchor" id="ab447b1c70f7c4dc6576bfabc1990c337"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; set&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &gt; vg::VG::strongly_connected_components </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the strongly connected components of the graph. </p>

</div>
</div>
<a class="anchor" id="a3d4db6ea2a99bda9a48411491aa6ed4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::swap_handles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap the nodes corresponding to the given handles, in the ordering used by for_each_handle when looping over the graph. Other handles to the nodes being swapped must not be invalidated. </p>

</div>
</div>
<a class="anchor" id="a0f8c9051591df60d405a8dc1006aa6d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::swap_node_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>new_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the ID of the node with the first id to the second, new ID not used by any node. Invalidates any paths containing the node, since they are not updated. </p>

</div>
</div>
<a class="anchor" id="aa906c5779ea372eb4dd0d9b8cc224be3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::swap_node_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>new_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the ID of the given node to the second, new ID not used by any node. Invalidates the paths. Invalidates any paths containing the node, since they are not updated. </p>

</div>
</div>
<a class="anchor" id="aa402d1cf817f83ca44f72f6112b6a2e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::swap_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap the given nodes. TODO: what does that mean? </p>

</div>
</div>
<a class="anchor" id="a124188a9e0cd68c87c2bc009ea7bd799"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::sync_paths </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize in-memory indexes and protobuf graph. </p>

</div>
</div>
<a class="anchor" id="a25bd74b77e139691555c8d48ecf67d9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; vg::VG::tail_nodes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the tail nodes (nodes with edges only to their left sides). These are required to be oriented forward. </p>

</div>
</div>
<a class="anchor" id="a47fbc525ed5e9f2a7b00c333f03fe6c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::tail_nodes </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the tail nodes (nodes with edges only to their left sides). These are required to be oriented forward. </p>

</div>
</div>
<a class="anchor" id="a5a4e14a60334c2ba3ce3bed0e3fd0b91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::to_dot </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&#160;</td>
          <td class="paramname"><em>alignments</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Locus.html">Locus</a> &gt;&#160;</td>
          <td class="paramname"><em>loci</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_paths</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>walk_paths</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>annotate_paths</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_mappings</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>simple_mode</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert_edge_ports</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>color_variants</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ultrabubble_labeling</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skip_missing_nodes</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ascii_labels</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>random_seed</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the graph to Dot format. </p>

</div>
</div>
<a class="anchor" id="a582500a3d49fe231faa49a5c2e467cc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::to_turtle </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>rdf_base_uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>precompress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the graph to Turtle format. </p>

</div>
</div>
<a class="anchor" id="ab928179a1a4c5a535aefab8cda99c591"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> vg::VG::total_length_of_nodes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the total sequence length of nodes in the graph. TODO: redundant with <a class="el" href="classvg_1_1VG.html#a23641dedefa2b6d573939515fcf5974c" title="Total sequence length. ">length()</a>. </p>

</div>
</div>
<a class="anchor" id="afce50214291804f0d9bdf9bcd39125a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &gt; vg::VG::transitive_sibling_sets </td>
          <td>(</td>
          <td class="paramtype">const set&lt; set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>sibs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove intransitive sibling sets, such as where (A, B, C) = S1 but C ∊ S2. </p>

</div>
</div>
<a class="anchor" id="a57296ecbcfce10f95b86233e10c35d7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::VG::trav_sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>trav</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sequence of a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>. </p>

</div>
</div>
<a class="anchor" id="a34a493a0628857a3bfae181295ba541d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; vg::VG::travs_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get traversals after this node on the same strand. Same as nodes_next but using set. </p>

</div>
</div>
<a class="anchor" id="ae065082f817e9bc0e278cf71f31af1e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; vg::VG::travs_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get traversals either before or after this node on the same strand. </p>

</div>
</div>
<a class="anchor" id="a0a962957210c079fa242b383d5c65de3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; vg::VG::travs_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get traversals before this node on the same strand. Same as nodes_prev but using set. </p>

</div>
</div>
<a class="anchor" id="a998cfb17a4433f05a1579f0d704208a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::unchop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does the reverse &mdash; combines nodes by removing edges where doing so has no effect on the graph labels. </p>

</div>
</div>
<a class="anchor" id="afc568712b6d4aa3b6dc965f37cc769a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1VG.html">VG</a> vg::VG::unfold </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_translation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ensure that all traversals up to max_length are represented as a path on one strand or the other without taking an inverting edge. All inverting edges are converted to non-inverting edges to reverse complement nodes. If no inverting edges are present, the strandedness of all nodes is the same as the input graph. If inverting edges are present, node strandedness is arbitrary. </p>

</div>
</div>
<a class="anchor" id="a1c0b7db8d3043747e8b9a44cba4eaac9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::unindex_edge_by_node_sides </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;&#160;</td>
          <td class="paramname"><em>side1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;&#160;</td>
          <td class="paramname"><em>side2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove an edge from the node side indexes, so it doesn't show up when you ask for the edges connected to the side of a node. Makes the edge untraversable until the indexes are rebuilt. </p>

</div>
</div>
<a class="anchor" id="a5677da9ff22052f6c6a85bfe66e1256d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::unindex_edge_by_node_sides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove an edge from the node side indexes, so it doesn't show up when you ask for the edges connected to the side of a node. Makes the edge untraversable until the indexes are rebuilt. </p>

</div>
</div>
<a class="anchor" id="a2239c89d6ac7e9dec0d76325c2a68f97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::wrap_with_null_nodes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add singular head and tail null nodes to graph. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a93f069b1a683a86ff2981a7f340ac009"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> vg::VG::current_id</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current id for <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a> to be added next. </p>

</div>
</div>
<a class="anchor" id="ab754d45647580a21216bd010b72c6815"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1pair__hash__map.html">pair_hash_map</a>&lt;pair&lt;<a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&gt;, <a class="el" href="structvg_1_1Edge.html">Edge</a>*&gt; vg::VG::edge_by_sides</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code><a class="el" href="structvg_1_1Edge.html">Edge</a></code>s by sides of <code><a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a></code>s they connect. Since duplicate edges are not permitted, two edges cannot connect the same pair of node sides. Each edge is indexed here with the smaller <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> first. The actual node order is recorded in the <a class="el" href="structvg_1_1Edge.html">Edge</a> object. </p>

</div>
</div>
<a class="anchor" id="a2e2c02a8216f0bb9b3a78e985845ea1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt;<a class="el" href="structvg_1_1Edge.html">Edge</a>*, int&gt; vg::VG::edge_index</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a947ad1a02ca5be020879d56976a00e2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt;<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, vector&lt;pair&lt;<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool&gt; &gt; &gt; vg::VG::edges_on_end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores the destinations and backward flags for edges attached to the ends of nodes (whether that node is "from" or "to"). </p>

</div>
</div>
<a class="anchor" id="a5eda797a26ee9d8c217527d77554e2ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt;<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, vector&lt;pair&lt;<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool&gt; &gt; &gt; vg::VG::edges_on_start</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores the destinations and backward flags for edges attached to the starts of nodes (whether that node is "from" or "to"). </p>

</div>
</div>
<a class="anchor" id="a9f32ef3d653601d2fcac5c1b31de0abb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;pair&lt;<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool&gt; &gt; vg::VG::empty_edge_ends</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Placeholder for functions that sometimes need to be passed an empty vector. </p>

</div>
</div>
<a class="anchor" id="a5c70121b4a8463c118b9c90c7090b28f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&gt; vg::VG::empty_ids</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Placeholder for functions that sometimes need to be passed an empty vector. </p>

</div>
</div>
<a class="anchor" id="a4772c77ed932bfed4d21e247918381a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Graph.html">Graph</a> vg::VG::graph</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Protobuf-based representation. </p>

</div>
</div>
<a class="anchor" id="a1f6fcd5a907e9bee524cf37a62ad5be2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::VG::name</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of the graph. </p>

</div>
</div>
<a class="anchor" id="aaf9360fb7acb595296f55cb445f87543"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt;<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, <a class="el" href="structvg_1_1Node.html">Node</a>*&gt; vg::VG::node_by_id</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code><a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a></code>s by id. </p>

</div>
</div>
<a class="anchor" id="a2ce9aecf57e0684821ee277d983eb248"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt;<a class="el" href="structvg_1_1Node.html">Node</a>*, int&gt; vg::VG::node_index</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nodes by position in nodes repeated field. this is critical to allow fast deletion of nodes </p>

</div>
</div>
<a class="anchor" id="a7c5150aba84e7ed2bde7986462a79989"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Paths.html">Paths</a> vg::VG::paths</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Manages paths of the graph. Initialized by setting paths._paths = graph.paths. </p>

</div>
</div>
<a class="anchor" id="ac697184acf2edadca58ddc776f9f4e7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;string, <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a>&gt; vg::VG::variant_to_traversal</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8f0519dc706937b8b593f803f3d8eac4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::warned_about_rewrites = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="vg_8hpp.html">vg.hpp</a></li>
<li>src/<a class="el" href="vg_8cpp.html">vg.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
