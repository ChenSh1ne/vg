<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>vg: vg::BaseAligner Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1BaseAligner.html">BaseAligner</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classvg_1_1BaseAligner-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::BaseAligner Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;gssw_aligner.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vg::BaseAligner:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvg_1_1BaseAligner.png" usemap="#vg::BaseAligner_map" alt=""/>
  <map id="vg::BaseAligner_map" name="vg::BaseAligner_map">
<area href="classvg_1_1Aligner.html" alt="vg::Aligner" shape="rect" coords="0,56,119,80"/>
<area href="classvg_1_1QualAdjAligner.html" alt="vg::QualAdjAligner" shape="rect" coords="129,56,248,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afc2c1dc7e065189988b93ef33f6159cd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#afc2c1dc7e065189988b93ef33f6159cd">max_possible_mapping_quality</a> (int length)</td></tr>
<tr class="separator:afc2c1dc7e065189988b93ef33f6159cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3c3573c3d19f6da8e05f9bfcb7897a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#a9c3c3573c3d19f6da8e05f9bfcb7897a">estimate_max_possible_mapping_quality</a> (int length, double min_diffs, double next_min_diffs)</td></tr>
<tr class="separator:a9c3c3573c3d19f6da8e05f9bfcb7897a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1970f2b89c74c7ce88bab46e74d13eae"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#a1970f2b89c74c7ce88bab46e74d13eae">align</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, <a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;g, bool traceback_aln, bool print_score_matrices)=0</td></tr>
<tr class="separator:a1970f2b89c74c7ce88bab46e74d13eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f1c2b7195fbf9f5e97e7ea23d679bc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#a49f1c2b7195fbf9f5e97e7ea23d679bc">align_pinned</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, <a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;g, bool pin_left)=0</td></tr>
<tr class="separator:a49f1c2b7195fbf9f5e97e7ea23d679bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b4cfbfd8143fdfeefa8f71de05c5a6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#a00b4cfbfd8143fdfeefa8f71de05c5a6">align_pinned_multi</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;alt_alignments, <a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;g, bool pin_left, int32_t max_alt_alns)=0</td></tr>
<tr class="separator:a00b4cfbfd8143fdfeefa8f71de05c5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3c1faea24501804c7ba06cd8b237b3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#a0e3c1faea24501804c7ba06cd8b237b3">align_global_banded</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, <a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;g, int32_t band_padding=0, bool permissive_banding=true)=0</td></tr>
<tr class="separator:a0e3c1faea24501804c7ba06cd8b237b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f450ff2d715eda847ae22ad5d769560"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#a8f450ff2d715eda847ae22ad5d769560">align_global_banded_multi</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;alt_alignments, <a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;g, int32_t max_alt_alns, int32_t band_padding=0, bool permissive_banding=true)=0</td></tr>
<tr class="separator:a8f450ff2d715eda847ae22ad5d769560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefbaafca736e03d6b0229b1c806c9ae"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#adefbaafca736e03d6b0229b1c806c9ae">align_xdrop</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, <a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;g, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, bool reverse_complemented, bool multithreaded)=0</td></tr>
<tr class="separator:adefbaafca736e03d6b0229b1c806c9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4fb0fcfb64b5d180757c70feaacd42"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#a4e4fb0fcfb64b5d180757c70feaacd42">align_xdrop_multi</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, <a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;g, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, bool reverse_complemented, int32_t max_alt_alns)=0</td></tr>
<tr class="separator:a4e4fb0fcfb64b5d180757c70feaacd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97333abf205115603eb8ed00b2df52b5"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#a97333abf205115603eb8ed00b2df52b5">score_exact_match</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, size_t read_offset, size_t length) const =0</td></tr>
<tr class="separator:a97333abf205115603eb8ed00b2df52b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1477419b5ad7ca61ea0fc80b36497f84"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#a1477419b5ad7ca61ea0fc80b36497f84">score_exact_match</a> (const string &amp;sequence, const string &amp;base_quality) const =0</td></tr>
<tr class="separator:a1477419b5ad7ca61ea0fc80b36497f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fbc4891f2b153b06d6073e6d57ba7c"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#ab6fbc4891f2b153b06d6073e6d57ba7c">score_exact_match</a> (string::const_iterator seq_begin, string::const_iterator seq_end, string::const_iterator base_qual_begin) const =0</td></tr>
<tr class="separator:ab6fbc4891f2b153b06d6073e6d57ba7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b25d57c5e4dca411fc2fe24d7f1f62"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#a69b25d57c5e4dca411fc2fe24d7f1f62">score_partial_alignment</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, <a class="el" href="classvg_1_1VG.html">VG</a> &amp;graph, const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, string::const_iterator seq_begin) const =0</td></tr>
<tr class="memdesc:a69b25d57c5e4dca411fc2fe24d7f1f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the score of a path against the given range of subsequence with the given qualities.  <a href="#a69b25d57c5e4dca411fc2fe24d7f1f62">More...</a><br/></td></tr>
<tr class="separator:a69b25d57c5e4dca411fc2fe24d7f1f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b6ef7af197b253e94496c70322b7b5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#a49b6ef7af197b253e94496c70322b7b5">score_gap</a> (size_t gap_length)</td></tr>
<tr class="memdesc:a49b6ef7af197b253e94496c70322b7b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the score of an insert or deletion of the given length.  <a href="#a49b6ef7af197b253e94496c70322b7b5">More...</a><br/></td></tr>
<tr class="separator:a49b6ef7af197b253e94496c70322b7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720c650265b4c779a7a41492210b8bf7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#a720c650265b4c779a7a41492210b8bf7">compute_mapping_quality</a> (vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;alignments, int max_mapping_quality, bool fast_approximation, double cluster_mq, bool use_cluster_mq, int overlap_count, double mq_estimate, double maybe_mq_threshold, double identity_weight)</td></tr>
<tr class="separator:a720c650265b4c779a7a41492210b8bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4475d279609293b3111f1c222b06fe5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#af4475d279609293b3111f1c222b06fe5">compute_paired_mapping_quality</a> (pair&lt; vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;, vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&gt; &amp;alignment_pairs, const vector&lt; double &gt; &amp;frag_weights, int max_mapping_quality1, int max_mapping_quality2, bool fast_approximation, double cluster_mq, bool use_cluster_mq, int overlap_count1, int overlap_count2, double mq_estimate1, double mq_estimate2, double maybe_mq_threshold, double identity_weight)</td></tr>
<tr class="memdesc:af4475d279609293b3111f1c222b06fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">same function for paired reads, mapping qualities are stored in both alignments in the pair  <a href="#af4475d279609293b3111f1c222b06fe5">More...</a><br/></td></tr>
<tr class="separator:af4475d279609293b3111f1c222b06fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b4cf42df50f5ee0219518807305ca4"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#ac3b4cf42df50f5ee0219518807305ca4">compute_mapping_quality</a> (vector&lt; double &gt; &amp;scores, bool fast_approximation)</td></tr>
<tr class="memdesc:ac3b4cf42df50f5ee0219518807305ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes mapping quality for the optimal score in a vector of scores.  <a href="#ac3b4cf42df50f5ee0219518807305ca4">More...</a><br/></td></tr>
<tr class="separator:ac3b4cf42df50f5ee0219518807305ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b66e786c2982ae9cda66a77e3c6919"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#a02b66e786c2982ae9cda66a77e3c6919">compute_group_mapping_quality</a> (vector&lt; double &gt; &amp;scores, vector&lt; size_t &gt; &amp;group)</td></tr>
<tr class="memdesc:a02b66e786c2982ae9cda66a77e3c6919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes mapping quality for a group of scores in a vector of scores (group given by indexes)  <a href="#a02b66e786c2982ae9cda66a77e3c6919">More...</a><br/></td></tr>
<tr class="separator:a02b66e786c2982ae9cda66a77e3c6919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3942620f778f66f82d5ff92bd189b1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#a1a3942620f778f66f82d5ff92bd189b1">mapping_quality_score_diff</a> (double mapping_quality) const </td></tr>
<tr class="separator:a1a3942620f778f66f82d5ff92bd189b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f96f1945447452db53985f2eba023d8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#a3f96f1945447452db53985f2eba023d8">score_to_unnormalized_likelihood_ln</a> (double score)</td></tr>
<tr class="separator:a3f96f1945447452db53985f2eba023d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8357ced3c9a0f26eda195c3eea16bd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#a6b8357ced3c9a0f26eda195c3eea16bd">longest_detectable_gap</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const string::const_iterator &amp;read_pos) const </td></tr>
<tr class="memdesc:a6b8357ced3c9a0f26eda195c3eea16bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The longest gap detectable from a read position without soft-clipping.  <a href="#a6b8357ced3c9a0f26eda195c3eea16bd">More...</a><br/></td></tr>
<tr class="separator:a6b8357ced3c9a0f26eda195c3eea16bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab753228bda847425bf5be6446cc8d4c1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#ab753228bda847425bf5be6446cc8d4c1">longest_detectable_gap</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment) const </td></tr>
<tr class="memdesc:ab753228bda847425bf5be6446cc8d4c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The longest gap detectable from any read position without soft-clipping.  <a href="#ab753228bda847425bf5be6446cc8d4c1">More...</a><br/></td></tr>
<tr class="separator:ab753228bda847425bf5be6446cc8d4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f65635fae8dedd0768bdc88d717545f"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#a5f65635fae8dedd0768bdc88d717545f">score_gappy_alignment</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const function&lt; size_t(<a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>, <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>, size_t)&gt; &amp;estimate_distance, bool strip_bonuses=false) const </td></tr>
<tr class="separator:a5f65635fae8dedd0768bdc88d717545f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7889eb0f61ae7fd52c3ae614f3747d"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#aeb7889eb0f61ae7fd52c3ae614f3747d">score_ungapped_alignment</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, bool strip_bonuses=false) const </td></tr>
<tr class="separator:aeb7889eb0f61ae7fd52c3ae614f3747d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2294ca81858059a5dad59efda8f90f89"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#a2294ca81858059a5dad59efda8f90f89">load_scoring_matrix</a> (std::istream &amp;matrix_stream)</td></tr>
<tr class="separator:a2294ca81858059a5dad59efda8f90f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a4f290e7817ca0c758769fb714e970"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#a78a4f290e7817ca0c758769fb714e970">remove_bonuses</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, bool pinned=false, bool pin_left=false) const </td></tr>
<tr class="separator:a78a4f290e7817ca0c758769fb714e970"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab2ec078b327638034b59c309dec80dbc"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#ab2ec078b327638034b59c309dec80dbc">maximum_mapping_quality_exact</a> (vector&lt; double &gt; &amp;scaled_scores, size_t *max_idx_out)</td></tr>
<tr class="separator:ab2ec078b327638034b59c309dec80dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188a1ea00284d382839a16e6f73e6ef6"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#a188a1ea00284d382839a16e6f73e6ef6">maximum_mapping_quality_approx</a> (vector&lt; double &gt; &amp;scaled_scores, size_t *max_idx_out)</td></tr>
<tr class="separator:a188a1ea00284d382839a16e6f73e6ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae68afc236d9d8bac09b710e751db81b5"><td class="memItemLeft" align="right" valign="top">int8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#ae68afc236d9d8bac09b710e751db81b5">nt_table</a> = nullptr</td></tr>
<tr class="separator:ae68afc236d9d8bac09b710e751db81b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb78987c376a75ea5ff70f2220c070c"><td class="memItemLeft" align="right" valign="top">int8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#aadb78987c376a75ea5ff70f2220c070c">score_matrix</a> = nullptr</td></tr>
<tr class="separator:aadb78987c376a75ea5ff70f2220c070c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6dfee02250ac630a51e7dfb23920bd"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#a8c6dfee02250ac630a51e7dfb23920bd">match</a></td></tr>
<tr class="separator:a8c6dfee02250ac630a51e7dfb23920bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1817bb7cf200f94d67582749ec24b128"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#a1817bb7cf200f94d67582749ec24b128">mismatch</a></td></tr>
<tr class="separator:a1817bb7cf200f94d67582749ec24b128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f475ed2b1abb69383c06db8ea62736e"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#a0f475ed2b1abb69383c06db8ea62736e">gap_open</a></td></tr>
<tr class="separator:a0f475ed2b1abb69383c06db8ea62736e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca84365eda89673d43192435a069963"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#adca84365eda89673d43192435a069963">gap_extension</a></td></tr>
<tr class="separator:adca84365eda89673d43192435a069963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1750f4587061f9d6dcf62abbd7d6347e"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#a1750f4587061f9d6dcf62abbd7d6347e">full_length_bonus</a></td></tr>
<tr class="separator:a1750f4587061f9d6dcf62abbd7d6347e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f211ed00ac67a73035a9317b7d7623"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#a10f211ed00ac67a73035a9317b7d7623">log_base</a> = 0.0</td></tr>
<tr class="separator:a10f211ed00ac67a73035a9317b7d7623"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:adb102937992cfa2030613b46a2f3151c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#adb102937992cfa2030613b46a2f3151c">BaseAligner</a> ()=default</td></tr>
<tr class="separator:adb102937992cfa2030613b46a2f3151c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49115fe049aff1100ea910c897801c3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#ad49115fe049aff1100ea910c897801c3">~BaseAligner</a> ()</td></tr>
<tr class="separator:ad49115fe049aff1100ea910c897801c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88146297f7a7d8e2b9567b39c18646aa"><td class="memItemLeft" align="right" valign="top">gssw_graph *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#a88146297f7a7d8e2b9567b39c18646aa">create_gssw_graph</a> (<a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;g)</td></tr>
<tr class="separator:a88146297f7a7d8e2b9567b39c18646aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791cba0fe8a42b9a2ae7f74364f78dde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#a791cba0fe8a42b9a2ae7f74364f78dde">visit_node</a> (gssw_node *node, list&lt; gssw_node * &gt; &amp;sorted_nodes, set&lt; gssw_node * &gt; &amp;unmarked_nodes, set&lt; gssw_node * &gt; &amp;temporary_marks)</td></tr>
<tr class="separator:a791cba0fe8a42b9a2ae7f74364f78dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69c33fbd1dbdcf33e8e6cf30a2eb5ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#aa69c33fbd1dbdcf33e8e6cf30a2eb5ff">reverse_graph</a> (<a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;g, <a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;reversed_graph_out)</td></tr>
<tr class="separator:aa69c33fbd1dbdcf33e8e6cf30a2eb5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab9d2cb1a778b19a29c9e616aaa0325"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#aaab9d2cb1a778b19a29c9e616aaa0325">unreverse_graph</a> (<a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="separator:aaab9d2cb1a778b19a29c9e616aaa0325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69124dcbade7c24de28db9b15eb3d8cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#a69124dcbade7c24de28db9b15eb3d8cf">unreverse_graph_mapping</a> (gssw_graph_mapping *gm)</td></tr>
<tr class="separator:a69124dcbade7c24de28db9b15eb3d8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd75723986ba465977d0ab4db275dd97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#afd75723986ba465977d0ab4db275dd97">gssw_mapping_to_alignment</a> (gssw_graph *graph, gssw_graph_mapping *gm, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, bool pinned, bool pin_left, bool print_score_matrices=false)</td></tr>
<tr class="separator:afd75723986ba465977d0ab4db275dd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b58d964f1b5712ee433cea17fd25e5"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#a87b58d964f1b5712ee433cea17fd25e5">graph_cigar</a> (gssw_graph_mapping *gm)</td></tr>
<tr class="separator:a87b58d964f1b5712ee433cea17fd25e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49df121823c5b30830b696d2f74173d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#ae49df121823c5b30830b696d2f74173d">group_mapping_quality_exact</a> (vector&lt; double &gt; &amp;scaled_scores, vector&lt; size_t &gt; &amp;group)</td></tr>
<tr class="separator:ae49df121823c5b30830b696d2f74173d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4e7dd63a4140484f09e5d2772972d9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#aba4e7dd63a4140484f09e5d2772972d9">estimate_next_best_score</a> (int length, double min_diffs)</td></tr>
<tr class="separator:aba4e7dd63a4140484f09e5d2772972d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ae9eca25f2ce201024def1dcf8fe6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html#ac0ae9eca25f2ce201024def1dcf8fe6b">init_mapping_quality</a> (double gc_content)</td></tr>
<tr class="separator:ac0ae9eca25f2ce201024def1dcf8fe6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The interface that any <a class="el" href="classvg_1_1Aligner.html">Aligner</a> should implement, with some default implementations. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="adb102937992cfa2030613b46a2f3151c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::BaseAligner::BaseAligner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad49115fe049aff1100ea910c897801c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BaseAligner::~BaseAligner </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1970f2b89c74c7ce88bab46e74d13eae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vg::BaseAligner::align </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceback_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_score_matrices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store optimal local alignment against a graph in the <a class="el" href="structvg_1_1Alignment.html">Alignment</a> object. Gives the full length bonus separately on each end of the alignment. Assumes that graph is topologically sorted by node index. </p>

<p>Implemented in <a class="el" href="classvg_1_1QualAdjAligner.html#a7fbee1a957406f431590b93ca740623f">vg::QualAdjAligner</a>, and <a class="el" href="classvg_1_1Aligner.html#afb8c7c797f8dbb090336dce216e0dc3b">vg::Aligner</a>.</p>

</div>
</div>
<a class="anchor" id="a0e3c1faea24501804c7ba06cd8b237b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vg::BaseAligner::align_global_banded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>band_padding</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>permissive_banding</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classvg_1_1QualAdjAligner.html#a732dea92da3162b0c13ed0639a6d336d">vg::QualAdjAligner</a>, and <a class="el" href="classvg_1_1Aligner.html#af69938fd14f39c0cd91736203d7ac139">vg::Aligner</a>.</p>

</div>
</div>
<a class="anchor" id="a8f450ff2d715eda847ae22ad5d769560"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vg::BaseAligner::align_global_banded_multi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>alt_alignments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>max_alt_alns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>band_padding</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>permissive_banding</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classvg_1_1QualAdjAligner.html#acf3ac79527ff39ed136b55b91d7ab41c">vg::QualAdjAligner</a>, and <a class="el" href="classvg_1_1Aligner.html#a22087fedea7ef2f306f74107497d1d44">vg::Aligner</a>.</p>

</div>
</div>
<a class="anchor" id="a49f1c2b7195fbf9f5e97e7ea23d679bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vg::BaseAligner::align_pinned </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classvg_1_1QualAdjAligner.html#a5ea2fabed23832992161124ffc16a200">vg::QualAdjAligner</a>, and <a class="el" href="classvg_1_1Aligner.html#a2dbb9bd2c0d67093db2b737689b1b063">vg::Aligner</a>.</p>

</div>
</div>
<a class="anchor" id="a00b4cfbfd8143fdfeefa8f71de05c5a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vg::BaseAligner::align_pinned_multi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>alt_alignments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>max_alt_alns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classvg_1_1QualAdjAligner.html#a81573468622bd3ab5df5351c970c63a3">vg::QualAdjAligner</a>, and <a class="el" href="classvg_1_1Aligner.html#a34d1189e2130b70bef19b1dbda7ace05">vg::Aligner</a>.</p>

</div>
</div>
<a class="anchor" id="adefbaafca736e03d6b0229b1c806c9ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vg::BaseAligner::align_xdrop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse_complemented</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>multithreaded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classvg_1_1QualAdjAligner.html#a96a204603f2ee91d9d8c4d633da0461a">vg::QualAdjAligner</a>, and <a class="el" href="classvg_1_1Aligner.html#aeabc06f0cfaa87a025652b50cea9c238">vg::Aligner</a>.</p>

</div>
</div>
<a class="anchor" id="a4e4fb0fcfb64b5d180757c70feaacd42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vg::BaseAligner::align_xdrop_multi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse_complemented</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>max_alt_alns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classvg_1_1QualAdjAligner.html#a826c6bb1a3e8205ae6fd69a011d6d96e">vg::QualAdjAligner</a>, and <a class="el" href="classvg_1_1Aligner.html#a0cd414514136c914318fbee7cd15ffe7">vg::Aligner</a>.</p>

</div>
</div>
<a class="anchor" id="a02b66e786c2982ae9cda66a77e3c6919"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t BaseAligner::compute_group_mapping_quality </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes mapping quality for a group of scores in a vector of scores (group given by indexes) </p>

</div>
</div>
<a class="anchor" id="a720c650265b4c779a7a41492210b8bf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BaseAligner::compute_mapping_quality </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>alignments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_mapping_quality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fast_approximation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cluster_mq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_cluster_mq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>overlap_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mq_estimate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maybe_mq_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>identity_weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>stores -10 * log_10(P_err) in alignment mapping_quality field where P_err is the probability that the alignment is not the correct one (assuming that one of the alignments in the vector is correct). alignments must have been created with this <a class="el" href="classvg_1_1Aligner.html">Aligner</a> for quality score to be valid </p>

</div>
</div>
<a class="anchor" id="ac3b4cf42df50f5ee0219518807305ca4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t BaseAligner::compute_mapping_quality </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fast_approximation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes mapping quality for the optimal score in a vector of scores. </p>

</div>
</div>
<a class="anchor" id="af4475d279609293b3111f1c222b06fe5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BaseAligner::compute_paired_mapping_quality </td>
          <td>(</td>
          <td class="paramtype">pair&lt; vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;, vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>alignment_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>frag_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_mapping_quality1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_mapping_quality2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fast_approximation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cluster_mq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_cluster_mq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>overlap_count1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>overlap_count2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mq_estimate1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mq_estimate2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maybe_mq_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>identity_weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>same function for paired reads, mapping qualities are stored in both alignments in the pair </p>

</div>
</div>
<a class="anchor" id="a88146297f7a7d8e2b9567b39c18646aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gssw_graph * BaseAligner::create_gssw_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9c3c3573c3d19f6da8e05f9bfcb7897a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double BaseAligner::estimate_max_possible_mapping_quality </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_diffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>next_min_diffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aba4e7dd63a4140484f09e5d2772972d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double BaseAligner::estimate_next_best_score </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_diffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a87b58d964f1b5712ee433cea17fd25e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string BaseAligner::graph_cigar </td>
          <td>(</td>
          <td class="paramtype">gssw_graph_mapping *&#160;</td>
          <td class="paramname"><em>gm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae49df121823c5b30830b696d2f74173d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double BaseAligner::group_mapping_quality_exact </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>scaled_scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afd75723986ba465977d0ab4db275dd97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BaseAligner::gssw_mapping_to_alignment </td>
          <td>(</td>
          <td class="paramtype">gssw_graph *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gssw_graph_mapping *&#160;</td>
          <td class="paramname"><em>gm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_score_matrices</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac0ae9eca25f2ce201024def1dcf8fe6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BaseAligner::init_mapping_quality </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gc_content</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2294ca81858059a5dad59efda8f90f89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BaseAligner::load_scoring_matrix </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>matrix_stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads a 5x5 substitution scoring matrix from an input stream (can be an ifstream) expecting 5 whitespace-separated 8-bit integers per line </p>

</div>
</div>
<a class="anchor" id="a6b8357ced3c9a0f26eda195c3eea16bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t BaseAligner::longest_detectable_gap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>read_pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The longest gap detectable from a read position without soft-clipping. </p>

</div>
</div>
<a class="anchor" id="ab753228bda847425bf5be6446cc8d4c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t BaseAligner::longest_detectable_gap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The longest gap detectable from any read position without soft-clipping. </p>

</div>
</div>
<a class="anchor" id="a1a3942620f778f66f82d5ff92bd189b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double BaseAligner::mapping_quality_score_diff </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mapping_quality</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the difference between an optimal and second-best alignment scores that would result in this mapping quality using the fast mapping quality approximation </p>

</div>
</div>
<a class="anchor" id="afc2c1dc7e065189988b93ef33f6159cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double BaseAligner::max_possible_mapping_quality </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a188a1ea00284d382839a16e6f73e6ef6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double BaseAligner::maximum_mapping_quality_approx </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>scaled_scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>max_idx_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a nonempty vector of nonnegative scaled alignment scores, approximate the mapping quality of the maximal score in the vector. Sets max_idx_out to the index of that score in the vector. May modify the input vector. </p>

</div>
</div>
<a class="anchor" id="ab2ec078b327638034b59c309dec80dbc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double BaseAligner::maximum_mapping_quality_exact </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>scaled_scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>max_idx_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a nonempty vector of nonnegative scaled alignment scores, compute the mapping quality of the maximal score in the vector. Sets max_idx_out to the index of that score in the vector. May modify the input vector. </p>

</div>
</div>
<a class="anchor" id="a78a4f290e7817ca0c758769fb714e970"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t BaseAligner::remove_bonuses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Without necessarily rescoring the entire alignment, return the score of the given alignment with bonuses removed. Assumes that bonuses are actually included in the score. Needs to know if the alignment was pinned-end or not, and, if so, which end was pinned. </p>

</div>
</div>
<a class="anchor" id="aa69c33fbd1dbdcf33e8e6cf30a2eb5ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BaseAligner::reverse_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>reversed_graph_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a97333abf205115603eb8ed00b2df52b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t vg::BaseAligner::score_exact_match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>read_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the score of an exact match in the given alignment, from the given offset, of the given length. </p>

<p>Implemented in <a class="el" href="classvg_1_1QualAdjAligner.html#abfb5fb7e14a9f9e3d5e5bd6ecf1b9702">vg::QualAdjAligner</a>, and <a class="el" href="classvg_1_1Aligner.html#a819090adc71ddf92a2f0d029f1a67d9d">vg::Aligner</a>.</p>

</div>
</div>
<a class="anchor" id="a1477419b5ad7ca61ea0fc80b36497f84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t vg::BaseAligner::score_exact_match </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>base_quality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the score of an exact match of the given sequence with the given qualities. Qualities may be ignored by some implementations. </p>

<p>Implemented in <a class="el" href="classvg_1_1QualAdjAligner.html#ab8a0d724464fdcc8c45bf7d77b888145">vg::QualAdjAligner</a>, and <a class="el" href="classvg_1_1Aligner.html#a199acfa933a6603c54a1e54888bf33a8">vg::Aligner</a>.</p>

</div>
</div>
<a class="anchor" id="ab6fbc4891f2b153b06d6073e6d57ba7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t vg::BaseAligner::score_exact_match </td>
          <td>(</td>
          <td class="paramtype">string::const_iterator&#160;</td>
          <td class="paramname"><em>seq_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string::const_iterator&#160;</td>
          <td class="paramname"><em>seq_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string::const_iterator&#160;</td>
          <td class="paramname"><em>base_qual_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the score of an exact match of the given range of sequence with the given qualities. Qualities may be ignored by some implementations. </p>

<p>Implemented in <a class="el" href="classvg_1_1QualAdjAligner.html#a1e076616cc54a33fa26504072f851ea0">vg::QualAdjAligner</a>, and <a class="el" href="classvg_1_1Aligner.html#addc0cb767355ab255f550b543d442dd7">vg::Aligner</a>.</p>

</div>
</div>
<a class="anchor" id="a49b6ef7af197b253e94496c70322b7b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t BaseAligner::score_gap </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>gap_length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the score of an insert or deletion of the given length. </p>

</div>
</div>
<a class="anchor" id="a5f65635fae8dedd0768bdc88d717545f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t BaseAligner::score_gappy_alignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; size_t(<a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>, <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>estimate_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strip_bonuses</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the score values in the aligner to score the given alignment, scoring gaps caused by jumping between between nodes using a custom gap length estimation function (which takes the from position, the to position, and a search limit in bp that happens to be the read length).</p>
<p>May include full length bonus or not. TODO: bool flags are bad. </p>

</div>
</div>
<a class="anchor" id="a69b25d57c5e4dca411fc2fe24d7f1f62"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t vg::BaseAligner::score_partial_alignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string::const_iterator&#160;</td>
          <td class="paramname"><em>seq_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the score of a path against the given range of subsequence with the given qualities. </p>

<p>Implemented in <a class="el" href="classvg_1_1QualAdjAligner.html#a28f52f5d8b23ba8f9f159908496619f0">vg::QualAdjAligner</a>, and <a class="el" href="classvg_1_1Aligner.html#a5358187b281a599f867ed7da46dce0c2">vg::Aligner</a>.</p>

</div>
</div>
<a class="anchor" id="a3f96f1945447452db53985f2eba023d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double BaseAligner::score_to_unnormalized_likelihood_ln </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>score</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a score to an unnormalized log likelihood for the sequence. Requires log_base to have been set. </p>

</div>
</div>
<a class="anchor" id="aeb7889eb0f61ae7fd52c3ae614f3747d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t BaseAligner::score_ungapped_alignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strip_bonuses</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the score values in the aligner to score the given alignment assuming that there are no gaps between Mappings in the <a class="el" href="structvg_1_1Path.html">Path</a> </p>

</div>
</div>
<a class="anchor" id="aaab9d2cb1a778b19a29c9e616aaa0325"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BaseAligner::unreverse_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a69124dcbade7c24de28db9b15eb3d8cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BaseAligner::unreverse_graph_mapping </td>
          <td>(</td>
          <td class="paramtype">gssw_graph_mapping *&#160;</td>
          <td class="paramname"><em>gm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a791cba0fe8a42b9a2ae7f74364f78dde"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::BaseAligner::visit_node </td>
          <td>(</td>
          <td class="paramtype">gssw_node *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list&lt; gssw_node * &gt; &amp;&#160;</td>
          <td class="paramname"><em>sorted_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; gssw_node * &gt; &amp;&#160;</td>
          <td class="paramname"><em>unmarked_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; gssw_node * &gt; &amp;&#160;</td>
          <td class="paramname"><em>temporary_marks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a1750f4587061f9d6dcf62abbd7d6347e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t vg::BaseAligner::full_length_bonus</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adca84365eda89673d43192435a069963"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t vg::BaseAligner::gap_extension</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0f475ed2b1abb69383c06db8ea62736e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t vg::BaseAligner::gap_open</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a10f211ed00ac67a73035a9317b7d7623"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::BaseAligner::log_base = 0.0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8c6dfee02250ac630a51e7dfb23920bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t vg::BaseAligner::match</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1817bb7cf200f94d67582749ec24b128"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t vg::BaseAligner::mismatch</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae68afc236d9d8bac09b710e751db81b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t* vg::BaseAligner::nt_table = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aadb78987c376a75ea5ff70f2220c070c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t* vg::BaseAligner::score_matrix = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="gssw__aligner_8hpp.html">gssw_aligner.hpp</a></li>
<li>src/<a class="el" href="gssw__aligner_8cpp.html">gssw_aligner.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 4 2018 22:29:39 for vg by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
