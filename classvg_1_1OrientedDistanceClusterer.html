<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>vg: vg::OrientedDistanceClusterer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1OrientedDistanceClusterer.html">OrientedDistanceClusterer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classvg_1_1OrientedDistanceClusterer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::OrientedDistanceClusterer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;cluster.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1OrientedDistanceClusterer_1_1DPScoreComparator.html">DPScoreComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceClusterer_1_1ODEdge.html">ODEdge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceClusterer_1_1ODNode.html">ODNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae295cbcd1f1d325e6fde676f6dcb05b6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceClusterer.html#ae295cbcd1f1d325e6fde676f6dcb05b6">hit_t</a> = pair&lt; const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> *, <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt;</td></tr>
<tr class="separator:ae295cbcd1f1d325e6fde676f6dcb05b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab996883ca097359a31a5e8d066b8ec61"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceClusterer.html#ab996883ca097359a31a5e8d066b8ec61">cluster_t</a> = vector&lt; <a class="el" href="classvg_1_1OrientedDistanceClusterer.html#ae295cbcd1f1d325e6fde676f6dcb05b6">hit_t</a> &gt;</td></tr>
<tr class="memdesc:ab996883ca097359a31a5e8d066b8ec61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each cluster is a vector of hits.  <a href="#ab996883ca097359a31a5e8d066b8ec61">More...</a><br/></td></tr>
<tr class="separator:ab996883ca097359a31a5e8d066b8ec61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4f4f8728292f7b55a2d7ce19c65be472"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceClusterer.html#a4f4f8728292f7b55a2d7ce19c65be472">OrientedDistanceClusterer</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, const <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> &amp;<a class="el" href="classvg_1_1OrientedDistanceClusterer.html#a02815fdd278c050d280e4722b128f32d">aligner</a>, <a class="el" href="classvg_1_1OrientedDistanceMeasurer.html">OrientedDistanceMeasurer</a> &amp;distance_measurer, bool unstranded, size_t max_expected_dist_approx_error=8, size_t min_mem_length=1)</td></tr>
<tr class="memdesc:a4f4f8728292f7b55a2d7ce19c65be472"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classvg_1_1Constructor.html">Constructor</a> using <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a>, optionally memoizing succinct data structure operations.  <a href="#a4f4f8728292f7b55a2d7ce19c65be472">More...</a><br/></td></tr>
<tr class="separator:a4f4f8728292f7b55a2d7ce19c65be472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3d1c7ef8605a908c201f1b164643f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceClusterer.html#aff3d1c7ef8605a908c201f1b164643f9">OrientedDistanceClusterer</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> &amp;<a class="el" href="classvg_1_1OrientedDistanceClusterer.html#a02815fdd278c050d280e4722b128f32d">aligner</a>, <a class="el" href="classvg_1_1OrientedDistanceMeasurer.html">OrientedDistanceMeasurer</a> &amp;distance_measurer, bool unstranded, size_t max_expected_dist_approx_error=8, size_t min_mem_length=1)</td></tr>
<tr class="memdesc:aff3d1c7ef8605a908c201f1b164643f9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classvg_1_1Constructor.html">Constructor</a> using <a class="el" href="classvg_1_1Aligner.html">Aligner</a>, optionally memoizing succinct data structure operations.  <a href="#aff3d1c7ef8605a908c201f1b164643f9">More...</a><br/></td></tr>
<tr class="separator:aff3d1c7ef8605a908c201f1b164643f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af355988106372edb9f4f1462c6f7d53a"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classvg_1_1OrientedDistanceClusterer.html#ab996883ca097359a31a5e8d066b8ec61">cluster_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceClusterer.html#af355988106372edb9f4f1462c6f7d53a">clusters</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, int32_t max_qual_score=60, int32_t log_likelihood_approx_factor=0, size_t min_median_mem_coverage_for_split=0, double suboptimal_edge_pruning_factor=.75)</td></tr>
<tr class="separator:af355988106372edb9f4f1462c6f7d53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a64fc16304bbe979775dda279258c4757"><td class="memItemLeft" align="right" valign="top">static vector&lt; pair&lt; pair<br class="typebreak"/>
&lt; size_t, size_t &gt;, int64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceClusterer.html#a64fc16304bbe979775dda279258c4757">pair_clusters</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment_1, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment_2, const vector&lt; <a class="el" href="classvg_1_1OrientedDistanceClusterer.html#ab996883ca097359a31a5e8d066b8ec61">cluster_t</a> * &gt; &amp;left_clusters, const vector&lt; <a class="el" href="classvg_1_1OrientedDistanceClusterer.html#ab996883ca097359a31a5e8d066b8ec61">cluster_t</a> * &gt; &amp;right_clusters, const vector&lt; pair&lt; size_t, size_t &gt;&gt; &amp;left_alt_cluster_anchors, const vector&lt; pair&lt; size_t, size_t &gt;&gt; &amp;right_alt_cluster_anchors, int64_t min_inter_cluster_distance, int64_t max_inter_cluster_distance, <a class="el" href="classvg_1_1OrientedDistanceMeasurer.html">OrientedDistanceMeasurer</a> &amp;distance_measurer)</td></tr>
<tr class="separator:a64fc16304bbe979775dda279258c4757"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a64119156e73fca657d99c62256aae124"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceClusterer.html#a64119156e73fca657d99c62256aae124">OrientedDistanceClusterer</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *<a class="el" href="classvg_1_1OrientedDistanceClusterer.html#a02815fdd278c050d280e4722b128f32d">aligner</a>, const <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *<a class="el" href="classvg_1_1OrientedDistanceClusterer.html#a8ad9627382493b606581f85deb4cd317">qual_adj_aligner</a>, <a class="el" href="classvg_1_1OrientedDistanceMeasurer.html">OrientedDistanceMeasurer</a> &amp;distance_measurer, bool unstranded, size_t max_expected_dist_approx_error, size_t min_mem_length)</td></tr>
<tr class="memdesc:a64119156e73fca657d99c62256aae124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal constructor that public constructors filter into.  <a href="#a64119156e73fca657d99c62256aae124">More...</a><br/></td></tr>
<tr class="separator:a64119156e73fca657d99c62256aae124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fad154b1267d5d3861870a51b482d9b"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; size_t, size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceClusterer.html#a5fad154b1267d5d3861870a51b482d9b">compute_tail_mem_coverage</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems)</td></tr>
<tr class="separator:a5fad154b1267d5d3861870a51b482d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96510c3f1316864da113417fd418db32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceClusterer.html#a96510c3f1316864da113417fd418db32">identify_sources_and_sinks</a> (vector&lt; size_t &gt; &amp;sources_out, vector&lt; size_t &gt; &amp;sinks_out)</td></tr>
<tr class="memdesc:a96510c3f1316864da113417fd418db32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills input vectors with indices of source and sink nodes.  <a href="#a96510c3f1316864da113417fd418db32">More...</a><br/></td></tr>
<tr class="separator:a96510c3f1316864da113417fd418db32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af673c60a8b3cb48354f1fc740ca302ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceClusterer.html#af673c60a8b3cb48354f1fc740ca302ef">connected_components</a> (vector&lt; vector&lt; size_t &gt;&gt; &amp;components_out)</td></tr>
<tr class="memdesc:af673c60a8b3cb48354f1fc740ca302ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify weakly connected components in the graph.  <a href="#af673c60a8b3cb48354f1fc740ca302ef">More...</a><br/></td></tr>
<tr class="separator:af673c60a8b3cb48354f1fc740ca302ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d49c49f04bc25d2d5ea6f7051842f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceClusterer.html#ae7d49c49f04bc25d2d5ea6f7051842f0">topological_order</a> (vector&lt; size_t &gt; &amp;order_out)</td></tr>
<tr class="memdesc:ae7d49c49f04bc25d2d5ea6f7051842f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the input vector with the indices of a topological sort.  <a href="#ae7d49c49f04bc25d2d5ea6f7051842f0">More...</a><br/></td></tr>
<tr class="separator:ae7d49c49f04bc25d2d5ea6f7051842f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98773e2b5618c3f8b0f70e0ebe717b38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceClusterer.html#a98773e2b5618c3f8b0f70e0ebe717b38">perform_dp</a> ()</td></tr>
<tr class="memdesc:a98773e2b5618c3f8b0f70e0ebe717b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform dynamic programming and store scores in nodes.  <a href="#a98773e2b5618c3f8b0f70e0ebe717b38">More...</a><br/></td></tr>
<tr class="separator:a98773e2b5618c3f8b0f70e0ebe717b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9264036d14c69dff24ba81cd5c84ca75"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceClusterer.html#a9264036d14c69dff24ba81cd5c84ca75">median_mem_coverage</a> (const vector&lt; size_t &gt; &amp;component, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln) const </td></tr>
<tr class="separator:a9264036d14c69dff24ba81cd5c84ca75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676e4766c5793f2aca2eea0fb969449b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceClusterer.html#a676e4766c5793f2aca2eea0fb969449b">prune_low_scoring_edges</a> (vector&lt; vector&lt; size_t &gt;&gt; &amp;components, size_t component_idx, double score_factor)</td></tr>
<tr class="separator:a676e4766c5793f2aca2eea0fb969449b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0534cf827a5f17bde1afbf8837b08ba3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceClusterer.html#a0534cf827a5f17bde1afbf8837b08ba3">component_topological_order</a> (const vector&lt; size_t &gt; &amp;component, vector&lt; size_t &gt; &amp;order_out) const </td></tr>
<tr class="memdesc:a0534cf827a5f17bde1afbf8837b08ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the topological order of.  <a href="#a0534cf827a5f17bde1afbf8837b08ba3">More...</a><br/></td></tr>
<tr class="separator:a0534cf827a5f17bde1afbf8837b08ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:adc789ea08b0f182ad7cddd182165e425"><td class="memItemLeft" align="right" valign="top">static unordered_map&lt; pair<br class="typebreak"/>
&lt; size_t, size_t &gt;, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceClusterer.html#adc789ea08b0f182ad7cddd182165e425">get_on_strand_distance_tree</a> (size_t num_items, const function&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>(size_t)&gt; &amp;get_position, const function&lt; int64_t(size_t)&gt; &amp;<a class="el" href="namespacevg.html#a716ebc4e690ac383342cc1c750bdddd0">get_offset</a>, <a class="el" href="classvg_1_1OrientedDistanceMeasurer.html">OrientedDistanceMeasurer</a> &amp;distance_measurer)</td></tr>
<tr class="separator:adc789ea08b0f182ad7cddd182165e425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d79802ffc1ff062ca42742782d07fc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceClusterer.html#ac2d79802ffc1ff062ca42742782d07fc">extend_dist_tree_by_permutations</a> (const function&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>(size_t)&gt; &amp;get_position, const function&lt; int64_t(size_t)&gt; &amp;<a class="el" href="namespacevg.html#a716ebc4e690ac383342cc1c750bdddd0">get_offset</a>, size_t num_items, <a class="el" href="classvg_1_1OrientedDistanceMeasurer.html">OrientedDistanceMeasurer</a> &amp;distance_measurer, int64_t max_failed_distance_probes, size_t decrement_frequency, unordered_map&lt; pair&lt; size_t, size_t &gt;, int64_t &gt; &amp;recorded_finite_dists, map&lt; pair&lt; size_t, size_t &gt;, size_t &gt; &amp;num_infinite_dists, UnionFind &amp;component_union_find, size_t &amp;num_possible_merges_remaining)</td></tr>
<tr class="separator:ac2d79802ffc1ff062ca42742782d07fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1ab144babfc4e584501af114266dac"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceClusterer.html#aae1ab144babfc4e584501af114266dac">extend_dist_tree_by_buckets</a> (const function&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>(size_t)&gt; &amp;get_position, const function&lt; int64_t(size_t)&gt; &amp;<a class="el" href="namespacevg.html#a716ebc4e690ac383342cc1c750bdddd0">get_offset</a>, size_t num_items, <a class="el" href="classvg_1_1OrientedDistanceMeasurer.html">OrientedDistanceMeasurer</a> &amp;distance_measurer, unordered_map&lt; pair&lt; size_t, size_t &gt;, int64_t &gt; &amp;recorded_finite_dists, UnionFind &amp;component_union_find, size_t &amp;num_possible_merges_remaining)</td></tr>
<tr class="separator:aae1ab144babfc4e584501af114266dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e9629769bc8ffd2c609cf88fc27f61"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceClusterer.html#a16e9629769bc8ffd2c609cf88fc27f61">exclude_dist_tree_merges</a> (const function&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>(size_t)&gt; &amp;get_position, <a class="el" href="classvg_1_1OrientedDistanceMeasurer.html">OrientedDistanceMeasurer</a> &amp;distance_measurer, map&lt; pair&lt; size_t, size_t &gt;, size_t &gt; &amp;num_infinite_dists, UnionFind &amp;component_union_find, size_t &amp;num_possible_merges_remaining, int64_t max_failed_distance_probes)</td></tr>
<tr class="separator:a16e9629769bc8ffd2c609cf88fc27f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31d8ef9e3eb3de2724b4a4a04452da1"><td class="memItemLeft" align="right" valign="top">static vector&lt; unordered_map<br class="typebreak"/>
&lt; size_t, int64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceClusterer.html#aa31d8ef9e3eb3de2724b4a4a04452da1">flatten_distance_tree</a> (size_t num_items, const unordered_map&lt; pair&lt; size_t, size_t &gt;, int64_t &gt; &amp;recorded_finite_dists)</td></tr>
<tr class="separator:aa31d8ef9e3eb3de2724b4a4a04452da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a8889140774fa5906f9786b9f5b6b1c91"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classvg_1_1OrientedDistanceClusterer_1_1ODNode.html">ODNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceClusterer.html#a8889140774fa5906f9786b9f5b6b1c91">nodes</a></td></tr>
<tr class="separator:a8889140774fa5906f9786b9f5b6b1c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fddce8bcc6fa2902fb51f37d56861b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1DistanceIndex.html">DistanceIndex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceClusterer.html#a69fddce8bcc6fa2902fb51f37d56861b">distance_index</a></td></tr>
<tr class="separator:a69fddce8bcc6fa2902fb51f37d56861b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02815fdd278c050d280e4722b128f32d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceClusterer.html#a02815fdd278c050d280e4722b128f32d">aligner</a></td></tr>
<tr class="separator:a02815fdd278c050d280e4722b128f32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad9627382493b606581f85deb4cd317"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceClusterer.html#a8ad9627382493b606581f85deb4cd317">qual_adj_aligner</a></td></tr>
<tr class="separator:a8ad9627382493b606581f85deb4cd317"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ab996883ca097359a31a5e8d066b8ec61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvg_1_1OrientedDistanceClusterer.html#ab996883ca097359a31a5e8d066b8ec61">vg::OrientedDistanceClusterer::cluster_t</a> =  vector&lt;<a class="el" href="classvg_1_1OrientedDistanceClusterer.html#ae295cbcd1f1d325e6fde676f6dcb05b6">hit_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Each cluster is a vector of hits. </p>

</div>
</div>
<a class="anchor" id="ae295cbcd1f1d325e6fde676f6dcb05b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvg_1_1OrientedDistanceClusterer.html#ae295cbcd1f1d325e6fde676f6dcb05b6">vg::OrientedDistanceClusterer::hit_t</a> =  pair&lt;const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a>*, <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each hit contains a pointer to the original MEM and the position of that particular hit in the graph. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4f4f8728292f7b55a2d7ce19c65be472"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::OrientedDistanceClusterer::OrientedDistanceClusterer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> &amp;&#160;</td>
          <td class="paramname"><em>aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1OrientedDistanceMeasurer.html">OrientedDistanceMeasurer</a> &amp;&#160;</td>
          <td class="paramname"><em>distance_measurer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unstranded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_expected_dist_approx_error</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_mem_length</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classvg_1_1Constructor.html">Constructor</a> using <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a>, optionally memoizing succinct data structure operations. </p>

</div>
</div>
<a class="anchor" id="aff3d1c7ef8605a908c201f1b164643f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::OrientedDistanceClusterer::OrientedDistanceClusterer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> &amp;&#160;</td>
          <td class="paramname"><em>aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1OrientedDistanceMeasurer.html">OrientedDistanceMeasurer</a> &amp;&#160;</td>
          <td class="paramname"><em>distance_measurer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unstranded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_expected_dist_approx_error</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_mem_length</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classvg_1_1Constructor.html">Constructor</a> using <a class="el" href="classvg_1_1Aligner.html">Aligner</a>, optionally memoizing succinct data structure operations. </p>

</div>
</div>
<a class="anchor" id="a64119156e73fca657d99c62256aae124"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::OrientedDistanceClusterer::OrientedDistanceClusterer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *&#160;</td>
          <td class="paramname"><em>aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *&#160;</td>
          <td class="paramname"><em>qual_adj_aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1OrientedDistanceMeasurer.html">OrientedDistanceMeasurer</a> &amp;&#160;</td>
          <td class="paramname"><em>distance_measurer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unstranded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_expected_dist_approx_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_mem_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal constructor that public constructors filter into. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af355988106372edb9f4f1462c6f7d53a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classvg_1_1OrientedDistanceClusterer.html#ab996883ca097359a31a5e8d066b8ec61">OrientedDistanceClusterer::cluster_t</a> &gt; vg::OrientedDistanceClusterer::clusters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>max_qual_score</em> = <code>60</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>log_likelihood_approx_factor</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_median_mem_coverage_for_split</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>suboptimal_edge_pruning_factor</em> = <code>.75</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a vector of clusters. Each cluster is represented a vector of MEM hits. Each hit contains a pointer to the original MEM and the position of that particular hit in the graph. </p>

</div>
</div>
<a class="anchor" id="a0534cf827a5f17bde1afbf8837b08ba3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::OrientedDistanceClusterer::component_topological_order </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>order_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the topological order of. </p>

</div>
</div>
<a class="anchor" id="a5fad154b1267d5d3861870a51b482d9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; size_t, size_t &gt; &gt; vg::OrientedDistanceClusterer::compute_tail_mem_coverage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a vector containing the number of SMEM beginnings to the left and the number of SMEM endings to the right of each read position </p>

</div>
</div>
<a class="anchor" id="af673c60a8b3cb48354f1fc740ca302ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::OrientedDistanceClusterer::connected_components </td>
          <td>(</td>
          <td class="paramtype">vector&lt; vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>components_out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identify weakly connected components in the graph. </p>

</div>
</div>
<a class="anchor" id="a16e9629769bc8ffd2c609cf88fc27f61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::OrientedDistanceClusterer::exclude_dist_tree_merges </td>
          <td>(</td>
          <td class="paramtype">const function&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>get_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1OrientedDistanceMeasurer.html">OrientedDistanceMeasurer</a> &amp;&#160;</td>
          <td class="paramname"><em>distance_measurer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; pair&lt; size_t, size_t &gt;, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>num_infinite_dists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnionFind &amp;&#160;</td>
          <td class="paramname"><em>component_union_find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>num_possible_merges_remaining</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_failed_distance_probes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Automatically blocks off merges in the distance tree between groups that can be inferred to be on separate components </p>

</div>
</div>
<a class="anchor" id="aae1ab144babfc4e584501af114266dac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::OrientedDistanceClusterer::extend_dist_tree_by_buckets </td>
          <td>(</td>
          <td class="paramtype">const function&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>get_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; int64_t(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>get_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1OrientedDistanceMeasurer.html">OrientedDistanceMeasurer</a> &amp;&#160;</td>
          <td class="paramname"><em>distance_measurer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_map&lt; pair&lt; size_t, size_t &gt;, int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>recorded_finite_dists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnionFind &amp;&#160;</td>
          <td class="paramname"><em>component_union_find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>num_possible_merges_remaining</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds edges into the distance tree by estimating the distance only between pairs of items that can be easily identified as having a finite distance (e.g. by sharing a path) </p>

</div>
</div>
<a class="anchor" id="ac2d79802ffc1ff062ca42742782d07fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::OrientedDistanceClusterer::extend_dist_tree_by_permutations </td>
          <td>(</td>
          <td class="paramtype">const function&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>get_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; int64_t(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>get_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1OrientedDistanceMeasurer.html">OrientedDistanceMeasurer</a> &amp;&#160;</td>
          <td class="paramname"><em>distance_measurer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_failed_distance_probes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>decrement_frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_map&lt; pair&lt; size_t, size_t &gt;, int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>recorded_finite_dists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; pair&lt; size_t, size_t &gt;, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>num_infinite_dists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnionFind &amp;&#160;</td>
          <td class="paramname"><em>component_union_find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>num_possible_merges_remaining</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds edges into the distance tree by estimating the distance between pairs generated by a high entropy deterministic permutation </p>

</div>
</div>
<a class="anchor" id="aa31d8ef9e3eb3de2724b4a4a04452da1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; unordered_map&lt; size_t, int64_t &gt; &gt; vg::OrientedDistanceClusterer::flatten_distance_tree </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; pair&lt; size_t, size_t &gt;, int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>recorded_finite_dists</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a number of nodes, and a map from node pair to signed relative distance on a consistent strand (defining a forrest of trees, as generated by <a class="el" href="classvg_1_1OrientedDistanceClusterer.html#adc789ea08b0f182ad7cddd182165e425">get_on_strand_distance_tree()</a>), flatten all the trees.</p>
<p>Returns a vector of maps from node ID to relative position in linear space, one map per input tree.</p>
<p>Assumes all the distances are transitive, even though this isn't quite true in graph space. </p>

</div>
</div>
<a class="anchor" id="adc789ea08b0f182ad7cddd182165e425"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; pair&lt; size_t, size_t &gt;, int64_t &gt; vg::OrientedDistanceClusterer::get_on_strand_distance_tree </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>get_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; int64_t(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>get_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1OrientedDistanceMeasurer.html">OrientedDistanceMeasurer</a> &amp;&#160;</td>
          <td class="paramname"><em>distance_measurer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a certain number of items, and a callback to get each item's position, and a callback to a fixed offset from that position build a distance forest with trees for items that we can verify are on the same strand of the same molecule.</p>
<p>We use the distance approximation to cluster the MEM hits according to the strand they fall on using the oriented distance estimation function in xg.</p>
<p>Returns a map from item pair (lower number first) to distance (which may be negative) from the first to the second along the items' forward strand. </p>

</div>
</div>
<a class="anchor" id="a96510c3f1316864da113417fd418db32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::OrientedDistanceClusterer::identify_sources_and_sinks </td>
          <td>(</td>
          <td class="paramtype">vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>sources_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>sinks_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills input vectors with indices of source and sink nodes. </p>

</div>
</div>
<a class="anchor" id="a9264036d14c69dff24ba81cd5c84ca75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::OrientedDistanceClusterer::median_mem_coverage </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the median coverage of bases in the reads by bases in the cluster, attempts to remove apparent redundant sub-MEMs </p>

</div>
</div>
<a class="anchor" id="a64fc16304bbe979775dda279258c4757"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; pair&lt; size_t, size_t &gt;, int64_t &gt; &gt; vg::OrientedDistanceClusterer::pair_clusters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1OrientedDistanceClusterer.html#ab996883ca097359a31a5e8d066b8ec61">cluster_t</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>left_clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1OrientedDistanceClusterer.html#ab996883ca097359a31a5e8d066b8ec61">cluster_t</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>right_clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; size_t, size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>left_alt_cluster_anchors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; size_t, size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>right_alt_cluster_anchors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_inter_cluster_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_inter_cluster_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1OrientedDistanceMeasurer.html">OrientedDistanceMeasurer</a> &amp;&#160;</td>
          <td class="paramname"><em>distance_measurer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given two vectors of clusters, an xg index, an bounds on the distance between clusters, returns a vector of pairs of cluster numbers (one in each vector) matched with the estimated distance </p>

</div>
</div>
<a class="anchor" id="a98773e2b5618c3f8b0f70e0ebe717b38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::OrientedDistanceClusterer::perform_dp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform dynamic programming and store scores in nodes. </p>

</div>
</div>
<a class="anchor" id="a676e4766c5793f2aca2eea0fb969449b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::OrientedDistanceClusterer::prune_low_scoring_edges </td>
          <td>(</td>
          <td class="paramtype">vector&lt; vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>component_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>score_factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prune edges that are not on any traceback that scores highly compared to the best score in the component, splits up the components (adding some to the end of the vector) if doing so splits a component </p>

</div>
</div>
<a class="anchor" id="ae7d49c49f04bc25d2d5ea6f7051842f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::OrientedDistanceClusterer::topological_order </td>
          <td>(</td>
          <td class="paramtype">vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>order_out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the input vector with the indices of a topological sort. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a02815fdd278c050d280e4722b128f32d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvg_1_1Aligner.html">Aligner</a>* vg::OrientedDistanceClusterer::aligner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a69fddce8bcc6fa2902fb51f37d56861b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvg_1_1DistanceIndex.html">DistanceIndex</a>* vg::OrientedDistanceClusterer::distance_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8889140774fa5906f9786b9f5b6b1c91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="classvg_1_1OrientedDistanceClusterer_1_1ODNode.html">ODNode</a>&gt; vg::OrientedDistanceClusterer::nodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8ad9627382493b606581f85deb4cd317"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a>* vg::OrientedDistanceClusterer::qual_adj_aligner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="cluster_8hpp.html">cluster.hpp</a></li>
<li>src/<a class="el" href="cluster_8cpp.html">cluster.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
