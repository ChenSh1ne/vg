<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>vg: vg::MultipathAlignmentGraph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html">MultipathAlignmentGraph</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classvg_1_1MultipathAlignmentGraph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::MultipathAlignmentGraph Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;multipath_alignment_graph.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a886d47d0bb11505a7ed9c8b6e3183036"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a886d47d0bb11505a7ed9c8b6e3183036">MultipathAlignmentGraph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const <a class="el" href="classvg_1_1MultipathMapper.html#a781815d148571276e536c7a7780017be">MultipathMapper::memcluster_t</a> &amp;hits, const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;projection_trans, const unordered_multimap&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;injection_trans, size_t max_branch_trim_length=0, gcsa::GCSA *gcsa=nullptr)</td></tr>
<tr class="separator:a886d47d0bb11505a7ed9c8b6e3183036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d3c327e2c5b5633400f45d30c8b8bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#aa6d3c327e2c5b5633400f45d30c8b8bf">MultipathAlignmentGraph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const <a class="el" href="classvg_1_1MultipathMapper.html#a781815d148571276e536c7a7780017be">MultipathMapper::memcluster_t</a> &amp;hits, const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;projection_trans, size_t max_branch_trim_length=0, gcsa::GCSA *gcsa=nullptr)</td></tr>
<tr class="memdesc:aa6d3c327e2c5b5633400f45d30c8b8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the previous constructor, but construct injection_trans implicitly and temporarily.  <a href="#aa6d3c327e2c5b5633400f45d30c8b8bf">More...</a><br/></td></tr>
<tr class="separator:aa6d3c327e2c5b5633400f45d30c8b8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9207833b929c3f0ef55a70c652d0a2e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a9207833b929c3f0ef55a70c652d0a2e7">MultipathAlignmentGraph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const vector&lt; pair&lt; pair&lt; string::const_iterator, string::const_iterator &gt;, <a class="el" href="structvg_1_1Path.html">Path</a> &gt;&gt; &amp;path_chunks, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;projection_trans, const unordered_multimap&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;injection_trans)</td></tr>
<tr class="separator:a9207833b929c3f0ef55a70c652d0a2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab870238b929730735859ff13df9741f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#ab870238b929730735859ff13df9741f9">MultipathAlignmentGraph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const vector&lt; pair&lt; pair&lt; string::const_iterator, string::const_iterator &gt;, <a class="el" href="structvg_1_1Path.html">Path</a> &gt;&gt; &amp;path_chunks, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;projection_trans)</td></tr>
<tr class="memdesc:ab870238b929730735859ff13df9741f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the previous constructor, but construct injection_trans implicitly and temporarily.  <a href="#ab870238b929730735859ff13df9741f9">More...</a><br/></td></tr>
<tr class="separator:ab870238b929730735859ff13df9741f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87791ea6b5320eac8567297334233997"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a87791ea6b5320eac8567297334233997">MultipathAlignmentGraph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;snarl_manager, size_t max_snarl_cut_size, const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;projection_trans, const unordered_multimap&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;injection_trans)</td></tr>
<tr class="memdesc:a87791ea6b5320eac8567297334233997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a multipath alignment graph using the path of a single-path alignment.  <a href="#a87791ea6b5320eac8567297334233997">More...</a><br/></td></tr>
<tr class="separator:a87791ea6b5320eac8567297334233997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c165af96bda6daeca4018472f3abe9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a94c165af96bda6daeca4018472f3abe9">MultipathAlignmentGraph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;snarl_manager, size_t max_snarl_cut_size, const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;projection_trans)</td></tr>
<tr class="memdesc:a94c165af96bda6daeca4018472f3abe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the previous constructor, but construct injection_trans implicitly and temporarily.  <a href="#a94c165af96bda6daeca4018472f3abe9">More...</a><br/></td></tr>
<tr class="separator:a94c165af96bda6daeca4018472f3abe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e2932360f805d5c6353cd25e377e5d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a85e2932360f805d5c6353cd25e377e5d">~MultipathAlignmentGraph</a> ()</td></tr>
<tr class="separator:a85e2932360f805d5c6353cd25e377e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565b45f37d5be97cd30bce1d29c134fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a565b45f37d5be97cd30bce1d29c134fc">topological_sort</a> (vector&lt; size_t &gt; &amp;order_out)</td></tr>
<tr class="separator:a565b45f37d5be97cd30bce1d29c134fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1709931c016b2126b6a9d909c2b1c725"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a1709931c016b2126b6a9d909c2b1c725">trim_hanging_indels</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment)</td></tr>
<tr class="separator:a1709931c016b2126b6a9d909c2b1c725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9c58b7f20245a4c400dd14e8488069"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#aeb9c58b7f20245a4c400dd14e8488069">remove_transitive_edges</a> (const vector&lt; size_t &gt; &amp;topological_order)</td></tr>
<tr class="separator:aeb9c58b7f20245a4c400dd14e8488069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae608d17e883c30c5dd8a4c38047d1e00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#ae608d17e883c30c5dd8a4c38047d1e00">prune_to_high_scoring_paths</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *aligner, double max_suboptimal_score_ratio, const vector&lt; size_t &gt; &amp;topological_order)</td></tr>
<tr class="separator:ae608d17e883c30c5dd8a4c38047d1e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af112f1a5af47cf079a163eec1c2e31f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#af112f1a5af47cf079a163eec1c2e31f4">clear_reachability_edges</a> ()</td></tr>
<tr class="separator:af112f1a5af47cf079a163eec1c2e31f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3199fb5e097873e2635e3fb34a8eafe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#ac3199fb5e097873e2635e3fb34a8eafe">trim_to_branch_points</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph, size_t max_trim_length=1)</td></tr>
<tr class="separator:ac3199fb5e097873e2635e3fb34a8eafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3543fd819b9bf29db1b49267c7a6b75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#ac3543fd819b9bf29db1b49267c7a6b75">resect_snarls_from_paths</a> (<a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> *cutting_snarls, const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;projection_trans, int64_t max_snarl_cut_size=5)</td></tr>
<tr class="separator:ac3543fd819b9bf29db1b49267c7a6b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca4ca727f888dfde453616c292d2a77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a8ca4ca727f888dfde453616c292d2a77">synthesize_tail_anchors</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;align_graph, const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *aligner, size_t min_anchor_size, size_t max_alt_alns, bool dynamic_alt_alns)</td></tr>
<tr class="separator:a8ca4ca727f888dfde453616c292d2a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab425ee12b86f18592c1f948bf745ae6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#aab425ee12b86f18592c1f948bf745ae6">add_reachability_edges</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;vg, const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;projection_trans, const unordered_multimap&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;injection_trans)</td></tr>
<tr class="memdesc:aab425ee12b86f18592c1f948bf745ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add edges between reachable nodes and split nodes at overlaps.  <a href="#aab425ee12b86f18592c1f948bf745ae6">More...</a><br/></td></tr>
<tr class="separator:aab425ee12b86f18592c1f948bf745ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b4b06282da8d80291ff115a2ee9b19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#ad0b4b06282da8d80291ff115a2ee9b19">align</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;align_graph, const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *aligner, bool score_anchors_as_matches, size_t max_alt_alns, bool dynamic_alt_alns, size_t band_padding, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln_out, const bool allow_negative_scores=false)</td></tr>
<tr class="separator:ad0b4b06282da8d80291ff115a2ee9b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502af6b8e769c0382c2fba1f485ccd9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a502af6b8e769c0382c2fba1f485ccd9d">align</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;align_graph, const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *aligner, bool score_anchors_as_matches, size_t max_alt_alns, bool dynamic_alt_alns, function&lt; size_t(const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;)&gt; band_padding_function, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln_out, const bool allow_negative_scores=false)</td></tr>
<tr class="separator:a502af6b8e769c0382c2fba1f485ccd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090155f04120616163803c84430e9e22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a090155f04120616163803c84430e9e22">to_dot</a> (ostream &amp;out, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> *alignment=nullptr) const </td></tr>
<tr class="separator:a090155f04120616163803c84430e9e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee71caddf247187f1a756a36f99381f"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a2ee71caddf247187f1a756a36f99381f">get_connected_components</a> () const </td></tr>
<tr class="memdesc:a2ee71caddf247187f1a756a36f99381f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get lists of the vg node IDs that participate in each connected component in the <a class="el" href="classvg_1_1MultipathAlignmentGraph.html">MultipathAlignmentGraph</a>.  <a href="#a2ee71caddf247187f1a756a36f99381f">More...</a><br/></td></tr>
<tr class="separator:a2ee71caddf247187f1a756a36f99381f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dce14022a795e72b616765bca9b6886"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a6dce14022a795e72b616765bca9b6886">empty</a> ()</td></tr>
<tr class="memdesc:a6dce14022a795e72b616765bca9b6886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the multipath alignment graph have any nodes?  <a href="#a6dce14022a795e72b616765bca9b6886">More...</a><br/></td></tr>
<tr class="separator:a6dce14022a795e72b616765bca9b6886"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8cbd1429036d9f365bd361ffbc8aa855"><td class="memItemLeft" align="right" valign="top">static unordered_multimap<br class="typebreak"/>
&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a8cbd1429036d9f365bd361ffbc8aa855">create_injection_trans</a> (const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;projection_trans)</td></tr>
<tr class="separator:a8cbd1429036d9f365bd361ffbc8aa855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af626a9a7a96800aa13aa257a5781fffe"><td class="memItemLeft" align="right" valign="top">static unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, <br class="typebreak"/>
pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#af626a9a7a96800aa13aa257a5781fffe">create_identity_projection_trans</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph)</td></tr>
<tr class="separator:af626a9a7a96800aa13aa257a5781fffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ae544522fd51c2b6e853d76d5c971a6f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#ae544522fd51c2b6e853d76d5c971a6f8">create_path_chunk_nodes</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const vector&lt; pair&lt; pair&lt; string::const_iterator, string::const_iterator &gt;, <a class="el" href="structvg_1_1Path.html">Path</a> &gt;&gt; &amp;path_chunks, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;projection_trans, const unordered_multimap&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;injection_trans)</td></tr>
<tr class="memdesc:ae544522fd51c2b6e853d76d5c971a6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the path chunks as nodes to the connectivity graph.  <a href="#ae544522fd51c2b6e853d76d5c971a6f8">More...</a><br/></td></tr>
<tr class="separator:ae544522fd51c2b6e853d76d5c971a6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6b16406e06cfc387261b1fd4161d33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a0b6b16406e06cfc387261b1fd4161d33">create_match_nodes</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const <a class="el" href="classvg_1_1MultipathMapper.html#a781815d148571276e536c7a7780017be">MultipathMapper::memcluster_t</a> &amp;hits, const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;projection_trans, const unordered_multimap&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;injection_trans)</td></tr>
<tr class="memdesc:a0b6b16406e06cfc387261b1fd4161d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk out MEMs into match nodes and filter out redundant sub-MEMs.  <a href="#a0b6b16406e06cfc387261b1fd4161d33">More...</a><br/></td></tr>
<tr class="separator:a0b6b16406e06cfc387261b1fd4161d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9837be5f0b807534244afe266208448"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#aa9837be5f0b807534244afe266208448">collapse_order_length_runs</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, gcsa::GCSA *gcsa)</td></tr>
<tr class="separator:aa9837be5f0b807534244afe266208448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba05a33bf075eb3eb7260e229245f06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#adba05a33bf075eb3eb7260e229245f06">reorder_adjacency_lists</a> (const vector&lt; size_t &gt; &amp;order)</td></tr>
<tr class="separator:adba05a33bf075eb3eb7260e229245f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4f887b7ce1bef26935c7416d7ae2fc"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; bool, <br class="typebreak"/>
unordered_map&lt; size_t, vector<br class="typebreak"/>
&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#aee4f887b7ce1bef26935c7416d7ae2fc">align_tails</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;align_graph, const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *aligner, size_t max_alt_alns, bool dynamic_alt_alns, unordered_set&lt; size_t &gt; *sources=nullptr)</td></tr>
<tr class="separator:aee4f887b7ce1bef26935c7416d7ae2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:aba6c4c7e8954cbe789393e5ced260a8d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#aba6c4c7e8954cbe789393e5ced260a8d">trim_and_check_for_empty</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, <a class="el" href="classvg_1_1PathNode.html">PathNode</a> &amp;<a class="el" href="namespacevg.html#a3bd8aa63fec8b9f6c3ed5808689975e6">path_node</a>, int64_t *removed_start_from_length=nullptr, int64_t *removed_end_from_length=nullptr)</td></tr>
<tr class="separator:aba6c4c7e8954cbe789393e5ced260a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a76f9356cd0afea7dea3003caea2526eb"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classvg_1_1PathNode.html">PathNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a76f9356cd0afea7dea3003caea2526eb">path_nodes</a></td></tr>
<tr class="memdesc:a76f9356cd0afea7dea3003caea2526eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nodes representing walked MEMs in the graph.  <a href="#a76f9356cd0afea7dea3003caea2526eb">More...</a><br/></td></tr>
<tr class="separator:a76f9356cd0afea7dea3003caea2526eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a113d4c5b6b5ca1d7748c1b812e8d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a77a113d4c5b6b5ca1d7748c1b812e8d3">has_reachability_edges</a> = false</td></tr>
<tr class="separator:a77a113d4c5b6b5ca1d7748c1b812e8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a886d47d0bb11505a7ed9c8b6e3183036"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::MultipathAlignmentGraph::MultipathAlignmentGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1MultipathMapper.html#a781815d148571276e536c7a7780017be">MultipathMapper::memcluster_t</a> &amp;&#160;</td>
          <td class="paramname"><em>hits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_multimap&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>injection_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_branch_trim_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gcsa::GCSA *&#160;</td>
          <td class="paramname"><em>gcsa</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a graph of the reachability between MEMs in a DAG-ified graph. If a GCSA is specified, use it to collapse MEMs whose lengths bump up against the GCSA's order limit on MEM length. Produces a graph with reachability edges. Assumes that the cluster is sorted by primarily length and secondarily lexicographically by read interval. </p>

</div>
</div>
<a class="anchor" id="aa6d3c327e2c5b5633400f45d30c8b8bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::MultipathAlignmentGraph::MultipathAlignmentGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1MultipathMapper.html#a781815d148571276e536c7a7780017be">MultipathMapper::memcluster_t</a> &amp;&#160;</td>
          <td class="paramname"><em>hits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_branch_trim_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gcsa::GCSA *&#160;</td>
          <td class="paramname"><em>gcsa</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as the previous constructor, but construct injection_trans implicitly and temporarily. </p>

</div>
</div>
<a class="anchor" id="a9207833b929c3f0ef55a70c652d0a2e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::MultipathAlignmentGraph::MultipathAlignmentGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; pair&lt; string::const_iterator, string::const_iterator &gt;, <a class="el" href="structvg_1_1Path.html">Path</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_multimap&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>injection_trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a graph of the reachability between MEMs in a linearized path graph. Produces a graph with reachability edges. </p>

</div>
</div>
<a class="anchor" id="ab870238b929730735859ff13df9741f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::MultipathAlignmentGraph::MultipathAlignmentGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; pair&lt; string::const_iterator, string::const_iterator &gt;, <a class="el" href="structvg_1_1Path.html">Path</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as the previous constructor, but construct injection_trans implicitly and temporarily. </p>

</div>
</div>
<a class="anchor" id="a87791ea6b5320eac8567297334233997"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::MultipathAlignmentGraph::MultipathAlignmentGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl_manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_snarl_cut_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_multimap&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>injection_trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a multipath alignment graph using the path of a single-path alignment. </p>

</div>
</div>
<a class="anchor" id="a94c165af96bda6daeca4018472f3abe9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::MultipathAlignmentGraph::MultipathAlignmentGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl_manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_snarl_cut_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as the previous constructor, but construct injection_trans implicitly and temporarily. </p>

</div>
</div>
<a class="anchor" id="a85e2932360f805d5c6353cd25e377e5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::MultipathAlignmentGraph::~MultipathAlignmentGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aab425ee12b86f18592c1f948bf745ae6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::add_reachability_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>vg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_multimap&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>injection_trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add edges between reachable nodes and split nodes at overlaps. </p>
<p>Get the offset in the first visited graph node at which the given MEM starts. Does not account for orientation.</p>
<p>Get the offset in the first visited graph node at which the given MEM ends (i.e. the past-the-end offset). Does not account for orientation.</p>
<p>Get the ID of the first node visited in the graph along the path for a MEM. Does not account for orientation.</p>
<p>Get the ID of the last node visited in the graph along the path for a MEM. Does not account for orientation.</p>
<p>Get the offset in the read of either the start or past-the-end position of the given MEM, according to the end flag.</p>
<p>Get the node ID in the graph of either the start or end position of the given MEM, according to the end flag. </p>

</div>
</div>
<a class="anchor" id="ad0b4b06282da8d80291ff115a2ee9b19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::align </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>align_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *&#160;</td>
          <td class="paramname"><em>aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>score_anchors_as_matches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_alt_alns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dynamic_alt_alns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_negative_scores</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do intervening and tail alignments between the anchoring paths and store the result in a <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>. Reachability edges must be in the graph. The <a class="el" href="structvg_1_1Alignment.html">Alignment</a> passed <em>must</em> be the same <a class="el" href="structvg_1_1Alignment.html">Alignment</a> that owns the sequence into which iterators were passed when the <a class="el" href="classvg_1_1MultipathAlignmentGraph.html">MultipathAlignmentGraph</a> was constructed! TODO: Shouldn't the class hold a reference to the <a class="el" href="structvg_1_1Alignment.html">Alignment</a> then?</p>
<p>Note that the output alignment may NOT be in topologically-sorted order, even if this <a class="el" href="classvg_1_1MultipathAlignmentGraph.html">MultipathAlignmentGraph</a> is. You MUST sort it with <a class="el" href="namespacevg.html#ae03e9d67c4a774a71895ade9f10c6d19" title="Put subpaths in topological order (assumed to be true for other algorithms) ">topologically_order_subpaths()</a> before trying to run DP on it. </p>

</div>
</div>
<a class="anchor" id="a502af6b8e769c0382c2fba1f485ccd9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::align </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>align_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *&#160;</td>
          <td class="paramname"><em>aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>score_anchors_as_matches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_alt_alns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dynamic_alt_alns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; size_t(const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>band_padding_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_negative_scores</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do intervening and tail alignments between the anchoring paths and store the result in a <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>. Reachability edges must be in the graph. Also, choose the band padding dynamically as a function of the inter-MEM sequence and graph. The <a class="el" href="structvg_1_1Alignment.html">Alignment</a> passed <em>must</em> be the same <a class="el" href="structvg_1_1Alignment.html">Alignment</a> that owns the sequence into which iterators were passed when the <a class="el" href="classvg_1_1MultipathAlignmentGraph.html">MultipathAlignmentGraph</a> was constructed! TODO: Shouldn't the class hold a reference to the <a class="el" href="structvg_1_1Alignment.html">Alignment</a> then?</p>
<p>Note that the output alignment may NOT be in topologically-sorted order, even if this <a class="el" href="classvg_1_1MultipathAlignmentGraph.html">MultipathAlignmentGraph</a> is. You MUST sort it with <a class="el" href="namespacevg.html#ae03e9d67c4a774a71895ade9f10c6d19" title="Put subpaths in topological order (assumed to be true for other algorithms) ">topologically_order_subpaths()</a> before trying to run DP on it. </p>

</div>
</div>
<a class="anchor" id="aee4f887b7ce1bef26935c7416d7ae2fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; bool, unordered_map&lt; size_t, vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &gt; &gt; vg::MultipathAlignmentGraph::align_tails </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>align_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *&#160;</td>
          <td class="paramname"><em>aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_alt_alns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dynamic_alt_alns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_set&lt; size_t &gt; *&#160;</td>
          <td class="paramname"><em>sources</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate alignments of the tails of the query sequence, beyond the sources and sinks. The <a class="el" href="structvg_1_1Alignment.html">Alignment</a> passed <em>must</em> be the one that owns the sequence we are working on. Returns a map from tail (left=false, right=true), to a map from subpath number to all the Alignments of the tail off of that subpath. Also computes the source subpaths and adds their numbers to the given set if not null. </p>

</div>
</div>
<a class="anchor" id="af112f1a5af47cf079a163eec1c2e31f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::clear_reachability_edges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear reachability edges, so that add_reachability_edges can be run (possibly after modifying the graph). </p>

</div>
</div>
<a class="anchor" id="aa9837be5f0b807534244afe266208448"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::collapse_order_length_runs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gcsa::GCSA *&#160;</td>
          <td class="paramname"><em>gcsa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Identifies runs of exact matches that are sub-maximal because they hit the order of the GCSA index and merges them into a single node, assumes that match nodes are sorted by length and then lexicographically by read interval, does not update edges </p>

</div>
</div>
<a class="anchor" id="af626a9a7a96800aa13aa257a5781fffe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; vg::MultipathAlignmentGraph::create_identity_projection_trans </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an identity projection translation from a DAG that did not need to be modified during dagification. </p>

</div>
</div>
<a class="anchor" id="a8cbd1429036d9f365bd361ffbc8aa855"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_multimap&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; vg::MultipathAlignmentGraph::create_injection_trans </td>
          <td>(</td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_trans</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create the constant injection translation data, which maps a node in the original graph to every one of its occurrences in the dagified graph, by reversing the projection translation. This data is needed to construct the <a class="el" href="classvg_1_1MultipathAlignmentGraph.html">MultipathAlignmentGraph</a>, and to perform some other operations on it, but is big enough that it is worth not making it a member. </p>

</div>
</div>
<a class="anchor" id="a0b6b16406e06cfc387261b1fd4161d33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::create_match_nodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1MultipathMapper.html#a781815d148571276e536c7a7780017be">MultipathMapper::memcluster_t</a> &amp;&#160;</td>
          <td class="paramname"><em>hits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_multimap&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>injection_trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Walk out MEMs into match nodes and filter out redundant sub-MEMs. </p>

</div>
</div>
<a class="anchor" id="ae544522fd51c2b6e853d76d5c971a6f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::create_path_chunk_nodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; pair&lt; string::const_iterator, string::const_iterator &gt;, <a class="el" href="structvg_1_1Path.html">Path</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_multimap&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>injection_trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the path chunks as nodes to the connectivity graph. </p>

</div>
</div>
<a class="anchor" id="a6dce14022a795e72b616765bca9b6886"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MultipathAlignmentGraph::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does the multipath alignment graph have any nodes? </p>

</div>
</div>
<a class="anchor" id="a2ee71caddf247187f1a756a36f99381f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &gt; vg::MultipathAlignmentGraph::get_connected_components </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get lists of the vg node IDs that participate in each connected component in the <a class="el" href="classvg_1_1MultipathAlignmentGraph.html">MultipathAlignmentGraph</a>. </p>

</div>
</div>
<a class="anchor" id="ae608d17e883c30c5dd8a4c38047d1e00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::prune_to_high_scoring_paths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *&#160;</td>
          <td class="paramname"><em>aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_suboptimal_score_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>topological_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes nodes and edges that are not part of any path that has an estimated score within some amount of the highest scoring path. Reachability edges must be present. </p>

</div>
</div>
<a class="anchor" id="aeb9c58b7f20245a4c400dd14e8488069"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::remove_transitive_edges </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>topological_order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all transitive edges from graph (reduces to minimum equivalent graph). Note: reorders internal representation of adjacency lists. Reachability edges must be in the graph. </p>

</div>
</div>
<a class="anchor" id="adba05a33bf075eb3eb7260e229245f06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::reorder_adjacency_lists </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reorders adjacency list representation of edges so that they follow the indicated ordering of their target nodes </p>

</div>
</div>
<a class="anchor" id="ac3543fd819b9bf29db1b49267c7a6b75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::resect_snarls_from_paths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> *&#160;</td>
          <td class="paramname"><em>cutting_snarls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_snarl_cut_size</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cut the interior of snarls out of anchoring paths (and split alignment nodes accordingly) unless they are longer than the max cut size. Reachability edges must be cleared. </p>

</div>
</div>
<a class="anchor" id="a8ca4ca727f888dfde453616c292d2a77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::synthesize_tail_anchors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>align_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *&#160;</td>
          <td class="paramname"><em>aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_anchor_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_alt_alns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dynamic_alt_alns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do some exploratory alignments of the tails of the graph, outside the outermost existing anchors, and define new anchoring paths from them. After this, you can call resect_snarls_from_paths, in order to get better coverage of possible combinations of snarl traversals in parts of the alignment that didn't originally have anchors. Produces <em>only</em> perfect match anchors, so it is still safe to use score_anchors_as_matches. The <a class="el" href="structvg_1_1Alignment.html">Alignment</a> passed <em>must</em> be the same <a class="el" href="structvg_1_1Alignment.html">Alignment</a> that owns the sequence into which iterators were passed when the <a class="el" href="classvg_1_1MultipathAlignmentGraph.html">MultipathAlignmentGraph</a> was constructed! TODO: Shouldn't the class hold a reference to the <a class="el" href="structvg_1_1Alignment.html">Alignment</a> then? </p>

</div>
</div>
<a class="anchor" id="a090155f04120616163803c84430e9e22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::to_dot </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> *&#160;</td>
          <td class="paramname"><em>alignment</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a <a class="el" href="classvg_1_1MultipathAlignmentGraph.html">MultipathAlignmentGraph</a> to a GraphViz Dot representation, output to the given ostream. If given the <a class="el" href="structvg_1_1Alignment.html">Alignment</a> query we are working on, can produce information about subpath iterators. </p>

</div>
</div>
<a class="anchor" id="a565b45f37d5be97cd30bce1d29c134fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::topological_sort </td>
          <td>(</td>
          <td class="paramtype">vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>order_out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills input vector with node indices of a topological sort. Reachability edges must be in the graph. </p>

</div>
</div>
<a class="anchor" id="aba6c4c7e8954cbe789393e5ced260a8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MultipathAlignmentGraph::trim_and_check_for_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1PathNode.html">PathNode</a> &amp;&#160;</td>
          <td class="paramname"><em>path_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>removed_start_from_length</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>removed_end_from_length</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Trim down the given <a class="el" href="classvg_1_1PathNode.html">PathNode</a> of everything except softclips. Return true if it all gets trimmed away and should be removed. Fills in removed_start_from_length and/or removed_end_from_length with the bases in the graph removed from the path on each end during trimming, if set. </p>

</div>
</div>
<a class="anchor" id="a1709931c016b2126b6a9d909c2b1c725"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::trim_hanging_indels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes non-softclip indels from path nodes. Does not update edges&ndash;should be called prior to adding computing edges. </p>

</div>
</div>
<a class="anchor" id="ac3199fb5e097873e2635e3fb34a8eafe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::trim_to_branch_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_trim_length</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove the ends of paths, up to a maximum length, if they cause the path to extend past a branch point in the graph. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a77a113d4c5b6b5ca1d7748c1b812e8d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MultipathAlignmentGraph::has_reachability_edges = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>We keep a flag for whether the reachability edges are set. This is for error checking, and is kind of a forgery (you should just check the actual edge records), but the state system we use is confusing so we want to make sure we have lots of asserts to enforce it. If this is set and you want it unset, use <a class="el" href="classvg_1_1MultipathAlignmentGraph.html#af112f1a5af47cf079a163eec1c2e31f4">clear_reachability_edges()</a>. If this is unset and you want it set, use <a class="el" href="classvg_1_1MultipathAlignmentGraph.html#aab425ee12b86f18592c1f948bf745ae6" title="Add edges between reachable nodes and split nodes at overlaps. ">add_reachability_edges()</a>. </p>

</div>
</div>
<a class="anchor" id="a76f9356cd0afea7dea3003caea2526eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="classvg_1_1PathNode.html">PathNode</a>&gt; vg::MultipathAlignmentGraph::path_nodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nodes representing walked MEMs in the graph. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="multipath__alignment__graph_8hpp.html">multipath_alignment_graph.hpp</a></li>
<li>src/<a class="el" href="multipath__alignment__graph_8cpp.html">multipath_alignment_graph.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
