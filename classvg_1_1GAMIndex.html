<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>vg: vg::GAMIndex Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1GAMIndex.html">GAMIndex</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classvg_1_1GAMIndex-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::GAMIndex Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;gam_index.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9c2661c669d27f7d13ccba9abd6ae445"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GAMIndex.html#a9c2661c669d27f7d13ccba9abd6ae445">cursor_t</a> = <a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">stream::ProtobufIterator</a>&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;</td></tr>
<tr class="separator:a9c2661c669d27f7d13ccba9abd6ae445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1dab51516ca66bf3fa11ba48ab2fbc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GAMIndex.html#afd1dab51516ca66bf3fa11ba48ab2fbc">bin_t</a> = make_unsigned&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt;::type</td></tr>
<tr class="separator:afd1dab51516ca66bf3fa11ba48ab2fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0171d8b8b943eadb4e8ff6e44a6454fd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GAMIndex.html#a0171d8b8b943eadb4e8ff6e44a6454fd">window_t</a> = make_unsigned&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt;::type</td></tr>
<tr class="separator:a0171d8b8b943eadb4e8ff6e44a6454fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aeed44b9a4906306d3a34fd2ad56cd361"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GAMIndex.html#aeed44b9a4906306d3a34fd2ad56cd361">GAMIndex</a> ()=default</td></tr>
<tr class="separator:aeed44b9a4906306d3a34fd2ad56cd361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bf1352cc56a2c39b16207b92ce805d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GAMIndex.html#aa3bf1352cc56a2c39b16207b92ce805d">load</a> (istream &amp;from)</td></tr>
<tr class="separator:aa3bf1352cc56a2c39b16207b92ce805d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84cfe29b003a12f55eb74407dd61bd3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GAMIndex.html#a84cfe29b003a12f55eb74407dd61bd3f">save</a> (ostream &amp;to) const </td></tr>
<tr class="memdesc:a84cfe29b003a12f55eb74407dd61bd3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a <a class="el" href="classvg_1_1GAMIndex.html">GAMIndex</a> to a file.  <a href="#a84cfe29b003a12f55eb74407dd61bd3f">More...</a><br/></td></tr>
<tr class="separator:a84cfe29b003a12f55eb74407dd61bd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f00884382854bd2549111aa3ce1f55c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GAMIndex.html#a7f00884382854bd2549111aa3ce1f55c">find</a> (<a class="el" href="classvg_1_1GAMIndex.html#a9c2661c669d27f7d13ccba9abd6ae445">cursor_t</a> &amp;cursor, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> node_id, const function&lt; void(const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; handle_result) const </td></tr>
<tr class="memdesc:a7f00884382854bd2549111aa3ce1f55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the given callback with all Alignments in the index that visit the given node.  <a href="#a7f00884382854bd2549111aa3ce1f55c">More...</a><br/></td></tr>
<tr class="separator:a7f00884382854bd2549111aa3ce1f55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e9e0b4471f26eca3e753b838664f3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GAMIndex.html#a20e9e0b4471f26eca3e753b838664f3e">find</a> (<a class="el" href="classvg_1_1GAMIndex.html#a9c2661c669d27f7d13ccba9abd6ae445">cursor_t</a> &amp;cursor, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> min_node, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> max_node, const function&lt; void(const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; handle_result) const </td></tr>
<tr class="memdesc:a20e9e0b4471f26eca3e753b838664f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the given callback with all Alignments in the index that visit a node in the given inclusive range.  <a href="#a20e9e0b4471f26eca3e753b838664f3e">More...</a><br/></td></tr>
<tr class="separator:a20e9e0b4471f26eca3e753b838664f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253a0d85c8e85fbf66420c9953159601"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GAMIndex.html#a253a0d85c8e85fbf66420c9953159601">find</a> (<a class="el" href="classvg_1_1GAMIndex.html#a9c2661c669d27f7d13ccba9abd6ae445">cursor_t</a> &amp;cursor, const vector&lt; pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt;&gt; &amp;ranges, const function&lt; void(const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; handle_result, bool only_fully_contained=false) const </td></tr>
<tr class="separator:a253a0d85c8e85fbf66420c9953159601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3465980d16c50e1123ae9a0b42ea70ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GAMIndex.html#a3465980d16c50e1123ae9a0b42ea70ca">index</a> (<a class="el" href="classvg_1_1GAMIndex.html#a9c2661c669d27f7d13ccba9abd6ae445">cursor_t</a> &amp;cursor)</td></tr>
<tr class="memdesc:a3465980d16c50e1123ae9a0b42ea70ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a cursor at the beginning of a sorted, readable file, index the file.  <a href="#a3465980d16c50e1123ae9a0b42ea70ca">More...</a><br/></td></tr>
<tr class="separator:a3465980d16c50e1123ae9a0b42ea70ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc09684ba6f63fa9188db5241cfdcbfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GAMIndex.html#afc09684ba6f63fa9188db5241cfdcbfa">add_group</a> (const vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;alns, int64_t virtual_start, int64_t virtual_past_end)</td></tr>
<tr class="separator:afc09684ba6f63fa9188db5241cfdcbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d211815186f7363660385cc7b9e9919"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; int64_t, int64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GAMIndex.html#a8d211815186f7363660385cc7b9e9919">find</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> node_id) const </td></tr>
<tr class="separator:a8d211815186f7363660385cc7b9e9919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be97db12851a3145cfc959b30587a3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GAMIndex.html#a9be97db12851a3145cfc959b30587a3b">find</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> node_id, const function&lt; bool(int64_t, int64_t)&gt; scan_callback) const </td></tr>
<tr class="separator:a9be97db12851a3145cfc959b30587a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf32df330fba5a57864a11e50002f244"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GAMIndex.html#adf32df330fba5a57864a11e50002f244">find</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> min_node, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> max_node, const function&lt; bool(int64_t, int64_t)&gt; scan_callback) const </td></tr>
<tr class="separator:adf32df330fba5a57864a11e50002f244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef48df601b1be068088906afc47b13a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GAMIndex.html#aef48df601b1be068088906afc47b13a3">add_group</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> min_id, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> max_id, int64_t virtual_start, int64_t virtual_past_end)</td></tr>
<tr class="separator:aef48df601b1be068088906afc47b13a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a15fcfc381f03c6bfe85c6aac53ead2c8"><td class="memItemLeft" align="right" valign="top">static vector&lt; <a class="el" href="classvg_1_1GAMIndex.html#afd1dab51516ca66bf3fa11ba48ab2fbc">bin_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GAMIndex.html#a15fcfc381f03c6bfe85c6aac53ead2c8">bins_of_id</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:a15fcfc381f03c6bfe85c6aac53ead2c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bins, from most to least specific, that a node ID occurs in.  <a href="#a15fcfc381f03c6bfe85c6aac53ead2c8">More...</a><br/></td></tr>
<tr class="separator:a15fcfc381f03c6bfe85c6aac53ead2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e96508f8a45c8d948b28d87118e3b62"><td class="memItemLeft" align="right" valign="top">static vector&lt; <a class="el" href="classvg_1_1GAMIndex.html#afd1dab51516ca66bf3fa11ba48ab2fbc">bin_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GAMIndex.html#a5e96508f8a45c8d948b28d87118e3b62">bins_of_range</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> min_id, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> max_id)</td></tr>
<tr class="separator:a5e96508f8a45c8d948b28d87118e3b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec4eec592cbb00fdae97db597fa832e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvg_1_1GAMIndex.html#afd1dab51516ca66bf3fa11ba48ab2fbc">bin_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GAMIndex.html#aeec4eec592cbb00fdae97db597fa832e">common_bin</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> a, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> b)</td></tr>
<tr class="memdesc:aeec4eec592cbb00fdae97db597fa832e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the most specific bin that contains both of the given node IDs.  <a href="#aeec4eec592cbb00fdae97db597fa832e">More...</a><br/></td></tr>
<tr class="separator:aeec4eec592cbb00fdae97db597fa832e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed252f0f8feba5f5789c654757de768"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvg_1_1GAMIndex.html#a0171d8b8b943eadb4e8ff6e44a6454fd">window_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GAMIndex.html#a7ed252f0f8feba5f5789c654757de768">window_of_id</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="separator:a7ed252f0f8feba5f5789c654757de768"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:af5c1bc1beedab8a017c0dad323b0842f"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GAMIndex.html#af5c1bc1beedab8a017c0dad323b0842f">MAX_INPUT_VERSION</a> = 1</td></tr>
<tr class="memdesc:af5c1bc1beedab8a017c0dad323b0842f"><td class="mdescLeft">&#160;</td><td class="mdescRight">What's the maximum GAM index version number we can read with this code?  <a href="#af5c1bc1beedab8a017c0dad323b0842f">More...</a><br/></td></tr>
<tr class="separator:af5c1bc1beedab8a017c0dad323b0842f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375c91cc5c973e0a7e687a00a0496687"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GAMIndex.html#a375c91cc5c973e0a7e687a00a0496687">OUTPUT_VERSION</a> = 1</td></tr>
<tr class="memdesc:a375c91cc5c973e0a7e687a00a0496687"><td class="mdescLeft">&#160;</td><td class="mdescRight">What's the version we serialize?  <a href="#a375c91cc5c973e0a7e687a00a0496687">More...</a><br/></td></tr>
<tr class="separator:a375c91cc5c973e0a7e687a00a0496687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c321371104034974907e38e6905424"><td class="memItemLeft" align="right" valign="top">static const string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GAMIndex.html#af0c321371104034974907e38e6905424">MAGIC_BYTES</a> = &quot;GAI!&quot;</td></tr>
<tr class="memdesc:af0c321371104034974907e38e6905424"><td class="mdescLeft">&#160;</td><td class="mdescRight">What magic value do we embed in the compressed gam index data?  <a href="#af0c321371104034974907e38e6905424">More...</a><br/></td></tr>
<tr class="separator:af0c321371104034974907e38e6905424"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a386753778938e9ec8c035f1d38ce775b"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="classvg_1_1GAMIndex.html#afd1dab51516ca66bf3fa11ba48ab2fbc">bin_t</a>, vector<br class="typebreak"/>
&lt; pair&lt; int64_t, int64_t &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GAMIndex.html#a386753778938e9ec8c035f1d38ce775b">bin_to_ranges</a></td></tr>
<tr class="separator:a386753778938e9ec8c035f1d38ce775b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c1d803a423723f93e459cb58a87192"><td class="memItemLeft" align="right" valign="top">map&lt; <a class="el" href="classvg_1_1GAMIndex.html#a0171d8b8b943eadb4e8ff6e44a6454fd">window_t</a>, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GAMIndex.html#a18c1d803a423723f93e459cb58a87192">window_to_start</a></td></tr>
<tr class="separator:a18c1d803a423723f93e459cb58a87192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb915dddfae7d8ef81afd16d814dfc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GAMIndex.html#abbb915dddfae7d8ef81afd16d814dfc8">last_group_min_id</a> = numeric_limits&lt;<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&gt;::min()</td></tr>
<tr class="separator:abbb915dddfae7d8ef81afd16d814dfc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a10f30b3fbddc8b1eeeeb765db2224fad"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GAMIndex.html#a10f30b3fbddc8b1eeeeb765db2224fad">WINDOW_SHIFT</a> = 8</td></tr>
<tr class="separator:a10f30b3fbddc8b1eeeeb765db2224fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An index for a node-ID-sorted GAM file. Reads are sorted by lowest visited node ID, then by highest visited node ID.</p>
<p>Works on a BAI-like concept of bins partitioning node ID space.</p>
<p>GAM files are serialized as count-prefixed groups of reads, which are the smallest unit that can be deserialized.</p>
<p>Every <em>group</em> of reads gets assigned to a bin which is the longest bin that completely contains the ID range used in the group.</p>
<p>We define <em>runs</em> of adjacent groups of reads which have the same bin, which are the basic subject of the index.</p>
<p>We then store an index from bin to the virtual offset ranges (start and past-the-end), in order, of runs that are assigned to the bin.</p>
<p>You will get non-contiguous virtual offset ranges for a node ID range when some reads run into the range from the left, then reads that start later don't, and then reads that start even later do again.</p>
<p>We also have a BAI-style linear index, mapping from tiling windows in node ID space to the lowest virtual offset of a group that overlaps the window.</p>
<p>The bin structure is that we partition all of node ID space into bins of power-of-2 size, starting with size 2 nodes. We number the bins such that 0 is the whole-ID-space bin, divided into 1 and 2, then into 3, 4, 5, and 6, and so on.</p>
<p>The tiling windows are just the node IDs down-shifted by a few bits.</p>
<p>Unmapped reads are considered to visit node ID 0. The maximum and minimum id_t values are used as sentinels, so they can't be real nodes.</p>
<p>All find operations are thread-safe with respect to each other. Simultaneous adds or finds and ads are prohibited. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="afd1dab51516ca66bf3fa11ba48ab2fbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvg_1_1GAMIndex.html#afd1dab51516ca66bf3fa11ba48ab2fbc">vg::GAMIndex::bin_t</a> =  make_unsigned&lt;<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9c2661c669d27f7d13ccba9abd6ae445"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvg_1_1GAMIndex.html#a9c2661c669d27f7d13ccba9abd6ae445">vg::GAMIndex::cursor_t</a> =  <a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">stream::ProtobufIterator</a>&lt;<a class="el" href="structvg_1_1Alignment.html">Alignment</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0171d8b8b943eadb4e8ff6e44a6454fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvg_1_1GAMIndex.html#a0171d8b8b943eadb4e8ff6e44a6454fd">vg::GAMIndex::window_t</a> =  make_unsigned&lt;<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aeed44b9a4906306d3a34fd2ad56cd361"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::GAMIndex::GAMIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="afc09684ba6f63fa9188db5241cfdcbfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::GAMIndex::add_group </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>alns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>virtual_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>virtual_past_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a group articulated as a vector of alignments, between the given virtual offsets. Must be called in virtual offset order for successive groups. </p>

</div>
</div>
<a class="anchor" id="aef48df601b1be068088906afc47b13a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::GAMIndex::add_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>min_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>max_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>virtual_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>virtual_past_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a group into the index, based on its minimum and maximum (inclusive) used node IDs. Must be called for all groups in virtual offset order. </p>

</div>
</div>
<a class="anchor" id="a15fcfc381f03c6bfe85c6aac53ead2c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::GAMIndex::bins_of_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the bins, from most to least specific, that a node ID occurs in. </p>

</div>
</div>
<a class="anchor" id="a5e96508f8a45c8d948b28d87118e3b62"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::GAMIndex::bins_of_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>min_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>max_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the bins, from most to least specific, that any of the node IDs in the given inclusive range occur in. There may be multiple bins at a given level of specificity; they will appear in numerical order. </p>

</div>
</div>
<a class="anchor" id="aeec4eec592cbb00fdae97db597fa832e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::GAMIndex::common_bin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the most specific bin that contains both of the given node IDs. </p>

</div>
</div>
<a class="anchor" id="a7f00884382854bd2549111aa3ce1f55c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::GAMIndex::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1GAMIndex.html#a9c2661c669d27f7d13ccba9abd6ae445">cursor_t</a> &amp;&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>handle_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call the given callback with all Alignments in the index that visit the given node. </p>

</div>
</div>
<a class="anchor" id="a20e9e0b4471f26eca3e753b838664f3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::GAMIndex::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1GAMIndex.html#a9c2661c669d27f7d13ccba9abd6ae445">cursor_t</a> &amp;&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>min_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>max_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>handle_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call the given callback with all Alignments in the index that visit a node in the given inclusive range. </p>

</div>
</div>
<a class="anchor" id="a253a0d85c8e85fbf66420c9953159601"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::GAMIndex::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1GAMIndex.html#a9c2661c669d27f7d13ccba9abd6ae445">cursor_t</a> &amp;&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>handle_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>only_fully_contained</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the given callback with all the Alignments in the index that visit a node in any of the given sorted, coalesced inclusive ranges. Emits each alignment at most once. If only_fully_contained is set, only Alignments where <em>all</em> the mappings are to nodes in one of the ranges will match. </p>

</div>
</div>
<a class="anchor" id="a8d211815186f7363660385cc7b9e9919"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::GAMIndex::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find all the ranges of run virtual offsets from the first position that might be relevant for the given node ID to the ends of all the bins it is in. Trims ranges by the linear index on the low end, and returns a series of potentially abutting but non-overlapping virtual offset ranges. Does not stop early (because it has no access to the actual reads to tell when it should stop looking at runs in a bin). So you will get ranges covering all runs in a bin that follow the runs you are interested in as well. </p>

</div>
</div>
<a class="anchor" id="a9be97db12851a3145cfc959b30587a3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::GAMIndex::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(int64_t, int64_t)&gt;&#160;</td>
          <td class="paramname"><em>scan_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find all the ranges of run virtual offsets to check for reads visiting the given node ID. Relies on a scanning callback, which will be called repeatedly with the start and past-the-end virtual offsets of runs which may contain groups touching the given node ID. When called, the callback should scan the run and return either true if it wants the next run, or false if it encountered a group with an out-of-range start and wants to stop iteration. Runs will be emitted in order, and truncated on the left to either the appropriate lower bound from the linear index, or the past-the-end of the previous run scanned. </p>

</div>
</div>
<a class="anchor" id="adf32df330fba5a57864a11e50002f244"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::GAMIndex::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>min_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>max_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(int64_t, int64_t)&gt;&#160;</td>
          <td class="paramname"><em>scan_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>the given inclusive node ID range. Relies on a scanning callback, which will be called repeatedly with the start and past-the-end virtual offsets of runs which may contain groups touching the given node ID. When called, the callback should scan the run and return either true if it wants the next run, or false if it encountered a group with an out-of-range start and wants to stop iteration. Runs will be emitted in order, and truncated on the left to either the appropriate lower bound from the linear index, or the past-the-end of the previous run scanned. </p>

</div>
</div>
<a class="anchor" id="a3465980d16c50e1123ae9a0b42ea70ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::GAMIndex::index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1GAMIndex.html#a9c2661c669d27f7d13ccba9abd6ae445">cursor_t</a> &amp;&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a cursor at the beginning of a sorted, readable file, index the file. </p>

</div>
</div>
<a class="anchor" id="aa3bf1352cc56a2c39b16207b92ce805d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::GAMIndex::load </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load a <a class="el" href="classvg_1_1GAMIndex.html">GAMIndex</a> from a file. File holds the index, not the GAM. </p>

</div>
</div>
<a class="anchor" id="a84cfe29b003a12f55eb74407dd61bd3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::GAMIndex::save </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>to</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a <a class="el" href="classvg_1_1GAMIndex.html">GAMIndex</a> to a file. </p>

</div>
</div>
<a class="anchor" id="a7ed252f0f8feba5f5789c654757de768"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::GAMIndex::window_of_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the linear index window that the given node ID falls in. The window range for a group is its min nodes' window through its max node's window. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a386753778938e9ec8c035f1d38ce775b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt;<a class="el" href="classvg_1_1GAMIndex.html#afd1dab51516ca66bf3fa11ba48ab2fbc">bin_t</a>, vector&lt;pair&lt;int64_t, int64_t&gt; &gt; &gt; vg::GAMIndex::bin_to_ranges</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps from bin number to all the ranges of virtual offsets, in order, for runs that land in the given bin. A run lands in a bin if that bin is the most specific bin that includes both its lowest and highest nodes it uses. </p>

</div>
</div>
<a class="anchor" id="abbb915dddfae7d8ef81afd16d814dfc8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> vg::GAMIndex::last_group_min_id = numeric_limits&lt;<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&gt;::min()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>What was the minimum node ID of the last group added? If this isn't strictly increasing, we're trying to idnex data that is not sorted. </p>

</div>
</div>
<a class="anchor" id="af0c321371104034974907e38e6905424"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const string vg::GAMIndex::MAGIC_BYTES = &quot;GAI!&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>What magic value do we embed in the compressed gam index data? </p>

</div>
</div>
<a class="anchor" id="af5c1bc1beedab8a017c0dad323b0842f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t vg::GAMIndex::MAX_INPUT_VERSION = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>What's the maximum GAM index version number we can read with this code? </p>

</div>
</div>
<a class="anchor" id="a375c91cc5c973e0a7e687a00a0496687"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t vg::GAMIndex::OUTPUT_VERSION = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>What's the version we serialize? </p>

</div>
</div>
<a class="anchor" id="a10f30b3fbddc8b1eeeeb765db2224fad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t vg::GAMIndex::WINDOW_SHIFT = 8</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a18c1d803a423723f93e459cb58a87192"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;<a class="el" href="classvg_1_1GAMIndex.html#a0171d8b8b943eadb4e8ff6e44a6454fd">window_t</a>, int64_t&gt; vg::GAMIndex::window_to_start</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps from linear index window to the virtual offset of the first group that overlaps that window (taking the group as a min-to-max node range). If you are looking for reads that visit a node, they can't possibly occur in a group before the first offset stored for the node's window (or any greater window). TODO: Should we make this a vector instead and hope nobody uses high/sparse node IDs? </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="gam__index_8hpp.html">gam_index.hpp</a></li>
<li>src/<a class="el" href="gam__index_8cpp.html">gam_index.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 4 2018 23:01:18 for vg by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
