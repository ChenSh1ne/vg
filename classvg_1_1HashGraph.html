<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>vg: vg::HashGraph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1HashGraph.html">HashGraph</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classvg_1_1HashGraph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::HashGraph Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;hash_graph.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vg::HashGraph:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvg_1_1HashGraph.png" usemap="#vg::HashGraph_map" alt=""/>
  <map id="vg::HashGraph_map" name="vg::HashGraph_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1HashGraph_1_1node__t.html">node_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1HashGraph_1_1path__mapping__t.html">path_mapping_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1HashGraph_1_1path__t.html">path_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5fb6c35e5ef4c8d4d816398fc5c8d4cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a5fb6c35e5ef4c8d4d816398fc5c8d4cb">HashGraph</a> ()</td></tr>
<tr class="separator:a5fb6c35e5ef4c8d4d816398fc5c8d4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5795c9e2e3f893e514e45268e3103c38"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a5795c9e2e3f893e514e45268e3103c38">~HashGraph</a> ()</td></tr>
<tr class="separator:a5795c9e2e3f893e514e45268e3103c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb348c5eeabcde13c11fdbb41cae1c0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#aefb348c5eeabcde13c11fdbb41cae1c0">has_node</a> (<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> node_id) const </td></tr>
<tr class="separator:aefb348c5eeabcde13c11fdbb41cae1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0737709e736c855691e4ce222408907"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#aa0737709e736c855691e4ce222408907">get_handle</a> (const <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &amp;node_id, bool is_reverse=false) const </td></tr>
<tr class="memdesc:aa0737709e736c855691e4ce222408907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the handle for the node with the given ID in the given orientation.  <a href="#aa0737709e736c855691e4ce222408907">More...</a><br/></td></tr>
<tr class="separator:aa0737709e736c855691e4ce222408907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56ffff3de1c2acc4ed8ef96dc511783"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#ae56ffff3de1c2acc4ed8ef96dc511783">get_id</a> (const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;handle) const </td></tr>
<tr class="memdesc:ae56ffff3de1c2acc4ed8ef96dc511783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID from a handle.  <a href="#ae56ffff3de1c2acc4ed8ef96dc511783">More...</a><br/></td></tr>
<tr class="separator:ae56ffff3de1c2acc4ed8ef96dc511783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e014a6b34caa378cdebaa0789a869d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a56e014a6b34caa378cdebaa0789a869d">get_is_reverse</a> (const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;handle) const </td></tr>
<tr class="memdesc:a56e014a6b34caa378cdebaa0789a869d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the orientation of a handle.  <a href="#a56e014a6b34caa378cdebaa0789a869d">More...</a><br/></td></tr>
<tr class="separator:a56e014a6b34caa378cdebaa0789a869d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab998348dca396d62a4bb1debc422900c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#ab998348dca396d62a4bb1debc422900c">flip</a> (const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;handle) const </td></tr>
<tr class="memdesc:ab998348dca396d62a4bb1debc422900c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the orientation of a handle (potentially without getting its ID)  <a href="#ab998348dca396d62a4bb1debc422900c">More...</a><br/></td></tr>
<tr class="separator:ab998348dca396d62a4bb1debc422900c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95c9518285d88309b2bac94e4604912"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#ad95c9518285d88309b2bac94e4604912">get_length</a> (const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;handle) const </td></tr>
<tr class="memdesc:ad95c9518285d88309b2bac94e4604912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of a node.  <a href="#ad95c9518285d88309b2bac94e4604912">More...</a><br/></td></tr>
<tr class="separator:ad95c9518285d88309b2bac94e4604912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a900a44996421bfe822854185cdb19"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a54a900a44996421bfe822854185cdb19">get_sequence</a> (const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;handle) const </td></tr>
<tr class="memdesc:a54a900a44996421bfe822854185cdb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sequence of a node, presented in the handle's local forward orientation.  <a href="#a54a900a44996421bfe822854185cdb19">More...</a><br/></td></tr>
<tr class="separator:a54a900a44996421bfe822854185cdb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f320beb22803044de9cc873d11b7b80"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a6f320beb22803044de9cc873d11b7b80">follow_edges_impl</a> (const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;handle, bool go_left, const std::function&lt; bool(const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;)&gt; &amp;iteratee) const </td></tr>
<tr class="separator:a6f320beb22803044de9cc873d11b7b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fddc415dfc8a4ae112630a464929ad"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#aa5fddc415dfc8a4ae112630a464929ad">for_each_handle_impl</a> (const std::function&lt; bool(const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;)&gt; &amp;iteratee, bool parallel=false) const </td></tr>
<tr class="separator:aa5fddc415dfc8a4ae112630a464929ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b6f2f2873d2d5876062131c334cfd0"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a43b6f2f2873d2d5876062131c334cfd0">node_size</a> (void) const </td></tr>
<tr class="separator:a43b6f2f2873d2d5876062131c334cfd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a3cd1543c185ad84e656dda708bf0a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a16a3cd1543c185ad84e656dda708bf0a">min_node_id</a> (void) const </td></tr>
<tr class="separator:a16a3cd1543c185ad84e656dda708bf0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1a36f27466b0c0183a7393954c834b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a8a1a36f27466b0c0183a7393954c834b">max_node_id</a> (void) const </td></tr>
<tr class="separator:a8a1a36f27466b0c0183a7393954c834b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88d997bfa31592e712c87c620ac248e"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#ae88d997bfa31592e712c87c620ac248e">get_degree</a> (const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;handle, bool go_left) const </td></tr>
<tr class="memdesc:ae88d997bfa31592e712c87c620ac248e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficiently get the number of edges attached to one side of a handle.  <a href="#ae88d997bfa31592e712c87c620ac248e">More...</a><br/></td></tr>
<tr class="separator:ae88d997bfa31592e712c87c620ac248e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88f9f307fa0b5a34c6cd96b5a0d1c84"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#ae88f9f307fa0b5a34c6cd96b5a0d1c84">create_handle</a> (const std::string &amp;sequence)</td></tr>
<tr class="memdesc:ae88f9f307fa0b5a34c6cd96b5a0d1c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new node with the given sequence and return the handle.  <a href="#ae88f9f307fa0b5a34c6cd96b5a0d1c84">More...</a><br/></td></tr>
<tr class="separator:ae88f9f307fa0b5a34c6cd96b5a0d1c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4c19ab536935bf833c6fbf8535eb5a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a4c4c19ab536935bf833c6fbf8535eb5a">create_handle</a> (const std::string &amp;sequence, const <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &amp;<a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:a4c4c19ab536935bf833c6fbf8535eb5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new node with the given id and sequence, then return the handle.  <a href="#a4c4c19ab536935bf833c6fbf8535eb5a">More...</a><br/></td></tr>
<tr class="separator:a4c4c19ab536935bf833c6fbf8535eb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa896670c64d504cc067607639e323c6e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#aa896670c64d504cc067607639e323c6e">destroy_handle</a> (const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;handle)</td></tr>
<tr class="separator:aa896670c64d504cc067607639e323c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4642ba1ee8a0acaec0f7e037f13a3726"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a4642ba1ee8a0acaec0f7e037f13a3726">create_edge</a> (const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;left, const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;right)</td></tr>
<tr class="separator:a4642ba1ee8a0acaec0f7e037f13a3726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9e990d9ac9bcd3247ad342f5597bf7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#aad9e990d9ac9bcd3247ad342f5597bf7">destroy_edge</a> (const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;left, const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;right)</td></tr>
<tr class="separator:aad9e990d9ac9bcd3247ad342f5597bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153a83cb6552f862993f1aba95308c24"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a153a83cb6552f862993f1aba95308c24">clear</a> (void)</td></tr>
<tr class="memdesc:a153a83cb6552f862993f1aba95308c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all nodes and edges. Does not update any stored paths.  <a href="#a153a83cb6552f862993f1aba95308c24">More...</a><br/></td></tr>
<tr class="separator:a153a83cb6552f862993f1aba95308c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2baff414f3e0c3d3a63260cd8b1f19ab"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a2baff414f3e0c3d3a63260cd8b1f19ab">swap_handles</a> (const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;a, const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;b)</td></tr>
<tr class="memdesc:a2baff414f3e0c3d3a63260cd8b1f19ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: swap_handles is actually not yet supported.  <a href="#a2baff414f3e0c3d3a63260cd8b1f19ab">More...</a><br/></td></tr>
<tr class="separator:a2baff414f3e0c3d3a63260cd8b1f19ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b741a08b4eebe011de20208b32232e0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a2b741a08b4eebe011de20208b32232e0">apply_orientation</a> (const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;handle)</td></tr>
<tr class="separator:a2b741a08b4eebe011de20208b32232e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e72a6e106dac2d90ab17334b981999"><td class="memItemLeft" align="right" valign="top">virtual vector&lt; <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#ab0e72a6e106dac2d90ab17334b981999">divide_handle</a> (const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;handle, const std::vector&lt; size_t &gt; &amp;offsets)</td></tr>
<tr class="separator:ab0e72a6e106dac2d90ab17334b981999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7253cd88de3db99a82c9c1a9e8d1d6c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#aa7253cd88de3db99a82c9c1a9e8d1d6c">has_path</a> (const std::string &amp;path_name) const </td></tr>
<tr class="memdesc:aa7253cd88de3db99a82c9c1a9e8d1d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a path name exists and is legal to get a path handle for.  <a href="#aa7253cd88de3db99a82c9c1a9e8d1d6c">More...</a><br/></td></tr>
<tr class="separator:aa7253cd88de3db99a82c9c1a9e8d1d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21e82973db50bd9bec89ff00a3b33a8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevg.html#aaf7aeec04909c1aac0ad991764d48e24">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#ae21e82973db50bd9bec89ff00a3b33a8">get_path_handle</a> (const std::string &amp;path_name) const </td></tr>
<tr class="separator:ae21e82973db50bd9bec89ff00a3b33a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addaa0475f3e7882f048f336e3df6be20"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#addaa0475f3e7882f048f336e3df6be20">get_path_name</a> (const <a class="el" href="namespacevg.html#aaf7aeec04909c1aac0ad991764d48e24">path_handle_t</a> &amp;path_handle) const </td></tr>
<tr class="memdesc:addaa0475f3e7882f048f336e3df6be20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the name of a path from a handle to it.  <a href="#addaa0475f3e7882f048f336e3df6be20">More...</a><br/></td></tr>
<tr class="separator:addaa0475f3e7882f048f336e3df6be20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8765ae3963b9256e23d3cda7272981"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a5a8765ae3963b9256e23d3cda7272981">get_occurrence_count</a> (const <a class="el" href="namespacevg.html#aaf7aeec04909c1aac0ad991764d48e24">path_handle_t</a> &amp;path_handle) const </td></tr>
<tr class="memdesc:a5a8765ae3963b9256e23d3cda7272981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of node occurrences in the path.  <a href="#a5a8765ae3963b9256e23d3cda7272981">More...</a><br/></td></tr>
<tr class="separator:a5a8765ae3963b9256e23d3cda7272981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9ba2a3aeb31ab5425273a3dbd723d8"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a8f9ba2a3aeb31ab5425273a3dbd723d8">get_path_count</a> () const </td></tr>
<tr class="memdesc:a8f9ba2a3aeb31ab5425273a3dbd723d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of paths stored in the graph.  <a href="#a8f9ba2a3aeb31ab5425273a3dbd723d8">More...</a><br/></td></tr>
<tr class="separator:a8f9ba2a3aeb31ab5425273a3dbd723d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9331b22252ba31cbca3511eddc3a5b0a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a9331b22252ba31cbca3511eddc3a5b0a">for_each_path_handle_impl</a> (const std::function&lt; bool(const <a class="el" href="namespacevg.html#aaf7aeec04909c1aac0ad991764d48e24">path_handle_t</a> &amp;)&gt; &amp;iteratee) const </td></tr>
<tr class="memdesc:a9331b22252ba31cbca3511eddc3a5b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a function on each path in the graph.  <a href="#a9331b22252ba31cbca3511eddc3a5b0a">More...</a><br/></td></tr>
<tr class="separator:a9331b22252ba31cbca3511eddc3a5b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa455500b64f22200ac94ff36ac424e5a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#aa455500b64f22200ac94ff36ac424e5a">get_occurrence</a> (const <a class="el" href="namespacevg.html#a3d6d387b606d4709a7e6abbb50b563eb">occurrence_handle_t</a> &amp;occurrence_handle) const </td></tr>
<tr class="memdesc:aa455500b64f22200ac94ff36ac424e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a node handle (node ID and orientation) from a handle to an occurrence on a path.  <a href="#aa455500b64f22200ac94ff36ac424e5a">More...</a><br/></td></tr>
<tr class="separator:aa455500b64f22200ac94ff36ac424e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0962304a83dfb9b67f885d7dbf6f39ff"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevg.html#a3d6d387b606d4709a7e6abbb50b563eb">occurrence_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a0962304a83dfb9b67f885d7dbf6f39ff">get_first_occurrence</a> (const <a class="el" href="namespacevg.html#aaf7aeec04909c1aac0ad991764d48e24">path_handle_t</a> &amp;path_handle) const </td></tr>
<tr class="separator:a0962304a83dfb9b67f885d7dbf6f39ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed32810ca7bc2fabba271806aca879a1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevg.html#a3d6d387b606d4709a7e6abbb50b563eb">occurrence_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#aed32810ca7bc2fabba271806aca879a1">get_last_occurrence</a> (const <a class="el" href="namespacevg.html#aaf7aeec04909c1aac0ad991764d48e24">path_handle_t</a> &amp;path_handle) const </td></tr>
<tr class="separator:aed32810ca7bc2fabba271806aca879a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4efd97a6a89e83942286452bddac67"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a8c4efd97a6a89e83942286452bddac67">has_next_occurrence</a> (const <a class="el" href="namespacevg.html#a3d6d387b606d4709a7e6abbb50b563eb">occurrence_handle_t</a> &amp;occurrence_handle) const </td></tr>
<tr class="memdesc:a8c4efd97a6a89e83942286452bddac67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the occurrence is not the last occurence on the path, else false.  <a href="#a8c4efd97a6a89e83942286452bddac67">More...</a><br/></td></tr>
<tr class="separator:a8c4efd97a6a89e83942286452bddac67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5754011f83cb1e65bebac89355503d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a5b5754011f83cb1e65bebac89355503d">has_previous_occurrence</a> (const <a class="el" href="namespacevg.html#a3d6d387b606d4709a7e6abbb50b563eb">occurrence_handle_t</a> &amp;occurrence_handle) const </td></tr>
<tr class="memdesc:a5b5754011f83cb1e65bebac89355503d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the occurrence is not the first occurence on the path, else false.  <a href="#a5b5754011f83cb1e65bebac89355503d">More...</a><br/></td></tr>
<tr class="separator:a5b5754011f83cb1e65bebac89355503d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72c0c61a134afc5529376802cf3f739"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevg.html#a3d6d387b606d4709a7e6abbb50b563eb">occurrence_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#ab72c0c61a134afc5529376802cf3f739">get_next_occurrence</a> (const <a class="el" href="namespacevg.html#a3d6d387b606d4709a7e6abbb50b563eb">occurrence_handle_t</a> &amp;occurrence_handle) const </td></tr>
<tr class="memdesc:ab72c0c61a134afc5529376802cf3f739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a handle to the next occurrence on the path.  <a href="#ab72c0c61a134afc5529376802cf3f739">More...</a><br/></td></tr>
<tr class="separator:ab72c0c61a134afc5529376802cf3f739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2dfa24d5692de9ba75d557d06176ffb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevg.html#a3d6d387b606d4709a7e6abbb50b563eb">occurrence_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#ad2dfa24d5692de9ba75d557d06176ffb">get_previous_occurrence</a> (const <a class="el" href="namespacevg.html#a3d6d387b606d4709a7e6abbb50b563eb">occurrence_handle_t</a> &amp;occurrence_handle) const </td></tr>
<tr class="memdesc:ad2dfa24d5692de9ba75d557d06176ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a handle to the previous occurrence on the path.  <a href="#ad2dfa24d5692de9ba75d557d06176ffb">More...</a><br/></td></tr>
<tr class="separator:ad2dfa24d5692de9ba75d557d06176ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe60075d700fca0abba5ef42ffe362e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevg.html#aaf7aeec04909c1aac0ad991764d48e24">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a8fe60075d700fca0abba5ef42ffe362e">get_path_handle_of_occurrence</a> (const <a class="el" href="namespacevg.html#a3d6d387b606d4709a7e6abbb50b563eb">occurrence_handle_t</a> &amp;occurrence_handle) const </td></tr>
<tr class="memdesc:a8fe60075d700fca0abba5ef42ffe362e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a handle to the path that an occurrence is on.  <a href="#a8fe60075d700fca0abba5ef42ffe362e">More...</a><br/></td></tr>
<tr class="separator:a8fe60075d700fca0abba5ef42ffe362e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139d9582a548643055f6eddfb14407d0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a139d9582a548643055f6eddfb14407d0">for_each_occurrence_on_handle_impl</a> (const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;handle, const function&lt; bool(const <a class="el" href="namespacevg.html#a3d6d387b606d4709a7e6abbb50b563eb">occurrence_handle_t</a> &amp;)&gt; &amp;iteratee) const </td></tr>
<tr class="memdesc:a139d9582a548643055f6eddfb14407d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a function with all occurrences of a node on paths.  <a href="#a139d9582a548643055f6eddfb14407d0">More...</a><br/></td></tr>
<tr class="separator:a139d9582a548643055f6eddfb14407d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf7cdad16ee57b77665981b3a94b7b8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a5bf7cdad16ee57b77665981b3a94b7b8">destroy_path</a> (const <a class="el" href="namespacevg.html#aaf7aeec04909c1aac0ad991764d48e24">path_handle_t</a> &amp;path)</td></tr>
<tr class="separator:a5bf7cdad16ee57b77665981b3a94b7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d3d60790d6da614822d24269940cb3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevg.html#aaf7aeec04909c1aac0ad991764d48e24">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#ad0d3d60790d6da614822d24269940cb3">create_path_handle</a> (const string &amp;name)</td></tr>
<tr class="separator:ad0d3d60790d6da614822d24269940cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378eebdbfd87aae0098e342ced05325b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevg.html#a3d6d387b606d4709a7e6abbb50b563eb">occurrence_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a378eebdbfd87aae0098e342ced05325b">append_occurrence</a> (const <a class="el" href="namespacevg.html#aaf7aeec04909c1aac0ad991764d48e24">path_handle_t</a> &amp;path, const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;to_append)</td></tr>
<tr class="separator:a378eebdbfd87aae0098e342ced05325b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a152a80d1b5c52b930a51fa937c1ba806"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a152a80d1b5c52b930a51fa937c1ba806">max_id</a> = 0</td></tr>
<tr class="memdesc:a152a80d1b5c52b930a51fa937c1ba806"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum ID in the graph.  <a href="#a152a80d1b5c52b930a51fa937c1ba806">More...</a><br/></td></tr>
<tr class="separator:a152a80d1b5c52b930a51fa937c1ba806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dba3ebdc7968db49c66cc0594ca1320"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a6dba3ebdc7968db49c66cc0594ca1320">min_id</a> = numeric_limits&lt;<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&gt;::max()</td></tr>
<tr class="memdesc:a6dba3ebdc7968db49c66cc0594ca1320"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum ID in the graph.  <a href="#a6dba3ebdc7968db49c66cc0594ca1320">More...</a><br/></td></tr>
<tr class="separator:a6dba3ebdc7968db49c66cc0594ca1320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7fa52134f840ea7c630892694a4a94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="structvg_1_1HashGraph_1_1node__t.html">node_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#acf7fa52134f840ea7c630892694a4a94">graph</a></td></tr>
<tr class="memdesc:acf7fa52134f840ea7c630892694a4a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the graph topology.  <a href="#acf7fa52134f840ea7c630892694a4a94">More...</a><br/></td></tr>
<tr class="separator:acf7fa52134f840ea7c630892694a4a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3d6ba66905470b785ea8c4f754b148"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1string__hash__map.html">string_hash_map</a>&lt; string, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a5c3d6ba66905470b785ea8c4f754b148">path_id</a></td></tr>
<tr class="memdesc:a5c3d6ba66905470b785ea8c4f754b148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps path names to path IDs.  <a href="#a5c3d6ba66905470b785ea8c4f754b148">More...</a><br/></td></tr>
<tr class="separator:a5c3d6ba66905470b785ea8c4f754b148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4311440e4ef60ffd00a8d8ef575b0aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; int64_t, <a class="el" href="structvg_1_1HashGraph_1_1path__t.html">path_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#ac4311440e4ef60ffd00a8d8ef575b0aa">paths</a></td></tr>
<tr class="memdesc:ac4311440e4ef60ffd00a8d8ef575b0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps path IDs to the actual paths.  <a href="#ac4311440e4ef60ffd00a8d8ef575b0aa">More...</a><br/></td></tr>
<tr class="separator:ac4311440e4ef60ffd00a8d8ef575b0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92287302405c3d227d95f348ffa6dd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, vector<br class="typebreak"/>
&lt; <a class="el" href="structvg_1_1HashGraph_1_1path__mapping__t.html">path_mapping_t</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#ab92287302405c3d227d95f348ffa6dd7">occurrences</a></td></tr>
<tr class="memdesc:ab92287302405c3d227d95f348ffa6dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps node IDs to their occurrences on paths.  <a href="#ab92287302405c3d227d95f348ffa6dd7">More...</a><br/></td></tr>
<tr class="separator:ab92287302405c3d227d95f348ffa6dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dcd8e88178aa4a9e3f6cef4a03493a7"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a1dcd8e88178aa4a9e3f6cef4a03493a7">next_path_id</a> = 1</td></tr>
<tr class="memdesc:a1dcd8e88178aa4a9e3f6cef4a03493a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The next path ID we will assign to a new path.  <a href="#a1dcd8e88178aa4a9e3f6cef4a03493a7">More...</a><br/></td></tr>
<tr class="separator:a1dcd8e88178aa4a9e3f6cef4a03493a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5fb6c35e5ef4c8d4d816398fc5c8d4cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::HashGraph::HashGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5795c9e2e3f893e514e45268e3103c38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::HashGraph::~HashGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a378eebdbfd87aae0098e342ced05325b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a3d6d387b606d4709a7e6abbb50b563eb">occurrence_handle_t</a> vg::HashGraph::append_occurrence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aaf7aeec04909c1aac0ad991764d48e24">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to_append</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Append a visit to a node to the given path. Returns a handle to the new final occurrence on the path which is appended. Handles to prior occurrences on the path, and to other paths, must remain valid. </p>

</div>
</div>
<a class="anchor" id="a2b741a08b4eebe011de20208b32232e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> vg::HashGraph::apply_orientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alter the node that the given handle corresponds to so the orientation indicated by the handle becomes the node's local forward orientation. Rewrites all edges pointing to the node and the node's sequence to reflect this. Invalidates all handles to the node (including the one passed). Returns a new, valid handle to the node in its new forward orientation. Note that it is possible for the node's ID to change. Does not update any stored paths. May change the ordering of the underlying graph. </p>

</div>
</div>
<a class="anchor" id="a153a83cb6552f862993f1aba95308c24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::HashGraph::clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all nodes and edges. Does not update any stored paths. </p>

</div>
</div>
<a class="anchor" id="a4642ba1ee8a0acaec0f7e037f13a3726"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::HashGraph::create_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an edge connecting the given handles in the given order and orientations. Ignores existing edges. </p>

</div>
</div>
<a class="anchor" id="ae88f9f307fa0b5a34c6cd96b5a0d1c84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> vg::HashGraph::create_handle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new node with the given sequence and return the handle. </p>

</div>
</div>
<a class="anchor" id="a4c4c19ab536935bf833c6fbf8535eb5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> vg::HashGraph::create_handle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new node with the given id and sequence, then return the handle. </p>

</div>
</div>
<a class="anchor" id="ad0d3d60790d6da614822d24269940cb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#aaf7aeec04909c1aac0ad991764d48e24">path_handle_t</a> vg::HashGraph::create_path_handle </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a path with the given name. The caller must ensure that no path with the given name exists already, or the behavior is undefined. Returns a handle to the created empty path. Handles to other paths must remain valid. </p>

</div>
</div>
<a class="anchor" id="aad9e990d9ac9bcd3247ad342f5597bf7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::HashGraph::destroy_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove the edge connecting the given handles in the given order and orientations. Ignores nonexistent edges. Does not update any stored paths. </p>

</div>
</div>
<a class="anchor" id="aa896670c64d504cc067607639e323c6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::HashGraph::destroy_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove the node belonging to the given handle and all of its edges. Does not update any stored paths. Invalidates the destroyed handle. May be called during serial for_each_handle iteration <b>ONLY</b> on the node being iterated. May <b>NOT</b> be called during parallel for_each_handle iteration. May <b>NOT</b> be called on the node from which edges are being followed during follow_edges. </p>

</div>
</div>
<a class="anchor" id="a5bf7cdad16ee57b77665981b3a94b7b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::HashGraph::destroy_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aaf7aeec04909c1aac0ad991764d48e24">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroy the given path. Invalidates handles to the path and its node occurrences. </p>

</div>
</div>
<a class="anchor" id="ab0e72a6e106dac2d90ab17334b981999"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &gt; vg::HashGraph::divide_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a handle's underlying node at the given offsets in the handle's orientation. Returns all of the handles to the parts. Other handles to the node being split may be invalidated. The split pieces stay in the same local forward orientation as the original node, but the returned handles come in the order and orientation appropriate for the handle passed in. Updates stored paths. </p>

</div>
</div>
<a class="anchor" id="ab998348dca396d62a4bb1debc422900c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> vg::HashGraph::flip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invert the orientation of a handle (potentially without getting its ID) </p>

</div>
</div>
<a class="anchor" id="a6f320beb22803044de9cc873d11b7b80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::HashGraph::follow_edges_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>go_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loop over all the handles to next/previous (right/left) nodes. Passes them to a callback which returns false to stop iterating and true to continue. Returns true if we finished and false if we stopped early. </p>

</div>
</div>
<a class="anchor" id="aa5fddc415dfc8a4ae112630a464929ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::HashGraph::for_each_handle_impl </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loop over all the nodes in the graph in their local forward orientations, in their internal stored order. Stop if the iteratee returns false. Can be told to run in parallel, in which case stopping after a false return value is on a best-effort basis and iteration order is not defined. </p>

</div>
</div>
<a class="anchor" id="a139d9582a548643055f6eddfb14407d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::HashGraph::for_each_occurrence_on_handle_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(const <a class="el" href="namespacevg.html#a3d6d387b606d4709a7e6abbb50b563eb">occurrence_handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a function with all occurrences of a node on paths. </p>

</div>
</div>
<a class="anchor" id="a9331b22252ba31cbca3511eddc3a5b0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::HashGraph::for_each_path_handle_impl </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="namespacevg.html#aaf7aeec04909c1aac0ad991764d48e24">path_handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a function on each path in the graph. </p>

</div>
</div>
<a class="anchor" id="ae88d997bfa31592e712c87c620ac248e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::HashGraph::get_degree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>go_left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Efficiently get the number of edges attached to one side of a handle. </p>

</div>
</div>
<a class="anchor" id="a0962304a83dfb9b67f885d7dbf6f39ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a3d6d387b606d4709a7e6abbb50b563eb">occurrence_handle_t</a> vg::HashGraph::get_first_occurrence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aaf7aeec04909c1aac0ad991764d48e24">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a handle to the first occurrence in a path. The path MUST be nonempty. </p>

</div>
</div>
<a class="anchor" id="aa0737709e736c855691e4ce222408907"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> vg::HashGraph::get_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up the handle for the node with the given ID in the given orientation. </p>

</div>
</div>
<a class="anchor" id="ae56ffff3de1c2acc4ed8ef96dc511783"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> vg::HashGraph::get_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ID from a handle. </p>

</div>
</div>
<a class="anchor" id="a56e014a6b34caa378cdebaa0789a869d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::HashGraph::get_is_reverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the orientation of a handle. </p>

</div>
</div>
<a class="anchor" id="aed32810ca7bc2fabba271806aca879a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a3d6d387b606d4709a7e6abbb50b563eb">occurrence_handle_t</a> vg::HashGraph::get_last_occurrence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aaf7aeec04909c1aac0ad991764d48e24">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a handle to the last occurrence in a path The path MUST be nonempty. </p>

</div>
</div>
<a class="anchor" id="ad95c9518285d88309b2bac94e4604912"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::HashGraph::get_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of a node. </p>

</div>
</div>
<a class="anchor" id="ab72c0c61a134afc5529376802cf3f739"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a3d6d387b606d4709a7e6abbb50b563eb">occurrence_handle_t</a> vg::HashGraph::get_next_occurrence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a3d6d387b606d4709a7e6abbb50b563eb">occurrence_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>occurrence_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a handle to the next occurrence on the path. </p>

</div>
</div>
<a class="anchor" id="aa455500b64f22200ac94ff36ac424e5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> vg::HashGraph::get_occurrence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a3d6d387b606d4709a7e6abbb50b563eb">occurrence_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>occurrence_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a node handle (node ID and orientation) from a handle to an occurrence on a path. </p>

</div>
</div>
<a class="anchor" id="a5a8765ae3963b9256e23d3cda7272981"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::HashGraph::get_occurrence_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aaf7aeec04909c1aac0ad991764d48e24">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of node occurrences in the path. </p>

</div>
</div>
<a class="anchor" id="a8f9ba2a3aeb31ab5425273a3dbd723d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::HashGraph::get_path_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of paths stored in the graph. </p>

</div>
</div>
<a class="anchor" id="ae21e82973db50bd9bec89ff00a3b33a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#aaf7aeec04909c1aac0ad991764d48e24">path_handle_t</a> vg::HashGraph::get_path_handle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Look up the path handle for the given path name. The path with that name must exist. </p>

</div>
</div>
<a class="anchor" id="a8fe60075d700fca0abba5ef42ffe362e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#aaf7aeec04909c1aac0ad991764d48e24">path_handle_t</a> vg::HashGraph::get_path_handle_of_occurrence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a3d6d387b606d4709a7e6abbb50b563eb">occurrence_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>occurrence_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a handle to the path that an occurrence is on. </p>

</div>
</div>
<a class="anchor" id="addaa0475f3e7882f048f336e3df6be20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::HashGraph::get_path_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aaf7aeec04909c1aac0ad991764d48e24">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up the name of a path from a handle to it. </p>

</div>
</div>
<a class="anchor" id="ad2dfa24d5692de9ba75d557d06176ffb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a3d6d387b606d4709a7e6abbb50b563eb">occurrence_handle_t</a> vg::HashGraph::get_previous_occurrence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a3d6d387b606d4709a7e6abbb50b563eb">occurrence_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>occurrence_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a handle to the previous occurrence on the path. </p>

</div>
</div>
<a class="anchor" id="a54a900a44996421bfe822854185cdb19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::HashGraph::get_sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the sequence of a node, presented in the handle's local forward orientation. </p>

</div>
</div>
<a class="anchor" id="a8c4efd97a6a89e83942286452bddac67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::HashGraph::has_next_occurrence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a3d6d387b606d4709a7e6abbb50b563eb">occurrence_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>occurrence_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the occurrence is not the last occurence on the path, else false. </p>

</div>
</div>
<a class="anchor" id="aefb348c5eeabcde13c11fdbb41cae1c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::HashGraph::has_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa7253cd88de3db99a82c9c1a9e8d1d6c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::HashGraph::has_path </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if a path name exists and is legal to get a path handle for. </p>

</div>
</div>
<a class="anchor" id="a5b5754011f83cb1e65bebac89355503d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::HashGraph::has_previous_occurrence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a3d6d387b606d4709a7e6abbb50b563eb">occurrence_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>occurrence_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the occurrence is not the first occurence on the path, else false. </p>

</div>
</div>
<a class="anchor" id="a8a1a36f27466b0c0183a7393954c834b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> vg::HashGraph::max_node_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the largest ID in the graph, or some larger number if the largest ID is unavailable. Return value is unspecified if the graph is empty. </p>

</div>
</div>
<a class="anchor" id="a16a3cd1543c185ad84e656dda708bf0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> vg::HashGraph::min_node_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the smallest ID in the graph, or some smaller number if the smallest ID is unavailable. Return value is unspecified if the graph is empty. </p>

</div>
</div>
<a class="anchor" id="a43b6f2f2873d2d5876062131c334cfd0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::HashGraph::node_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of nodes in the graph TODO: can't be node_count because XG has a field named node_count. </p>

</div>
</div>
<a class="anchor" id="a2baff414f3e0c3d3a63260cd8b1f19ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::HashGraph::swap_handles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO: swap_handles is actually not yet supported. </p>
<p>Swap the nodes corresponding to the given handles, in the ordering used by for_each_handle when looping over the graph. Other handles to the nodes being swapped must not be invalidated. If a swap is made while for_each_handle is running, it affects the order of the handles traversed during the current traversal (so swapping an already seen handle to a later handle's position will make the seen handle be visited again and the later handle not be visited at all). </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="acf7fa52134f840ea7c630892694a4a94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt;<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="structvg_1_1HashGraph_1_1node__t.html">node_t</a>&gt; vg::HashGraph::graph</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encodes the graph topology. </p>

</div>
</div>
<a class="anchor" id="a152a80d1b5c52b930a51fa937c1ba806"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> vg::HashGraph::max_id = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum ID in the graph. </p>

</div>
</div>
<a class="anchor" id="a6dba3ebdc7968db49c66cc0594ca1320"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> vg::HashGraph::min_id = numeric_limits&lt;<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&gt;::max()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The minimum ID in the graph. </p>

</div>
</div>
<a class="anchor" id="a1dcd8e88178aa4a9e3f6cef4a03493a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::HashGraph::next_path_id = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The next path ID we will assign to a new path. </p>

</div>
</div>
<a class="anchor" id="ab92287302405c3d227d95f348ffa6dd7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt;<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, vector&lt;<a class="el" href="structvg_1_1HashGraph_1_1path__mapping__t.html">path_mapping_t</a>*&gt; &gt; vg::HashGraph::occurrences</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps node IDs to their occurrences on paths. </p>

</div>
</div>
<a class="anchor" id="a5c3d6ba66905470b785ea8c4f754b148"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1string__hash__map.html">string_hash_map</a>&lt;string, int64_t&gt; vg::HashGraph::path_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps path names to path IDs. </p>

</div>
</div>
<a class="anchor" id="ac4311440e4ef60ffd00a8d8ef575b0aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt;int64_t, <a class="el" href="structvg_1_1HashGraph_1_1path__t.html">path_t</a>&gt; vg::HashGraph::paths</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps path IDs to the actual paths. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="hash__graph_8hpp.html">hash_graph.hpp</a></li>
<li>src/<a class="el" href="hash__graph_8cpp.html">hash_graph.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
