<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>vg: vg::HashGraph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1HashGraph.html">HashGraph</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classvg_1_1HashGraph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::HashGraph Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;hash_graph.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vg::HashGraph:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvg_1_1HashGraph.png" usemap="#vg::HashGraph_map" alt=""/>
  <map id="vg::HashGraph_map" name="vg::HashGraph_map">
<area href="classhandlegraph_1_1MutablePathDeletableHandleGraph.html" alt="handlegraph::MutablePathDeletableHandleGraph" shape="rect" coords="148,168,435,192"/>
<area href="classhandlegraph_1_1MutablePathHandleGraph.html" alt="handlegraph::MutablePathHandleGraph" shape="rect" coords="0,112,287,136"/>
<area href="classhandlegraph_1_1DeletableHandleGraph.html" alt="handlegraph::DeletableHandleGraph" shape="rect" coords="297,112,584,136"/>
<area href="classhandlegraph_1_1PathHandleGraph.html" alt="handlegraph::PathHandleGraph" shape="rect" coords="0,56,287,80"/>
<area href="classhandlegraph_1_1MutableHandleGraph.html" alt="handlegraph::MutableHandleGraph" shape="rect" coords="297,56,584,80"/>
<area href="classhandlegraph_1_1HandleGraph.html" alt="handlegraph::HandleGraph" shape="rect" coords="0,0,287,24"/>
<area href="classhandlegraph_1_1HandleGraph.html" alt="handlegraph::HandleGraph" shape="rect" coords="297,0,584,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1HashGraph_1_1node__t.html">node_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1HashGraph_1_1path__mapping__t.html">path_mapping_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph_1_1path__t.html">path_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5fb6c35e5ef4c8d4d816398fc5c8d4cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a5fb6c35e5ef4c8d4d816398fc5c8d4cb">HashGraph</a> ()</td></tr>
<tr class="separator:a5fb6c35e5ef4c8d4d816398fc5c8d4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5795c9e2e3f893e514e45268e3103c38"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a5795c9e2e3f893e514e45268e3103c38">~HashGraph</a> ()</td></tr>
<tr class="separator:a5795c9e2e3f893e514e45268e3103c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29999ce4218c1cea889fa5b57ca261ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a29999ce4218c1cea889fa5b57ca261ce">HashGraph</a> (istream &amp;in)</td></tr>
<tr class="memdesc:a29999ce4218c1cea889fa5b57ca261ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize from a stream of data.  <a href="#a29999ce4218c1cea889fa5b57ca261ce">More...</a><br/></td></tr>
<tr class="separator:a29999ce4218c1cea889fa5b57ca261ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb348c5eeabcde13c11fdbb41cae1c0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#aefb348c5eeabcde13c11fdbb41cae1c0">has_node</a> (<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> node_id) const </td></tr>
<tr class="memdesc:aefb348c5eeabcde13c11fdbb41cae1c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to check if a node exists by ID.  <a href="#aefb348c5eeabcde13c11fdbb41cae1c0">More...</a><br/></td></tr>
<tr class="separator:aefb348c5eeabcde13c11fdbb41cae1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0737709e736c855691e4ce222408907"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#aa0737709e736c855691e4ce222408907">get_handle</a> (const <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &amp;node_id, bool is_reverse=false) const </td></tr>
<tr class="memdesc:aa0737709e736c855691e4ce222408907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the handle for the node with the given ID in the given orientation.  <a href="#aa0737709e736c855691e4ce222408907">More...</a><br/></td></tr>
<tr class="separator:aa0737709e736c855691e4ce222408907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56ffff3de1c2acc4ed8ef96dc511783"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#ae56ffff3de1c2acc4ed8ef96dc511783">get_id</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const </td></tr>
<tr class="memdesc:ae56ffff3de1c2acc4ed8ef96dc511783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID from a handle.  <a href="#ae56ffff3de1c2acc4ed8ef96dc511783">More...</a><br/></td></tr>
<tr class="separator:ae56ffff3de1c2acc4ed8ef96dc511783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e014a6b34caa378cdebaa0789a869d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a56e014a6b34caa378cdebaa0789a869d">get_is_reverse</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const </td></tr>
<tr class="memdesc:a56e014a6b34caa378cdebaa0789a869d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the orientation of a handle.  <a href="#a56e014a6b34caa378cdebaa0789a869d">More...</a><br/></td></tr>
<tr class="separator:a56e014a6b34caa378cdebaa0789a869d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab998348dca396d62a4bb1debc422900c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#ab998348dca396d62a4bb1debc422900c">flip</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const </td></tr>
<tr class="memdesc:ab998348dca396d62a4bb1debc422900c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the orientation of a handle (potentially without getting its ID)  <a href="#ab998348dca396d62a4bb1debc422900c">More...</a><br/></td></tr>
<tr class="separator:ab998348dca396d62a4bb1debc422900c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95c9518285d88309b2bac94e4604912"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#ad95c9518285d88309b2bac94e4604912">get_length</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const </td></tr>
<tr class="memdesc:ad95c9518285d88309b2bac94e4604912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of a node.  <a href="#ad95c9518285d88309b2bac94e4604912">More...</a><br/></td></tr>
<tr class="separator:ad95c9518285d88309b2bac94e4604912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a900a44996421bfe822854185cdb19"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a54a900a44996421bfe822854185cdb19">get_sequence</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const </td></tr>
<tr class="memdesc:a54a900a44996421bfe822854185cdb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sequence of a node, presented in the handle's local forward orientation.  <a href="#a54a900a44996421bfe822854185cdb19">More...</a><br/></td></tr>
<tr class="separator:a54a900a44996421bfe822854185cdb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f320beb22803044de9cc873d11b7b80"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a6f320beb22803044de9cc873d11b7b80">follow_edges_impl</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;iteratee) const </td></tr>
<tr class="separator:a6f320beb22803044de9cc873d11b7b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fddc415dfc8a4ae112630a464929ad"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#aa5fddc415dfc8a4ae112630a464929ad">for_each_handle_impl</a> (const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;iteratee, bool parallel=false) const </td></tr>
<tr class="separator:aa5fddc415dfc8a4ae112630a464929ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b6f2f2873d2d5876062131c334cfd0"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a43b6f2f2873d2d5876062131c334cfd0">node_size</a> (void) const </td></tr>
<tr class="separator:a43b6f2f2873d2d5876062131c334cfd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a3cd1543c185ad84e656dda708bf0a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a16a3cd1543c185ad84e656dda708bf0a">min_node_id</a> (void) const </td></tr>
<tr class="separator:a16a3cd1543c185ad84e656dda708bf0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1a36f27466b0c0183a7393954c834b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a8a1a36f27466b0c0183a7393954c834b">max_node_id</a> (void) const </td></tr>
<tr class="separator:a8a1a36f27466b0c0183a7393954c834b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88d997bfa31592e712c87c620ac248e"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#ae88d997bfa31592e712c87c620ac248e">get_degree</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left) const </td></tr>
<tr class="memdesc:ae88d997bfa31592e712c87c620ac248e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficiently get the number of edges attached to one side of a handle.  <a href="#ae88d997bfa31592e712c87c620ac248e">More...</a><br/></td></tr>
<tr class="separator:ae88d997bfa31592e712c87c620ac248e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88f9f307fa0b5a34c6cd96b5a0d1c84"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#ae88f9f307fa0b5a34c6cd96b5a0d1c84">create_handle</a> (const std::string &amp;sequence)</td></tr>
<tr class="memdesc:ae88f9f307fa0b5a34c6cd96b5a0d1c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new node with the given sequence and return the handle.  <a href="#ae88f9f307fa0b5a34c6cd96b5a0d1c84">More...</a><br/></td></tr>
<tr class="separator:ae88f9f307fa0b5a34c6cd96b5a0d1c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4c19ab536935bf833c6fbf8535eb5a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a4c4c19ab536935bf833c6fbf8535eb5a">create_handle</a> (const std::string &amp;sequence, const <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &amp;<a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:a4c4c19ab536935bf833c6fbf8535eb5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new node with the given id and sequence, then return the handle.  <a href="#a4c4c19ab536935bf833c6fbf8535eb5a">More...</a><br/></td></tr>
<tr class="separator:a4c4c19ab536935bf833c6fbf8535eb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa896670c64d504cc067607639e323c6e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#aa896670c64d504cc067607639e323c6e">destroy_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle)</td></tr>
<tr class="separator:aa896670c64d504cc067607639e323c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4642ba1ee8a0acaec0f7e037f13a3726"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a4642ba1ee8a0acaec0f7e037f13a3726">create_edge</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right)</td></tr>
<tr class="separator:a4642ba1ee8a0acaec0f7e037f13a3726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9e990d9ac9bcd3247ad342f5597bf7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#aad9e990d9ac9bcd3247ad342f5597bf7">destroy_edge</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right)</td></tr>
<tr class="separator:aad9e990d9ac9bcd3247ad342f5597bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153a83cb6552f862993f1aba95308c24"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a153a83cb6552f862993f1aba95308c24">clear</a> (void)</td></tr>
<tr class="memdesc:a153a83cb6552f862993f1aba95308c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all nodes and edges. Does not update any stored paths.  <a href="#a153a83cb6552f862993f1aba95308c24">More...</a><br/></td></tr>
<tr class="separator:a153a83cb6552f862993f1aba95308c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2baff414f3e0c3d3a63260cd8b1f19ab"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a2baff414f3e0c3d3a63260cd8b1f19ab">swap_handles</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;a, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;b)</td></tr>
<tr class="memdesc:a2baff414f3e0c3d3a63260cd8b1f19ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: swap_handles is actually not yet supported.  <a href="#a2baff414f3e0c3d3a63260cd8b1f19ab">More...</a><br/></td></tr>
<tr class="separator:a2baff414f3e0c3d3a63260cd8b1f19ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b741a08b4eebe011de20208b32232e0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a2b741a08b4eebe011de20208b32232e0">apply_orientation</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle)</td></tr>
<tr class="separator:a2b741a08b4eebe011de20208b32232e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e72a6e106dac2d90ab17334b981999"><td class="memItemLeft" align="right" valign="top">virtual vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#ab0e72a6e106dac2d90ab17334b981999">divide_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const std::vector&lt; size_t &gt; &amp;offsets)</td></tr>
<tr class="separator:ab0e72a6e106dac2d90ab17334b981999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7253cd88de3db99a82c9c1a9e8d1d6c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#aa7253cd88de3db99a82c9c1a9e8d1d6c">has_path</a> (const std::string &amp;path_name) const </td></tr>
<tr class="memdesc:aa7253cd88de3db99a82c9c1a9e8d1d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a path name exists and is legal to get a path handle for.  <a href="#aa7253cd88de3db99a82c9c1a9e8d1d6c">More...</a><br/></td></tr>
<tr class="separator:aa7253cd88de3db99a82c9c1a9e8d1d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21e82973db50bd9bec89ff00a3b33a8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#ae21e82973db50bd9bec89ff00a3b33a8">get_path_handle</a> (const std::string &amp;path_name) const </td></tr>
<tr class="separator:ae21e82973db50bd9bec89ff00a3b33a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addaa0475f3e7882f048f336e3df6be20"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#addaa0475f3e7882f048f336e3df6be20">get_path_name</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const </td></tr>
<tr class="memdesc:addaa0475f3e7882f048f336e3df6be20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the name of a path from a handle to it.  <a href="#addaa0475f3e7882f048f336e3df6be20">More...</a><br/></td></tr>
<tr class="separator:addaa0475f3e7882f048f336e3df6be20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8765ae3963b9256e23d3cda7272981"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a5a8765ae3963b9256e23d3cda7272981">get_occurrence_count</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const </td></tr>
<tr class="memdesc:a5a8765ae3963b9256e23d3cda7272981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of node occurrences in the path.  <a href="#a5a8765ae3963b9256e23d3cda7272981">More...</a><br/></td></tr>
<tr class="separator:a5a8765ae3963b9256e23d3cda7272981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9ba2a3aeb31ab5425273a3dbd723d8"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a8f9ba2a3aeb31ab5425273a3dbd723d8">get_path_count</a> () const </td></tr>
<tr class="memdesc:a8f9ba2a3aeb31ab5425273a3dbd723d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of paths stored in the graph.  <a href="#a8f9ba2a3aeb31ab5425273a3dbd723d8">More...</a><br/></td></tr>
<tr class="separator:a8f9ba2a3aeb31ab5425273a3dbd723d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9331b22252ba31cbca3511eddc3a5b0a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a9331b22252ba31cbca3511eddc3a5b0a">for_each_path_handle_impl</a> (const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; &amp;iteratee) const </td></tr>
<tr class="memdesc:a9331b22252ba31cbca3511eddc3a5b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a function on each path in the graph.  <a href="#a9331b22252ba31cbca3511eddc3a5b0a">More...</a><br/></td></tr>
<tr class="separator:a9331b22252ba31cbca3511eddc3a5b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa455500b64f22200ac94ff36ac424e5a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#aa455500b64f22200ac94ff36ac424e5a">get_occurrence</a> (const <a class="el" href="structhandlegraph_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;occurrence_handle) const </td></tr>
<tr class="memdesc:aa455500b64f22200ac94ff36ac424e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a node handle (node ID and orientation) from a handle to an occurrence on a path.  <a href="#aa455500b64f22200ac94ff36ac424e5a">More...</a><br/></td></tr>
<tr class="separator:aa455500b64f22200ac94ff36ac424e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0962304a83dfb9b67f885d7dbf6f39ff"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1occurrence__handle__t.html">occurrence_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a0962304a83dfb9b67f885d7dbf6f39ff">get_first_occurrence</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const </td></tr>
<tr class="separator:a0962304a83dfb9b67f885d7dbf6f39ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed32810ca7bc2fabba271806aca879a1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1occurrence__handle__t.html">occurrence_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#aed32810ca7bc2fabba271806aca879a1">get_last_occurrence</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const </td></tr>
<tr class="separator:aed32810ca7bc2fabba271806aca879a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4efd97a6a89e83942286452bddac67"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a8c4efd97a6a89e83942286452bddac67">has_next_occurrence</a> (const <a class="el" href="structhandlegraph_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;occurrence_handle) const </td></tr>
<tr class="memdesc:a8c4efd97a6a89e83942286452bddac67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the occurrence is not the last occurence on the path, else false.  <a href="#a8c4efd97a6a89e83942286452bddac67">More...</a><br/></td></tr>
<tr class="separator:a8c4efd97a6a89e83942286452bddac67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5754011f83cb1e65bebac89355503d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a5b5754011f83cb1e65bebac89355503d">has_previous_occurrence</a> (const <a class="el" href="structhandlegraph_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;occurrence_handle) const </td></tr>
<tr class="memdesc:a5b5754011f83cb1e65bebac89355503d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the occurrence is not the first occurence on the path, else false.  <a href="#a5b5754011f83cb1e65bebac89355503d">More...</a><br/></td></tr>
<tr class="separator:a5b5754011f83cb1e65bebac89355503d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72c0c61a134afc5529376802cf3f739"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1occurrence__handle__t.html">occurrence_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#ab72c0c61a134afc5529376802cf3f739">get_next_occurrence</a> (const <a class="el" href="structhandlegraph_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;occurrence_handle) const </td></tr>
<tr class="memdesc:ab72c0c61a134afc5529376802cf3f739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a handle to the next occurrence on the path.  <a href="#ab72c0c61a134afc5529376802cf3f739">More...</a><br/></td></tr>
<tr class="separator:ab72c0c61a134afc5529376802cf3f739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2dfa24d5692de9ba75d557d06176ffb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1occurrence__handle__t.html">occurrence_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#ad2dfa24d5692de9ba75d557d06176ffb">get_previous_occurrence</a> (const <a class="el" href="structhandlegraph_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;occurrence_handle) const </td></tr>
<tr class="memdesc:ad2dfa24d5692de9ba75d557d06176ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a handle to the previous occurrence on the path.  <a href="#ad2dfa24d5692de9ba75d557d06176ffb">More...</a><br/></td></tr>
<tr class="separator:ad2dfa24d5692de9ba75d557d06176ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe60075d700fca0abba5ef42ffe362e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a8fe60075d700fca0abba5ef42ffe362e">get_path_handle_of_occurrence</a> (const <a class="el" href="structhandlegraph_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;occurrence_handle) const </td></tr>
<tr class="memdesc:a8fe60075d700fca0abba5ef42ffe362e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a handle to the path that an occurrence is on.  <a href="#a8fe60075d700fca0abba5ef42ffe362e">More...</a><br/></td></tr>
<tr class="separator:a8fe60075d700fca0abba5ef42ffe362e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139d9582a548643055f6eddfb14407d0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a139d9582a548643055f6eddfb14407d0">for_each_occurrence_on_handle_impl</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const function&lt; bool(const <a class="el" href="structhandlegraph_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;)&gt; &amp;iteratee) const </td></tr>
<tr class="memdesc:a139d9582a548643055f6eddfb14407d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a function with all occurrences of a node on paths.  <a href="#a139d9582a548643055f6eddfb14407d0">More...</a><br/></td></tr>
<tr class="separator:a139d9582a548643055f6eddfb14407d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf7cdad16ee57b77665981b3a94b7b8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a5bf7cdad16ee57b77665981b3a94b7b8">destroy_path</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path)</td></tr>
<tr class="separator:a5bf7cdad16ee57b77665981b3a94b7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d3d60790d6da614822d24269940cb3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#ad0d3d60790d6da614822d24269940cb3">create_path_handle</a> (const string &amp;name)</td></tr>
<tr class="separator:ad0d3d60790d6da614822d24269940cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378eebdbfd87aae0098e342ced05325b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1occurrence__handle__t.html">occurrence_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a378eebdbfd87aae0098e342ced05325b">append_occurrence</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;to_append)</td></tr>
<tr class="separator:a378eebdbfd87aae0098e342ced05325b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadea5fc540908b3061b10d39e0fc4180"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#aadea5fc540908b3061b10d39e0fc4180">serialize</a> (ostream &amp;out) const </td></tr>
<tr class="separator:aadea5fc540908b3061b10d39e0fc4180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee9a975a807aaf69e7a412bc5b61dae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a7ee9a975a807aaf69e7a412bc5b61dae">deserialize</a> (istream &amp;in)</td></tr>
<tr class="separator:a7ee9a975a807aaf69e7a412bc5b61dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1MutablePathHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html">handlegraph::MutablePathHandleGraph</a></td></tr>
<tr class="memitem:a2fc36c06e32b7cb5339f046a0c5a45d7 inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#a2fc36c06e32b7cb5339f046a0c5a45d7">create_path_handle</a> (const std::string &amp;name)=0</td></tr>
<tr class="separator:a2fc36c06e32b7cb5339f046a0c5a45d7 inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1PathHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1PathHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">handlegraph::PathHandleGraph</a></td></tr>
<tr class="memitem:a3313c420e4cf77baf157af2732848850 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a3313c420e4cf77baf157af2732848850 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a3313c420e4cf77baf157af2732848850">for_each_path_handle</a> (const Iteratee &amp;iteratee) const </td></tr>
<tr class="separator:a3313c420e4cf77baf157af2732848850 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008069cd57d3d74b5c362fa178ec37f4 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a008069cd57d3d74b5c362fa178ec37f4 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a008069cd57d3d74b5c362fa178ec37f4">for_each_occurrence_on_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const Iteratee &amp;iteratee) const </td></tr>
<tr class="separator:a008069cd57d3d74b5c362fa178ec37f4 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632498485896564a0f91c07eb18488cb inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual std::vector<br class="typebreak"/>
&lt; <a class="el" href="structhandlegraph_1_1occurrence__handle__t.html">occurrence_handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a632498485896564a0f91c07eb18488cb">occurrences_of_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool match_orientation=false) const </td></tr>
<tr class="separator:a632498485896564a0f91c07eb18488cb inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed6b61e10e5ad54812cf8bac2d56e9f inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a0ed6b61e10e5ad54812cf8bac2d56e9f">is_empty</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const </td></tr>
<tr class="memdesc:a0ed6b61e10e5ad54812cf8bac2d56e9f inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given path is empty, and false otherwise.  <a href="#a0ed6b61e10e5ad54812cf8bac2d56e9f">More...</a><br/></td></tr>
<tr class="separator:a0ed6b61e10e5ad54812cf8bac2d56e9f inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af053bc1c7a356ea975cce61ab428db76 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:af053bc1c7a356ea975cce61ab428db76 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#af053bc1c7a356ea975cce61ab428db76">for_each_occurrence_in_path</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path, const Iteratee &amp;iteratee) const </td></tr>
<tr class="separator:af053bc1c7a356ea975cce61ab428db76 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1HandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1HandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1HandleGraph.html">handlegraph::HandleGraph</a></td></tr>
<tr class="memitem:a5dcea1610fac82460ff304e07b4dd6e0 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a5dcea1610fac82460ff304e07b4dd6e0 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a5dcea1610fac82460ff304e07b4dd6e0">follow_edges</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left, const Iteratee &amp;iteratee) const </td></tr>
<tr class="separator:a5dcea1610fac82460ff304e07b4dd6e0 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19cbfb7cccb8b05d3952b0c7a0e60c1c inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a19cbfb7cccb8b05d3952b0c7a0e60c1c inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a19cbfb7cccb8b05d3952b0c7a0e60c1c">for_each_handle</a> (const Iteratee &amp;iteratee, bool parallel=false) const </td></tr>
<tr class="separator:a19cbfb7cccb8b05d3952b0c7a0e60c1c inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda410641b362f9530c62dd503a7abec inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#adda410641b362f9530c62dd503a7abec">has_edge</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right) const </td></tr>
<tr class="separator:adda410641b362f9530c62dd503a7abec inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6828fde4d2a0063efef7e421a4118c inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a6f6828fde4d2a0063efef7e421a4118c">has_edge</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge)</td></tr>
<tr class="memdesc:a6f6828fde4d2a0063efef7e421a4118c inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient wrapper of has_edge for edge_t argument.  <a href="#a6f6828fde4d2a0063efef7e421a4118c">More...</a><br/></td></tr>
<tr class="separator:a6f6828fde4d2a0063efef7e421a4118c inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996223319f59bf614a02a78a3038bd89 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a996223319f59bf614a02a78a3038bd89">forward</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const </td></tr>
<tr class="memdesc:a996223319f59bf614a02a78a3038bd89 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the locally forward version of a handle.  <a href="#a996223319f59bf614a02a78a3038bd89">More...</a><br/></td></tr>
<tr class="separator:a996223319f59bf614a02a78a3038bd89 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e807b8d982fe8d55166c1685a1d4918 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a3e807b8d982fe8d55166c1685a1d4918">edge_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right) const </td></tr>
<tr class="separator:a3e807b8d982fe8d55166c1685a1d4918 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b2c0307f4fafb0acd3a0c02fe578b9 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#ad4b2c0307f4fafb0acd3a0c02fe578b9">traverse_edge_handle</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left) const </td></tr>
<tr class="separator:ad4b2c0307f4fafb0acd3a0c02fe578b9 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a10d13e6e403d64221c0b2f3566b78f inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a6a10d13e6e403d64221c0b2f3566b78f inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a6a10d13e6e403d64221c0b2f3566b78f">for_each_edge</a> (const Iteratee &amp;iteratee, bool parallel=false) const </td></tr>
<tr class="separator:a6a10d13e6e403d64221c0b2f3566b78f inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1DeletableHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">handlegraph::DeletableHandleGraph</a></td></tr>
<tr class="memitem:aec2b397c1b4ec7f9c75ccc5b9ce06564 inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#aec2b397c1b4ec7f9c75ccc5b9ce06564">destroy_edge</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge)</td></tr>
<tr class="memdesc:aec2b397c1b4ec7f9c75ccc5b9ce06564 inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient wrapper for destroy_edge.  <a href="#aec2b397c1b4ec7f9c75ccc5b9ce06564">More...</a><br/></td></tr>
<tr class="separator:aec2b397c1b4ec7f9c75ccc5b9ce06564 inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1MutableHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1MutableHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">handlegraph::MutableHandleGraph</a></td></tr>
<tr class="memitem:a3ff0a0f9497da3498170fdfc2ce97797 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a3ff0a0f9497da3498170fdfc2ce97797">create_edge</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge)</td></tr>
<tr class="memdesc:a3ff0a0f9497da3498170fdfc2ce97797 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient wrapper for create_edge.  <a href="#a3ff0a0f9497da3498170fdfc2ce97797">More...</a><br/></td></tr>
<tr class="separator:a3ff0a0f9497da3498170fdfc2ce97797 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c38787f0ff4a2695e61d98cb402175 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a05c38787f0ff4a2695e61d98cb402175">divide_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, size_t offset)</td></tr>
<tr class="memdesc:a05c38787f0ff4a2695e61d98cb402175 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of divide_handle for a single division point.  <a href="#a05c38787f0ff4a2695e61d98cb402175">More...</a><br/></td></tr>
<tr class="separator:a05c38787f0ff4a2695e61d98cb402175 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a152a80d1b5c52b930a51fa937c1ba806"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a152a80d1b5c52b930a51fa937c1ba806">max_id</a> = 0</td></tr>
<tr class="memdesc:a152a80d1b5c52b930a51fa937c1ba806"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum ID in the graph.  <a href="#a152a80d1b5c52b930a51fa937c1ba806">More...</a><br/></td></tr>
<tr class="separator:a152a80d1b5c52b930a51fa937c1ba806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dba3ebdc7968db49c66cc0594ca1320"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a6dba3ebdc7968db49c66cc0594ca1320">min_id</a> = numeric_limits&lt;<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&gt;::max()</td></tr>
<tr class="memdesc:a6dba3ebdc7968db49c66cc0594ca1320"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum ID in the graph.  <a href="#a6dba3ebdc7968db49c66cc0594ca1320">More...</a><br/></td></tr>
<tr class="separator:a6dba3ebdc7968db49c66cc0594ca1320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7fa52134f840ea7c630892694a4a94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="structvg_1_1HashGraph_1_1node__t.html">node_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#acf7fa52134f840ea7c630892694a4a94">graph</a></td></tr>
<tr class="memdesc:acf7fa52134f840ea7c630892694a4a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the graph topology.  <a href="#acf7fa52134f840ea7c630892694a4a94">More...</a><br/></td></tr>
<tr class="separator:acf7fa52134f840ea7c630892694a4a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3d6ba66905470b785ea8c4f754b148"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1string__hash__map.html">string_hash_map</a>&lt; string, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a5c3d6ba66905470b785ea8c4f754b148">path_id</a></td></tr>
<tr class="memdesc:a5c3d6ba66905470b785ea8c4f754b148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps path names to path IDs.  <a href="#a5c3d6ba66905470b785ea8c4f754b148">More...</a><br/></td></tr>
<tr class="separator:a5c3d6ba66905470b785ea8c4f754b148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4311440e4ef60ffd00a8d8ef575b0aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; int64_t, <a class="el" href="classvg_1_1HashGraph_1_1path__t.html">path_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#ac4311440e4ef60ffd00a8d8ef575b0aa">paths</a></td></tr>
<tr class="memdesc:ac4311440e4ef60ffd00a8d8ef575b0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps path IDs to the actual paths.  <a href="#ac4311440e4ef60ffd00a8d8ef575b0aa">More...</a><br/></td></tr>
<tr class="separator:ac4311440e4ef60ffd00a8d8ef575b0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92287302405c3d227d95f348ffa6dd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, vector<br class="typebreak"/>
&lt; <a class="el" href="structvg_1_1HashGraph_1_1path__mapping__t.html">path_mapping_t</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#ab92287302405c3d227d95f348ffa6dd7">occurrences</a></td></tr>
<tr class="memdesc:ab92287302405c3d227d95f348ffa6dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps node IDs to their occurrences on paths.  <a href="#ab92287302405c3d227d95f348ffa6dd7">More...</a><br/></td></tr>
<tr class="separator:ab92287302405c3d227d95f348ffa6dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dcd8e88178aa4a9e3f6cef4a03493a7"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HashGraph.html#a1dcd8e88178aa4a9e3f6cef4a03493a7">next_path_id</a> = 1</td></tr>
<tr class="memdesc:a1dcd8e88178aa4a9e3f6cef4a03493a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The next path ID we will assign to a new path.  <a href="#a1dcd8e88178aa4a9e3f6cef4a03493a7">More...</a><br/></td></tr>
<tr class="separator:a1dcd8e88178aa4a9e3f6cef4a03493a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classhandlegraph_1_1PathHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classhandlegraph_1_1PathHandleGraph')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">handlegraph::PathHandleGraph</a></td></tr>
<tr class="memitem:a3fb688cab856c3833fe4b859225fd2bc inherit pro_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a3fb688cab856c3833fe4b859225fd2bc">for_each_occurrence_on_handle_impl</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;)&gt; &amp;iteratee) const =0</td></tr>
<tr class="separator:a3fb688cab856c3833fe4b859225fd2bc inherit pro_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5fb6c35e5ef4c8d4d816398fc5c8d4cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::HashGraph::HashGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5795c9e2e3f893e514e45268e3103c38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::HashGraph::~HashGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a29999ce4218c1cea889fa5b57ca261ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::HashGraph::HashGraph </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserialize from a stream of data. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a378eebdbfd87aae0098e342ced05325b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1occurrence__handle__t.html">occurrence_handle_t</a> vg::HashGraph::append_occurrence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to_append</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Append a visit to a node to the given path. Returns a handle to the new final occurrence on the path which is appended. Handles to prior occurrences on the path, and to other paths, must remain valid. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#a228ea12b8fcd948128b38faef2601021">handlegraph::MutablePathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a2b741a08b4eebe011de20208b32232e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::HashGraph::apply_orientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alter the node that the given handle corresponds to so the orientation indicated by the handle becomes the node's local forward orientation. Rewrites all edges pointing to the node and the node's sequence to reflect this. Invalidates all handles to the node (including the one passed). Returns a new, valid handle to the node in its new forward orientation. Note that it is possible for the node's ID to change. Does not update any stored paths. May change the ordering of the underlying graph. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a71433449cb13e22dc19caaf544b6d7bc">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a153a83cb6552f862993f1aba95308c24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::HashGraph::clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all nodes and edges. Does not update any stored paths. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#a6e1a83e72b47643e43c6176f39d8db5e">handlegraph::DeletableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a4642ba1ee8a0acaec0f7e037f13a3726"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::HashGraph::create_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an edge connecting the given handles in the given order and orientations. Ignores existing edges. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a34a5e01f270713ba856a93c55039faf0">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="ae88f9f307fa0b5a34c6cd96b5a0d1c84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::HashGraph::create_handle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new node with the given sequence and return the handle. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a8c9d8ca8160a9b94a57000eab3e97aaa">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a4c4c19ab536935bf833c6fbf8535eb5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::HashGraph::create_handle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new node with the given id and sequence, then return the handle. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#ae844fce457858cd2dc54dde786f79e5c">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="ad0d3d60790d6da614822d24269940cb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> vg::HashGraph::create_path_handle </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a path with the given name. The caller must ensure that no path with the given name exists already, or the behavior is undefined. Returns a handle to the created empty path. Handles to other paths must remain valid. </p>

</div>
</div>
<a class="anchor" id="a7ee9a975a807aaf69e7a412bc5b61dae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::HashGraph::deserialize </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aad9e990d9ac9bcd3247ad342f5597bf7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::HashGraph::destroy_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove the edge connecting the given handles in the given order and orientations. Ignores nonexistent edges. Does not update any stored paths. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#a285ac35e805eab548c4106ee534d79f2">handlegraph::DeletableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="aa896670c64d504cc067607639e323c6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::HashGraph::destroy_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove the node belonging to the given handle and all of its edges. Does not update any stored paths. Invalidates the destroyed handle. May be called during serial for_each_handle iteration <b>ONLY</b> on the node being iterated. May <b>NOT</b> be called during parallel for_each_handle iteration. May <b>NOT</b> be called on the node from which edges are being followed during follow_edges. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#a06d4d3ecda0694d5045c457f3eecd8e3">handlegraph::DeletableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a5bf7cdad16ee57b77665981b3a94b7b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::HashGraph::destroy_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroy the given path. Invalidates handles to the path and its node occurrences. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#a05a7303ef2f259c6384b0b9b1f9d3f56">handlegraph::MutablePathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="ab0e72a6e106dac2d90ab17334b981999"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; vg::HashGraph::divide_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a handle's underlying node at the given offsets in the handle's orientation. Returns all of the handles to the parts. Other handles to the node being split may be invalidated. The split pieces stay in the same local forward orientation as the original node, but the returned handles come in the order and orientation appropriate for the handle passed in. Updates stored paths. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#aca166406fa2000778552ed77c41a5e4c">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="ab998348dca396d62a4bb1debc422900c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::HashGraph::flip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invert the orientation of a handle (potentially without getting its ID) </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#aaa3f94ae7e884408ef6e8ca8fd45c7d7">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a6f320beb22803044de9cc873d11b7b80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::HashGraph::follow_edges_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>go_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loop over all the handles to next/previous (right/left) nodes. Passes them to a callback which returns false to stop iterating and true to continue. Returns true if we finished and false if we stopped early. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a89bbc118fe1e8e1acb162c14be33e8b5">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="aa5fddc415dfc8a4ae112630a464929ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::HashGraph::for_each_handle_impl </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loop over all the nodes in the graph in their local forward orientations, in their internal stored order. Stop if the iteratee returns false. Can be told to run in parallel, in which case stopping after a false return value is on a best-effort basis and iteration order is not defined. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#af48ba081fcb810267dc50e3a3e7ad391">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a139d9582a548643055f6eddfb14407d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::HashGraph::for_each_occurrence_on_handle_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(const <a class="el" href="structhandlegraph_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a function with all occurrences of a node on paths. </p>

</div>
</div>
<a class="anchor" id="a9331b22252ba31cbca3511eddc3a5b0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::HashGraph::for_each_path_handle_impl </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a function on each path in the graph. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a79f48793555f6be311f6df6603324e7b">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="ae88d997bfa31592e712c87c620ac248e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::HashGraph::get_degree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>go_left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Efficiently get the number of edges attached to one side of a handle. </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1HandleGraph.html#a8800aafcd81470ba313839138f608a39">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a0962304a83dfb9b67f885d7dbf6f39ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1occurrence__handle__t.html">occurrence_handle_t</a> vg::HashGraph::get_first_occurrence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a handle to the first occurrence in a path. The path MUST be nonempty. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a3769fd156e96d8f80c19422670301602">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="aa0737709e736c855691e4ce222408907"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::HashGraph::get_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up the handle for the node with the given ID in the given orientation. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a6dd9d70931835f5c75518b23a780b744">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="ae56ffff3de1c2acc4ed8ef96dc511783"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> vg::HashGraph::get_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ID from a handle. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#adb7f6e144bf2a59679f7b2eddad934eb">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a56e014a6b34caa378cdebaa0789a869d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::HashGraph::get_is_reverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the orientation of a handle. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a92773f90eb58f18adb9418a4440223c1">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="aed32810ca7bc2fabba271806aca879a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1occurrence__handle__t.html">occurrence_handle_t</a> vg::HashGraph::get_last_occurrence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a handle to the last occurrence in a path The path MUST be nonempty. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a6d1d56f58f494cda270a8f718789f421">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="ad95c9518285d88309b2bac94e4604912"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::HashGraph::get_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of a node. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a569ff35fb85c725b0b6b6933ed303e49">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="ab72c0c61a134afc5529376802cf3f739"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1occurrence__handle__t.html">occurrence_handle_t</a> vg::HashGraph::get_next_occurrence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>occurrence_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a handle to the next occurrence on the path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a7dabb96d3562a23ef8ec862e17379b5f">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="aa455500b64f22200ac94ff36ac424e5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::HashGraph::get_occurrence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>occurrence_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a node handle (node ID and orientation) from a handle to an occurrence on a path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#ab604c33073e78361e01232ddafabefdb">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a5a8765ae3963b9256e23d3cda7272981"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::HashGraph::get_occurrence_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of node occurrences in the path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a31e0aef90af7737c924b138f8942ed33">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a8f9ba2a3aeb31ab5425273a3dbd723d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::HashGraph::get_path_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of paths stored in the graph. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#acd5df753593ecdfb7aa8c411b98ebad9">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="ae21e82973db50bd9bec89ff00a3b33a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> vg::HashGraph::get_path_handle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Look up the path handle for the given path name. The path with that name must exist. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a5d6059d716882a80e3982de17011866e">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a8fe60075d700fca0abba5ef42ffe362e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> vg::HashGraph::get_path_handle_of_occurrence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>occurrence_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a handle to the path that an occurrence is on. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a04a7882174a4b9edafb9b7a6dfc5ce00">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="addaa0475f3e7882f048f336e3df6be20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::HashGraph::get_path_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up the name of a path from a handle to it. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a565f4312a42dfe77ae14c1ee9ed9f2ba">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="ad2dfa24d5692de9ba75d557d06176ffb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1occurrence__handle__t.html">occurrence_handle_t</a> vg::HashGraph::get_previous_occurrence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>occurrence_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a handle to the previous occurrence on the path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#af9ee6b325b0ea0b7f46aa3e7008e8222">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a54a900a44996421bfe822854185cdb19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::HashGraph::get_sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the sequence of a node, presented in the handle's local forward orientation. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a8cc2ab8a1292e30ba5e167a823f66d92">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a8c4efd97a6a89e83942286452bddac67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::HashGraph::has_next_occurrence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>occurrence_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the occurrence is not the last occurence on the path, else false. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a8eda7ca3307a4feb4be31db9d768265d">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="aefb348c5eeabcde13c11fdbb41cae1c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::HashGraph::has_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to check if a node exists by ID. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a6e58a79001cd7d839ac1f1adaff34dfb">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="aa7253cd88de3db99a82c9c1a9e8d1d6c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::HashGraph::has_path </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if a path name exists and is legal to get a path handle for. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#ab7de11c1e994bc104378c4b798013430">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a5b5754011f83cb1e65bebac89355503d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::HashGraph::has_previous_occurrence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>occurrence_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the occurrence is not the first occurence on the path, else false. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a17498b2c4e2dfb355593c80bdbc590da">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a8a1a36f27466b0c0183a7393954c834b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> vg::HashGraph::max_node_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the largest ID in the graph, or some larger number if the largest ID is unavailable. Return value is unspecified if the graph is empty. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a5a2e2b1ea6a29b3f4b34a6abcb6dbc50">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a16a3cd1543c185ad84e656dda708bf0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> vg::HashGraph::min_node_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the smallest ID in the graph, or some smaller number if the smallest ID is unavailable. Return value is unspecified if the graph is empty. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a85c52fe4b5f483504ed142d0ad94a969">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a43b6f2f2873d2d5876062131c334cfd0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::HashGraph::node_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of nodes in the graph TODO: can't be node_count because XG has a field named node_count. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#ab76511940f95dceb5fb162f39d316a1d">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="aadea5fc540908b3061b10d39e0fc4180"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::HashGraph::serialize </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2baff414f3e0c3d3a63260cd8b1f19ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::HashGraph::swap_handles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO: swap_handles is actually not yet supported. </p>
<p>Swap the nodes corresponding to the given handles, in the ordering used by for_each_handle when looping over the graph. Other handles to the nodes being swapped must not be invalidated. If a swap is made while for_each_handle is running, it affects the order of the handles traversed during the current traversal (so swapping an already seen handle to a later handle's position will make the seen handle be visited again and the later handle not be visited at all). </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a87a4f4e1eece8a26d36af78ef1bc1751">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="acf7fa52134f840ea7c630892694a4a94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt;<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="structvg_1_1HashGraph_1_1node__t.html">node_t</a>&gt; vg::HashGraph::graph</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encodes the graph topology. </p>

</div>
</div>
<a class="anchor" id="a152a80d1b5c52b930a51fa937c1ba806"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> vg::HashGraph::max_id = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum ID in the graph. </p>

</div>
</div>
<a class="anchor" id="a6dba3ebdc7968db49c66cc0594ca1320"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> vg::HashGraph::min_id = numeric_limits&lt;<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&gt;::max()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The minimum ID in the graph. </p>

</div>
</div>
<a class="anchor" id="a1dcd8e88178aa4a9e3f6cef4a03493a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::HashGraph::next_path_id = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The next path ID we will assign to a new path. </p>

</div>
</div>
<a class="anchor" id="ab92287302405c3d227d95f348ffa6dd7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt;<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, vector&lt;<a class="el" href="structvg_1_1HashGraph_1_1path__mapping__t.html">path_mapping_t</a>*&gt; &gt; vg::HashGraph::occurrences</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps node IDs to their occurrences on paths. </p>

</div>
</div>
<a class="anchor" id="a5c3d6ba66905470b785ea8c4f754b148"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1string__hash__map.html">string_hash_map</a>&lt;string, int64_t&gt; vg::HashGraph::path_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps path names to path IDs. </p>

</div>
</div>
<a class="anchor" id="ac4311440e4ef60ffd00a8d8ef575b0aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt;int64_t, <a class="el" href="classvg_1_1HashGraph_1_1path__t.html">path_t</a>&gt; vg::HashGraph::paths</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps path IDs to the actual paths. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="hash__graph_8hpp.html">hash_graph.hpp</a></li>
<li>src/<a class="el" href="hash__graph_8cpp.html">hash_graph.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
