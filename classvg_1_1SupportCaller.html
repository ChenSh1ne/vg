<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>vg: vg::SupportCaller Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1SupportCaller.html">SupportCaller</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classvg_1_1SupportCaller-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::SupportCaller Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;support_caller.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vg::SupportCaller:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvg_1_1SupportCaller.png" usemap="#vg::SupportCaller_map" alt=""/>
  <map id="vg::SupportCaller_map" name="vg::SupportCaller_map">
<area href="classvg_1_1Configurable.html" alt="vg::Configurable" shape="rect" coords="0,0,110,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller_1_1PrimaryPath.html">PrimaryPath</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae794f8e0fba185201cc7ce6d41f2a09d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#ae794f8e0fba185201cc7ce6d41f2a09d">SupportCaller</a> ()=default</td></tr>
<tr class="separator:ae794f8e0fba185201cc7ce6d41f2a09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ddaf695dd368f86f2192954f138b31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a70ddaf695dd368f86f2192954f138b31">call</a> (<a class="el" href="structvg_1_1SupportAugmentedGraph.html">SupportAugmentedGraph</a> &amp;augmented, string pileup_filename=&quot;&quot;)</td></tr>
<tr class="separator:a70ddaf695dd368f86f2192954f138b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7d15eed023928433d5a6c3f7097939"><td class="memItemLeft" align="right" valign="top">tuple&lt; vector&lt; <a class="el" href="structvg_1_1Support.html">Support</a> &gt;<br class="typebreak"/>
, vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a7e7d15eed023928433d5a6c3f7097939">get_traversal_supports_and_sizes</a> (<a class="el" href="structvg_1_1SupportAugmentedGraph.html">SupportAugmentedGraph</a> &amp;augmented, <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;snarl_manager, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;site, const vector&lt; <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt; &amp;traversals, const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> *minus_traversal=NULL)</td></tr>
<tr class="separator:a7e7d15eed023928433d5a6c3f7097939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01e7eacc46cd32095b49f6b4ac1916f"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#ac01e7eacc46cd32095b49f6b4ac1916f">find_best_traversals</a> (<a class="el" href="structvg_1_1SupportAugmentedGraph.html">SupportAugmentedGraph</a> &amp;augmented, <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;snarl_manager, <a class="el" href="classvg_1_1TraversalFinder.html">TraversalFinder</a> *finder, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;site, const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;baseline_support, size_t copy_budget, function&lt; void(const <a class="el" href="structvg_1_1Locus.html">Locus</a> &amp;, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *)&gt; emit_locus)</td></tr>
<tr class="separator:ac01e7eacc46cd32095b49f6b4ac1916f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122bc21c6e3795bf018cacf541ab6d6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a122bc21c6e3795bf018cacf541ab6d6e">is_reference</a> (const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;trav, <a class="el" href="structvg_1_1AugmentedGraph.html">AugmentedGraph</a> &amp;augmented)</td></tr>
<tr class="separator:a122bc21c6e3795bf018cacf541ab6d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d58daaa5f0c090e934d0dbaaa14ce8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#aa6d58daaa5f0c090e934d0dbaaa14ce8">is_reference</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, <a class="el" href="structvg_1_1AugmentedGraph.html">AugmentedGraph</a> &amp;augmented)</td></tr>
<tr class="separator:aa6d58daaa5f0c090e934d0dbaaa14ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71092920f5b02ba09285d071a3d3059"><td class="memItemLeft" align="right" valign="top">map&lt; string, <a class="el" href="classvg_1_1SupportCaller_1_1PrimaryPath.html">PrimaryPath</a> &gt;<br class="typebreak"/>
::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#af71092920f5b02ba09285d071a3d3059">find_path</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;site, map&lt; string, <a class="el" href="classvg_1_1SupportCaller_1_1PrimaryPath.html">PrimaryPath</a> &gt; &amp;primary_paths)</td></tr>
<tr class="separator:af71092920f5b02ba09285d071a3d3059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvg_1_1Configurable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classvg_1_1Configurable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvg_1_1Configurable.html">vg::Configurable</a></td></tr>
<tr class="memitem:afa7bba48c6289ea9b9095acd79a5658e inherit pub_methods_classvg_1_1Configurable"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Configurable.html#afa7bba48c6289ea9b9095acd79a5658e">register_option</a> (<a class="el" href="classvg_1_1OptionInterface.html">OptionInterface</a> *option)</td></tr>
<tr class="separator:afa7bba48c6289ea9b9095acd79a5658e inherit pub_methods_classvg_1_1Configurable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553f14c4f4a19bb51d40ffb211945b3a inherit pub_methods_classvg_1_1Configurable"><td class="memItemLeft" align="right" valign="top">virtual vector&lt; <a class="el" href="classvg_1_1OptionInterface.html">OptionInterface</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Configurable.html#a553f14c4f4a19bb51d40ffb211945b3a">get_options</a> ()</td></tr>
<tr class="separator:a553f14c4f4a19bb51d40ffb211945b3a inherit pub_methods_classvg_1_1Configurable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee830d6a5cdcf8e7a2896a443bcc80cc inherit pub_methods_classvg_1_1Configurable"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Configurable.html#aee830d6a5cdcf8e7a2896a443bcc80cc">get_name</a> ()</td></tr>
<tr class="separator:aee830d6a5cdcf8e7a2896a443bcc80cc inherit pub_methods_classvg_1_1Configurable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa339586afbf179881045478d4b6f09db"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#aa339586afbf179881045478d4b6f09db">support_quality</a> (const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;support)</td></tr>
<tr class="separator:aa339586afbf179881045478d4b6f09db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:abc8b8ec1ae50ef22ec1bb7f9307edcdd"><td class="memItemLeft" align="right" valign="top">function&lt; double(const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#abc8b8ec1ae50ef22ec1bb7f9307edcdd">support_val</a></td></tr>
<tr class="separator:abc8b8ec1ae50ef22ec1bb7f9307edcdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3793a603d54a9274ed8e2b0e3abc5dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; bool &gt; convert_to_vcf&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#af3793a603d54a9274ed8e2b0e3abc5dc">this</a></td></tr>
<tr class="memdesc:af3793a603d54a9274ed8e2b0e3abc5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should we output in VCF (true) or Protobuf <a class="el" href="structvg_1_1Locus.html" title="Describes a genetic locus with multiple possible alleles, a genotype, and observational support...">Locus</a> (false) format?  <a href="#af3793a603d54a9274ed8e2b0e3abc5dc">More...</a><br/></td></tr>
<tr class="separator:af3793a603d54a9274ed8e2b0e3abc5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd38674a20e47fd3bffe9f1a3c412c53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; bool &gt; convert_to_vcf no&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#acd38674a20e47fd3bffe9f1a3c412c53">vcf</a></td></tr>
<tr class="separator:acd38674a20e47fd3bffe9f1a3c412c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541691854268040600d85ac3d5d1a108"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; bool &gt; convert_to_vcf no&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a541691854268040600d85ac3d5d1a108">V</a></td></tr>
<tr class="separator:a541691854268040600d85ac3d5d1a108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80afc297411ff87d793461d259106a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; bool &gt; convert_to_vcf no&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#ae80afc297411ff87d793461d259106a2">true</a></td></tr>
<tr class="separator:ae80afc297411ff87d793461d259106a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e9a4ecc2f56ea8fe5ac2cba6ddc42e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; bool &gt; convert_to_vcf <br class="typebreak"/>
no output variants in binary <br class="typebreak"/>
Loci format instead of text <br class="typebreak"/>
VCF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#af9e9a4ecc2f56ea8fe5ac2cba6ddc42e">format</a></td></tr>
<tr class="separator:af9e9a4ecc2f56ea8fe5ac2cba6ddc42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6584c21b8d57196db570a3642e23a27"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#ae6584c21b8d57196db570a3642e23a27">locus_buffer_size</a> = 1000</td></tr>
<tr class="memdesc:ae6584c21b8d57196db570a3642e23a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">How big should our output buffer be?  <a href="#ae6584c21b8d57196db570a3642e23a27">More...</a><br/></td></tr>
<tr class="separator:ae6584c21b8d57196db570a3642e23a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6600a3aeeb8f2bbf19f422d0eb8f841a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; vector&lt; string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a6600a3aeeb8f2bbf19f422d0eb8f841a">ref_path_names</a></td></tr>
<tr class="memdesc:a6600a3aeeb8f2bbf19f422d0eb8f841a"><td class="mdescLeft">&#160;</td><td class="mdescRight">What are the names of the reference paths, if any, in the graph?  <a href="#a6600a3aeeb8f2bbf19f422d0eb8f841a">More...</a><br/></td></tr>
<tr class="separator:a6600a3aeeb8f2bbf19f422d0eb8f841a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d89567cf42fb8cb646001046c55d0cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; vector&lt; string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a6d89567cf42fb8cb646001046c55d0cc">contig_name_overrides</a></td></tr>
<tr class="separator:a6d89567cf42fb8cb646001046c55d0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c187e37f3ba63eeaba57b9b1bc2ae64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a3c187e37f3ba63eeaba57b9b1bc2ae64">length_overrides</a></td></tr>
<tr class="separator:a3c187e37f3ba63eeaba57b9b1bc2ae64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e613538924447d54fbecbf8d14f501d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a4e613538924447d54fbecbf8d14f501d">sample_name</a></td></tr>
<tr class="memdesc:a4e613538924447d54fbecbf8d14f501d"><td class="mdescLeft">&#160;</td><td class="mdescRight">What name should we use for the sample in the VCF file?  <a href="#a4e613538924447d54fbecbf8d14f501d">More...</a><br/></td></tr>
<tr class="separator:a4e613538924447d54fbecbf8d14f501d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed18b083fd15705d07c6a5e35739937"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#afed18b083fd15705d07c6a5e35739937">variant_offset</a></td></tr>
<tr class="memdesc:afed18b083fd15705d07c6a5e35739937"><td class="mdescLeft">&#160;</td><td class="mdescRight">How far should we offset positions of variants?  <a href="#afed18b083fd15705d07c6a5e35739937">More...</a><br/></td></tr>
<tr class="separator:afed18b083fd15705d07c6a5e35739937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1d059f7ca1760f2f2232bf10823df8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#aae1d059f7ca1760f2f2232bf10823df8">max_search_depth</a></td></tr>
<tr class="separator:aae1d059f7ca1760f2f2232bf10823df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cea088e31aee9726bda4efd25fef82f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a4cea088e31aee9726bda4efd25fef82f">max_search_width</a></td></tr>
<tr class="separator:a4cea088e31aee9726bda4efd25fef82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65abecae63da2cabc9a3bc4f7a710ded"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a65abecae63da2cabc9a3bc4f7a710ded">min_fraction_for_call</a></td></tr>
<tr class="separator:a65abecae63da2cabc9a3bc4f7a710ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e5b0b963ac2a2c00c36ab31a13765c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a94e5b0b963ac2a2c00c36ab31a13765c">max_het_bias</a></td></tr>
<tr class="separator:a94e5b0b963ac2a2c00c36ab31a13765c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370d5fb988f39ab6a03efbf1bbed1d65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a370d5fb988f39ab6a03efbf1bbed1d65">max_ref_het_bias</a></td></tr>
<tr class="memdesc:a370d5fb988f39ab6a03efbf1bbed1d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like above, but applied to ref / alt ratio (instead of alt / ref)  <a href="#a370d5fb988f39ab6a03efbf1bbed1d65">More...</a><br/></td></tr>
<tr class="separator:a370d5fb988f39ab6a03efbf1bbed1d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03841cbfb977456890928bbcd831362"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#af03841cbfb977456890928bbcd831362">max_indel_het_bias</a></td></tr>
<tr class="memdesc:af03841cbfb977456890928bbcd831362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the max het bias, but applies to novel indels.  <a href="#af03841cbfb977456890928bbcd831362">More...</a><br/></td></tr>
<tr class="separator:af03841cbfb977456890928bbcd831362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5685ff84488c17db0bca88f8ce7d697"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#ac5685ff84488c17db0bca88f8ce7d697">max_indel_ma_bias</a></td></tr>
<tr class="memdesc:ac5685ff84488c17db0bca88f8ce7d697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the max het bias, but applies to multiallelic indels.  <a href="#ac5685ff84488c17db0bca88f8ce7d697">More...</a><br/></td></tr>
<tr class="separator:ac5685ff84488c17db0bca88f8ce7d697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db9e682e135333e47b6ecb0b5374efb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a8db9e682e135333e47b6ecb0b5374efb">min_total_support_for_call</a></td></tr>
<tr class="separator:a8db9e682e135333e47b6ecb0b5374efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da5805e7c262a8fe317ad9e0b49817a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a1da5805e7c262a8fe317ad9e0b49817a">ref_bin_size</a></td></tr>
<tr class="separator:a1da5805e7c262a8fe317ad9e0b49817a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72cd919ebff400d32250e4f0882929f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a72cd919ebff400d32250e4f0882929f4">expected_coverage</a></td></tr>
<tr class="separator:a72cd919ebff400d32250e4f0882929f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032117d5fd316be83877834de8d25a99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a032117d5fd316be83877834de8d25a99">use_average_support</a></td></tr>
<tr class="separator:a032117d5fd316be83877834de8d25a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3826a4f33deff50ad7d35c0b121e95c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#ad3826a4f33deff50ad7d35c0b121e95c">average_support_switch_threshold</a></td></tr>
<tr class="separator:ad3826a4f33deff50ad7d35c0b121e95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4149e268405a8af09ee45decd51ec717"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a4149e268405a8af09ee45decd51ec717">max_bubble_paths</a> = 100</td></tr>
<tr class="separator:a4149e268405a8af09ee45decd51ec717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31afb796c7822133359248f2f53d2c4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a31afb796c7822133359248f2f53d2c4b">min_mad_for_filter</a></td></tr>
<tr class="separator:a31afb796c7822133359248f2f53d2c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c9519695b82b720072a1125a638b30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a89c9519695b82b720072a1125a638b30">max_dp_for_filter</a></td></tr>
<tr class="memdesc:a89c9519695b82b720072a1125a638b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">what's the maximum total depth to give a PASS in the filter column  <a href="#a89c9519695b82b720072a1125a638b30">More...</a><br/></td></tr>
<tr class="separator:a89c9519695b82b720072a1125a638b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ac3dd541bcb9ab18eeb73ba93b4809"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#aa4ac3dd541bcb9ab18eeb73ba93b4809">max_dp_multiple_for_filter</a></td></tr>
<tr class="separator:aa4ac3dd541bcb9ab18eeb73ba93b4809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f075288ed00491db3479a2717a595d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a3f075288ed00491db3479a2717a595d8">max_local_dp_multiple_for_filter</a></td></tr>
<tr class="separator:a3f075288ed00491db3479a2717a595d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2588765531eceb32bfc8a487d6503d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#aca2588765531eceb32bfc8a487d6503d">min_ad_log_likelihood_for_filter</a></td></tr>
<tr class="memdesc:aca2588765531eceb32bfc8a487d6503d"><td class="mdescLeft">&#160;</td><td class="mdescRight">what's the min log likelihood for allele depth assignments to PASS?  <a href="#aca2588765531eceb32bfc8a487d6503d">More...</a><br/></td></tr>
<tr class="separator:aca2588765531eceb32bfc8a487d6503d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216ee27f03698399b7ded8342d846ba1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a216ee27f03698399b7ded8342d846ba1">write_trivial_calls</a></td></tr>
<tr class="separator:a216ee27f03698399b7ded8342d846ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c63051b322bb03bb9de210c6b63ee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a92c63051b322bb03bb9de210c6b63ee7">call_other_by_coverage</a></td></tr>
<tr class="separator:a92c63051b322bb03bb9de210c6b63ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626d85743ce833b7745afe9c1ab66cb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a626d85743ce833b7745afe9c1ab66cb6">use_support_count</a></td></tr>
<tr class="separator:a626d85743ce833b7745afe9c1ab66cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2310ebac3bb08de54267e7f7aa1b06d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a2310ebac3bb08de54267e7f7aa1b06d4">support_file_name</a></td></tr>
<tr class="memdesc:a2310ebac3bb08de54267e7f7aa1b06d4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvg_1_1Path.html">Path</a> of supports file generated from the <a class="el" href="classvg_1_1PileupAugmenter.html">PileupAugmenter</a> (via vg augment)  <a href="#a2310ebac3bb08de54267e7f7aa1b06d4">More...</a><br/></td></tr>
<tr class="separator:a2310ebac3bb08de54267e7f7aa1b06d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16284074baabe10886ae5e33b2d0e165"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a16284074baabe10886ae5e33b2d0e165">verbose</a> = false</td></tr>
<tr class="memdesc:a16284074baabe10886ae5e33b2d0e165"><td class="mdescLeft">&#160;</td><td class="mdescRight">print warnings etc. to stderr  <a href="#a16284074baabe10886ae5e33b2d0e165">More...</a><br/></td></tr>
<tr class="separator:a16284074baabe10886ae5e33b2d0e165"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classvg_1_1SupportCaller.html">SupportCaller</a>: take an augmented graph from a Caller and produce actual calls in a VCF. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae794f8e0fba185201cc7ce6d41f2a09d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::SupportCaller::SupportCaller </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set up to call with default parameters. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a70ddaf695dd368f86f2192954f138b31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SupportCaller::call </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1SupportAugmentedGraph.html">SupportAugmentedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>augmented</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>pileup_filename</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce calls for the given annotated augmented graph. If a pileup_filename is provided, the pileup is loaded again and used to add comments describing variants </p>

</div>
</div>
<a class="anchor" id="ac01e7eacc46cd32095b49f6b4ac1916f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt; vg::SupportCaller::find_best_traversals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1SupportAugmentedGraph.html">SupportAugmentedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>augmented</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl_manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1TraversalFinder.html">TraversalFinder</a> *&#160;</td>
          <td class="paramname"><em>finder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;&#160;</td>
          <td class="paramname"><em>site</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>baseline_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>copy_budget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(const <a class="el" href="structvg_1_1Locus.html">Locus</a> &amp;, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *)&gt;&#160;</td>
          <td class="paramname"><em>emit_locus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For the given snarl, find the reference traversal, the best traversal, and the second-best traversal, recursively, if any exist. These traversals will be fully filled in with nodes.</p>
<p>Only snarls which are ultrabubbles can be called.</p>
<p>Expects the given baseline support for a diploid call.</p>
<p>Will not return more than 1 + copy_budget SnarlTraversals, and will return less if some copies are called as having the same traversal.</p>
<p>Does not deduplicate agains the ref traversal; it may be the same as the best or second-best.</p>
<p>Uses the given copy number allowance, and emits a <a class="el" href="structvg_1_1Locus.html" title="Describes a genetic locus with multiple possible alleles, a genotype, and observational support...">Locus</a> for this <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> and any child Snarls.</p>
<p>If no path through the <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> can be found, emits no <a class="el" href="structvg_1_1Locus.html" title="Describes a genetic locus with multiple possible alleles, a genotype, and observational support...">Locus</a> and returns no SnarlTraversals. </p>

</div>
</div>
<a class="anchor" id="af71092920f5b02ba09285d071a3d3059"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; string, <a class="el" href="classvg_1_1SupportCaller_1_1PrimaryPath.html">SupportCaller::PrimaryPath</a> &gt;::iterator vg::SupportCaller::find_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;&#160;</td>
          <td class="paramname"><em>site</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; string, <a class="el" href="classvg_1_1SupportCaller_1_1PrimaryPath.html">PrimaryPath</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>primary_paths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the primary path, if any, that the given site is threaded onto.</p>
<p>TODO: can only work by brute-force search. </p>

</div>
</div>
<a class="anchor" id="a7e7d15eed023928433d5a6c3f7097939"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple&lt; vector&lt; <a class="el" href="structvg_1_1Support.html">Support</a> &gt;, vector&lt; size_t &gt; &gt; vg::SupportCaller::get_traversal_supports_and_sizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1SupportAugmentedGraph.html">SupportAugmentedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>augmented</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl_manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;&#160;</td>
          <td class="paramname"><em>site</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>traversals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> *&#160;</td>
          <td class="paramname"><em>minus_traversal</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the support and size for each traversal in a list. Discount support of minus_traversal if it's specified. Use average_support_switch_threshold and use_average_support to decide whether to return min or avg supports</p>
<p>Get the support for each traversal in a list, using average_support_switch_threshold to decide if we use the minimum or average </p>

</div>
</div>
<a class="anchor" id="a122bc21c6e3795bf018cacf541ab6d6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::SupportCaller::is_reference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>trav</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1AugmentedGraph.html">AugmentedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>augmented</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decide if the given <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> is included in the original base graph (true), or if it represents a novel variant (false).</p>
<p>Looks at the nodes in the traversal, and sees if their calls are CALL_REFERENCE or not.</p>
<p>Handles single-edge traversals. </p>

</div>
</div>
<a class="anchor" id="aa6d58daaa5f0c090e934d0dbaaa14ce8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::SupportCaller::is_reference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1AugmentedGraph.html">AugmentedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>augmented</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decide if the given <a class="el" href="structvg_1_1Path.html">Path</a> is included in the original base graph (true) or if it represents a novel variant (false).</p>
<p>Looks at the nodes, and sees if their calls are CALL_REFERENCE or not.</p>
<p>The path can't be empty; it has to be anchored to something (probably the start and end of the snarl it came from). </p>

</div>
</div>
<a class="anchor" id="aa339586afbf179881045478d4b6f09db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double vg::SupportCaller::support_quality </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>support</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ad3826a4f33deff50ad7d35c0b121e95c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;size_t&gt; vg::SupportCaller::average_support_switch_threshold</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;use-avg-support-above&quot;</span>, <span class="stringliteral">&quot;uUaAtT&quot;</span>, 100,</div>
<div class="line">        <span class="stringliteral">&quot;use average instead of minimum support for sites this long or longer&quot;</span>}</div>
</div><!-- fragment --><p>Max traversal length threshold at which we switch from minimum support to average support (so we don't use average support on pairs of adjacent errors and miscall them, but we do use it on long runs of reference inside a deletion where the min support might not be representative. </p>

</div>
</div>
<a class="anchor" id="a92c63051b322bb03bb9de210c6b63ee7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;bool&gt; vg::SupportCaller::call_other_by_coverage</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;call-nodes-by-coverage&quot;</span>, <span class="stringliteral">&quot;cCoObB&quot;</span>, <span class="keyword">false</span>,</div>
<div class="line">        <span class="stringliteral">&quot;make calls on nodes/edges outside snarls by coverage&quot;</span>}</div>
</div><!-- fragment --><p>Should we call on nodes/edges outside of snarls by coverage (true), or just assert that primary path things exist and off-path things don't (false)? </p>

</div>
</div>
<a class="anchor" id="a6d89567cf42fb8cb646001046c55d0cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;vector&lt;string&gt; &gt; vg::SupportCaller::contig_name_overrides</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;contig&quot;</span>, <span class="stringliteral">&quot;c&quot;</span>, {},</div>
<div class="line">        <span class="stringliteral">&quot;use the given name as the VCF name for the corresponding reference path (can repeat)&quot;</span>}</div>
</div><!-- fragment --><p>What name should we give each contig in the VCF file? Autodetected from path names if empty or too short. </p>

</div>
</div>
<a class="anchor" id="a72cd919ebff400d32250e4f0882929f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;double&gt; vg::SupportCaller::expected_coverage</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;avg-coverage&quot;</span>, <span class="stringliteral">&quot;C&quot;</span>, 0.0,</div>
<div class="line">        <span class="stringliteral">&quot;specify expected coverage (instead of computing on reference)&quot;</span>}</div>
</div><!-- fragment --><p>On some graphs, we can't get the coverage because it's split over parallel paths. Allow overriding here </p>

</div>
</div>
<a class="anchor" id="af9e9a4ecc2f56ea8fe5ac2cba6ddc42e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;bool&gt; convert_to_vcf no output variants in binary Loci format instead of text VCF vg::SupportCaller::format</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3c187e37f3ba63eeaba57b9b1bc2ae64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;vector&lt;size_t&gt; &gt; vg::SupportCaller::length_overrides</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;length&quot;</span>, <span class="stringliteral">&quot;l&quot;</span>, {},</div>
<div class="line">        <span class="stringliteral">&quot;override total sequence length in VCF for the corresponding reference path (can repeat)&quot;</span>}</div>
</div><!-- fragment --><p>What should the total sequence length reported in the VCF header be for each contig? Autodetected from path lengths if empty or too short. </p>

</div>
</div>
<a class="anchor" id="ae6584c21b8d57196db570a3642e23a27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::SupportCaller::locus_buffer_size = 1000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How big should our output buffer be? </p>

</div>
</div>
<a class="anchor" id="a4149e268405a8af09ee45decd51ec717"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::SupportCaller::max_bubble_paths = 100</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>What's the maximum number of bubble path combinations we can explore while finding one with maximum support? </p>

</div>
</div>
<a class="anchor" id="a89c9519695b82b720072a1125a638b30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;size_t&gt; vg::SupportCaller::max_dp_for_filter</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;max-dp&quot;</span>, <span class="stringliteral">&quot;MmDdAaXxPp&quot;</span>, 0,</div>
<div class="line">        <span class="stringliteral">&quot;max depth to PASS filter (0 for unlimited)&quot;</span>}</div>
</div><!-- fragment -->
<p>what's the maximum total depth to give a PASS in the filter column </p>

</div>
</div>
<a class="anchor" id="aa4ac3dd541bcb9ab18eeb73ba93b4809"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;double&gt; vg::SupportCaller::max_dp_multiple_for_filter</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;max-dp-multiple&quot;</span>, <span class="stringliteral">&quot;MmDdAaXxPp&quot;</span>, 0,</div>
<div class="line">        <span class="stringliteral">&quot;max portion of global expected depth to PASS filter (0 for unlimited)&quot;</span>}</div>
</div><!-- fragment --><p>what's the maximum total depth to give a PASS in the filter column, as a multiple of the global baseline coverage? </p>

</div>
</div>
<a class="anchor" id="a94e5b0b963ac2a2c00c36ab31a13765c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;double&gt; vg::SupportCaller::max_het_bias</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;max-het-bias&quot;</span>, <span class="stringliteral">&quot;H&quot;</span>, 10,</div>
<div class="line">        <span class="stringliteral">&quot;max imbalance factor to call heterozygous, alt major on SNPs&quot;</span>}</div>
</div><!-- fragment --><p>What fraction of the reads supporting an alt are we willing to discount? At 2, if twice the reads support one allele as the other, we'll call homozygous instead of heterozygous. At infinity, every call will be heterozygous if even one read supports each allele. </p>

</div>
</div>
<a class="anchor" id="af03841cbfb977456890928bbcd831362"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;double&gt; vg::SupportCaller::max_indel_het_bias</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;max-indel-het-bias&quot;</span>, <span class="stringliteral">&quot;I&quot;</span>, 3,</div>
<div class="line">        <span class="stringliteral">&quot;max imbalance factor to call heterozygous, alt major on indels&quot;</span>}</div>
</div><!-- fragment -->
<p>Like the max het bias, but applies to novel indels. </p>

</div>
</div>
<a class="anchor" id="ac5685ff84488c17db0bca88f8ce7d697"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;double&gt; vg::SupportCaller::max_indel_ma_bias</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;max-indel-ma-bias&quot;</span>, <span class="stringliteral">&quot;G&quot;</span>, 6,</div>
<div class="line">        <span class="stringliteral">&quot;max imbalance factor between ref and alt2 to call 1/2 double alt on indels&quot;</span>}</div>
</div><!-- fragment -->
<p>Like the max het bias, but applies to multiallelic indels. </p>

</div>
</div>
<a class="anchor" id="a3f075288ed00491db3479a2717a595d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;double&gt; vg::SupportCaller::max_local_dp_multiple_for_filter</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;max-local-dp-multiple&quot;</span>, <span class="stringliteral">&quot;MmLlOoDdAaXxPp&quot;</span>, 0,</div>
<div class="line">        <span class="stringliteral">&quot;max portion of local expected depth to PASS filter (0 for unlimited)&quot;</span>}</div>
</div><!-- fragment --><p>what's the maximum total depth to give a PASS in the filter column, as a multiple of the local baseline coverage? </p>

</div>
</div>
<a class="anchor" id="a370d5fb988f39ab6a03efbf1bbed1d65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;double&gt; vg::SupportCaller::max_ref_het_bias</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;max-ref-bias&quot;</span>, <span class="stringliteral">&quot;R&quot;</span>, 4.5,</div>
<div class="line">        <span class="stringliteral">&quot;max imbalance factor to call heterozygous, ref major&quot;</span>}</div>
</div><!-- fragment -->
<p>Like above, but applied to ref / alt ratio (instead of alt / ref) </p>

</div>
</div>
<a class="anchor" id="aae1d059f7ca1760f2f2232bf10823df8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;int64_t&gt; vg::SupportCaller::max_search_depth</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;max-search-depth&quot;</span>, <span class="stringliteral">&quot;D&quot;</span>, 1000,</div>
<div class="line">        <span class="stringliteral">&quot;maximum depth for path search&quot;</span>}</div>
</div><!-- fragment --><p>How many nodes should we be willing to look at on our path back to the primary path? Keep in mind we need to look at all valid paths (and all combinations thereof) until we find a valid pair. </p>

</div>
</div>
<a class="anchor" id="a4cea088e31aee9726bda4efd25fef82f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;int64_t&gt; vg::SupportCaller::max_search_width</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;max-search-width&quot;</span>, <span class="stringliteral">&quot;wWmMsS&quot;</span>, 1000,</div>
<div class="line">        <span class="stringliteral">&quot;maximum width for path search&quot;</span>}</div>
</div><!-- fragment --><p>How many search states should we allow on the DFS stack when searching for traversals? </p>

</div>
</div>
<a class="anchor" id="aca2588765531eceb32bfc8a487d6503d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;double&gt; vg::SupportCaller::min_ad_log_likelihood_for_filter</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;min-ad-log-likelihood&quot;</span>, <span class="stringliteral">&quot;MmAaDdLliI&quot;</span>, -9.0,</div>
<div class="line">        <span class="stringliteral">&quot;min log likelihood for AD assignments to PASS filter (0 for unlimited)&quot;</span>}</div>
</div><!-- fragment -->
<p>what's the min log likelihood for allele depth assignments to PASS? </p>

</div>
</div>
<a class="anchor" id="a65abecae63da2cabc9a3bc4f7a710ded"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;double&gt; vg::SupportCaller::min_fraction_for_call</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;min-cov-frac&quot;</span>, <span class="stringliteral">&quot;F&quot;</span>, 0,</div>
<div class="line">        <span class="stringliteral">&quot;min fraction of average coverage at which to call&quot;</span>}</div>
</div><!-- fragment --><p>What fraction of average coverage should be the minimum to call a variant (or a single copy)? Default to 0 because vg call is still applying depth thresholding </p>

</div>
</div>
<a class="anchor" id="a31afb796c7822133359248f2f53d2c4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;size_t&gt; vg::SupportCaller::min_mad_for_filter</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;min-mad&quot;</span>, <span class="stringliteral">&quot;E&quot;</span>, 5,</div>
<div class="line">        <span class="stringliteral">&quot;min. ref/alt allele depth to PASS filter or be a second-best allele&quot;</span>}</div>
</div><!-- fragment --><p>what's the minimum ref or alt allele depth to give a PASS in the filter column? Also used as a min actual support for a second-best allele call </p>

</div>
</div>
<a class="anchor" id="a8db9e682e135333e47b6ecb0b5374efb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;size_t&gt; vg::SupportCaller::min_total_support_for_call</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;min-count&quot;</span>, <span class="stringliteral">&quot;n&quot;</span>, 1, </div>
<div class="line">        <span class="stringliteral">&quot;min total supporting read count to call a variant&quot;</span>}</div>
</div><!-- fragment --><p>What's the minimum integer number of reads that must support a call? We don't necessarily want to call a SNP as het because we have a single </p>

</div>
</div>
<a class="anchor" id="a1da5805e7c262a8fe317ad9e0b49817a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;size_t&gt; vg::SupportCaller::ref_bin_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;bin-size&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>, 250,</div>
<div class="line">        <span class="stringliteral">&quot;bin size used for counting coverage&quot;</span>}</div>
</div><!-- fragment --><p>Bin size used for counting coverage along the reference path. The bin coverage is used for computing the probability of an allele of a certain depth </p>

</div>
</div>
<a class="anchor" id="a6600a3aeeb8f2bbf19f422d0eb8f841a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;vector&lt;string&gt; &gt; vg::SupportCaller::ref_path_names</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;ref&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>, {},</div>
<div class="line">        <span class="stringliteral">&quot;use the path with the given name as a reference path (can repeat)&quot;</span>}</div>
</div><!-- fragment -->
<p>What are the names of the reference paths, if any, in the graph? </p>

</div>
</div>
<a class="anchor" id="a4e613538924447d54fbecbf8d14f501d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;string&gt; vg::SupportCaller::sample_name</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;sample&quot;</span>, <span class="stringliteral">&quot;S&quot;</span>, <span class="stringliteral">&quot;SAMPLE&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;name the sample in the VCF with the given name&quot;</span>}</div>
</div><!-- fragment -->
<p>What name should we use for the sample in the VCF file? </p>

</div>
</div>
<a class="anchor" id="a2310ebac3bb08de54267e7f7aa1b06d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;string&gt; vg::SupportCaller::support_file_name</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;support-file&quot;</span>, <span class="stringliteral">&quot;s&quot;</span>, {},</div>
<div class="line">            <span class="stringliteral">&quot;path of file containing supports generated by vg augment -P -s&quot;</span>}</div>
</div><!-- fragment -->
<p><a class="el" href="structvg_1_1Path.html">Path</a> of supports file generated from the <a class="el" href="classvg_1_1PileupAugmenter.html">PileupAugmenter</a> (via vg augment) </p>

</div>
</div>
<a class="anchor" id="abc8b8ec1ae50ef22ec1bb7f9307edcdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function&lt;double(const <a class="el" href="structvg_1_1Support.html">Support</a>&amp;)&gt; vg::SupportCaller::support_val</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the amount of support. Can use this function to toggle between unweighted (total from genotypekit) and quality-weighted (support_quality below) in one place. </p>

</div>
</div>
<a class="anchor" id="af3793a603d54a9274ed8e2b0e3abc5dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;bool&gt; convert_to_vcf vg::SupportCaller::this</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Should we output in VCF (true) or Protobuf <a class="el" href="structvg_1_1Locus.html" title="Describes a genetic locus with multiple possible alleles, a genotype, and observational support...">Locus</a> (false) format? </p>

</div>
</div>
<a class="anchor" id="ae80afc297411ff87d793461d259106a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;bool&gt; convert_to_vcf no vg::SupportCaller::true</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a032117d5fd316be83877834de8d25a99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;bool&gt; vg::SupportCaller::use_average_support</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;use-avg-support&quot;</span>, <span class="stringliteral">&quot;u&quot;</span>, <span class="keyword">false</span>,</div>
<div class="line">        <span class="stringliteral">&quot;use average instead of minimum support&quot;</span>}</div>
</div><!-- fragment --><p>Should we use average support instead of minimum support for our calculations? </p>

</div>
</div>
<a class="anchor" id="a626d85743ce833b7745afe9c1ab66cb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;bool&gt; vg::SupportCaller::use_support_count</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;use-support-count&quot;</span>, <span class="stringliteral">&quot;T&quot;</span>, <span class="keyword">false</span>,</div>
<div class="line">        <span class="stringliteral">&quot;use total support count instead of total support quality for selecting top alleles&quot;</span>}</div>
</div><!-- fragment --><p>Use total support count (true) instead of total support quality (false) when choosing top alleles and deciding gentypes based on the biases. </p>

</div>
</div>
<a class="anchor" id="a541691854268040600d85ac3d5d1a108"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;bool&gt; convert_to_vcf no vg::SupportCaller::V</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afed18b083fd15705d07c6a5e35739937"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;int64_t&gt; vg::SupportCaller::variant_offset</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;offset&quot;</span>, <span class="stringliteral">&quot;o&quot;</span>, 0,</div>
<div class="line">        <span class="stringliteral">&quot;offset variant positions by this amount in VCF&quot;</span>}</div>
</div><!-- fragment -->
<p>How far should we offset positions of variants? </p>

</div>
</div>
<a class="anchor" id="acd38674a20e47fd3bffe9f1a3c412c53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;bool&gt; convert_to_vcf no vg::SupportCaller::vcf</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a16284074baabe10886ae5e33b2d0e165"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::SupportCaller::verbose = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>print warnings etc. to stderr </p>

</div>
</div>
<a class="anchor" id="a216ee27f03698399b7ded8342d846ba1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;bool&gt; vg::SupportCaller::write_trivial_calls</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;trival&quot;</span>, <span class="stringliteral">&quot;ivtTIRV&quot;</span>, <span class="keyword">false</span>,</div>
<div class="line">        <span class="stringliteral">&quot;write trivial vcf calls (ex 0/0 genotypes)&quot;</span>}</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="support__caller_8hpp.html">support_caller.hpp</a></li>
<li>src/<a class="el" href="support__caller_8cpp.html">support_caller.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 1 2018 17:57:07 for vg by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
