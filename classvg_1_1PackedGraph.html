<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>vg: vg::PackedGraph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1PackedGraph.html">PackedGraph</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classvg_1_1PackedGraph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::PackedGraph Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;packed_graph.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vg::PackedGraph:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvg_1_1PackedGraph.png" usemap="#vg::PackedGraph_map" alt=""/>
  <map id="vg::PackedGraph_map" name="vg::PackedGraph_map">
<area href="classhandlegraph_1_1MutablePathDeletableHandleGraph.html" alt="handlegraph::MutablePathDeletableHandleGraph" shape="rect" coords="371,224,658,248"/>
<area href="classhandlegraph_1_1MutablePathMutableHandleGraph.html" alt="handlegraph::MutablePathMutableHandleGraph" shape="rect" coords="148,168,435,192"/>
<area href="classhandlegraph_1_1DeletableHandleGraph.html" alt="handlegraph::DeletableHandleGraph" shape="rect" coords="594,168,881,192"/>
<area href="classhandlegraph_1_1MutablePathHandleGraph.html" alt="handlegraph::MutablePathHandleGraph" shape="rect" coords="0,112,287,136"/>
<area href="classhandlegraph_1_1MutableHandleGraph.html" alt="handlegraph::MutableHandleGraph" shape="rect" coords="297,112,584,136"/>
<area href="classhandlegraph_1_1MutableHandleGraph.html" alt="handlegraph::MutableHandleGraph" shape="rect" coords="594,112,881,136"/>
<area href="classhandlegraph_1_1PathHandleGraph.html" alt="handlegraph::PathHandleGraph" shape="rect" coords="0,56,287,80"/>
<area href="classhandlegraph_1_1HandleGraph.html" alt="handlegraph::HandleGraph" shape="rect" coords="297,56,584,80"/>
<area href="classhandlegraph_1_1HandleGraph.html" alt="handlegraph::HandleGraph" shape="rect" coords="594,56,881,80"/>
<area href="classhandlegraph_1_1HandleGraph.html" alt="handlegraph::HandleGraph" shape="rect" coords="0,0,287,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a132c63e64b953aea4d5ed4732e832931"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a132c63e64b953aea4d5ed4732e832931">PackedGraph</a> ()</td></tr>
<tr class="separator:a132c63e64b953aea4d5ed4732e832931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624885b445c2e1d3b184d9c0c7a21d2e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a624885b445c2e1d3b184d9c0c7a21d2e">~PackedGraph</a> ()</td></tr>
<tr class="separator:a624885b445c2e1d3b184d9c0c7a21d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee9fc527de97b9a0798323ae5bd37d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#afee9fc527de97b9a0798323ae5bd37d9">PackedGraph</a> (istream &amp;in)</td></tr>
<tr class="memdesc:afee9fc527de97b9a0798323ae5bd37d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a stream.  <a href="#afee9fc527de97b9a0798323ae5bd37d9">More...</a><br/></td></tr>
<tr class="separator:afee9fc527de97b9a0798323ae5bd37d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6727c69a69d98508508f2a1d60e1db94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a6727c69a69d98508508f2a1d60e1db94">serialize</a> (ostream &amp;out) const </td></tr>
<tr class="memdesc:a6727c69a69d98508508f2a1d60e1db94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output to a stream.  <a href="#a6727c69a69d98508508f2a1d60e1db94">More...</a><br/></td></tr>
<tr class="separator:a6727c69a69d98508508f2a1d60e1db94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd309cf7a7d2bc62e1ca5d2a178c5e8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#abd309cf7a7d2bc62e1ca5d2a178c5e8d">deserialize</a> (istream &amp;in)</td></tr>
<tr class="memdesc:abd309cf7a7d2bc62e1ca5d2a178c5e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load contents from a stream and replace current contents.  <a href="#abd309cf7a7d2bc62e1ca5d2a178c5e8d">More...</a><br/></td></tr>
<tr class="separator:abd309cf7a7d2bc62e1ca5d2a178c5e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c0404ec39b09a6da748ad6426b5090"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#ac6c0404ec39b09a6da748ad6426b5090">has_node</a> (<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> node_id) const </td></tr>
<tr class="memdesc:ac6c0404ec39b09a6da748ad6426b5090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to check if a node exists by ID.  <a href="#ac6c0404ec39b09a6da748ad6426b5090">More...</a><br/></td></tr>
<tr class="separator:ac6c0404ec39b09a6da748ad6426b5090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086e9de2f2bafa5648ccaad339a31f50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a086e9de2f2bafa5648ccaad339a31f50">get_handle</a> (const <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &amp;node_id, bool is_reverse=false) const </td></tr>
<tr class="memdesc:a086e9de2f2bafa5648ccaad339a31f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the handle for the node with the given ID in the given orientation.  <a href="#a086e9de2f2bafa5648ccaad339a31f50">More...</a><br/></td></tr>
<tr class="separator:a086e9de2f2bafa5648ccaad339a31f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea2e0e792655f092ca39f0fb86eb245"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a7ea2e0e792655f092ca39f0fb86eb245">get_id</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const </td></tr>
<tr class="memdesc:a7ea2e0e792655f092ca39f0fb86eb245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID from a handle.  <a href="#a7ea2e0e792655f092ca39f0fb86eb245">More...</a><br/></td></tr>
<tr class="separator:a7ea2e0e792655f092ca39f0fb86eb245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7a9dcea634bf8c65e35042d73c9c20"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#aff7a9dcea634bf8c65e35042d73c9c20">get_is_reverse</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const </td></tr>
<tr class="memdesc:aff7a9dcea634bf8c65e35042d73c9c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the orientation of a handle.  <a href="#aff7a9dcea634bf8c65e35042d73c9c20">More...</a><br/></td></tr>
<tr class="separator:aff7a9dcea634bf8c65e35042d73c9c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334cc87fba7fb59a317c049f95789fc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a334cc87fba7fb59a317c049f95789fc3">flip</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const </td></tr>
<tr class="memdesc:a334cc87fba7fb59a317c049f95789fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the orientation of a handle (potentially without getting its ID)  <a href="#a334cc87fba7fb59a317c049f95789fc3">More...</a><br/></td></tr>
<tr class="separator:a334cc87fba7fb59a317c049f95789fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8e618ed215b7207fb2ac9810bc12be"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#acc8e618ed215b7207fb2ac9810bc12be">get_length</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const </td></tr>
<tr class="memdesc:acc8e618ed215b7207fb2ac9810bc12be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of a node.  <a href="#acc8e618ed215b7207fb2ac9810bc12be">More...</a><br/></td></tr>
<tr class="separator:acc8e618ed215b7207fb2ac9810bc12be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1afe172126487f9d3acc1f306743353a"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a1afe172126487f9d3acc1f306743353a">get_sequence</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const </td></tr>
<tr class="memdesc:a1afe172126487f9d3acc1f306743353a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sequence of a node, presented in the handle's local forward orientation.  <a href="#a1afe172126487f9d3acc1f306743353a">More...</a><br/></td></tr>
<tr class="separator:a1afe172126487f9d3acc1f306743353a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b94fb83b99c42d63634211aefe29b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#ab8b94fb83b99c42d63634211aefe29b3">follow_edges_impl</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;iteratee) const </td></tr>
<tr class="separator:ab8b94fb83b99c42d63634211aefe29b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac104360f349e95850117700aca78ad1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#ac104360f349e95850117700aca78ad1d">for_each_handle_impl</a> (const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;iteratee, bool parallel=false) const </td></tr>
<tr class="separator:ac104360f349e95850117700aca78ad1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc65594abfca94e73dcc974a8560500"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a1bc65594abfca94e73dcc974a8560500">node_size</a> (void) const </td></tr>
<tr class="memdesc:a1bc65594abfca94e73dcc974a8560500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of nodes in the graph.  <a href="#a1bc65594abfca94e73dcc974a8560500">More...</a><br/></td></tr>
<tr class="separator:a1bc65594abfca94e73dcc974a8560500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997a7c7e4314d13b4640cb107d14f0bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a997a7c7e4314d13b4640cb107d14f0bb">min_node_id</a> (void) const </td></tr>
<tr class="separator:a997a7c7e4314d13b4640cb107d14f0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205e6873f65cace24fdd0e07c7f30f3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a205e6873f65cace24fdd0e07c7f30f3f">max_node_id</a> (void) const </td></tr>
<tr class="separator:a205e6873f65cace24fdd0e07c7f30f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81627a008970ff5a61bfb1e14ec234a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a81627a008970ff5a61bfb1e14ec234a6">create_handle</a> (const std::string &amp;sequence)</td></tr>
<tr class="memdesc:a81627a008970ff5a61bfb1e14ec234a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new node with the given sequence and return the handle.  <a href="#a81627a008970ff5a61bfb1e14ec234a6">More...</a><br/></td></tr>
<tr class="separator:a81627a008970ff5a61bfb1e14ec234a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d918c637b49410cda5ce76a24b465f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a2d918c637b49410cda5ce76a24b465f6">create_handle</a> (const std::string &amp;sequence, const <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &amp;<a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:a2d918c637b49410cda5ce76a24b465f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new node with the given id and sequence, then return the handle.  <a href="#a2d918c637b49410cda5ce76a24b465f6">More...</a><br/></td></tr>
<tr class="separator:a2d918c637b49410cda5ce76a24b465f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7303219550214d39fd7030ab0fec4bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#ab7303219550214d39fd7030ab0fec4bb">destroy_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle)</td></tr>
<tr class="separator:ab7303219550214d39fd7030ab0fec4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeec0612fcf13e4e1fc2ef3566577ae2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#adeec0612fcf13e4e1fc2ef3566577ae2">create_edge</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right)</td></tr>
<tr class="separator:adeec0612fcf13e4e1fc2ef3566577ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d96cfb6f21239655c5d29ee27039c1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a9d96cfb6f21239655c5d29ee27039c1d">destroy_edge</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right)</td></tr>
<tr class="separator:a9d96cfb6f21239655c5d29ee27039c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab71e7430cf6c1941dae6391b3891034"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#aab71e7430cf6c1941dae6391b3891034">clear</a> (void)</td></tr>
<tr class="memdesc:aab71e7430cf6c1941dae6391b3891034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all nodes and edges. Does not update any stored paths.  <a href="#aab71e7430cf6c1941dae6391b3891034">More...</a><br/></td></tr>
<tr class="separator:aab71e7430cf6c1941dae6391b3891034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa743018733bc15ec3bb4af4516041be7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#aa743018733bc15ec3bb4af4516041be7">apply_orientation</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle)</td></tr>
<tr class="separator:aa743018733bc15ec3bb4af4516041be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7ad0e766a15d8f2992eb1bd557b987"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a5b7ad0e766a15d8f2992eb1bd557b987">divide_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const std::vector&lt; size_t &gt; &amp;offsets)</td></tr>
<tr class="separator:a5b7ad0e766a15d8f2992eb1bd557b987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ca74884d23adfee43225ca141a8dec"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#af2ca74884d23adfee43225ca141a8dec">get_path_count</a> () const </td></tr>
<tr class="memdesc:af2ca74884d23adfee43225ca141a8dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of paths stored in the graph.  <a href="#af2ca74884d23adfee43225ca141a8dec">More...</a><br/></td></tr>
<tr class="separator:af2ca74884d23adfee43225ca141a8dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cd5723ae6daeebf665e438028502f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a13cd5723ae6daeebf665e438028502f7">has_path</a> (const std::string &amp;path_name) const </td></tr>
<tr class="memdesc:a13cd5723ae6daeebf665e438028502f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a path name exists and is legal to get a path handle for.  <a href="#a13cd5723ae6daeebf665e438028502f7">More...</a><br/></td></tr>
<tr class="separator:a13cd5723ae6daeebf665e438028502f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c7e1d168fad98be732b80cbf4c87ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#aa0c7e1d168fad98be732b80cbf4c87ff">get_path_handle</a> (const std::string &amp;path_name) const </td></tr>
<tr class="separator:aa0c7e1d168fad98be732b80cbf4c87ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645cc630338a8b22385e689fbc958da2"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a645cc630338a8b22385e689fbc958da2">get_path_name</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const </td></tr>
<tr class="memdesc:a645cc630338a8b22385e689fbc958da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the name of a path from a handle to it.  <a href="#a645cc630338a8b22385e689fbc958da2">More...</a><br/></td></tr>
<tr class="separator:a645cc630338a8b22385e689fbc958da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec02c3f969dea36259b1febf3f47fb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#adec02c3f969dea36259b1febf3f47fb5">get_is_circular</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const </td></tr>
<tr class="memdesc:adec02c3f969dea36259b1febf3f47fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up whether a path is circular.  <a href="#adec02c3f969dea36259b1febf3f47fb5">More...</a><br/></td></tr>
<tr class="separator:adec02c3f969dea36259b1febf3f47fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb019b26cd5055fd2925cf560361781c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#adb019b26cd5055fd2925cf560361781c">get_step_count</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const </td></tr>
<tr class="memdesc:adb019b26cd5055fd2925cf560361781c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of node steps in the path.  <a href="#adb019b26cd5055fd2925cf560361781c">More...</a><br/></td></tr>
<tr class="separator:adb019b26cd5055fd2925cf560361781c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b75917e641622bcd9e219328b376cc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a6b75917e641622bcd9e219328b376cc4">get_handle_of_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const </td></tr>
<tr class="memdesc:a6b75917e641622bcd9e219328b376cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a node handle (node ID and orientation) from a handle to an step on a path.  <a href="#a6b75917e641622bcd9e219328b376cc4">More...</a><br/></td></tr>
<tr class="separator:a6b75917e641622bcd9e219328b376cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa156ded7ff506b1d7e4022d11ca22f0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#aa156ded7ff506b1d7e4022d11ca22f0e">path_begin</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const </td></tr>
<tr class="separator:aa156ded7ff506b1d7e4022d11ca22f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254f9326e56a1d51e406d67272b9315b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a254f9326e56a1d51e406d67272b9315b">path_end</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const </td></tr>
<tr class="separator:a254f9326e56a1d51e406d67272b9315b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add76118cc368710ef4cf3a8c42ed9e4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#add76118cc368710ef4cf3a8c42ed9e4f">get_next_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const </td></tr>
<tr class="separator:add76118cc368710ef4cf3a8c42ed9e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc5afeb4ee7b6528a4d18cc8fdf3102"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a7bc5afeb4ee7b6528a4d18cc8fdf3102">get_previous_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const </td></tr>
<tr class="separator:a7bc5afeb4ee7b6528a4d18cc8fdf3102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e974a94f4c6b70e95ebf93eebb31f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a13e974a94f4c6b70e95ebf93eebb31f7">get_path_handle_of_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const </td></tr>
<tr class="memdesc:a13e974a94f4c6b70e95ebf93eebb31f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a handle to the path that an step is on.  <a href="#a13e974a94f4c6b70e95ebf93eebb31f7">More...</a><br/></td></tr>
<tr class="separator:a13e974a94f4c6b70e95ebf93eebb31f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718d6317146b977dbc3319a1b678e568"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a718d6317146b977dbc3319a1b678e568">for_each_path_handle_impl</a> (const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; &amp;iteratee) const </td></tr>
<tr class="memdesc:a718d6317146b977dbc3319a1b678e568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a function on each path in the graph.  <a href="#a718d6317146b977dbc3319a1b678e568">More...</a><br/></td></tr>
<tr class="separator:a718d6317146b977dbc3319a1b678e568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ada20d068021f390084c4a65662397"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#af4ada20d068021f390084c4a65662397">for_each_step_on_handle_impl</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const function&lt; bool(const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;)&gt; &amp;iteratee) const </td></tr>
<tr class="memdesc:af4ada20d068021f390084c4a65662397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the given function for each step of the given handle on a path.  <a href="#af4ada20d068021f390084c4a65662397">More...</a><br/></td></tr>
<tr class="separator:af4ada20d068021f390084c4a65662397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1840f8ccf0d3885913c8a0a616955f18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a1840f8ccf0d3885913c8a0a616955f18">destroy_path</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path)</td></tr>
<tr class="separator:a1840f8ccf0d3885913c8a0a616955f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e15ac4a634370a741180edcb077a6d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a2e15ac4a634370a741180edcb077a6d9">create_path_handle</a> (const string &amp;name, bool is_circular=false)</td></tr>
<tr class="separator:a2e15ac4a634370a741180edcb077a6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d01b62c6ef94590e19cac29253ae7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#af3d01b62c6ef94590e19cac29253ae7d">append_step</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;to_append)</td></tr>
<tr class="separator:af3d01b62c6ef94590e19cac29253ae7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54ce3460954e9e7dcdee9f7c3a2a16b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#ae54ce3460954e9e7dcdee9f7c3a2a16b">prepend_step</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;to_prepend)</td></tr>
<tr class="separator:ae54ce3460954e9e7dcdee9f7c3a2a16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29790b629ec299e66c8873b8629a4ce0"><td class="memItemLeft" align="right" valign="top">pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <br class="typebreak"/>
<a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a29790b629ec299e66c8873b8629a4ce0">rewrite_segment</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;segment_begin, const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;segment_end, const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;new_segment)</td></tr>
<tr class="separator:a29790b629ec299e66c8873b8629a4ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48ebc3cb8ca87fa07a73620a30eb9d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#af48ebc3cb8ca87fa07a73620a30eb9d5">set_circularity</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path, bool circular)</td></tr>
<tr class="separator:af48ebc3cb8ca87fa07a73620a30eb9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b3f235ce99bb842a6dfa96b4acfdec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a87b3f235ce99bb842a6dfa96b4acfdec">compactify</a> (void)</td></tr>
<tr class="memdesc:a87b3f235ce99bb842a6dfa96b4acfdec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized <a class="el" href="classvg_1_1PackedGraph.html">PackedGraph</a> methods.  <a href="#a87b3f235ce99bb842a6dfa96b4acfdec">More...</a><br/></td></tr>
<tr class="separator:a87b3f235ce99bb842a6dfa96b4acfdec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1MutablePathHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html">handlegraph::MutablePathHandleGraph</a></td></tr>
<tr class="memitem:a0873a6eb776bb2557a5b8453dbf13824 inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#a0873a6eb776bb2557a5b8453dbf13824">create_path_handle</a> (const std::string &amp;name, bool is_circular=false)=0</td></tr>
<tr class="separator:a0873a6eb776bb2557a5b8453dbf13824 inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28f1372aa6dad2654a22eb8463e2a07 inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual std::pair<br class="typebreak"/>
&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#af28f1372aa6dad2654a22eb8463e2a07">rewrite_segment</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;segment_begin, const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;segment_end, const std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;new_segment)=0</td></tr>
<tr class="separator:af28f1372aa6dad2654a22eb8463e2a07 inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1PathHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1PathHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">handlegraph::PathHandleGraph</a></td></tr>
<tr class="memitem:a3313c420e4cf77baf157af2732848850 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a3313c420e4cf77baf157af2732848850 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a3313c420e4cf77baf157af2732848850">for_each_path_handle</a> (const Iteratee &amp;iteratee) const </td></tr>
<tr class="separator:a3313c420e4cf77baf157af2732848850 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63696ee6a047a75505c6096c635c16b inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:ae63696ee6a047a75505c6096c635c16b inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#ae63696ee6a047a75505c6096c635c16b">for_each_step_on_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const Iteratee &amp;iteratee) const </td></tr>
<tr class="separator:ae63696ee6a047a75505c6096c635c16b inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac121fdcefdeffba0a88b6bd3a2789471 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual std::vector<br class="typebreak"/>
&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#ac121fdcefdeffba0a88b6bd3a2789471">steps_of_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool match_orientation=false) const </td></tr>
<tr class="separator:ac121fdcefdeffba0a88b6bd3a2789471 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed6b61e10e5ad54812cf8bac2d56e9f inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a0ed6b61e10e5ad54812cf8bac2d56e9f">is_empty</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const </td></tr>
<tr class="memdesc:a0ed6b61e10e5ad54812cf8bac2d56e9f inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given path is empty, and false otherwise.  <a href="#a0ed6b61e10e5ad54812cf8bac2d56e9f">More...</a><br/></td></tr>
<tr class="separator:a0ed6b61e10e5ad54812cf8bac2d56e9f inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade32a59c445376a454c9a2526c5260cc inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhandlegraph_1_1PathForEachSocket.html">PathForEachSocket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#ade32a59c445376a454c9a2526c5260cc">scan_path</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path) const </td></tr>
<tr class="separator:ade32a59c445376a454c9a2526c5260cc inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c085eb8590fff9d4035a9bf87cf7a7 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a31c085eb8590fff9d4035a9bf87cf7a7 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a31c085eb8590fff9d4035a9bf87cf7a7">for_each_step_in_path</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path, const Iteratee &amp;iteratee) const </td></tr>
<tr class="separator:a31c085eb8590fff9d4035a9bf87cf7a7 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1HandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1HandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1HandleGraph.html">handlegraph::HandleGraph</a></td></tr>
<tr class="memitem:a5dcea1610fac82460ff304e07b4dd6e0 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a5dcea1610fac82460ff304e07b4dd6e0 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a5dcea1610fac82460ff304e07b4dd6e0">follow_edges</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left, const Iteratee &amp;iteratee) const </td></tr>
<tr class="separator:a5dcea1610fac82460ff304e07b4dd6e0 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19cbfb7cccb8b05d3952b0c7a0e60c1c inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a19cbfb7cccb8b05d3952b0c7a0e60c1c inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a19cbfb7cccb8b05d3952b0c7a0e60c1c">for_each_handle</a> (const Iteratee &amp;iteratee, bool parallel=false) const </td></tr>
<tr class="separator:a19cbfb7cccb8b05d3952b0c7a0e60c1c inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8800aafcd81470ba313839138f608a39 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a8800aafcd81470ba313839138f608a39">get_degree</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left) const </td></tr>
<tr class="separator:a8800aafcd81470ba313839138f608a39 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda410641b362f9530c62dd503a7abec inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#adda410641b362f9530c62dd503a7abec">has_edge</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right) const </td></tr>
<tr class="separator:adda410641b362f9530c62dd503a7abec inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6828fde4d2a0063efef7e421a4118c inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a6f6828fde4d2a0063efef7e421a4118c">has_edge</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge)</td></tr>
<tr class="memdesc:a6f6828fde4d2a0063efef7e421a4118c inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient wrapper of has_edge for edge_t argument.  <a href="#a6f6828fde4d2a0063efef7e421a4118c">More...</a><br/></td></tr>
<tr class="separator:a6f6828fde4d2a0063efef7e421a4118c inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996223319f59bf614a02a78a3038bd89 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a996223319f59bf614a02a78a3038bd89">forward</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const </td></tr>
<tr class="memdesc:a996223319f59bf614a02a78a3038bd89 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the locally forward version of a handle.  <a href="#a996223319f59bf614a02a78a3038bd89">More...</a><br/></td></tr>
<tr class="separator:a996223319f59bf614a02a78a3038bd89 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e807b8d982fe8d55166c1685a1d4918 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a3e807b8d982fe8d55166c1685a1d4918">edge_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right) const </td></tr>
<tr class="separator:a3e807b8d982fe8d55166c1685a1d4918 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b2c0307f4fafb0acd3a0c02fe578b9 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#ad4b2c0307f4fafb0acd3a0c02fe578b9">traverse_edge_handle</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left) const </td></tr>
<tr class="separator:ad4b2c0307f4fafb0acd3a0c02fe578b9 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a10d13e6e403d64221c0b2f3566b78f inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a6a10d13e6e403d64221c0b2f3566b78f inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a6a10d13e6e403d64221c0b2f3566b78f">for_each_edge</a> (const Iteratee &amp;iteratee, bool parallel=false) const </td></tr>
<tr class="separator:a6a10d13e6e403d64221c0b2f3566b78f inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1MutableHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1MutableHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">handlegraph::MutableHandleGraph</a></td></tr>
<tr class="memitem:a3ff0a0f9497da3498170fdfc2ce97797 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a3ff0a0f9497da3498170fdfc2ce97797">create_edge</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge)</td></tr>
<tr class="memdesc:a3ff0a0f9497da3498170fdfc2ce97797 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient wrapper for create_edge.  <a href="#a3ff0a0f9497da3498170fdfc2ce97797">More...</a><br/></td></tr>
<tr class="separator:a3ff0a0f9497da3498170fdfc2ce97797 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c38787f0ff4a2695e61d98cb402175 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a05c38787f0ff4a2695e61d98cb402175">divide_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, size_t offset)</td></tr>
<tr class="memdesc:a05c38787f0ff4a2695e61d98cb402175 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of divide_handle for a single division point.  <a href="#a05c38787f0ff4a2695e61d98cb402175">More...</a><br/></td></tr>
<tr class="separator:a05c38787f0ff4a2695e61d98cb402175 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1DeletableHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">handlegraph::DeletableHandleGraph</a></td></tr>
<tr class="memitem:aec2b397c1b4ec7f9c75ccc5b9ce06564 inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#aec2b397c1b4ec7f9c75ccc5b9ce06564">destroy_edge</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge)</td></tr>
<tr class="memdesc:aec2b397c1b4ec7f9c75ccc5b9ce06564 inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient wrapper for destroy_edge.  <a href="#aec2b397c1b4ec7f9c75ccc5b9ce06564">More...</a><br/></td></tr>
<tr class="separator:aec2b397c1b4ec7f9c75ccc5b9ce06564 inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ac43f7cfe8c2733b9e5d22c07d079b4c0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#ac43f7cfe8c2733b9e5d22c07d079b4c0">new_node_record</a> (<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> node_id)</td></tr>
<tr class="separator:ac43f7cfe8c2733b9e5d22c07d079b4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815c50fcafe42eceb57fa805e26c15a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a815c50fcafe42eceb57fa805e26c15a2">remove_edge_reference</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;on, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;to)</td></tr>
<tr class="memdesc:a815c50fcafe42eceb57fa805e26c15a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and edge on given handle, to a given handle, and remove it from the edge list.  <a href="#a815c50fcafe42eceb57fa805e26c15a2">More...</a><br/></td></tr>
<tr class="separator:a815c50fcafe42eceb57fa805e26c15a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a33e7f7f3e6bb52c4c18c9aff8ed0e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a4a33e7f7f3e6bb52c4c18c9aff8ed0e0">eject_deleted_paths</a> ()</td></tr>
<tr class="memdesc:a4a33e7f7f3e6bb52c4c18c9aff8ed0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we've deleted any paths, remove them from the paths vector and reassign path IDs.  <a href="#a4a33e7f7f3e6bb52c4c18c9aff8ed0e0">More...</a><br/></td></tr>
<tr class="separator:a4a33e7f7f3e6bb52c4c18c9aff8ed0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f66502e40b92222c957aa7aab1b4bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a27f66502e40b92222c957aa7aab1b4bf">defragment</a> (bool force=false)</td></tr>
<tr class="separator:a27f66502e40b92222c957aa7aab1b4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487cc1ff62ce2b45ecfae8cf03f3f80b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a487cc1ff62ce2b45ecfae8cf03f3f80b">defragment_path</a> (<a class="el" href="structvg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> &amp;path, bool force=false)</td></tr>
<tr class="separator:a487cc1ff62ce2b45ecfae8cf03f3f80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37cc4482ff4e28d72fbabc46425ee65a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a37cc4482ff4e28d72fbabc46425ee65a">encode_nucleotide</a> (const char &amp;nt) const </td></tr>
<tr class="memdesc:a37cc4482ff4e28d72fbabc46425ee65a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience functions to translate between encodings in the vectors.  <a href="#a37cc4482ff4e28d72fbabc46425ee65a">More...</a><br/></td></tr>
<tr class="separator:a37cc4482ff4e28d72fbabc46425ee65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ccd8da2c15a7f3f60f76985938e08c"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a18ccd8da2c15a7f3f60f76985938e08c">decode_nucleotide</a> (const uint64_t &amp;val) const </td></tr>
<tr class="separator:a18ccd8da2c15a7f3f60f76985938e08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47116e32d103cb77f2e771d79ba2491"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#af47116e32d103cb77f2e771d79ba2491">complement_encoded_nucleotide</a> (const uint64_t &amp;val) const </td></tr>
<tr class="separator:af47116e32d103cb77f2e771d79ba2491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c006ce06a15ff022d28cca7a307af55"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a9c006ce06a15ff022d28cca7a307af55">graph_iv_index</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const </td></tr>
<tr class="separator:a9c006ce06a15ff022d28cca7a307af55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc540897eeaeb048ca255ca9557951c0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#afc540897eeaeb048ca255ca9557951c0">graph_index_to_seq_len_index</a> (const size_t &amp;graph_index) const </td></tr>
<tr class="separator:afc540897eeaeb048ca255ca9557951c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14def552979728ce470d58d80831d620"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a14def552979728ce470d58d80831d620">graph_index_to_seq_start_index</a> (const size_t &amp;graph_index) const </td></tr>
<tr class="separator:a14def552979728ce470d58d80831d620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04450e3349e5e82d5826be886256e67"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#ab04450e3349e5e82d5826be886256e67">graph_index_to_node_member_index</a> (const size_t &amp;graph_index) const </td></tr>
<tr class="separator:ab04450e3349e5e82d5826be886256e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae896ca69226b0a49b66c9be16c216b74"><td class="memItemLeft" align="right" valign="top">const uint64_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#ae896ca69226b0a49b66c9be16c216b74">encode_traversal</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const </td></tr>
<tr class="separator:ae896ca69226b0a49b66c9be16c216b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe84c2d3f394d8c27990aa8288cb187"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a3fe84c2d3f394d8c27990aa8288cb187">decode_traversal</a> (const uint64_t &amp;val) const </td></tr>
<tr class="separator:a3fe84c2d3f394d8c27990aa8288cb187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66741cf53286444b967af6a1b91815e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#ae66741cf53286444b967af6a1b91815e">get_next_edge_index</a> (const uint64_t &amp;edge_index) const </td></tr>
<tr class="separator:ae66741cf53286444b967af6a1b91815e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbcfc96892fd8e3c169fd88207b7835"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a6fbcfc96892fd8e3c169fd88207b7835">get_edge_target</a> (const uint64_t &amp;edge_index) const </td></tr>
<tr class="separator:a6fbcfc96892fd8e3c169fd88207b7835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b18ce1fb030c1fb7327e4afe5e1f38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#ab5b18ce1fb030c1fb7327e4afe5e1f38">set_edge_target</a> (const uint64_t &amp;edge_index, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle)</td></tr>
<tr class="separator:ab5b18ce1fb030c1fb7327e4afe5e1f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a732e0e7c999a574a5d62882ce5485645"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a732e0e7c999a574a5d62882ce5485645">get_next_membership</a> (const uint64_t &amp;membership_index) const </td></tr>
<tr class="separator:a732e0e7c999a574a5d62882ce5485645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94ec2ec4e131fcf6fe9b0453a2ddce1"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#ae94ec2ec4e131fcf6fe9b0453a2ddce1">get_membership_step</a> (const uint64_t &amp;membership_index) const </td></tr>
<tr class="separator:ae94ec2ec4e131fcf6fe9b0453a2ddce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808a866f63de4bf3e5dc498f5aa12df4"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a808a866f63de4bf3e5dc498f5aa12df4">get_membership_path</a> (const uint64_t &amp;membership_index) const </td></tr>
<tr class="separator:a808a866f63de4bf3e5dc498f5aa12df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e3994de60e5e43b564fa02a061cb61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#ad0e3994de60e5e43b564fa02a061cb61">set_next_membership</a> (const uint64_t &amp;membership_index, const uint64_t &amp;next)</td></tr>
<tr class="separator:ad0e3994de60e5e43b564fa02a061cb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf4c21b1bfceca8ec1943bdb8fcfafa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#acdf4c21b1bfceca8ec1943bdb8fcfafa">set_membership_step</a> (const uint64_t &amp;membership_index, const uint64_t &amp;step)</td></tr>
<tr class="separator:acdf4c21b1bfceca8ec1943bdb8fcfafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd34ad81d04491ef967174a737787bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#aedd34ad81d04491ef967174a737787bf">set_membership_path</a> (const uint64_t &amp;membership_index, const uint64_t &amp;path)</td></tr>
<tr class="separator:aedd34ad81d04491ef967174a737787bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a9622b28dda6d9044b7fa9fe0f15fc"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#ae4a9622b28dda6d9044b7fa9fe0f15fc">get_step_trav</a> (const <a class="el" href="structvg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> &amp;path, const uint64_t &amp;step_index) const </td></tr>
<tr class="separator:ae4a9622b28dda6d9044b7fa9fe0f15fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af240bb7b43a92817b4ab8c672e47a55a"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#af240bb7b43a92817b4ab8c672e47a55a">get_step_prev</a> (const <a class="el" href="structvg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> &amp;path, const uint64_t &amp;step_index) const </td></tr>
<tr class="separator:af240bb7b43a92817b4ab8c672e47a55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ab2801bd25e0982cb2e9f9d79b366a"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a38ab2801bd25e0982cb2e9f9d79b366a">get_step_next</a> (const <a class="el" href="structvg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> &amp;path, const uint64_t &amp;step_index) const </td></tr>
<tr class="separator:a38ab2801bd25e0982cb2e9f9d79b366a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb4e3f7fb25c8986ef99b60ba5a95a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a0bb4e3f7fb25c8986ef99b60ba5a95a9">set_step_trav</a> (<a class="el" href="structvg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> &amp;path, const uint64_t &amp;step_index, const uint64_t &amp;trav)</td></tr>
<tr class="separator:a0bb4e3f7fb25c8986ef99b60ba5a95a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541350620e4c9a4be7f198b643feec1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a541350620e4c9a4be7f198b643feec1f">set_step_prev</a> (<a class="el" href="structvg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> &amp;path, const uint64_t &amp;step_index, const uint64_t &amp;prev_index)</td></tr>
<tr class="separator:a541350620e4c9a4be7f198b643feec1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac8c11725824173d4566cc522ede043"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a2ac8c11725824173d4566cc522ede043">set_step_next</a> (<a class="el" href="structvg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> &amp;path, const uint64_t &amp;step_index, const uint64_t &amp;next_index)</td></tr>
<tr class="separator:a2ac8c11725824173d4566cc522ede043"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a1f70696ea881303deb5c8d718fa537e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a1f70696ea881303deb5c8d718fa537e3">max_id</a> = 0</td></tr>
<tr class="memdesc:a1f70696ea881303deb5c8d718fa537e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum ID in the graph.  <a href="#a1f70696ea881303deb5c8d718fa537e3">More...</a><br/></td></tr>
<tr class="separator:a1f70696ea881303deb5c8d718fa537e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932ff978adf42a3389923af0720f129c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a932ff978adf42a3389923af0720f129c">min_id</a> = std::numeric_limits&lt;<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&gt;::max()</td></tr>
<tr class="memdesc:a932ff978adf42a3389923af0720f129c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum ID in the graph.  <a href="#a932ff978adf42a3389923af0720f129c">More...</a><br/></td></tr>
<tr class="separator:a932ff978adf42a3389923af0720f129c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5915df07a9f9027edf54fd8b5b8b8dfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1PagedVector.html">PagedVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a5915df07a9f9027edf54fd8b5b8b8dfb">graph_iv</a></td></tr>
<tr class="separator:a5915df07a9f9027edf54fd8b5b8b8dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d2debbc4175fec335d8817708b69a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1PagedVector.html">PagedVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#ac7d2debbc4175fec335d8817708b69a0">seq_start_iv</a></td></tr>
<tr class="memdesc:ac7d2debbc4175fec335d8817708b69a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the start of a node's sequence in seq_iv. Matches the order of graph_iv.  <a href="#ac7d2debbc4175fec335d8817708b69a0">More...</a><br/></td></tr>
<tr class="separator:ac7d2debbc4175fec335d8817708b69a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a48b43e3e6bdc6b21951d24b7fa7a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1PackedVector.html">PackedVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#ae4a48b43e3e6bdc6b21951d24b7fa7a9">seq_length_iv</a></td></tr>
<tr class="memdesc:ae4a48b43e3e6bdc6b21951d24b7fa7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the length of a node's sequence in seq_iv. Matches the order of graph_iv.  <a href="#ae4a48b43e3e6bdc6b21951d24b7fa7a9">More...</a><br/></td></tr>
<tr class="separator:ae4a48b43e3e6bdc6b21951d24b7fa7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe70e0219efd0b57399982c12fc49ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1PagedVector.html">PagedVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#aafe70e0219efd0b57399982c12fc49ee">edge_lists_iv</a></td></tr>
<tr class="separator:aafe70e0219efd0b57399982c12fc49ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513189c05c6f624f996fe5b045477512"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1PackedDeque.html">PackedDeque</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a513189c05c6f624f996fe5b045477512">id_to_graph_iv</a></td></tr>
<tr class="separator:a513189c05c6f624f996fe5b045477512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99e2f08212cbff6a091fe37e618cc4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1PackedVector.html">PackedVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#ab99e2f08212cbff6a091fe37e618cc4b">seq_iv</a></td></tr>
<tr class="memdesc:ab99e2f08212cbff6a091fe37e618cc4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes all of the sequences of all nodes in the graph.  <a href="#ab99e2f08212cbff6a091fe37e618cc4b">More...</a><br/></td></tr>
<tr class="separator:ab99e2f08212cbff6a091fe37e618cc4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75428a60532edb8d43d166621aba1f56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1PagedVector.html">PagedVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a75428a60532edb8d43d166621aba1f56">path_membership_node_iv</a></td></tr>
<tr class="separator:a75428a60532edb8d43d166621aba1f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c402f1d539134d6a9a6c7453e52710f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1PagedVector.html">PagedVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a6c402f1d539134d6a9a6c7453e52710f">path_membership_id_iv</a></td></tr>
<tr class="separator:a6c402f1d539134d6a9a6c7453e52710f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37afe277bbd7412d561117d6eb97b346"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1PagedVector.html">PagedVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a37afe277bbd7412d561117d6eb97b346">path_membership_offset_iv</a></td></tr>
<tr class="memdesc:a37afe277bbd7412d561117d6eb97b346"><td class="mdescLeft">&#160;</td><td class="mdescRight">1-based offset of the occurrence of the node in the corresponding <a class="el" href="structvg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> vector.  <a href="#a37afe277bbd7412d561117d6eb97b346">More...</a><br/></td></tr>
<tr class="separator:a37afe277bbd7412d561117d6eb97b346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973617a65121afa8a2917761e58b83c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1PagedVector.html">PagedVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a973617a65121afa8a2917761e58b83c0">path_membership_next_iv</a></td></tr>
<tr class="separator:a973617a65121afa8a2917761e58b83c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b511822169f490c769e20e6f6dcf2f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1string__hash__map.html">string_hash_map</a>&lt; string, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a0b511822169f490c769e20e6f6dcf2f5">path_id</a></td></tr>
<tr class="memdesc:a0b511822169f490c769e20e6f6dcf2f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map from path names to index in the paths vector.  <a href="#a0b511822169f490c769e20e6f6dcf2f5">More...</a><br/></td></tr>
<tr class="separator:a0b511822169f490c769e20e6f6dcf2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf783e035e29c9584ffc0cdd882260f"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#abdf783e035e29c9584ffc0cdd882260f">paths</a></td></tr>
<tr class="memdesc:abdf783e035e29c9584ffc0cdd882260f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of the embedded paths in the graph.  <a href="#abdf783e035e29c9584ffc0cdd882260f">More...</a><br/></td></tr>
<tr class="separator:abdf783e035e29c9584ffc0cdd882260f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00427073fe898e5d8d88d3ceb44f9365"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a00427073fe898e5d8d88d3ceb44f9365">deleted_node_records</a> = 0</td></tr>
<tr class="separator:a00427073fe898e5d8d88d3ceb44f9365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ddf4f1e79e7f38e339cd5fea4f0304"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a54ddf4f1e79e7f38e339cd5fea4f0304">deleted_edge_records</a> = 0</td></tr>
<tr class="separator:a54ddf4f1e79e7f38e339cd5fea4f0304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d5976b3c64b4ac1972ba9789c49fd1"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a00d5976b3c64b4ac1972ba9789c49fd1">deleted_membership_records</a> = 0</td></tr>
<tr class="separator:a00d5976b3c64b4ac1972ba9789c49fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:abd7e5dc4f51d971279498d333e135f11"><td class="memItemLeft" align="right" valign="top">static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#abd7e5dc4f51d971279498d333e135f11">defrag_factor</a> = .2</td></tr>
<tr class="memdesc:abd7e5dc4f51d971279498d333e135f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defragment when the orphaned records are this fraction of the whole.  <a href="#abd7e5dc4f51d971279498d333e135f11">More...</a><br/></td></tr>
<tr class="separator:abd7e5dc4f51d971279498d333e135f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2448556d94acc07aa90b1e4b548f16e2"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a2448556d94acc07aa90b1e4b548f16e2">PAGE_WIDTH</a> = 128</td></tr>
<tr class="memdesc:a2448556d94acc07aa90b1e4b548f16e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">We use a standard page width for all page-compressed vectors.  <a href="#a2448556d94acc07aa90b1e4b548f16e2">More...</a><br/></td></tr>
<tr class="separator:a2448556d94acc07aa90b1e4b548f16e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d329b354cd2c995cd12a2c73853167"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#ae2d329b354cd2c995cd12a2c73853167">GRAPH_RECORD_SIZE</a> = 2</td></tr>
<tr class="separator:ae2d329b354cd2c995cd12a2c73853167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ebc41729ec0a4515a179b6defddcb9"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#ab1ebc41729ec0a4515a179b6defddcb9">GRAPH_START_EDGES_OFFSET</a> = 0</td></tr>
<tr class="separator:ab1ebc41729ec0a4515a179b6defddcb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab906fbd319bb59570a8d1d3ccf27d80b"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#ab906fbd319bb59570a8d1d3ccf27d80b">GRAPH_END_EDGES_OFFSET</a> = 1</td></tr>
<tr class="separator:ab906fbd319bb59570a8d1d3ccf27d80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689377dfb144ffa13bf68ed062199eb8"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a689377dfb144ffa13bf68ed062199eb8">SEQ_START_RECORD_SIZE</a> = 1</td></tr>
<tr class="separator:a689377dfb144ffa13bf68ed062199eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaaaab401ca3965e907d96b0cff56b11"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#adaaaab401ca3965e907d96b0cff56b11">SEQ_LENGTH_RECORD_SIZE</a> = 1</td></tr>
<tr class="separator:adaaaab401ca3965e907d96b0cff56b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb24cfbf0b50892939d200e5e93d7b1"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a9fb24cfbf0b50892939d200e5e93d7b1">EDGE_RECORD_SIZE</a> = 2</td></tr>
<tr class="separator:a9fb24cfbf0b50892939d200e5e93d7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdd3120e81fd2ca8a4a4e4fa945890b"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#affdd3120e81fd2ca8a4a4e4fa945890b">EDGE_TRAV_OFFSET</a> = 0</td></tr>
<tr class="separator:affdd3120e81fd2ca8a4a4e4fa945890b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9378fc747024443b37b10601fa01624"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#ac9378fc747024443b37b10601fa01624">EDGE_NEXT_OFFSET</a> = 1</td></tr>
<tr class="separator:ac9378fc747024443b37b10601fa01624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af788380d2585197c95bda5f133351398"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#af788380d2585197c95bda5f133351398">NODE_MEMBER_RECORD_SIZE</a> = 1</td></tr>
<tr class="separator:af788380d2585197c95bda5f133351398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cdaf84ef6f5746d7c595213c228c19"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a13cdaf84ef6f5746d7c595213c228c19">MEMBERSHIP_ID_RECORD_SIZE</a> = 1</td></tr>
<tr class="separator:a13cdaf84ef6f5746d7c595213c228c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8f3e26e84a1a59ce2175fa7b4a61c3"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#abe8f3e26e84a1a59ce2175fa7b4a61c3">MEMBERSHIP_OFFSET_RECORD_SIZE</a> = 1</td></tr>
<tr class="separator:abe8f3e26e84a1a59ce2175fa7b4a61c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b3680f244409f77233f9bf5c1d28c5"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a46b3680f244409f77233f9bf5c1d28c5">MEMBERSHIP_NEXT_RECORD_SIZE</a> = 1</td></tr>
<tr class="separator:a46b3680f244409f77233f9bf5c1d28c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed96ecea43ddc6d67f43d86954a05738"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#aed96ecea43ddc6d67f43d86954a05738">PATH_RECORD_SIZE</a> = 2</td></tr>
<tr class="separator:aed96ecea43ddc6d67f43d86954a05738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49dd379a28da06a70f2c6c400123b735"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a49dd379a28da06a70f2c6c400123b735">PATH_PREV_OFFSET</a> = 0</td></tr>
<tr class="separator:a49dd379a28da06a70f2c6c400123b735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ea35be78eaa547ebd7388a17445792"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a26ea35be78eaa547ebd7388a17445792">PATH_NEXT_OFFSET</a> = 1</td></tr>
<tr class="separator:a26ea35be78eaa547ebd7388a17445792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98bf9690a767e62345d46d57e712b239"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedGraph.html#a98bf9690a767e62345d46d57e712b239">STEP_RECORD_SIZE</a> = 1</td></tr>
<tr class="separator:a98bf9690a767e62345d46d57e712b239"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classhandlegraph_1_1PathHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classhandlegraph_1_1PathHandleGraph')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">handlegraph::PathHandleGraph</a></td></tr>
<tr class="memitem:a2bbdf56b268001c629cf000f5bd8bb9a inherit pro_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a2bbdf56b268001c629cf000f5bd8bb9a">for_each_step_on_handle_impl</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;)&gt; &amp;iteratee) const =0</td></tr>
<tr class="separator:a2bbdf56b268001c629cf000f5bd8bb9a inherit pro_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a132c63e64b953aea4d5ed4732e832931"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::PackedGraph::PackedGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a624885b445c2e1d3b184d9c0c7a21d2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::PackedGraph::~PackedGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afee9fc527de97b9a0798323ae5bd37d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::PackedGraph::PackedGraph </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct from a stream. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af3d01b62c6ef94590e19cac29253ae7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> vg::PackedGraph::append_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to_append</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Append a visit to a node to the given path. Returns a handle to the new final step on the path which is appended. Handles to prior steps on the path, and to other paths, must remain valid. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#a83a4a14a629cde03d33e4eb3f6bb192d">handlegraph::MutablePathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="aa743018733bc15ec3bb4af4516041be7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::PackedGraph::apply_orientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alter the node that the given handle corresponds to so the orientation indicated by the handle becomes the node's local forward orientation. Rewrites all edges pointing to the node and the node's sequence to reflect this. Invalidates all handles to the node (including the one passed). Returns a new, valid handle to the node in its new forward orientation. Note that it is possible for the node's ID to change. Does not update any stored paths. May change the ordering of the underlying graph. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a71433449cb13e22dc19caaf544b6d7bc">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="aab71e7430cf6c1941dae6391b3891034"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PackedGraph::clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all nodes and edges. Does not update any stored paths. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#a6e1a83e72b47643e43c6176f39d8db5e">handlegraph::DeletableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a87b3f235ce99bb842a6dfa96b4acfdec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PackedGraph::compactify </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialized <a class="el" href="classvg_1_1PackedGraph.html">PackedGraph</a> methods. </p>
<p>Attempt to compress data into less memory, possibly using more memory temporarily (especially useful before serializing). <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a> handles remain valid, but path and step handles are invalidated. </p>

</div>
</div>
<a class="anchor" id="af47116e32d103cb77f2e771d79ba2491"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t vg::PackedGraph::complement_encoded_nucleotide </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adeec0612fcf13e4e1fc2ef3566577ae2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PackedGraph::create_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an edge connecting the given handles in the given order and orientations. Ignores existing edges. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a34a5e01f270713ba856a93c55039faf0">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a81627a008970ff5a61bfb1e14ec234a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::PackedGraph::create_handle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new node with the given sequence and return the handle. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a8c9d8ca8160a9b94a57000eab3e97aaa">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a2d918c637b49410cda5ce76a24b465f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::PackedGraph::create_handle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new node with the given id and sequence, then return the handle. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#ae844fce457858cd2dc54dde786f79e5c">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a2e15ac4a634370a741180edcb077a6d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> vg::PackedGraph::create_path_handle </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_circular</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a path with the given name. The caller must ensure that no path with the given name exists already, or the behavior is undefined. Returns a handle to the created empty path. Handles to other paths must remain valid. </p>

</div>
</div>
<a class="anchor" id="a18ccd8da2c15a7f3f60f76985938e08c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char vg::PackedGraph::decode_nucleotide </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3fe84c2d3f394d8c27990aa8288cb187"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp; vg::PackedGraph::decode_traversal </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a27f66502e40b92222c957aa7aab1b4bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PackedGraph::defragment </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if have orphaned enough records in the graph's various linked lists to warrant reallocating and defragmenting them. If so, do it. Optionally, defragment even if we have not deleted many things. </p>

</div>
</div>
<a class="anchor" id="a487cc1ff62ce2b45ecfae8cf03f3f80b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PackedGraph::defragment_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if have orphaned enough records in the linked list of the path to warrant reallocating and defragmenting it. If so, do it. Optionally, defragment even if we have not deleted many things. WARNING: invalidates step_handle_t's to this path. </p>

</div>
</div>
<a class="anchor" id="abd309cf7a7d2bc62e1ca5d2a178c5e8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PackedGraph::deserialize </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load contents from a stream and replace current contents. </p>

</div>
</div>
<a class="anchor" id="a9d96cfb6f21239655c5d29ee27039c1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PackedGraph::destroy_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove the edge connecting the given handles in the given order and orientations. Ignores nonexistent edges. Does not update any stored paths. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#a285ac35e805eab548c4106ee534d79f2">handlegraph::DeletableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="ab7303219550214d39fd7030ab0fec4bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PackedGraph::destroy_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove the node belonging to the given handle and all of its edges. Does not update any stored paths. Invalidates the destroyed handle. May be called during serial for_each_handle iteration <b>ONLY</b> on the node being iterated. May <b>NOT</b> be called during parallel for_each_handle iteration. May <b>NOT</b> be called on the node from which edges are being followed during follow_edges. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#a06d4d3ecda0694d5045c457f3eecd8e3">handlegraph::DeletableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a1840f8ccf0d3885913c8a0a616955f18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PackedGraph::destroy_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroy the given path. Invalidates handles to the path and its node steps. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#a05a7303ef2f259c6384b0b9b1f9d3f56">handlegraph::MutablePathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a5b7ad0e766a15d8f2992eb1bd557b987"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; vg::PackedGraph::divide_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a handle's underlying node at the given offsets in the handle's orientation. Returns all of the handles to the parts. Other handles to the node being split may be invalidated. The split pieces stay in the same local forward orientation as the original node, but the returned handles come in the order and orientation appropriate for the handle passed in. Updates stored paths. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#aca166406fa2000778552ed77c41a5e4c">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a4a33e7f7f3e6bb52c4c18c9aff8ed0e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PackedGraph::eject_deleted_paths </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If we've deleted any paths, remove them from the paths vector and reassign path IDs. </p>

</div>
</div>
<a class="anchor" id="a37cc4482ff4e28d72fbabc46425ee65a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t vg::PackedGraph::encode_nucleotide </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>nt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience functions to translate between encodings in the vectors. </p>

</div>
</div>
<a class="anchor" id="ae896ca69226b0a49b66c9be16c216b74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint64_t &amp; vg::PackedGraph::encode_traversal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a334cc87fba7fb59a317c049f95789fc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::PackedGraph::flip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invert the orientation of a handle (potentially without getting its ID) </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#aaa3f94ae7e884408ef6e8ca8fd45c7d7">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="ab8b94fb83b99c42d63634211aefe29b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::PackedGraph::follow_edges_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>go_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loop over all the handles to next/previous (right/left) nodes. Passes them to a callback which returns false to stop iterating and true to continue. Returns true if we finished and false if we stopped early. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a89bbc118fe1e8e1acb162c14be33e8b5">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="ac104360f349e95850117700aca78ad1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::PackedGraph::for_each_handle_impl </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loop over all the nodes in the graph in their local forward orientations, in their internal stored order. Stop if the iteratee returns false. Can be told to run in parallel, in which case stopping after a false return value is on a best-effort basis and iteration order is not defined. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#af48ba081fcb810267dc50e3a3e7ad391">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a718d6317146b977dbc3319a1b678e568"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::PackedGraph::for_each_path_handle_impl </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a function on each path in the graph. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a79f48793555f6be311f6df6603324e7b">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="af4ada20d068021f390084c4a65662397"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::PackedGraph::for_each_step_on_handle_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the given function for each step of the given handle on a path. </p>

</div>
</div>
<a class="anchor" id="a6fbcfc96892fd8e3c169fd88207b7835"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t vg::PackedGraph::get_edge_target </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>edge_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a086e9de2f2bafa5648ccaad339a31f50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::PackedGraph::get_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up the handle for the node with the given ID in the given orientation. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a6dd9d70931835f5c75518b23a780b744">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a6b75917e641622bcd9e219328b376cc4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::PackedGraph::get_handle_of_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a node handle (node ID and orientation) from a handle to an step on a path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a339e690ce3e2bb8280dd1f3ea45abe42">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a7ea2e0e792655f092ca39f0fb86eb245"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> vg::PackedGraph::get_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ID from a handle. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#adb7f6e144bf2a59679f7b2eddad934eb">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="adec02c3f969dea36259b1febf3f47fb5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::PackedGraph::get_is_circular </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up whether a path is circular. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a9391c34d9f0c16b21d5bb3bb7ec772e4">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="aff7a9dcea634bf8c65e35042d73c9c20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::PackedGraph::get_is_reverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the orientation of a handle. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a92773f90eb58f18adb9418a4440223c1">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="acc8e618ed215b7207fb2ac9810bc12be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::PackedGraph::get_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of a node. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a569ff35fb85c725b0b6b6933ed303e49">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a808a866f63de4bf3e5dc498f5aa12df4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t vg::PackedGraph::get_membership_path </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>membership_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae94ec2ec4e131fcf6fe9b0453a2ddce1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t vg::PackedGraph::get_membership_step </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>membership_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae66741cf53286444b967af6a1b91815e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t vg::PackedGraph::get_next_edge_index </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>edge_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a732e0e7c999a574a5d62882ce5485645"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t vg::PackedGraph::get_next_membership </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>membership_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="add76118cc368710ef4cf3a8c42ed9e4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> vg::PackedGraph::get_next_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a handle to the next step on the path. If the given step is the final step of a non-circular path, returns the past-the-last step that is also returned by path_end. In a circular path, the "last" step will loop around to the "first" (i.e. the one returned by path_begin). Note: to iterate over each step one time, even in a circular path, consider for_each_step_in_path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a209786f5c9e2c0210b383f2022ee221f">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="af2ca74884d23adfee43225ca141a8dec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::PackedGraph::get_path_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of paths stored in the graph. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#acd5df753593ecdfb7aa8c411b98ebad9">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="aa0c7e1d168fad98be732b80cbf4c87ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> vg::PackedGraph::get_path_handle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Look up the path handle for the given path name. The path with that name must exist. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a5d6059d716882a80e3982de17011866e">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a13e974a94f4c6b70e95ebf93eebb31f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> vg::PackedGraph::get_path_handle_of_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a handle to the path that an step is on. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a1d1ca9865da585257709f54769f5d6a9">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a645cc630338a8b22385e689fbc958da2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::PackedGraph::get_path_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up the name of a path from a handle to it. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a565f4312a42dfe77ae14c1ee9ed9f2ba">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a7bc5afeb4ee7b6528a4d18cc8fdf3102"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> vg::PackedGraph::get_previous_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a handle to the previous step on the path. If the given step is the first step of a non-circular path, this method has undefined behavior. In a circular path, it will loop around from the "first" step (i.e. the one returned by path_begin) to the "last" step. Note: to iterate over each step one time, even in a circular path, consider for_each_step_in_path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a71040226b29aa5046f4cc04c8c9aa9fb">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a1afe172126487f9d3acc1f306743353a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::PackedGraph::get_sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the sequence of a node, presented in the handle's local forward orientation. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a8cc2ab8a1292e30ba5e167a823f66d92">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="adb019b26cd5055fd2925cf560361781c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::PackedGraph::get_step_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of node steps in the path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#add91075c3490f8dc5acf667f2b26832c">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a38ab2801bd25e0982cb2e9f9d79b366a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t vg::PackedGraph::get_step_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>step_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af240bb7b43a92817b4ab8c672e47a55a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t vg::PackedGraph::get_step_prev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>step_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae4a9622b28dda6d9044b7fa9fe0f15fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t vg::PackedGraph::get_step_trav </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>step_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab04450e3349e5e82d5826be886256e67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t vg::PackedGraph::graph_index_to_node_member_index </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>graph_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afc540897eeaeb048ca255ca9557951c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t vg::PackedGraph::graph_index_to_seq_len_index </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>graph_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a14def552979728ce470d58d80831d620"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t vg::PackedGraph::graph_index_to_seq_start_index </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>graph_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9c006ce06a15ff022d28cca7a307af55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::PackedGraph::graph_iv_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac6c0404ec39b09a6da748ad6426b5090"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::PackedGraph::has_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to check if a node exists by ID. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a6e58a79001cd7d839ac1f1adaff34dfb">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a13cd5723ae6daeebf665e438028502f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::PackedGraph::has_path </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if a path name exists and is legal to get a path handle for. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#ab7de11c1e994bc104378c4b798013430">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a205e6873f65cace24fdd0e07c7f30f3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> vg::PackedGraph::max_node_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the largest ID in the graph, or some larger number if the largest ID is unavailable. Return value is unspecified if the graph is empty. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a5a2e2b1ea6a29b3f4b34a6abcb6dbc50">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a997a7c7e4314d13b4640cb107d14f0bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> vg::PackedGraph::min_node_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the smallest ID in the graph, or some smaller number if the smallest ID is unavailable. Return value is unspecified if the graph is empty. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a85c52fe4b5f483504ed142d0ad94a969">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="ac43f7cfe8c2733b9e5d22c07d079b4c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::PackedGraph::new_node_record </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize all of the data corresponding with a new node and return it's 1-based offset </p>

</div>
</div>
<a class="anchor" id="a1bc65594abfca94e73dcc974a8560500"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::PackedGraph::node_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of nodes in the graph. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#ab76511940f95dceb5fb162f39d316a1d">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="aa156ded7ff506b1d7e4022d11ca22f0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> vg::PackedGraph::path_begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a handle to the first step, or in a circular path to an arbitrary step considered "first". If the path is empty, returns the past-the-last step returned by path_end. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a815759484087ed92214c2c1c6b9d1a11">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a254f9326e56a1d51e406d67272b9315b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> vg::PackedGraph::path_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a handle to a fictitious position past the end of a path. This position is return by get_next_step for the final step in a path in a non-circular path. Note that get_next_step will <em>NEVER</em> return this value for a circular path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a5c3a5e04838d9e4a0a0ddf574c4de827">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="ae54ce3460954e9e7dcdee9f7c3a2a16b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> vg::PackedGraph::prepend_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to_prepend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prepend a visit to a node to the given path. Returns a handle to the new first step on the path which is appended. If the path is cirular, the new step is placed between the steps considered "last" and "first" by the method path_begin. Handles to later steps on the path, and to other paths, must remain valid. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#aed17038a0104017d37ff74e15f7f436a">handlegraph::MutablePathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a815c50fcafe42eceb57fa805e26c15a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PackedGraph::remove_edge_reference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find and edge on given handle, to a given handle, and remove it from the edge list. </p>

</div>
</div>
<a class="anchor" id="a29790b629ec299e66c8873b8629a4ce0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; vg::PackedGraph::rewrite_segment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>segment_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>segment_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_segment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete a segment of a path and rewrite it as some other sequence of steps. Returns a pair of step_handle_t's that indicate the range of the new segment in the path. The segment to delete should be designated by the first and the past-the-last step handle. If the step that is returned by path_begin is deleted, path_begin will now return the first step from the new segment or, in the case that the new segment is empty, segment_end. </p>

</div>
</div>
<a class="anchor" id="a6727c69a69d98508508f2a1d60e1db94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PackedGraph::serialize </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output to a stream. </p>

</div>
</div>
<a class="anchor" id="af48ebc3cb8ca87fa07a73620a30eb9d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PackedGraph::set_circularity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>circular</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a path circular or non-circular. If the path is becoming circular, the last step is joined to the first step. If the path is becoming linear, the step considered "last" is unjoined from the step considered "first" according to the method path_begin. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#a9172694447503e35d50093d55e845eb8">handlegraph::MutablePathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="ab5b18ce1fb030c1fb7327e4afe5e1f38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PackedGraph::set_edge_target </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>edge_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aedd34ad81d04491ef967174a737787bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PackedGraph::set_membership_path </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>membership_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acdf4c21b1bfceca8ec1943bdb8fcfafa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PackedGraph::set_membership_step </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>membership_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad0e3994de60e5e43b564fa02a061cb61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PackedGraph::set_next_membership </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>membership_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>next</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2ac8c11725824173d4566cc522ede043"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PackedGraph::set_step_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>step_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>next_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a541350620e4c9a4be7f198b643feec1f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PackedGraph::set_step_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>step_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>prev_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0bb4e3f7fb25c8986ef99b60ba5a95a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PackedGraph::set_step_trav </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>step_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>trav</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="abd7e5dc4f51d971279498d333e135f11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double vg::PackedGraph::defrag_factor = .2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defragment when the orphaned records are this fraction of the whole. </p>
<p>Define all of the static class variables. </p>

</div>
</div>
<a class="anchor" id="a54ddf4f1e79e7f38e339cd5fea4f0304"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t vg::PackedGraph::deleted_edge_records = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a00d5976b3c64b4ac1972ba9789c49fd1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t vg::PackedGraph::deleted_membership_records = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a00427073fe898e5d8d88d3ceb44f9365"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t vg::PackedGraph::deleted_node_records = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aafe70e0219efd0b57399982c12fc49ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1PagedVector.html">PagedVector</a> vg::PackedGraph::edge_lists_iv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encodes a series of edges lists of nodes. {ID|orientation (bit-packed), next edge index} </p>

</div>
</div>
<a class="anchor" id="ac9378fc747024443b37b10601fa01624"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t vg::PackedGraph::EDGE_NEXT_OFFSET = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9fb24cfbf0b50892939d200e5e93d7b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t vg::PackedGraph::EDGE_RECORD_SIZE = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="affdd3120e81fd2ca8a4a4e4fa945890b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t vg::PackedGraph::EDGE_TRAV_OFFSET = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab906fbd319bb59570a8d1d3ccf27d80b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t vg::PackedGraph::GRAPH_END_EDGES_OFFSET = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5915df07a9f9027edf54fd8b5b8b8dfb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1PagedVector.html">PagedVector</a> vg::PackedGraph::graph_iv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encodes the topology of the graph. Consists of fixed width records that represent offsets in edge_lists_iv. {start edge list index, end edge list index} </p>

</div>
</div>
<a class="anchor" id="ae2d329b354cd2c995cd12a2c73853167"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t vg::PackedGraph::GRAPH_RECORD_SIZE = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab1ebc41729ec0a4515a179b6defddcb9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t vg::PackedGraph::GRAPH_START_EDGES_OFFSET = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a513189c05c6f624f996fe5b045477512"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1PackedDeque.html">PackedDeque</a> vg::PackedGraph::id_to_graph_iv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encodes the 1-based offset of an ID in graph_iv in units of GRAPH_RECORD_SIZE. If no node with that ID exists, contains a 0. The index of a given ID is computed by (ID - min ID). </p>

</div>
</div>
<a class="anchor" id="a1f70696ea881303deb5c8d718fa537e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> vg::PackedGraph::max_id = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum ID in the graph. </p>

</div>
</div>
<a class="anchor" id="a13cdaf84ef6f5746d7c595213c228c19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t vg::PackedGraph::MEMBERSHIP_ID_RECORD_SIZE = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a46b3680f244409f77233f9bf5c1d28c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t vg::PackedGraph::MEMBERSHIP_NEXT_RECORD_SIZE = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abe8f3e26e84a1a59ce2175fa7b4a61c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t vg::PackedGraph::MEMBERSHIP_OFFSET_RECORD_SIZE = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a932ff978adf42a3389923af0720f129c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> vg::PackedGraph::min_id = std::numeric_limits&lt;<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&gt;::max()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The minimum ID in the graph. </p>

</div>
</div>
<a class="anchor" id="af788380d2585197c95bda5f133351398"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t vg::PackedGraph::NODE_MEMBER_RECORD_SIZE = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2448556d94acc07aa90b1e4b548f16e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t vg::PackedGraph::PAGE_WIDTH = 128</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We use a standard page width for all page-compressed vectors. </p>

</div>
</div>
<a class="anchor" id="a0b511822169f490c769e20e6f6dcf2f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1string__hash__map.html">string_hash_map</a>&lt;string, int64_t&gt; vg::PackedGraph::path_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map from path names to index in the paths vector. </p>

</div>
</div>
<a class="anchor" id="a6c402f1d539134d6a9a6c7453e52710f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1PagedVector.html">PagedVector</a> vg::PackedGraph::path_membership_id_iv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encodes a series of linked lists of the memberships within paths. The nodes in the linked list are split over three separate vectors, with the entry at the same index in each vector corresponding to the same linked list node. <a class="el" href="structvg_1_1Path.html">Path</a> ID (0-based index) </p>

</div>
</div>
<a class="anchor" id="a973617a65121afa8a2917761e58b83c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1PagedVector.html">PagedVector</a> vg::PackedGraph::path_membership_next_iv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>1-based offset of the next occurrence of this node on a path within this vector (or 0 if there is none) </p>

</div>
</div>
<a class="anchor" id="a75428a60532edb8d43d166621aba1f56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1PagedVector.html">PagedVector</a> vg::PackedGraph::path_membership_node_iv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encodes the membership of a node in all paths. In the same order as graph_iv. Consists of 1-based offset to the corresponding heads of linked lists in path_membership_value_iv, which contains the actual pointers into the paths. </p>

</div>
</div>
<a class="anchor" id="a37afe277bbd7412d561117d6eb97b346"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1PagedVector.html">PagedVector</a> vg::PackedGraph::path_membership_offset_iv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>1-based offset of the occurrence of the node in the corresponding <a class="el" href="structvg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> vector. </p>

</div>
</div>
<a class="anchor" id="a26ea35be78eaa547ebd7388a17445792"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t vg::PackedGraph::PATH_NEXT_OFFSET = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a49dd379a28da06a70f2c6c400123b735"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t vg::PackedGraph::PATH_PREV_OFFSET = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aed96ecea43ddc6d67f43d86954a05738"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t vg::PackedGraph::PATH_RECORD_SIZE = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abdf783e035e29c9584ffc0cdd882260f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="structvg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a>&gt; vg::PackedGraph::paths</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector of the embedded paths in the graph. </p>

</div>
</div>
<a class="anchor" id="ab99e2f08212cbff6a091fe37e618cc4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1PackedVector.html">PackedVector</a> vg::PackedGraph::seq_iv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encodes all of the sequences of all nodes in the graph. </p>

</div>
</div>
<a class="anchor" id="ae4a48b43e3e6bdc6b21951d24b7fa7a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1PackedVector.html">PackedVector</a> vg::PackedGraph::seq_length_iv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encodes the length of a node's sequence in seq_iv. Matches the order of graph_iv. </p>

</div>
</div>
<a class="anchor" id="adaaaab401ca3965e907d96b0cff56b11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t vg::PackedGraph::SEQ_LENGTH_RECORD_SIZE = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac7d2debbc4175fec335d8817708b69a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1PagedVector.html">PagedVector</a> vg::PackedGraph::seq_start_iv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encodes the start of a node's sequence in seq_iv. Matches the order of graph_iv. </p>

</div>
</div>
<a class="anchor" id="a689377dfb144ffa13bf68ed062199eb8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t vg::PackedGraph::SEQ_START_RECORD_SIZE = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a98bf9690a767e62345d46d57e712b239"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t vg::PackedGraph::STEP_RECORD_SIZE = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="packed__graph_8hpp.html">packed_graph.hpp</a></li>
<li>src/<a class="el" href="packed__graph_8cpp.html">packed_graph.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
