<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>vg: vg::SnarlManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classvg_1_1SnarlManager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::SnarlManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;snarls.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1SnarlManager_1_1SnarlRecord.html">SnarlRecord</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1037a2341484dc7b54a68cd7207d34b8"><td class="memTemplParams" colspan="2">template&lt;typename SnarlIterator &gt; </td></tr>
<tr class="memitem:a1037a2341484dc7b54a68cd7207d34b8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a1037a2341484dc7b54a68cd7207d34b8">SnarlManager</a> (SnarlIterator begin, SnarlIterator <a class="el" href="namespacevg.html#ae28509de83b851bdc0d8ff2fa7bd4275">end</a>)</td></tr>
<tr class="separator:a1037a2341484dc7b54a68cd7207d34b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b2b80def0128deea2d2da4886b955e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a61b2b80def0128deea2d2da4886b955e">SnarlManager</a> (istream &amp;in)</td></tr>
<tr class="memdesc:a61b2b80def0128deea2d2da4886b955e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> for the snarls contained in an input stream.  <a href="#a61b2b80def0128deea2d2da4886b955e">More...</a><br/></td></tr>
<tr class="separator:a61b2b80def0128deea2d2da4886b955e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe16f481e15e098c885d63f47eceb59c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#afe16f481e15e098c885d63f47eceb59c">SnarlManager</a> (const function&lt; void(const function&lt; void(<a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;)&gt; &amp;)&gt; &amp;for_each_snarl)</td></tr>
<tr class="memdesc:afe16f481e15e098c885d63f47eceb59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> from a function that calls a callback with each <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> in turn.  <a href="#afe16f481e15e098c885d63f47eceb59c">More...</a><br/></td></tr>
<tr class="separator:afe16f481e15e098c885d63f47eceb59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b0ecd9e372556380231f29788948d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a43b0ecd9e372556380231f29788948d5">SnarlManager</a> ()=default</td></tr>
<tr class="separator:a43b0ecd9e372556380231f29788948d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6eb9b943f3e1b090e21f23dae5f8ea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a3a6eb9b943f3e1b090e21f23dae5f8ea">~SnarlManager</a> ()=default</td></tr>
<tr class="memdesc:a3a6eb9b943f3e1b090e21f23dae5f8ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a3a6eb9b943f3e1b090e21f23dae5f8ea">More...</a><br/></td></tr>
<tr class="separator:a3a6eb9b943f3e1b090e21f23dae5f8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e61adc170e3d9241a723ca7593883da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a8e61adc170e3d9241a723ca7593883da">SnarlManager</a> (const <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;other)=delete</td></tr>
<tr class="memdesc:a8e61adc170e3d9241a723ca7593883da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cannot be copied because of all the internal pointer indexes.  <a href="#a8e61adc170e3d9241a723ca7593883da">More...</a><br/></td></tr>
<tr class="separator:a8e61adc170e3d9241a723ca7593883da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08acef6ec793e011aa7537f9ccb4dcfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a08acef6ec793e011aa7537f9ccb4dcfe">operator=</a> (const <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;other)=delete</td></tr>
<tr class="separator:a08acef6ec793e011aa7537f9ccb4dcfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7549f1ed7e0e02ae36f172ab5f1d3dbd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a7549f1ed7e0e02ae36f172ab5f1d3dbd">SnarlManager</a> (<a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;&amp;other)=default</td></tr>
<tr class="memdesc:a7549f1ed7e0e02ae36f172ab5f1d3dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be moved.  <a href="#a7549f1ed7e0e02ae36f172ab5f1d3dbd">More...</a><br/></td></tr>
<tr class="separator:a7549f1ed7e0e02ae36f172ab5f1d3dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f0f956456ef8ec76616fc47bc74428"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#af6f0f956456ef8ec76616fc47bc74428">operator=</a> (<a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;&amp;other)=default</td></tr>
<tr class="separator:af6f0f956456ef8ec76616fc47bc74428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e38645c741715cdad3eea4c637a93d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a63e38645c741715cdad3eea4c637a93d">add_snarl</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;new_snarl)</td></tr>
<tr class="separator:a63e38645c741715cdad3eea4c637a93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634d4253e7fa5c09aa00f909f171bc61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a634d4253e7fa5c09aa00f909f171bc61">flip</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *snarl)</td></tr>
<tr class="memdesc:a634d4253e7fa5c09aa00f909f171bc61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the orientation of a managed snarl.  <a href="#a634d4253e7fa5c09aa00f909f171bc61">More...</a><br/></td></tr>
<tr class="separator:a634d4253e7fa5c09aa00f909f171bc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05aac472334ea39d3b7e5ce95e0ffb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#ab05aac472334ea39d3b7e5ce95e0ffb2">flip</a> (const <a class="el" href="namespacevg.html#aa9d8b2ece3ab50a38656273662553f2d">Chain</a> *snarl)</td></tr>
<tr class="separator:ab05aac472334ea39d3b7e5ce95e0ffb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf5fd439b35298107ddf2900559259c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#aacf5fd439b35298107ddf2900559259c">finish</a> ()</td></tr>
<tr class="separator:aacf5fd439b35298107ddf2900559259c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c7e3818ab278a6a05a0b6495acf4ad"><td class="memItemLeft" align="right" valign="top">const vector&lt; const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a84c7e3818ab278a6a05a0b6495acf4ad">children_of</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *snarl) const </td></tr>
<tr class="separator:a84c7e3818ab278a6a05a0b6495acf4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f9d90eee8e249e0c70aae9badca727"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#af9f9d90eee8e249e0c70aae9badca727">parent_of</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *snarl) const </td></tr>
<tr class="memdesc:af9f9d90eee8e249e0c70aae9badca727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the parent of a <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> or nullptr if there is none.  <a href="#af9f9d90eee8e249e0c70aae9badca727">More...</a><br/></td></tr>
<tr class="separator:af9f9d90eee8e249e0c70aae9badca727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de178b8d497f60b85a605e58ec94943"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a5de178b8d497f60b85a605e58ec94943">get_depth</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *) const </td></tr>
<tr class="separator:a5de178b8d497f60b85a605e58ec94943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75df598ce937690899e8933ae6ec5ace"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a75df598ce937690899e8933ae6ec5ace">into_which_snarl</a> (int64_t <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>, bool <a class="el" href="namespacevg.html#a91adfc6327b5709dc73fcc7edbe5da57">reverse</a>) const </td></tr>
<tr class="separator:a75df598ce937690899e8933ae6ec5ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa519884a5484a5aaa2dcfe9de0bc1031"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#aa519884a5484a5aaa2dcfe9de0bc1031">into_which_snarl</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;visit) const </td></tr>
<tr class="separator:aa519884a5484a5aaa2dcfe9de0bc1031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba061d23c1a3b181f21fbfa8aac81e0b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacevg.html#aa9d8b2ece3ab50a38656273662553f2d">Chain</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#aba061d23c1a3b181f21fbfa8aac81e0b">chain_of</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *snarl) const </td></tr>
<tr class="separator:aba061d23c1a3b181f21fbfa8aac81e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b988ac39ab5d3f9279e7a0fef6afef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a61b988ac39ab5d3f9279e7a0fef6afef">chain_orientation_of</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *snarl) const </td></tr>
<tr class="separator:a61b988ac39ab5d3f9279e7a0fef6afef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005f19e7f17aa3ae15a449026c7a08b0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a005f19e7f17aa3ae15a449026c7a08b0">chain_rank_of</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *snarl) const </td></tr>
<tr class="separator:a005f19e7f17aa3ae15a449026c7a08b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6a0924ce953c5dd1a43a91558c4391"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#abe6a0924ce953c5dd1a43a91558c4391">in_nontrivial_chain</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *here) const </td></tr>
<tr class="separator:abe6a0924ce953c5dd1a43a91558c4391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5fedfcf0ee83d55991f194b80820fc"><td class="memItemLeft" align="right" valign="top">const deque&lt; <a class="el" href="namespacevg.html#aa9d8b2ece3ab50a38656273662553f2d">Chain</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a3b5fedfcf0ee83d55991f194b80820fc">chains_of</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *snarl) const </td></tr>
<tr class="separator:a3b5fedfcf0ee83d55991f194b80820fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa646b28397d4750cf44c6ad7b9f52680"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1NetGraph.html">NetGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#aa646b28397d4750cf44c6ad7b9f52680">net_graph_of</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *snarl, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph, bool <a class="el" href="namespacevg.html#a2b3c73fb05994914ef332744b99609fb">use_internal_connectivity</a>=true) const </td></tr>
<tr class="separator:aa646b28397d4750cf44c6ad7b9f52680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed2f4feb348f0f086f55f8df156d8c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a5ed2f4feb348f0f086f55f8df156d8c0">is_leaf</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *snarl) const </td></tr>
<tr class="memdesc:a5ed2f4feb348f0f086f55f8df156d8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if snarl has no children and false otherwise.  <a href="#a5ed2f4feb348f0f086f55f8df156d8c0">More...</a><br/></td></tr>
<tr class="separator:a5ed2f4feb348f0f086f55f8df156d8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7efb7b2608894b946c78b889f0db2b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#aae7efb7b2608894b946c78b889f0db2b">is_root</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *snarl) const </td></tr>
<tr class="memdesc:aae7efb7b2608894b946c78b889f0db2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if snarl has no parent and false otherwise.  <a href="#aae7efb7b2608894b946c78b889f0db2b">More...</a><br/></td></tr>
<tr class="separator:aae7efb7b2608894b946c78b889f0db2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf421ca80fa05d3a9371fddb19b86014"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#abf421ca80fa05d3a9371fddb19b86014">is_trivial</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *snarl, <a class="el" href="classvg_1_1VG.html">VG</a> &amp;graph) const </td></tr>
<tr class="separator:abf421ca80fa05d3a9371fddb19b86014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fac44cd969db5961b536197bcee8f8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a0fac44cd969db5961b536197bcee8f8f">all_children_trivial</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *snarl, <a class="el" href="classvg_1_1VG.html">VG</a> &amp;graph) const </td></tr>
<tr class="memdesc:a0fac44cd969db5961b536197bcee8f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the snarl lacks any nontrivial children.  <a href="#a0fac44cd969db5961b536197bcee8f8f">More...</a><br/></td></tr>
<tr class="separator:a0fac44cd969db5961b536197bcee8f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98fcfa5fb523b8d1bbbdf773ab85c0d1"><td class="memItemLeft" align="right" valign="top">const vector&lt; const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a98fcfa5fb523b8d1bbbdf773ab85c0d1">top_level_snarls</a> () const </td></tr>
<tr class="memdesc:a98fcfa5fb523b8d1bbbdf773ab85c0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to a vector with the roots of the <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> trees.  <a href="#a98fcfa5fb523b8d1bbbdf773ab85c0d1">More...</a><br/></td></tr>
<tr class="separator:a98fcfa5fb523b8d1bbbdf773ab85c0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ad5160df9e8435fe99e972a4ffd02e"><td class="memItemLeft" align="right" valign="top">pair&lt; unordered_set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt;<br class="typebreak"/>
, unordered_set&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a58ad5160df9e8435fe99e972a4ffd02e">shallow_contents</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *snarl, <a class="el" href="classvg_1_1VG.html">VG</a> &amp;graph, bool include_boundary_nodes) const </td></tr>
<tr class="separator:a58ad5160df9e8435fe99e972a4ffd02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6a288f8d3607c98db20e0b55fd9b40"><td class="memItemLeft" align="right" valign="top">pair&lt; unordered_set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt;<br class="typebreak"/>
, unordered_set&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a1a6a288f8d3607c98db20e0b55fd9b40">deep_contents</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *snarl, <a class="el" href="classvg_1_1VG.html">VG</a> &amp;graph, bool include_boundary_nodes) const </td></tr>
<tr class="separator:a1a6a288f8d3607c98db20e0b55fd9b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b60d404998384059e8dd9e0432cda87"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Visit.html">Visit</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a9b60d404998384059e8dd9e0432cda87">visits_left</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;visit, <a class="el" href="classvg_1_1VG.html">VG</a> &amp;graph, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *in_snarl) const </td></tr>
<tr class="separator:a9b60d404998384059e8dd9e0432cda87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb4b4d043dd52455571b2eef780cb31"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Visit.html">Visit</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#aceb4b4d043dd52455571b2eef780cb31">visits_right</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;visit, <a class="el" href="classvg_1_1VG.html">VG</a> &amp;graph, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *in_snarl) const </td></tr>
<tr class="separator:aceb4b4d043dd52455571b2eef780cb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea761735531b87113912b801bed2e078"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; pair&lt; int64_t, <br class="typebreak"/>
bool &gt;, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#aea761735531b87113912b801bed2e078">snarl_boundary_index</a> () const </td></tr>
<tr class="separator:aea761735531b87113912b801bed2e078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3439bdd4ff6e1bcc80c195d9dc7844b8"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; pair&lt; int64_t, <br class="typebreak"/>
bool &gt;, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a3439bdd4ff6e1bcc80c195d9dc7844b8">snarl_start_index</a> () const </td></tr>
<tr class="memdesc:a3439bdd4ff6e1bcc80c195d9dc7844b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map from all <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> start boundaries to the <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> they point into.  <a href="#a3439bdd4ff6e1bcc80c195d9dc7844b8">More...</a><br/></td></tr>
<tr class="separator:a3439bdd4ff6e1bcc80c195d9dc7844b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c67c2b436a8eadda6a0ef24ae3fb5d"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; pair&lt; int64_t, <br class="typebreak"/>
bool &gt;, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a32c67c2b436a8eadda6a0ef24ae3fb5d">snarl_end_index</a> () const </td></tr>
<tr class="separator:a32c67c2b436a8eadda6a0ef24ae3fb5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b42f12442007c78fd32607d61ba3ccb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a6b42f12442007c78fd32607d61ba3ccb">for_each_top_level_snarl</a> (const function&lt; void(const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *)&gt; &amp;lambda) const </td></tr>
<tr class="memdesc:a6b42f12442007c78fd32607d61ba3ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a function on all top level sites.  <a href="#a6b42f12442007c78fd32607d61ba3ccb">More...</a><br/></td></tr>
<tr class="separator:a6b42f12442007c78fd32607d61ba3ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8ab565dfb0bc5b5818ec67d4a93404"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a5b8ab565dfb0bc5b5818ec67d4a93404">for_each_snarl_preorder</a> (const function&lt; void(const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *)&gt; &amp;lambda) const </td></tr>
<tr class="memdesc:a5b8ab565dfb0bc5b5818ec67d4a93404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a function on all sites in a preorder traversal.  <a href="#a5b8ab565dfb0bc5b5818ec67d4a93404">More...</a><br/></td></tr>
<tr class="separator:a5b8ab565dfb0bc5b5818ec67d4a93404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71710865e315d8a49d832ff23938ff12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a71710865e315d8a49d832ff23938ff12">for_each_top_level_snarl_parallel</a> (const function&lt; void(const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *)&gt; &amp;lambda) const </td></tr>
<tr class="memdesc:a71710865e315d8a49d832ff23938ff12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a function on all top level sites in parallel.  <a href="#a71710865e315d8a49d832ff23938ff12">More...</a><br/></td></tr>
<tr class="separator:a71710865e315d8a49d832ff23938ff12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1331fb4dfe5b1fa3f769c6577c8051b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a1331fb4dfe5b1fa3f769c6577c8051b1">for_each_snarl_parallel</a> (const function&lt; void(const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *)&gt; &amp;lambda) const </td></tr>
<tr class="memdesc:a1331fb4dfe5b1fa3f769c6577c8051b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a function on all sites in parallel.  <a href="#a1331fb4dfe5b1fa3f769c6577c8051b1">More...</a><br/></td></tr>
<tr class="separator:a1331fb4dfe5b1fa3f769c6577c8051b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06c503af8e4cc2311c63f770f308e77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#ac06c503af8e4cc2311c63f770f308e77">for_each_chain</a> (const function&lt; void(const <a class="el" href="namespacevg.html#aa9d8b2ece3ab50a38656273662553f2d">Chain</a> *)&gt; &amp;lambda) const </td></tr>
<tr class="memdesc:ac06c503af8e4cc2311c63f770f308e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ececute a function on all chains.  <a href="#ac06c503af8e4cc2311c63f770f308e77">More...</a><br/></td></tr>
<tr class="separator:ac06c503af8e4cc2311c63f770f308e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb04f08cb7bb84a56b172e571703b839"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#abb04f08cb7bb84a56b172e571703b839">for_each_chain_parallel</a> (const function&lt; void(const <a class="el" href="namespacevg.html#aa9d8b2ece3ab50a38656273662553f2d">Chain</a> *)&gt; &amp;lambda) const </td></tr>
<tr class="memdesc:abb04f08cb7bb84a56b172e571703b839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ececute a function on all chains in parallel.  <a href="#abb04f08cb7bb84a56b172e571703b839">More...</a><br/></td></tr>
<tr class="separator:abb04f08cb7bb84a56b172e571703b839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a597046dc213a9fdcde3638093d45c56d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a597046dc213a9fdcde3638093d45c56d">manage</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;not_owned) const </td></tr>
<tr class="separator:a597046dc213a9fdcde3638093d45c56d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a17e285d4331385073da27ecc70c7268b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvg_1_1SnarlManager_1_1SnarlRecord.html">SnarlRecord</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a17e285d4331385073da27ecc70c7268b">record</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *snarl) const </td></tr>
<tr class="memdesc:a17e285d4331385073da27ecc70c7268b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the const <a class="el" href="structvg_1_1SnarlManager_1_1SnarlRecord.html">SnarlRecord</a> for a const managed snarl.  <a href="#a17e285d4331385073da27ecc70c7268b">More...</a><br/></td></tr>
<tr class="separator:a17e285d4331385073da27ecc70c7268b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce002195299049e9925e94546d989b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1SnarlManager_1_1SnarlRecord.html">SnarlRecord</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a3ce002195299049e9925e94546d989b9">record</a> (<a class="el" href="structvg_1_1Snarl.html">Snarl</a> *snarl)</td></tr>
<tr class="memdesc:a3ce002195299049e9925e94546d989b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="structvg_1_1SnarlManager_1_1SnarlRecord.html">SnarlRecord</a> for a managed snarl.  <a href="#a3ce002195299049e9925e94546d989b9">More...</a><br/></td></tr>
<tr class="separator:a3ce002195299049e9925e94546d989b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a87a6e424e9b39f77b43061b692039"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a42a87a6e424e9b39f77b43061b692039">unrecord</a> (const <a class="el" href="structvg_1_1SnarlManager_1_1SnarlRecord.html">SnarlRecord</a> *<a class="el" href="classvg_1_1SnarlManager.html#a17e285d4331385073da27ecc70c7268b">record</a>) const </td></tr>
<tr class="memdesc:a42a87a6e424e9b39f77b43061b692039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the const <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> owned by a const <a class="el" href="structvg_1_1SnarlManager_1_1SnarlRecord.html">SnarlRecord</a>.  <a href="#a42a87a6e424e9b39f77b43061b692039">More...</a><br/></td></tr>
<tr class="separator:a42a87a6e424e9b39f77b43061b692039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb8bf1eb342004f69b33caadad5a713"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#aeeb8bf1eb342004f69b33caadad5a713">unrecord</a> (<a class="el" href="structvg_1_1SnarlManager_1_1SnarlRecord.html">SnarlRecord</a> *<a class="el" href="classvg_1_1SnarlManager.html#a17e285d4331385073da27ecc70c7268b">record</a>)</td></tr>
<tr class="memdesc:aeeb8bf1eb342004f69b33caadad5a713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> owned by a <a class="el" href="structvg_1_1SnarlManager_1_1SnarlRecord.html">SnarlRecord</a>.  <a href="#aeeb8bf1eb342004f69b33caadad5a713">More...</a><br/></td></tr>
<tr class="separator:aeeb8bf1eb342004f69b33caadad5a713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962ce88320136f82a1f5f58a036698c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a962ce88320136f82a1f5f58a036698c2">build_indexes</a> ()</td></tr>
<tr class="memdesc:a962ce88320136f82a1f5f58a036698c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds tree indexes after Snarls have been added to the snarls vector.  <a href="#a962ce88320136f82a1f5f58a036698c2">More...</a><br/></td></tr>
<tr class="separator:a962ce88320136f82a1f5f58a036698c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21875edf1a991436156fa6dc5196cd22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a21875edf1a991436156fa6dc5196cd22">get_depths</a> ()</td></tr>
<tr class="separator:a21875edf1a991436156fa6dc5196cd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafce72a1ca8a2f7bcab217ebbf4f2073"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#aafce72a1ca8a2f7bcab217ebbf4f2073">get_depths_recursive</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *snarl, size_t depth)</td></tr>
<tr class="separator:aafce72a1ca8a2f7bcab217ebbf4f2073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac724d3651c3e631d8d72d43682a049d3"><td class="memItemLeft" align="right" valign="top">deque&lt; <a class="el" href="namespacevg.html#aa9d8b2ece3ab50a38656273662553f2d">Chain</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#ac724d3651c3e631d8d72d43682a049d3">compute_chains</a> (const vector&lt; const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> * &gt; &amp;input_snarls)</td></tr>
<tr class="separator:ac724d3651c3e631d8d72d43682a049d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5015eacc04d12d02ef5196fb23f3075"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#ae5015eacc04d12d02ef5196fb23f3075">regularize</a> ()</td></tr>
<tr class="separator:ae5015eacc04d12d02ef5196fb23f3075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8702e75f648f081fa3cf40c557a00d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Visit.html">Visit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a9b8702e75f648f081fa3cf40c557a00d">next_snarl</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;here) const </td></tr>
<tr class="separator:a9b8702e75f648f081fa3cf40c557a00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a9f09a1fac6e98e6280bb1a28791c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Visit.html">Visit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a51a9f09a1fac6e98e6280bb1a28791c6">prev_snarl</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;here) const </td></tr>
<tr class="separator:a51a9f09a1fac6e98e6280bb1a28791c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55675e8bb8ad6b81b09328f5261335e6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a55675e8bb8ad6b81b09328f5261335e6">snarl_sharing_start</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *here) const </td></tr>
<tr class="separator:a55675e8bb8ad6b81b09328f5261335e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc1b95707babec9c7cd8436ddbd7d45"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#acdc1b95707babec9c7cd8436ddbd7d45">snarl_sharing_end</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *here) const </td></tr>
<tr class="separator:acdc1b95707babec9c7cd8436ddbd7d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ab56cf756bc65189eeb1d4f1f3f6573b6"><td class="memItemLeft" align="right" valign="top">deque&lt; <a class="el" href="structvg_1_1SnarlManager_1_1SnarlRecord.html">SnarlRecord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#ab56cf756bc65189eeb1d4f1f3f6573b6">snarls</a></td></tr>
<tr class="separator:ab56cf756bc65189eeb1d4f1f3f6573b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13a661f6abe1feaf2c4ca4471a85a90"><td class="memItemLeft" align="right" valign="top">vector&lt; const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#ab13a661f6abe1feaf2c4ca4471a85a90">roots</a></td></tr>
<tr class="memdesc:ab13a661f6abe1feaf2c4ca4471a85a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Roots of snarl trees.  <a href="#ab13a661f6abe1feaf2c4ca4471a85a90">More...</a><br/></td></tr>
<tr class="separator:ab13a661f6abe1feaf2c4ca4471a85a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9758d889f875b1260f49985cf3ef35"><td class="memItemLeft" align="right" valign="top">deque&lt; <a class="el" href="namespacevg.html#aa9d8b2ece3ab50a38656273662553f2d">Chain</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a2d9758d889f875b1260f49985cf3ef35">root_chains</a></td></tr>
<tr class="memdesc:a2d9758d889f875b1260f49985cf3ef35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chains of root-level snarls. Uses a deque so Chain* pointers don't get invalidated.  <a href="#a2d9758d889f875b1260f49985cf3ef35">More...</a><br/></td></tr>
<tr class="separator:a2d9758d889f875b1260f49985cf3ef35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1d327aa074d59976802999d0d179d1"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; pair&lt; int64_t, <br class="typebreak"/>
bool &gt;, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html#a0f1d327aa074d59976802999d0d179d1">snarl_into</a></td></tr>
<tr class="memdesc:a0f1d327aa074d59976802999d0d179d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of node traversals to the snarls they point into.  <a href="#a0f1d327aa074d59976802999d0d179d1">More...</a><br/></td></tr>
<tr class="separator:a0f1d327aa074d59976802999d0d179d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A structure to keep track of the tree relationships between Snarls and perform utility algorithms on them </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1037a2341484dc7b54a68cd7207d34b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SnarlIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vg::SnarlManager::SnarlManager </td>
          <td>(</td>
          <td class="paramtype">SnarlIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SnarlIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> for the snarls returned by an iterator Also covers iterators of chains of snarls. </p>

</div>
</div>
<a class="anchor" id="a61b2b80def0128deea2d2da4886b955e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::SnarlManager::SnarlManager </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> for the snarls contained in an input stream. </p>

</div>
</div>
<a class="anchor" id="afe16f481e15e098c885d63f47eceb59c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::SnarlManager::SnarlManager </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(const function&lt; void(<a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;)&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>for_each_snarl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> from a function that calls a callback with each <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> in turn. </p>

</div>
</div>
<a class="anchor" id="a43b0ecd9e372556380231f29788948d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::SnarlManager::SnarlManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor for an empty <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a>. Must call <a class="el" href="classvg_1_1SnarlManager.html#aacf5fd439b35298107ddf2900559259c">finish()</a> once all snarls have been added with <a class="el" href="classvg_1_1SnarlManager.html#a63e38645c741715cdad3eea4c637a93d">add_snarl()</a>. </p>

</div>
</div>
<a class="anchor" id="a3a6eb9b943f3e1b090e21f23dae5f8ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::SnarlManager::~SnarlManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<a class="anchor" id="a8e61adc170e3d9241a723ca7593883da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::SnarlManager::SnarlManager </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cannot be copied because of all the internal pointer indexes. </p>

</div>
</div>
<a class="anchor" id="a7549f1ed7e0e02ae36f172ab5f1d3dbd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::SnarlManager::SnarlManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be moved. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a63e38645c741715cdad3eea4c637a93d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a>* vg::SnarlManager::add_snarl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;&#160;</td>
          <td class="paramname"><em>new_snarl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the given snarl to the <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a>. After all snarls have been added, <a class="el" href="classvg_1_1SnarlManager.html#aacf5fd439b35298107ddf2900559259c">finish()</a> must be called to compute chains and indexes. We don't let precomputed chains be added, because we want chain orientations relative to snarls to be deterministic given an order of snarls. Returns a pointer to the managed snarl copy. Only this function may add in new Snarls. </p>

</div>
</div>
<a class="anchor" id="a0fac44cd969db5961b536197bcee8f8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::SnarlManager::all_children_trivial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td>
          <td class="paramname"><em>snarl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the snarl lacks any nontrivial children. </p>

</div>
</div>
<a class="anchor" id="a962ce88320136f82a1f5f58a036698c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SnarlManager::build_indexes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds tree indexes after Snarls have been added to the snarls vector. </p>

</div>
</div>
<a class="anchor" id="aba061d23c1a3b181f21fbfa8aac81e0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacevg.html#aa9d8b2ece3ab50a38656273662553f2d">Chain</a>* vg::SnarlManager::chain_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td>
          <td class="paramname"><em>snarl</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the Chain that the given snarl participates in. Instead of asking this class to walk the chain for you, use ChainIterators on this chain. This is always non-null. </p>

</div>
</div>
<a class="anchor" id="a61b988ac39ab5d3f9279e7a0fef6afef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::SnarlManager::chain_orientation_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td>
          <td class="paramname"><em>snarl</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the given <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> is backward in its chain, return true. Otherwise, return false. </p>

</div>
</div>
<a class="anchor" id="a005f19e7f17aa3ae15a449026c7a08b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::SnarlManager::chain_rank_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td>
          <td class="paramname"><em>snarl</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the rank that the given snarl appears in in its chain. If two snarls are in forward orientation in the chain, then leaving the end of the lower rank snarl will eventually reach the start of the higher rank snarl. If either or both snarls is backward, you leave/arrive at the other bounding node instead.</p>
<p>Sorting snarls by rank will let you visit them in chain order without walking the whole chain. </p>

</div>
</div>
<a class="anchor" id="a3b5fedfcf0ee83d55991f194b80820fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const deque&lt;<a class="el" href="namespacevg.html#aa9d8b2ece3ab50a38656273662553f2d">Chain</a>&gt;&amp; vg::SnarlManager::chains_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td>
          <td class="paramname"><em>snarl</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get all the snarls in all the chains under the given parent snarl. If the parent snarl is null, gives the top-level chains that connect and contain the top-level root snarls. Unary snarls and snarls in trivial chains will be presented as their own chains. Snarls are not necessarily oriented appropriately given their ordering in the chain. Useful for making a net graph. </p>

</div>
</div>
<a class="anchor" id="a84c7e3818ab278a6a05a0b6495acf4ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt;const <a class="el" href="structvg_1_1Snarl.html">Snarl</a>*&gt;&amp; vg::SnarlManager::children_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td>
          <td class="paramname"><em>snarl</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a vector of pointers to the children of a <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a>. If given null, returns the top-level root snarls. </p>

</div>
</div>
<a class="anchor" id="ac724d3651c3e631d8d72d43682a049d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">deque&lt;<a class="el" href="namespacevg.html#aa9d8b2ece3ab50a38656273662553f2d">Chain</a>&gt; vg::SnarlManager::compute_chains </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_snarls</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Actually compute chains for a set of already indexed snarls, which is important when chains were not provided. Returns the chains. </p>

</div>
</div>
<a class="anchor" id="a1a6a288f8d3607c98db20e0b55fd9b40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;unordered_set&lt;<a class="el" href="structvg_1_1Node.html">Node</a>*&gt;, unordered_set&lt;<a class="el" href="structvg_1_1Edge.html">Edge</a>*&gt; &gt; vg::SnarlManager::deep_contents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td>
          <td class="paramname"><em>snarl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_boundary_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Nodes and Edges contained in this <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a>, including those in child Snarls (optionally includes <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a>'s own boundary Nodes) </p>

</div>
</div>
<a class="anchor" id="aacf5fd439b35298107ddf2900559259c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SnarlManager::finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Note that we have finished calling add_snarl. Compute the snarl parent/child indexes and chains. </p>

</div>
</div>
<a class="anchor" id="a634d4253e7fa5c09aa00f909f171bc61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SnarlManager::flip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td>
          <td class="paramname"><em>snarl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses the orientation of a managed snarl. </p>

</div>
</div>
<a class="anchor" id="ab05aac472334ea39d3b7e5ce95e0ffb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SnarlManager::flip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aa9d8b2ece3ab50a38656273662553f2d">Chain</a> *&#160;</td>
          <td class="paramname"><em>snarl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reverses the order and orientation of a managed chain, leaving all the component snarls in their original orientations. </p>

</div>
</div>
<a class="anchor" id="ac06c503af8e4cc2311c63f770f308e77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SnarlManager::for_each_chain </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="namespacevg.html#aa9d8b2ece3ab50a38656273662553f2d">Chain</a> *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ececute a function on all chains. </p>

</div>
</div>
<a class="anchor" id="abb04f08cb7bb84a56b172e571703b839"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SnarlManager::for_each_chain_parallel </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="namespacevg.html#aa9d8b2ece3ab50a38656273662553f2d">Chain</a> *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ececute a function on all chains in parallel. </p>

</div>
</div>
<a class="anchor" id="a1331fb4dfe5b1fa3f769c6577c8051b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SnarlManager::for_each_snarl_parallel </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a function on all sites in parallel. </p>

</div>
</div>
<a class="anchor" id="a5b8ab565dfb0bc5b5818ec67d4a93404"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SnarlManager::for_each_snarl_preorder </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a function on all sites in a preorder traversal. </p>

</div>
</div>
<a class="anchor" id="a6b42f12442007c78fd32607d61ba3ccb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SnarlManager::for_each_top_level_snarl </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a function on all top level sites. </p>

</div>
</div>
<a class="anchor" id="a71710865e315d8a49d832ff23938ff12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SnarlManager::for_each_top_level_snarl_parallel </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a function on all top level sites in parallel. </p>

</div>
</div>
<a class="anchor" id="a5de178b8d497f60b85a605e58ec94943"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::SnarlManager::get_depth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a21875edf1a991436156fa6dc5196cd22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SnarlManager::get_depths </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aafce72a1ca8a2f7bcab217ebbf4f2073"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SnarlManager::get_depths_recursive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td>
          <td class="paramname"><em>snarl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abe6a0924ce953c5dd1a43a91558c4391"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::SnarlManager::in_nontrivial_chain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td>
          <td class="paramname"><em>here</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if a <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> is part of a nontrivial chain of more than one snarl. Note that <a class="el" href="classvg_1_1SnarlManager.html#aba061d23c1a3b181f21fbfa8aac81e0b">chain_of()</a> still works for snarls in trivial chains. </p>

</div>
</div>
<a class="anchor" id="a75df598ce937690899e8933ae6ec5ace"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a>* vg::SnarlManager::into_which_snarl </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> that a traversal points into at either the start or end, or nullptr if the traversal does not point into any <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a>. Note that Snarls store the end <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> pointing out of rather than into the <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a>, so they must be reversed to query it. </p>

</div>
</div>
<a class="anchor" id="aa519884a5484a5aaa2dcfe9de0bc1031"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a>* vg::SnarlManager::into_which_snarl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;&#160;</td>
          <td class="paramname"><em>visit</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> that a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> points into. If the <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> contains a <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> rather than a node ID, returns a pointer the managed version of that snarl. </p>

</div>
</div>
<a class="anchor" id="a5ed2f4feb348f0f086f55f8df156d8c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::SnarlManager::is_leaf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td>
          <td class="paramname"><em>snarl</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if snarl has no children and false otherwise. </p>

</div>
</div>
<a class="anchor" id="aae7efb7b2608894b946c78b889f0db2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::SnarlManager::is_root </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td>
          <td class="paramname"><em>snarl</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if snarl has no parent and false otherwise. </p>

</div>
</div>
<a class="anchor" id="abf421ca80fa05d3a9371fddb19b86014"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::SnarlManager::is_trivial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td>
          <td class="paramname"><em>snarl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the sanrl is trivial (an ultrabubble with just the start and end nodes) and false otherwise. TODO: Implement without needing the vg graph, by adding a flag to trivial snarls. </p>

</div>
</div>
<a class="anchor" id="a597046dc213a9fdcde3638093d45c56d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a>* vg::SnarlManager::manage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;&#160;</td>
          <td class="paramname"><em>not_owned</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> that we don't own (like from a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a>), find the pointer to the managed copy of that <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a>. </p>

</div>
</div>
<a class="anchor" id="aa646b28397d4750cf44c6ad7b9f52680"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1NetGraph.html">NetGraph</a> vg::SnarlManager::net_graph_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td>
          <td class="paramname"><em>snarl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_internal_connectivity</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the net graph of the given <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a>'s contents, using the given backing HandleGraph. If use_internal_connectivity is false, each chain and unary child snarl is treated as an ordinary node which is assumed to be only traversable from one side to the other. Otherwise, traversing the graph works like it would if you actually went through the internal graphs fo child snarls. </p>

</div>
</div>
<a class="anchor" id="a9b8702e75f648f081fa3cf40c557a00d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Visit.html">Visit</a> vg::SnarlManager::next_snarl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;&#160;</td>
          <td class="paramname"><em>here</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> to the snarl coming after the given <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> to a snarl, or a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> with no <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> no next snarl exists. Accounts for snarls' orientations. </p>

</div>
</div>
<a class="anchor" id="a08acef6ec793e011aa7537f9ccb4dcfe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a>&amp; vg::SnarlManager::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af6f0f956456ef8ec76616fc47bc74428"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a>&amp; vg::SnarlManager::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af9f9d90eee8e249e0c70aae9badca727"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a>* vg::SnarlManager::parent_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td>
          <td class="paramname"><em>snarl</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the parent of a <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> or nullptr if there is none. </p>

</div>
</div>
<a class="anchor" id="a51a9f09a1fac6e98e6280bb1a28791c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Visit.html">Visit</a> vg::SnarlManager::prev_snarl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;&#160;</td>
          <td class="paramname"><em>here</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> to the snarl coming before the given <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> to a snarl, or a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> with no <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> no previous snarl exists. Accounts for snarls' orientations. </p>

</div>
</div>
<a class="anchor" id="a17e285d4331385073da27ecc70c7268b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvg_1_1SnarlManager_1_1SnarlRecord.html">SnarlRecord</a>* vg::SnarlManager::record </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td>
          <td class="paramname"><em>snarl</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the const <a class="el" href="structvg_1_1SnarlManager_1_1SnarlRecord.html">SnarlRecord</a> for a const managed snarl. </p>

</div>
</div>
<a class="anchor" id="a3ce002195299049e9925e94546d989b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1SnarlManager_1_1SnarlRecord.html">SnarlRecord</a>* vg::SnarlManager::record </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td>
          <td class="paramname"><em>snarl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="structvg_1_1SnarlManager_1_1SnarlRecord.html">SnarlRecord</a> for a managed snarl. </p>

</div>
</div>
<a class="anchor" id="ae5015eacc04d12d02ef5196fb23f3075"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SnarlManager::regularize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Modify the snarls and chains to enforce a couple of invariants:</p>
<ol type="1">
<li>The start node IDs of the snarls in a chain shall be unique.</li>
</ol>
<p>(This is needed by the distance indexing code, which identifies child snarls by their start nodes. TODO: That distance indexing code needs to also work out unary snarls abitting the ends of chains, which may be allowed eventually.)</p>
<ol type="1">
<li>Snarls will be oriented forward in their chains.</li>
<li>Snarls will be oriented in a chain to maximize the number of snarls that start with lower node IDs than they end with.</li>
</ol>
<p>Depends on the indexes from <a class="el" href="classvg_1_1SnarlManager.html#a962ce88320136f82a1f5f58a036698c2" title="Builds tree indexes after Snarls have been added to the snarls vector. ">build_indexes()</a> having been built. </p>

</div>
</div>
<a class="anchor" id="a58ad5160df9e8435fe99e972a4ffd02e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;unordered_set&lt;<a class="el" href="structvg_1_1Node.html">Node</a>*&gt;, unordered_set&lt;<a class="el" href="structvg_1_1Edge.html">Edge</a>*&gt; &gt; vg::SnarlManager::shallow_contents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td>
          <td class="paramname"><em>snarl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_boundary_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Nodes and Edges contained in this <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> but not in any child Snarls (always includes the Nodes that form the boundaries of child Snarls, optionally includes this <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a>'s own boundary Nodes) </p>

</div>
</div>
<a class="anchor" id="aea761735531b87113912b801bed2e078"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt;pair&lt;int64_t, bool&gt;, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a>*&gt; vg::SnarlManager::snarl_boundary_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a map from all <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> boundaries to the <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> they point into. Note that this means that end boundaries will be reversed. </p>

</div>
</div>
<a class="anchor" id="a32c67c2b436a8eadda6a0ef24ae3fb5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt;pair&lt;int64_t, bool&gt;, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a>*&gt; vg::SnarlManager::snarl_end_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a map from all <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> end boundaries to the <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> they point into. Note that this means that end boundaries will be reversed. </p>

</div>
</div>
<a class="anchor" id="acdc1b95707babec9c7cd8436ddbd7d45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a>* vg::SnarlManager::snarl_sharing_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td>
          <td class="paramname"><em>here</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a>, if any, that shares this <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a>'s end node as either its start or its end. Does not count this snarl, even if this snarl is unary. Basic operation used to traverse a chain. Caller must account for snarls' orientations within a chain. </p>

</div>
</div>
<a class="anchor" id="a55675e8bb8ad6b81b09328f5261335e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a>* vg::SnarlManager::snarl_sharing_start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td>
          <td class="paramname"><em>here</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a>, if any, that shares this <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a>'s start node as either its start or its end. Does not count this snarl, even if this snarl is unary. Basic operation used to traverse a chain. Caller must account for snarls' orientations within a chain. </p>

</div>
</div>
<a class="anchor" id="a3439bdd4ff6e1bcc80c195d9dc7844b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt;pair&lt;int64_t, bool&gt;, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a>*&gt; vg::SnarlManager::snarl_start_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a map from all <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> start boundaries to the <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> they point into. </p>

</div>
</div>
<a class="anchor" id="a98fcfa5fb523b8d1bbbdf773ab85c0d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt;const <a class="el" href="structvg_1_1Snarl.html">Snarl</a>*&gt;&amp; vg::SnarlManager::top_level_snarls </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to a vector with the roots of the <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> trees. </p>

</div>
</div>
<a class="anchor" id="a42a87a6e424e9b39f77b43061b692039"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a>* vg::SnarlManager::unrecord </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1SnarlManager_1_1SnarlRecord.html">SnarlRecord</a> *&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the const <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> owned by a const <a class="el" href="structvg_1_1SnarlManager_1_1SnarlRecord.html">SnarlRecord</a>. </p>

</div>
</div>
<a class="anchor" id="aeeb8bf1eb342004f69b33caadad5a713"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Snarl.html">Snarl</a>* vg::SnarlManager::unrecord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1SnarlManager_1_1SnarlRecord.html">SnarlRecord</a> *&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> owned by a <a class="el" href="structvg_1_1SnarlManager_1_1SnarlRecord.html">SnarlRecord</a>. </p>

</div>
</div>
<a class="anchor" id="a9b60d404998384059e8dd9e0432cda87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="structvg_1_1Visit.html">Visit</a>&gt; vg::SnarlManager::visits_left </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;&#160;</td>
          <td class="paramname"><em>visit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td>
          <td class="paramname"><em>in_snarl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Look left from the given visit in the given graph and gets all the attached Visits to nodes or snarls. </p>

</div>
</div>
<a class="anchor" id="aceb4b4d043dd52455571b2eef780cb31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="structvg_1_1Visit.html">Visit</a>&gt; vg::SnarlManager::visits_right </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;&#160;</td>
          <td class="paramname"><em>visit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td>
          <td class="paramname"><em>in_snarl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Look left from the given visit in the given graph and gets all the attached Visits to nodes or snarls. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a2d9758d889f875b1260f49985cf3ef35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">deque&lt;<a class="el" href="namespacevg.html#aa9d8b2ece3ab50a38656273662553f2d">Chain</a>&gt; vg::SnarlManager::root_chains</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Chains of root-level snarls. Uses a deque so Chain* pointers don't get invalidated. </p>

</div>
</div>
<a class="anchor" id="ab13a661f6abe1feaf2c4ca4471a85a90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;const <a class="el" href="structvg_1_1Snarl.html">Snarl</a>*&gt; vg::SnarlManager::roots</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Roots of snarl trees. </p>

</div>
</div>
<a class="anchor" id="a0f1d327aa074d59976802999d0d179d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt;pair&lt;int64_t, bool&gt;, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a>*&gt; vg::SnarlManager::snarl_into</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map of node traversals to the snarls they point into. </p>

</div>
</div>
<a class="anchor" id="ab56cf756bc65189eeb1d4f1f3f6573b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">deque&lt;<a class="el" href="structvg_1_1SnarlManager_1_1SnarlRecord.html">SnarlRecord</a>&gt; vg::SnarlManager::snarls</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Master list of the snarls in the graph. Use a deque so pointers never get invalidated but we still have some locality. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="snarls_8hpp.html">snarls.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
