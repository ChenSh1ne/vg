<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::HaplotypeIndexer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1HaplotypeIndexer.html">HaplotypeIndexer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classvg_1_1HaplotypeIndexer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::HaplotypeIndexer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;haplotype_indexer.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vg::HaplotypeIndexer:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvg_1_1HaplotypeIndexer.png" usemap="#vg::HaplotypeIndexer_map" alt=""/>
  <map id="vg::HaplotypeIndexer_map" name="vg::HaplotypeIndexer_map">
<area href="classvg_1_1Progressive.html" alt="vg::Progressive" shape="rect" coords="0,0,131,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae0b8cbfe64f32152ceefa57daf9ece72"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HaplotypeIndexer.html#ae0b8cbfe64f32152ceefa57daf9ece72">HaplotypeIndexer</a> ()</td></tr>
<tr class="memdesc:ae0b8cbfe64f32152ceefa57daf9ece72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform initialization of backing libraries.  <a href="#ae0b8cbfe64f32152ceefa57daf9ece72">More...</a><br /></td></tr>
<tr class="separator:ae0b8cbfe64f32152ceefa57daf9ece72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55930d99cba18adc343d9aeac16dae9f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HaplotypeIndexer.html#a55930d99cba18adc343d9aeac16dae9f">parse_vcf</a> (const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> *graph, map&lt; string, <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;alt_paths, const vector&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;contigs, vcflib::VariantCallFile &amp;variant_file, std::vector&lt; std::string &gt; &amp;sample_names, const function&lt; void(size_t, const gbwt::VariantPaths &amp;, gbwt::PhasingInformation &amp;)&gt; &amp;handle_contig_haplotype_batch)</td></tr>
<tr class="separator:a55930d99cba18adc343d9aeac16dae9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49df3c8edf46023038e552aff560b767"><td class="memItemLeft" align="right" valign="top">tuple&lt; vector&lt; string &gt;, size_t, vector&lt; string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HaplotypeIndexer.html#a49df3c8edf46023038e552aff560b767">generate_threads</a> (const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> *graph, map&lt; string, <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;alt_paths, bool <a class="el" href="classvg_1_1HaplotypeIndexer.html#ad9505a82880c8d30cd41bc83c4a9d76b">index_paths</a>, const string &amp;vcf_filename, const vector&lt; string &gt; &amp;aln_filenames, const string &amp;aln_format, const function&lt; void(size_t)&gt; &amp;bit_width_ready, const function&lt; void(const gbwt::vector_type &amp;, const gbwt::size_type(&amp;)[4])&gt; &amp;each_thread)</td></tr>
<tr class="separator:a49df3c8edf46023038e552aff560b767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a04acd03b684f8d8a476b72bb811bf"><td class="memItemLeft" align="right" valign="top">unique_ptr&lt; gbwt::DynamicGBWT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HaplotypeIndexer.html#ab2a04acd03b684f8d8a476b72bb811bf">build_gbwt</a> (const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> *graph, map&lt; string, <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;alt_paths, bool <a class="el" href="classvg_1_1HaplotypeIndexer.html#ad9505a82880c8d30cd41bc83c4a9d76b">index_paths</a>, const string &amp;vcf_filename, const vector&lt; string &gt; &amp;aln_filenames, const string &amp;aln_format)</td></tr>
<tr class="separator:ab2a04acd03b684f8d8a476b72bb811bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvg_1_1Progressive"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classvg_1_1Progressive')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvg_1_1Progressive.html">vg::Progressive</a></td></tr>
<tr class="memitem:a4eb5050eb36ed519cbfa398748ef183b inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#a4eb5050eb36ed519cbfa398748ef183b">preload_progress</a> (const string &amp;message)</td></tr>
<tr class="separator:a4eb5050eb36ed519cbfa398748ef183b inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cce3f715516ed2bbb4ce3a312b01e02 inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#a1cce3f715516ed2bbb4ce3a312b01e02">create_progress</a> (const string &amp;message, long count)</td></tr>
<tr class="separator:a1cce3f715516ed2bbb4ce3a312b01e02 inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d4e92a36a277be5bc0cee5d01f5ca1 inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#a75d4e92a36a277be5bc0cee5d01f5ca1">create_progress</a> (long count)</td></tr>
<tr class="separator:a75d4e92a36a277be5bc0cee5d01f5ca1 inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d64e6aa69bc094c163f4827602a302c inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#a0d64e6aa69bc094c163f4827602a302c">update_progress</a> (long i)</td></tr>
<tr class="separator:a0d64e6aa69bc094c163f4827602a302c inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1de11917caf25974a02e2f5c3946280 inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#ab1de11917caf25974a02e2f5c3946280">increment_progress</a> ()</td></tr>
<tr class="separator:ab1de11917caf25974a02e2f5c3946280 inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab8c6ae92870077bb59f86a15c8d18f inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#aaab8c6ae92870077bb59f86a15c8d18f">destroy_progress</a> (void)</td></tr>
<tr class="separator:aaab8c6ae92870077bb59f86a15c8d18f inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:afb3592792a7d781cb6e88fe7949b7bfe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HaplotypeIndexer.html#afb3592792a7d781cb6e88fe7949b7bfe">warn_on_missing_variants</a> = true</td></tr>
<tr class="memdesc:afb3592792a7d781cb6e88fe7949b7bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a warning if variants in the VCF can't be found in the graph.  <a href="#afb3592792a7d781cb6e88fe7949b7bfe">More...</a><br /></td></tr>
<tr class="separator:afb3592792a7d781cb6e88fe7949b7bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71ee1525ebe28961647878f3b08c016"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HaplotypeIndexer.html#ab71ee1525ebe28961647878f3b08c016">found_missing_variants</a> = 0</td></tr>
<tr class="separator:ab71ee1525ebe28961647878f3b08c016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512203218e3b78afa0fc5c0e594e6516"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HaplotypeIndexer.html#a512203218e3b78afa0fc5c0e594e6516">max_missing_variant_warnings</a> = 10</td></tr>
<tr class="memdesc:a512203218e3b78afa0fc5c0e594e6516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only report up to this many of them.  <a href="#a512203218e3b78afa0fc5c0e594e6516">More...</a><br /></td></tr>
<tr class="separator:a512203218e3b78afa0fc5c0e594e6516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae814c4307983b700ace3cce764a412ca"><td class="memItemLeft" align="right" valign="top">map&lt; string, string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HaplotypeIndexer.html#ae814c4307983b700ace3cce764a412ca">path_to_vcf</a></td></tr>
<tr class="separator:ae814c4307983b700ace3cce764a412ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8061130697dc26811303c4b67b081245"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HaplotypeIndexer.html#a8061130697dc26811303c4b67b081245">rename_variants</a> = true</td></tr>
<tr class="separator:a8061130697dc26811303c4b67b081245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3823e07210ab4a9ceabd7de359f0ce37"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HaplotypeIndexer.html#a3823e07210ab4a9ceabd7de359f0ce37">batch_file_prefix</a> = &quot;&quot;</td></tr>
<tr class="separator:a3823e07210ab4a9ceabd7de359f0ce37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9505a82880c8d30cd41bc83c4a9d76b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HaplotypeIndexer.html#ad9505a82880c8d30cd41bc83c4a9d76b">index_paths</a> = false</td></tr>
<tr class="separator:ad9505a82880c8d30cd41bc83c4a9d76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881e755025092748b18f037fb1078e65"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HaplotypeIndexer.html#a881e755025092748b18f037fb1078e65">phase_homozygous</a> = true</td></tr>
<tr class="memdesc:a881e755025092748b18f037fb1078e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Phase homozygous unphased variants.  <a href="#a881e755025092748b18f037fb1078e65">More...</a><br /></td></tr>
<tr class="separator:a881e755025092748b18f037fb1078e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb44a055288c0a9debed5662e461959e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HaplotypeIndexer.html#acb44a055288c0a9debed5662e461959e">force_phasing</a> = false</td></tr>
<tr class="memdesc:acb44a055288c0a9debed5662e461959e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arbitrarily phase all unphased variants.  <a href="#acb44a055288c0a9debed5662e461959e">More...</a><br /></td></tr>
<tr class="separator:acb44a055288c0a9debed5662e461959e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9991b56b5003075a5a072e06e669a3c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HaplotypeIndexer.html#a9991b56b5003075a5a072e06e669a3c1">discard_overlaps</a> = false</td></tr>
<tr class="memdesc:a9991b56b5003075a5a072e06e669a3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join together overlapping haplotypes.  <a href="#a9991b56b5003075a5a072e06e669a3c1">More...</a><br /></td></tr>
<tr class="separator:a9991b56b5003075a5a072e06e669a3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681bcf3fb6014ae885adb3dec25ff2fc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HaplotypeIndexer.html#a681bcf3fb6014ae885adb3dec25ff2fc">samples_in_batch</a> = 200</td></tr>
<tr class="memdesc:a681bcf3fb6014ae885adb3dec25ff2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of samples to process together in a haplotype batch.  <a href="#a681bcf3fb6014ae885adb3dec25ff2fc">More...</a><br /></td></tr>
<tr class="separator:a681bcf3fb6014ae885adb3dec25ff2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8d5ce81546e16ffb7bf652c098bb11"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HaplotypeIndexer.html#abc8d5ce81546e16ffb7bf652c098bb11">gbwt_buffer_size</a> = gbwt::DynamicGBWT::INSERT_BATCH_SIZE / gbwt::MILLION</td></tr>
<tr class="memdesc:abc8d5ce81546e16ffb7bf652c098bb11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the GBWT buffer in millions of nodes.  <a href="#abc8d5ce81546e16ffb7bf652c098bb11">More...</a><br /></td></tr>
<tr class="separator:abc8d5ce81546e16ffb7bf652c098bb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71885cc768549e78097e76e77e90ea8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HaplotypeIndexer.html#af71885cc768549e78097e76e77e90ea8">id_interval</a> = gbwt::DynamicGBWT::SAMPLE_INTERVAL</td></tr>
<tr class="memdesc:af71885cc768549e78097e76e77e90ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interval at which to sample for GBWT locate.  <a href="#af71885cc768549e78097e76e77e90ea8">More...</a><br /></td></tr>
<tr class="separator:af71885cc768549e78097e76e77e90ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfc79b62d07a12ccc173ba953a6482d"><td class="memItemLeft" align="right" valign="top">pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HaplotypeIndexer.html#abbfc79b62d07a12ccc173ba953a6482d">sample_range</a> = pair&lt;size_t, size_t&gt;(0, numeric_limits&lt;size_t&gt;::max())</td></tr>
<tr class="memdesc:abbfc79b62d07a12ccc173ba953a6482d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvg_1_1Range.html" title="This defines a range of values to test, from start to &lt;=end, going up by step. ">Range</a> of VCF samples to process (first to past-last).  <a href="#abbfc79b62d07a12ccc173ba953a6482d">More...</a><br /></td></tr>
<tr class="separator:abbfc79b62d07a12ccc173ba953a6482d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add79c3d35a8a04fb5147a8dda65de8bf"><td class="memItemLeft" align="right" valign="top">map&lt; string, pair&lt; size_t, size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HaplotypeIndexer.html#add79c3d35a8a04fb5147a8dda65de8bf">regions</a></td></tr>
<tr class="separator:add79c3d35a8a04fb5147a8dda65de8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead849ac7d6dc12063c666a0222e3bef"><td class="memItemLeft" align="right" valign="top">unordered_set&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HaplotypeIndexer.html#aead849ac7d6dc12063c666a0222e3bef">excluded_samples</a></td></tr>
<tr class="separator:aead849ac7d6dc12063c666a0222e3bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classvg_1_1Progressive"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classvg_1_1Progressive')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classvg_1_1Progressive.html">vg::Progressive</a></td></tr>
<tr class="memitem:a6653625f496832c4cb8711185d5e04cb inherit pub_attribs_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#a6653625f496832c4cb8711185d5e04cb">show_progress</a> = false</td></tr>
<tr class="separator:a6653625f496832c4cb8711185d5e04cb inherit pub_attribs_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Allows indexing haplotypes, either to pre-parsed haplotype files or to a GBWT. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae0b8cbfe64f32152ceefa57daf9ece72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b8cbfe64f32152ceefa57daf9ece72">&#9670;&nbsp;</a></span>HaplotypeIndexer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::HaplotypeIndexer::HaplotypeIndexer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform initialization of backing libraries. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab2a04acd03b684f8d8a476b72bb811bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a04acd03b684f8d8a476b72bb811bf">&#9670;&nbsp;</a></span>build_gbwt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; gbwt::DynamicGBWT &gt; vg::HaplotypeIndexer::build_gbwt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; string, <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>alt_paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>index_paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>vcf_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>aln_filenames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>aln_format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build a GBWT from the given haplotype sources.</p>
<p>graph is the graph to operate on.</p>
<p>alt_paths is a map of pre-extracted alt paths. If not filled in, alt paths will be extracted. The map will be cleared when the function returns.</p>
<p>index_paths is a flag for whether to include non-alt paths in the graph as haplotypes in the GBWT.</p>
<p>If vcf_filename is set, includes haplotypes from the VCF in the GBWT. If batch_file_prefix is set on the object, also dumps VCF parse information.</p>
<p>If aln_filenames is nonempty, includes alignment paths from those files as haplotypes. In that case, index_paths must be false and vcf_filenames must be empty.</p>
<p>aln_format can be "GAM" or "GAF"</p>
<p>Respects excluded_samples and does not produce threads for them. </p>

</div>
</div>
<a id="a49df3c8edf46023038e552aff560b767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49df3c8edf46023038e552aff560b767">&#9670;&nbsp;</a></span>generate_threads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple&lt; vector&lt; string &gt;, size_t, vector&lt; string &gt; &gt; vg::HaplotypeIndexer::generate_threads </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; string, <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>alt_paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>index_paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>vcf_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>aln_filenames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>aln_format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>bit_width_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const gbwt::vector_type &amp;, const gbwt::size_type(&amp;)[4])&gt; &amp;&#160;</td>
          <td class="paramname"><em>each_thread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Collect haplotype threads and metadata by combining haplotype sources.</p>
<p>graph is the graph to operate on.</p>
<p>alt_paths is a map of pre-extracted alt paths. If not filled in, alt paths will be extracted. The map will be cleared when the function returns.</p>
<p>index_paths is a flag for whether to include non-alt paths in the graph as haplotypes in the GBWT.</p>
<p>If vcf_filename is set, includes haplotypes from the VCF in the GBWT. If batch_file_prefix is set on the object, also dumps VCF parse information.</p>
<p>If aln_filenames is nonempty, includes alignment paths from those files as haplotypes. In that case, index_paths must be false and vcf_filenames must be empty.</p>
<p>aln_format can be "GAM" or "GAF"</p>
<p>First, determines the bit width necessary to encode the threads that will be produced, and announces it to the bit_width_ready callback.</p>
<p>Then, for each thread in serial (describing a contiguous portion of a haplotype on a contig), calls each_thread with the thread data itself and an array of numbers describing the thread name.</p>
<p>Respects excluded_samples and does not produce threads for them.</p>
<p>Returns the sample names, the total haplotype count, and the contig names. </p>

</div>
</div>
<a id="a55930d99cba18adc343d9aeac16dae9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55930d99cba18adc343d9aeac16dae9f">&#9670;&nbsp;</a></span>parse_vcf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::HaplotypeIndexer::parse_vcf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; string, <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>alt_paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>contigs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcflib::VariantCallFile &amp;&#160;</td>
          <td class="paramname"><em>variant_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>sample_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(size_t, const gbwt::VariantPaths &amp;, gbwt::PhasingInformation &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>handle_contig_haplotype_batch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse a VCF file into the types needed for GBWT indexing.</p>
<p>Takes a graph, a map of alt paths by name that will be extracted from the graph if not populated, a vector of contigs in the graph to process, in order, and the corresponding VCF file, already open. Sample parsing on the VCF file should be turned off.</p>
<p>Uses the given vector of sample names, which must be pre-populated with any other samples (such as "ref") already in a GBWTBuilder that you are using with the results of this function. Sample names from the VCF will be added.</p>
<p>Calls the callback serially with the contig number, each contig's gbwt::VariantPaths, for each gbwt::PhasingInformation batch of samples. The gbwt::PhasingInformation is not const because the GBWT library needs to modify it in order to generate haplotypes from it efficiently.</p>
<p>If batch_file_prefix is set on the object, also dumps VCF parse information.</p>
<p>Doesn't create threads for embedded graph paths itself.</p>
<p>Ignores excluded_samples.</p>
<p>Returns the number of haplotypes created (2 per sample) This number will need to be adjusted if any samples' haplotypes are filtered out later. This function ignores any sample filters and processes the entire VCF. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3823e07210ab4a9ceabd7de359f0ce37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3823e07210ab4a9ceabd7de359f0ce37">&#9670;&nbsp;</a></span>batch_file_prefix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::HaplotypeIndexer::batch_file_prefix = &quot;&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If batch_file_prefix is nonempty, a file for each contig is saved to PREFIX_VCFCONTIG, and files for each batch of haplotypes are saved to files named like PREFIX_VCFCONTIG_STARTSAMPLE_ENDSAMPLE. Otherwise, the batch files are still saved, but to temporary files. </p>

</div>
</div>
<a id="a9991b56b5003075a5a072e06e669a3c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9991b56b5003075a5a072e06e669a3c1">&#9670;&nbsp;</a></span>discard_overlaps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::HaplotypeIndexer::discard_overlaps = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join together overlapping haplotypes. </p>

</div>
</div>
<a id="aead849ac7d6dc12063c666a0222e3bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead849ac7d6dc12063c666a0222e3bef">&#9670;&nbsp;</a></span>excluded_samples</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_set&lt;string&gt; vg::HaplotypeIndexer::excluded_samples</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Excluded VCF sample names, for which threads will not be generated. Ignored during VCF parsing. </p>

</div>
</div>
<a id="acb44a055288c0a9debed5662e461959e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb44a055288c0a9debed5662e461959e">&#9670;&nbsp;</a></span>force_phasing</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::HaplotypeIndexer::force_phasing = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arbitrarily phase all unphased variants. </p>

</div>
</div>
<a id="ab71ee1525ebe28961647878f3b08c016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71ee1525ebe28961647878f3b08c016">&#9670;&nbsp;</a></span>found_missing_variants</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::HaplotypeIndexer::found_missing_variants = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Track the number of variants in the phasing VCF that aren't found in the graph TODO: Make atomic? </p>

</div>
</div>
<a id="abc8d5ce81546e16ffb7bf652c098bb11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8d5ce81546e16ffb7bf652c098bb11">&#9670;&nbsp;</a></span>gbwt_buffer_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::HaplotypeIndexer::gbwt_buffer_size = gbwt::DynamicGBWT::INSERT_BATCH_SIZE / gbwt::MILLION</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of the GBWT buffer in millions of nodes. </p>

</div>
</div>
<a id="af71885cc768549e78097e76e77e90ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71885cc768549e78097e76e77e90ea8">&#9670;&nbsp;</a></span>id_interval</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::HaplotypeIndexer::id_interval = gbwt::DynamicGBWT::SAMPLE_INTERVAL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interval at which to sample for GBWT locate. </p>

</div>
</div>
<a id="ad9505a82880c8d30cd41bc83c4a9d76b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9505a82880c8d30cd41bc83c4a9d76b">&#9670;&nbsp;</a></span>index_paths</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::HaplotypeIndexer::index_paths = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If set to true, store paths from the graph alognside haplotype threads from the VCF, if any. </p>

</div>
</div>
<a id="a512203218e3b78afa0fc5c0e594e6516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512203218e3b78afa0fc5c0e594e6516">&#9670;&nbsp;</a></span>max_missing_variant_warnings</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::HaplotypeIndexer::max_missing_variant_warnings = 10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Only report up to this many of them. </p>

</div>
</div>
<a id="ae814c4307983b700ace3cce764a412ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae814c4307983b700ace3cce764a412ca">&#9670;&nbsp;</a></span>path_to_vcf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;string, string&gt; vg::HaplotypeIndexer::path_to_vcf</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="structvg_1_1Path.html">Path</a> names in the graph are mapped to VCF contig names via path_to_vcf, or used as-is if no entry there is found. </p>

</div>
</div>
<a id="a881e755025092748b18f037fb1078e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881e755025092748b18f037fb1078e65">&#9670;&nbsp;</a></span>phase_homozygous</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::HaplotypeIndexer::phase_homozygous = true</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Phase homozygous unphased variants. </p>

</div>
</div>
<a id="add79c3d35a8a04fb5147a8dda65de8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add79c3d35a8a04fb5147a8dda65de8bf">&#9670;&nbsp;</a></span>regions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;string, pair&lt;size_t, size_t&gt; &gt; vg::HaplotypeIndexer::regions</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="structvg_1_1Region.html">Region</a> restrictions for contigs, in VCF name space, as 0-based exclusive-end ranges. </p>

</div>
</div>
<a id="a8061130697dc26811303c4b67b081245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8061130697dc26811303c4b67b081245">&#9670;&nbsp;</a></span>rename_variants</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::HaplotypeIndexer::rename_variants = true</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use graph path names instead of VCF path names when composing variant alt paths. </p>

</div>
</div>
<a id="abbfc79b62d07a12ccc173ba953a6482d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbfc79b62d07a12ccc173ba953a6482d">&#9670;&nbsp;</a></span>sample_range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;size_t, size_t&gt; vg::HaplotypeIndexer::sample_range = pair&lt;size_t, size_t&gt;(0, numeric_limits&lt;size_t&gt;::max())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structvg_1_1Range.html" title="This defines a range of values to test, from start to &lt;=end, going up by step. ">Range</a> of VCF samples to process (first to past-last). </p>

</div>
</div>
<a id="a681bcf3fb6014ae885adb3dec25ff2fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a681bcf3fb6014ae885adb3dec25ff2fc">&#9670;&nbsp;</a></span>samples_in_batch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::HaplotypeIndexer::samples_in_batch = 200</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of samples to process together in a haplotype batch. </p>

</div>
</div>
<a id="afb3592792a7d781cb6e88fe7949b7bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3592792a7d781cb6e88fe7949b7bfe">&#9670;&nbsp;</a></span>warn_on_missing_variants</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::HaplotypeIndexer::warn_on_missing_variants = true</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a warning if variants in the VCF can't be found in the graph. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="haplotype__indexer_8hpp.html">haplotype_indexer.hpp</a></li>
<li>src/<a class="el" href="haplotype__indexer_8cpp.html">haplotype_indexer.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
