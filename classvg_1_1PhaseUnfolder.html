<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>vg: vg::PhaseUnfolder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1PhaseUnfolder.html">PhaseUnfolder</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classvg_1_1PhaseUnfolder-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::PhaseUnfolder Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;phase_unfolder.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7484966dc448f4c3b894a53233f46d9f"><td class="memItemLeft" align="right" valign="top">typedef gbwt::SearchState&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#a7484966dc448f4c3b894a53233f46d9f">search_type</a></td></tr>
<tr class="separator:a7484966dc448f4c3b894a53233f46d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402b0f84990279594bfbb1cd71ffd8e5"><td class="memItemLeft" align="right" valign="top">typedef gbwt::vector_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#a402b0f84990279594bfbb1cd71ffd8e5">path_type</a></td></tr>
<tr class="separator:a402b0f84990279594bfbb1cd71ffd8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95529e399d5ef61f6a426e1b5cfe9237"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; <a class="el" href="classvg_1_1PhaseUnfolder.html#a7484966dc448f4c3b894a53233f46d9f">search_type</a>, <br class="typebreak"/>
<a class="el" href="classvg_1_1PhaseUnfolder.html#a402b0f84990279594bfbb1cd71ffd8e5">path_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#a95529e399d5ef61f6a426e1b5cfe9237">state_type</a></td></tr>
<tr class="separator:a95529e399d5ef61f6a426e1b5cfe9237"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1db52634162af03c2cb8e88ac9087ca2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#a1db52634162af03c2cb8e88ac9087ca2">PhaseUnfolder</a> (const <a class="el" href="classxg_1_1XG.html">xg::XG</a> &amp;<a class="el" href="classvg_1_1PhaseUnfolder.html#af243361112a7fce2eb831c28c735f6be">xg_index</a>, const gbwt::GBWT &amp;<a class="el" href="classvg_1_1PhaseUnfolder.html#abe0ad79b8b65bea2a4f871913c83ee65">gbwt_index</a>, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">vg::id_t</a> next_node)</td></tr>
<tr class="separator:a1db52634162af03c2cb8e88ac9087ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f0d57a45dd09927cfa2cb5dbc9115f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#a58f0d57a45dd09927cfa2cb5dbc9115f">unfold</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;graph, bool show_progress=false)</td></tr>
<tr class="separator:a58f0d57a45dd09927cfa2cb5dbc9115f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98e5c7496de1812a297eb95af4be6b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#ae98e5c7496de1812a297eb95af4be6b0">restore_paths</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;graph, bool show_progress=false) const </td></tr>
<tr class="separator:ae98e5c7496de1812a297eb95af4be6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aab2694e14dac4f3520932588711388"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#a3aab2694e14dac4f3520932588711388">verify_paths</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;unfolded, bool show_progress=false) const </td></tr>
<tr class="separator:a3aab2694e14dac4f3520932588711388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c276c53410eebfadeafb72539c3f37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#a78c276c53410eebfadeafb72539c3f37">write_mapping</a> (const std::string &amp;filename) const </td></tr>
<tr class="separator:a78c276c53410eebfadeafb72539c3f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf93e421183b64f73276639c3c23dfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#adbf93e421183b64f73276639c3c23dfb">read_mapping</a> (const std::string &amp;filename)</td></tr>
<tr class="separator:adbf93e421183b64f73276639c3c23dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495a17bd92b71379b3e7b9b8e805322e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">vg::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#a495a17bd92b71379b3e7b9b8e805322e">get_mapping</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">vg::id_t</a> node) const </td></tr>
<tr class="separator:a495a17bd92b71379b3e7b9b8e805322e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3e1fd06e6b6140b41c42f4c7beae4eb9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structvg_1_1Edge.html">Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#a3e1fd06e6b6140b41c42f4c7beae4eb9">make_edge</a> (gbwt::node_type from, gbwt::node_type to)</td></tr>
<tr class="separator:a3e1fd06e6b6140b41c42f4c7beae4eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aa9f017a0cd422c1229edd25c0235e17a"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="classvg_1_1VG.html">VG</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#aa9f017a0cd422c1229edd25c0235e17a">complement_components</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;graph, bool show_progress)</td></tr>
<tr class="separator:aa9f017a0cd422c1229edd25c0235e17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac274b029b11fb5e049701eff948d7b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#a1ac274b029b11fb5e049701eff948d7b">unfold_component</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;component, <a class="el" href="classvg_1_1VG.html">VG</a> &amp;graph, <a class="el" href="classvg_1_1VG.html">VG</a> &amp;unfolded)</td></tr>
<tr class="separator:a1ac274b029b11fb5e049701eff948d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79c28e9eeb018ce3f59fa3a863697c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#aa79c28e9eeb018ce3f59fa3a863697c2">generate_paths</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;component, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">vg::id_t</a> from)</td></tr>
<tr class="separator:aa79c28e9eeb018ce3f59fa3a863697c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03abe6d87d589e1d3736ae9edd5a518"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#af03abe6d87d589e1d3736ae9edd5a518">generate_threads</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;component, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">vg::id_t</a> from)</td></tr>
<tr class="separator:af03abe6d87d589e1d3736ae9edd5a518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02d721a40368b2da3a34909399c82d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#ad02d721a40368b2da3a34909399c82d2">create_state</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">vg::id_t</a> node, bool is_reverse, bool starting)</td></tr>
<tr class="separator:ad02d721a40368b2da3a34909399c82d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610d8256b9dc58fe6d04b1ff7aaafebb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#a610d8256b9dc58fe6d04b1ff7aaafebb">extend_state</a> (<a class="el" href="classvg_1_1PhaseUnfolder.html#a95529e399d5ef61f6a426e1b5cfe9237">state_type</a> state, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">vg::id_t</a> node, bool is_reverse)</td></tr>
<tr class="separator:a610d8256b9dc58fe6d04b1ff7aaafebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a20697627b7742f98776111b8dbc66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#a40a20697627b7742f98776111b8dbc66">extend_path</a> (const <a class="el" href="classvg_1_1PhaseUnfolder.html#a402b0f84990279594bfbb1cd71ffd8e5">path_type</a> &amp;path)</td></tr>
<tr class="separator:a40a20697627b7742f98776111b8dbc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e7cee8d0922cf0aac91dba0d86f1c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#a28e7cee8d0922cf0aac91dba0d86f1c3">insert_path</a> (const <a class="el" href="classvg_1_1PhaseUnfolder.html#a402b0f84990279594bfbb1cd71ffd8e5">path_type</a> &amp;path, bool from_border, bool to_border)</td></tr>
<tr class="memdesc:a28e7cee8d0922cf0aac91dba0d86f1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the path into the set in the canonical orientation.  <a href="#a28e7cee8d0922cf0aac91dba0d86f1c3">More...</a><br/></td></tr>
<tr class="separator:a28e7cee8d0922cf0aac91dba0d86f1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae52ee7605f03c82622c63c55463db7"><td class="memItemLeft" align="right" valign="top">gbwt::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#abae52ee7605f03c82622c63c55463db7">get_prefix</a> (gbwt::node_type from, gbwt::node_type node)</td></tr>
<tr class="memdesc:abae52ee7605f03c82622c63c55463db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id for the duplicate of 'node' after 'from'.  <a href="#abae52ee7605f03c82622c63c55463db7">More...</a><br/></td></tr>
<tr class="separator:abae52ee7605f03c82622c63c55463db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97128de268b43c9ccf9dd117829adedf"><td class="memItemLeft" align="right" valign="top">gbwt::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#a97128de268b43c9ccf9dd117829adedf">get_suffix</a> (gbwt::node_type node, gbwt::node_type to)</td></tr>
<tr class="memdesc:a97128de268b43c9ccf9dd117829adedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id for the duplicate of 'node' before 'to'.  <a href="#a97128de268b43c9ccf9dd117829adedf">More...</a><br/></td></tr>
<tr class="separator:a97128de268b43c9ccf9dd117829adedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:af243361112a7fce2eb831c28c735f6be"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxg_1_1XG.html">xg::XG</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#af243361112a7fce2eb831c28c735f6be">xg_index</a></td></tr>
<tr class="memdesc:af243361112a7fce2eb831c28c735f6be"><td class="mdescLeft">&#160;</td><td class="mdescRight">XG and GBWT indexes for the original graph.  <a href="#af243361112a7fce2eb831c28c735f6be">More...</a><br/></td></tr>
<tr class="separator:af243361112a7fce2eb831c28c735f6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0ad79b8b65bea2a4f871913c83ee65"><td class="memItemLeft" align="right" valign="top">const gbwt::GBWT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#abe0ad79b8b65bea2a4f871913c83ee65">gbwt_index</a></td></tr>
<tr class="separator:abe0ad79b8b65bea2a4f871913c83ee65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30c8d79f4461cae38e4ec2268a22022"><td class="memItemLeft" align="right" valign="top">gcsa::NodeMapping&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#ae30c8d79f4461cae38e4ec2268a22022">mapping</a></td></tr>
<tr class="memdesc:ae30c8d79f4461cae38e4ec2268a22022"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvg_1_1Mapping.html">Mapping</a> from duplicated nodes to original ids.  <a href="#ae30c8d79f4461cae38e4ec2268a22022">More...</a><br/></td></tr>
<tr class="separator:ae30c8d79f4461cae38e4ec2268a22022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ec1d4e6557b27c4f92c0280c80b90a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1hash__set.html">hash_set</a>&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">vg::id_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#a29ec1d4e6557b27c4f92c0280c80b90a">border</a></td></tr>
<tr class="memdesc:a29ec1d4e6557b27c4f92c0280c80b90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal data structures for the current component.  <a href="#a29ec1d4e6557b27c4f92c0280c80b90a">More...</a><br/></td></tr>
<tr class="separator:a29ec1d4e6557b27c4f92c0280c80b90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d3333de41989b2ca10db84ddb1d5a8"><td class="memItemLeft" align="right" valign="top">std::stack&lt; <a class="el" href="classvg_1_1PhaseUnfolder.html#a95529e399d5ef61f6a426e1b5cfe9237">state_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#ac7d3333de41989b2ca10db84ddb1d5a8">states</a></td></tr>
<tr class="separator:ac7d3333de41989b2ca10db84ddb1d5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfa46441300e0817643b310aced989b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classvg_1_1PhaseUnfolder.html#a402b0f84990279594bfbb1cd71ffd8e5">path_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#a2bfa46441300e0817643b310aced989b">reference_paths</a></td></tr>
<tr class="separator:a2bfa46441300e0817643b310aced989b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f18b1c10e5d2104bd04df2013f5a0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1pair__hash__map.html">pair_hash_map</a>&lt; std::pair<br class="typebreak"/>
&lt; gbwt::node_type, <br class="typebreak"/>
gbwt::node_type &gt;<br class="typebreak"/>
, gbwt::node_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#a64f18b1c10e5d2104bd04df2013f5a0f">prefixes</a></td></tr>
<tr class="separator:a64f18b1c10e5d2104bd04df2013f5a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e235a2b6022ec40a6e66c63c8dd1df0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1pair__hash__map.html">pair_hash_map</a>&lt; std::pair<br class="typebreak"/>
&lt; gbwt::node_type, <br class="typebreak"/>
gbwt::node_type &gt;<br class="typebreak"/>
, gbwt::node_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#a8e235a2b6022ec40a6e66c63c8dd1df0">suffixes</a></td></tr>
<tr class="separator:a8e235a2b6022ec40a6e66c63c8dd1df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326b5a34e3c5255b95fbad3eb536fa48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1pair__hash__set.html">pair_hash_set</a>&lt; std::pair<br class="typebreak"/>
&lt; gbwt::node_type, <br class="typebreak"/>
gbwt::node_type &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html#a326b5a34e3c5255b95fbad3eb536fa48">crossing_edges</a></td></tr>
<tr class="separator:a326b5a34e3c5255b95fbad3eb536fa48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Transforms the pruned subregions of the input graph into collections of disconnected distinct traversal haplotypes. Use in combination with pruning to simplify the graph for GCSA2 indexing without losing observed variation. Requires the XG index of the original graph and an empty GBWT index or an GBWT index of the original graph. Note: <a class="el" href="classvg_1_1PhaseUnfolder.html">PhaseUnfolder</a> only considers paths of length &gt;= 2. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a402b0f84990279594bfbb1cd71ffd8e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef gbwt::vector_type <a class="el" href="classvg_1_1PhaseUnfolder.html#a402b0f84990279594bfbb1cd71ffd8e5">vg::PhaseUnfolder::path_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7484966dc448f4c3b894a53233f46d9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef gbwt::SearchState <a class="el" href="classvg_1_1PhaseUnfolder.html#a7484966dc448f4c3b894a53233f46d9f">vg::PhaseUnfolder::search_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a95529e399d5ef61f6a426e1b5cfe9237"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="classvg_1_1PhaseUnfolder.html#a7484966dc448f4c3b894a53233f46d9f">search_type</a>, <a class="el" href="classvg_1_1PhaseUnfolder.html#a402b0f84990279594bfbb1cd71ffd8e5">path_type</a>&gt; <a class="el" href="classvg_1_1PhaseUnfolder.html#a95529e399d5ef61f6a426e1b5cfe9237">vg::PhaseUnfolder::state_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1db52634162af03c2cb8e88ac9087ca2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::PhaseUnfolder::PhaseUnfolder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxg_1_1XG.html">xg::XG</a> &amp;&#160;</td>
          <td class="paramname"><em>xg_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gbwt::GBWT &amp;&#160;</td>
          <td class="paramname"><em>gbwt_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">vg::id_t</a>&#160;</td>
          <td class="paramname"><em>next_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a new <a class="el" href="classvg_1_1PhaseUnfolder.html">PhaseUnfolder</a> backed by the given XG and GBWT indexes. These indexes must represent the same original graph. 'next_node' should usually be max_node_id() + 1 in the original graph. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa9f017a0cd422c1229edd25c0235e17a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; <a class="el" href="classvg_1_1VG.html">VG</a> &gt; vg::PhaseUnfolder::complement_components </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate a complement graph consisting of the edges that are in the GBWT index but not in the input graph. Split the complement into disjoint components and return the components. </p>

</div>
</div>
<a class="anchor" id="ad02d721a40368b2da3a34909399c82d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PhaseUnfolder::create_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">vg::id_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>starting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create or extend the state with the given node orientation, and insert it into the stack if it is supported by the GBWT index. Use 'starting' to determine whether the initial state is for the threads starting at the node or for the threads passing through the node. </p>

</div>
</div>
<a class="anchor" id="a40a20697627b7742f98776111b8dbc66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PhaseUnfolder::extend_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1PhaseUnfolder.html#a402b0f84990279594bfbb1cd71ffd8e5">path_type</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Try to extend the path at both ends until the border by using the reference paths. Insert the extended path into the set in the canonical orientation. </p>

</div>
</div>
<a class="anchor" id="a610d8256b9dc58fe6d04b1ff7aaafebb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::PhaseUnfolder::extend_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1PhaseUnfolder.html#a95529e399d5ef61f6a426e1b5cfe9237">state_type</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">vg::id_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa79c28e9eeb018ce3f59fa3a863697c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PhaseUnfolder::generate_paths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">vg::id_t</a>&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate all paths supported by the XG index passing through the given node until the border or until the path ends. Insert the generated paths into the set in the canonical orientation, and use them as reference paths for extending threads. </p>

</div>
</div>
<a class="anchor" id="af03abe6d87d589e1d3736ae9edd5a518"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PhaseUnfolder::generate_threads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">vg::id_t</a>&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate all paths supported by the GBWT index from the given node until the border. Extend paths that start/end at internal nodes using the reference paths. If the node is a border node, consider all threads passing through it. Otherwise consider only the threads starting from it, and do not output threads reaching a border. </p>

</div>
</div>
<a class="anchor" id="a495a17bd92b71379b3e7b9b8e805322e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">vg::id_t</a> vg::PhaseUnfolder::get_mapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">vg::id_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the id of the corresponding node in the original graph. </p>

</div>
</div>
<a class="anchor" id="abae52ee7605f03c82622c63c55463db7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gbwt::node_type vg::PhaseUnfolder::get_prefix </td>
          <td>(</td>
          <td class="paramtype">gbwt::node_type&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gbwt::node_type&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the id for the duplicate of 'node' after 'from'. </p>

</div>
</div>
<a class="anchor" id="a97128de268b43c9ccf9dd117829adedf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gbwt::node_type vg::PhaseUnfolder::get_suffix </td>
          <td>(</td>
          <td class="paramtype">gbwt::node_type&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gbwt::node_type&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the id for the duplicate of 'node' before 'to'. </p>

</div>
</div>
<a class="anchor" id="a28e7cee8d0922cf0aac91dba0d86f1c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PhaseUnfolder::insert_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1PhaseUnfolder.html#a402b0f84990279594bfbb1cd71ffd8e5">path_type</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_border</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_border</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert the path into the set in the canonical orientation. </p>

</div>
</div>
<a class="anchor" id="a3e1fd06e6b6140b41c42f4c7beae4eb9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structvg_1_1Edge.html">Edge</a> vg::PhaseUnfolder::make_edge </td>
          <td>(</td>
          <td class="paramtype">gbwt::node_type&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gbwt::node_type&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an edge between two node orientations. </p>

</div>
</div>
<a class="anchor" id="adbf93e421183b64f73276639c3c23dfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PhaseUnfolder::read_mapping </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace the existing node mapping with the one loaded from the file. This should be used before calling <a class="el" href="classvg_1_1PhaseUnfolder.html#a58f0d57a45dd09927cfa2cb5dbc9115f">unfold()</a>. The identifiers for new duplicated nodes will follow the ones in the loaded mapping. </p>

</div>
</div>
<a class="anchor" id="ae98e5c7496de1812a297eb95af4be6b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PhaseUnfolder::restore_paths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_progress</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Restore the edges on XG paths. This is effectively the same as unfolding with an empty GBWT index, except that the inserted nodes will have their original identifiers. </p>

</div>
</div>
<a class="anchor" id="a58f0d57a45dd09927cfa2cb5dbc9115f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PhaseUnfolder::unfold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_progress</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unfold the pruned regions in the input graph:</p>
<ul>
<li>Determine the connected components of edges missing from the input graph, as determined by the XG paths and GBWT threads.</li>
<li>For each component, find all border-to-border paths and threads supported by the indexes. Then unfold the component by duplicating the nodes, so that the paths are disjoint, except for their shared prefixes and suffixes.</li>
<li>Extend the input graph with the unfolded components. </li>
</ul>

</div>
</div>
<a class="anchor" id="a1ac274b029b11fb5e049701eff948d7b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::PhaseUnfolder::unfold_component </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>unfolded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate all border-to-border paths in the component supported by the indexes. Unfold the paths by duplicating the inner nodes so that the paths become disjoint, except for their shared prefixes/suffixes. </p>

</div>
</div>
<a class="anchor" id="a3aab2694e14dac4f3520932588711388"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::PhaseUnfolder::verify_paths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>unfolded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_progress</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Verify that the graph contains the XG paths and the GBWT threads in the backing indexes. Returns the number of paths for which the verification failed. Uses OMP threads. </p>

</div>
</div>
<a class="anchor" id="a78c276c53410eebfadeafb72539c3f37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PhaseUnfolder::write_mapping </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the mapping to the specified file with a header. The file will contain mappings from header.next_node - header.mapping_size (inclusive) to header.next_node (exclusive). </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a29ec1d4e6557b27c4f92c0280c80b90a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1hash__set.html">hash_set</a>&lt;<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">vg::id_t</a>&gt; vg::PhaseUnfolder::border</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal data structures for the current component. </p>

</div>
</div>
<a class="anchor" id="a326b5a34e3c5255b95fbad3eb536fa48"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1pair__hash__set.html">pair_hash_set</a>&lt;std::pair&lt;gbwt::node_type, gbwt::node_type&gt; &gt; vg::PhaseUnfolder::crossing_edges</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abe0ad79b8b65bea2a4f871913c83ee65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const gbwt::GBWT&amp; vg::PhaseUnfolder::gbwt_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae30c8d79f4461cae38e4ec2268a22022"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gcsa::NodeMapping vg::PhaseUnfolder::mapping</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structvg_1_1Mapping.html">Mapping</a> from duplicated nodes to original ids. </p>

</div>
</div>
<a class="anchor" id="a64f18b1c10e5d2104bd04df2013f5a0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1pair__hash__map.html">pair_hash_map</a>&lt;std::pair&lt;gbwt::node_type, gbwt::node_type&gt;, gbwt::node_type&gt; vg::PhaseUnfolder::prefixes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries for the unfolded prefixes and reverse suffixes. prefixes[(from, to)] is the mapping for to, and suffixes[(from, to)] is the mapping for from. </p>

</div>
</div>
<a class="anchor" id="a2bfa46441300e0817643b310aced989b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classvg_1_1PhaseUnfolder.html#a402b0f84990279594bfbb1cd71ffd8e5">path_type</a>&gt; vg::PhaseUnfolder::reference_paths</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac7d3333de41989b2ca10db84ddb1d5a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stack&lt;<a class="el" href="classvg_1_1PhaseUnfolder.html#a95529e399d5ef61f6a426e1b5cfe9237">state_type</a>&gt; vg::PhaseUnfolder::states</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8e235a2b6022ec40a6e66c63c8dd1df0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1pair__hash__map.html">pair_hash_map</a>&lt;std::pair&lt;gbwt::node_type, gbwt::node_type&gt;, gbwt::node_type&gt; vg::PhaseUnfolder::suffixes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af243361112a7fce2eb831c28c735f6be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classxg_1_1XG.html">xg::XG</a>&amp; vg::PhaseUnfolder::xg_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>XG and GBWT indexes for the original graph. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="phase__unfolder_8hpp.html">phase_unfolder.hpp</a></li>
<li>src/<a class="el" href="phase__unfolder_8cpp.html">phase_unfolder.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 1 2018 17:57:07 for vg by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
