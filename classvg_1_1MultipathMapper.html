<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>vg: vg::MultipathMapper Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1MultipathMapper.html">MultipathMapper</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classvg_1_1MultipathMapper-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::MultipathMapper Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;multipath_mapper.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vg::MultipathMapper:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvg_1_1MultipathMapper.png" usemap="#vg::MultipathMapper_map" alt=""/>
  <map id="vg::MultipathMapper_map" name="vg::MultipathMapper_map">
<area href="classvg_1_1BaseMapper.html" alt="vg::BaseMapper" shape="rect" coords="0,56,127,80"/>
<area href="classvg_1_1AlignerClient.html" alt="vg::AlignerClient" shape="rect" coords="0,0,127,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a781815d148571276e536c7a7780017be"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a781815d148571276e536c7a7780017be">memcluster_t</a> = vector&lt; pair&lt; const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> *, <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt;&gt;</td></tr>
<tr class="memdesc:a781815d148571276e536c7a7780017be"><td class="mdescLeft">&#160;</td><td class="mdescRight">We often pass around clusters of MEMs and their graph positions.  <a href="#a781815d148571276e536c7a7780017be">More...</a><br/></td></tr>
<tr class="separator:a781815d148571276e536c7a7780017be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee49f1e1960e8fa8128b03726aaff61"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> = tuple&lt; <a class="el" href="classvg_1_1HashGraph.html">HashGraph</a> *, <a class="el" href="classvg_1_1MultipathMapper.html#a781815d148571276e536c7a7780017be">memcluster_t</a>, size_t &gt;</td></tr>
<tr class="separator:a5ee49f1e1960e8fa8128b03726aaff61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acc3f954c49a556ca49b8d571e2bf0f80"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#acc3f954c49a556ca49b8d571e2bf0f80">MultipathMapper</a> (<a class="el" href="classxg_1_1XG.html">xg::XG</a> *xg_index, gcsa::GCSA *gcsa_index, gcsa::LCPArray *lcp_array, <a class="el" href="classhaplo_1_1ScoreProvider.html">haplo::ScoreProvider</a> *<a class="el" href="classvg_1_1BaseMapper.html#af69ce88df203124121b71bdfdc6f3694">haplo_score_provider</a>=nullptr, <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> *<a class="el" href="classvg_1_1MultipathMapper.html#a82e1a1af4b8ba0170cf7817cd44f1008">snarl_manager</a>=nullptr, <a class="el" href="classvg_1_1DistanceIndex.html">DistanceIndex</a> *<a class="el" href="classvg_1_1MultipathMapper.html#a4c23c9347169a532cac0e21636c2d4bb">distance_index</a>=nullptr)</td></tr>
<tr class="separator:acc3f954c49a556ca49b8d571e2bf0f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4b40b1c3c0668b884ae3247779f188"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#aae4b40b1c3c0668b884ae3247779f188">~MultipathMapper</a> ()</td></tr>
<tr class="separator:aae4b40b1c3c0668b884ae3247779f188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422996497786dca48fec812d13ffc81b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a422996497786dca48fec812d13ffc81b">multipath_map</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, vector&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt; &amp;multipath_alns_out, size_t max_alt_mappings)</td></tr>
<tr class="memdesc:a422996497786dca48fec812d13ffc81b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map read in alignment to graph and make multipath alignments.  <a href="#a422996497786dca48fec812d13ffc81b">More...</a><br/></td></tr>
<tr class="separator:a422996497786dca48fec812d13ffc81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27190ea63595c2d7119b27d198848373"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a27190ea63595c2d7119b27d198848373">multipath_map_paired</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment1, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment2, vector&lt; pair&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;&gt; &amp;multipath_aln_pairs_out, vector&lt; pair&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a>, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&gt; &amp;ambiguous_pair_buffer, size_t max_alt_mappings)</td></tr>
<tr class="separator:a27190ea63595c2d7119b27d198848373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d289c370da90f69420d260f8298c1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a27d289c370da90f69420d260f8298c1e">reduce_to_single_path</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln, vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;alns_out, size_t max_alt_mappings) const </td></tr>
<tr class="separator:a27d289c370da90f69420d260f8298c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a6f15f0273faa48ff52a59a08855e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#ac0a6f15f0273faa48ff52a59a08855e1">set_automatic_min_clustering_length</a> (double random_mem_probability=0.5)</td></tr>
<tr class="separator:ac0a6f15f0273faa48ff52a59a08855e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedf2b5ed6093154c18ef1c24911e40f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#aeedf2b5ed6093154c18ef1c24911e40f">calibrate_mismapping_detection</a> (size_t num_simulations=1000, size_t simulated_read_length=150)</td></tr>
<tr class="separator:aeedf2b5ed6093154c18ef1c24911e40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373038067171533375512e963f28fa65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a373038067171533375512e963f28fa65">init_band_padding_memo</a> ()</td></tr>
<tr class="memdesc:a373038067171533375512e963f28fa65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should be called once after construction, or any time the band padding multiplier is changed.  <a href="#a373038067171533375512e963f28fa65">More...</a><br/></td></tr>
<tr class="separator:a373038067171533375512e963f28fa65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvg_1_1BaseMapper"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classvg_1_1BaseMapper')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvg_1_1BaseMapper.html">vg::BaseMapper</a></td></tr>
<tr class="memitem:abd17202084a4e11cfbf5304daee468a3 inherit pub_methods_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#abd17202084a4e11cfbf5304daee468a3">BaseMapper</a> (<a class="el" href="classxg_1_1XG.html">xg::XG</a> *xidex, gcsa::GCSA *g, gcsa::LCPArray *a, <a class="el" href="classhaplo_1_1ScoreProvider.html">haplo::ScoreProvider</a> *<a class="el" href="classvg_1_1BaseMapper.html#af69ce88df203124121b71bdfdc6f3694">haplo_score_provider</a>=nullptr)</td></tr>
<tr class="separator:abd17202084a4e11cfbf5304daee468a3 inherit pub_methods_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895c239d974f084e7a0a83025e104fd8 inherit pub_methods_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a895c239d974f084e7a0a83025e104fd8">BaseMapper</a> (void)</td></tr>
<tr class="separator:a895c239d974f084e7a0a83025e104fd8 inherit pub_methods_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2884c6722e6bd9c9aab6671a85a6c3c0 inherit pub_methods_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a2884c6722e6bd9c9aab6671a85a6c3c0">random_match_length</a> (double chance_random)</td></tr>
<tr class="separator:a2884c6722e6bd9c9aab6671a85a6c3c0 inherit pub_methods_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91089ef5009359b6be8b9455e505396 inherit pub_methods_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#ad91089ef5009359b6be8b9455e505396">set_fragment_length_distr_params</a> (size_t maximum_sample_size=1000, size_t reestimation_frequency=1000, double robust_estimation_fraction=0.95)</td></tr>
<tr class="separator:ad91089ef5009359b6be8b9455e505396 inherit pub_methods_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0552850ea91ef5c075a63690fe6e6578 inherit pub_methods_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a0552850ea91ef5c075a63690fe6e6578">set_alignment_scores</a> (int8_t match, int8_t mismatch, int8_t gap_open, int8_t gap_extend, int8_t full_length_bonus, uint32_t xdrop_max_gap_length=default_xdrop_max_gap_length, double <a class="el" href="classvg_1_1BaseMapper.html#a33465e76a17e2580a6e095f3373239c5">haplotype_consistency_exponent</a>=1)</td></tr>
<tr class="memdesc:a0552850ea91ef5c075a63690fe6e6578 inherit pub_methods_classvg_1_1BaseMapper"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override alignment score setting to support haplotype consistency exponent.  <a href="#a0552850ea91ef5c075a63690fe6e6578">More...</a><br/></td></tr>
<tr class="separator:a0552850ea91ef5c075a63690fe6e6578 inherit pub_methods_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903d4be40e368c6dd1c91f6fe2ec4d67 inherit pub_methods_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a903d4be40e368c6dd1c91f6fe2ec4d67">set_cache_size</a> (int new_cache_size)</td></tr>
<tr class="separator:a903d4be40e368c6dd1c91f6fe2ec4d67 inherit pub_methods_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605bec54cb2bac4ce873dc7b2783cd5d inherit pub_methods_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a605bec54cb2bac4ce873dc7b2783cd5d">has_fixed_fragment_length_distr</a> ()</td></tr>
<tr class="memdesc:a605bec54cb2bac4ce873dc7b2783cd5d inherit pub_methods_classvg_1_1BaseMapper"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if fragment length distribution has been fixed.  <a href="#a605bec54cb2bac4ce873dc7b2783cd5d">More...</a><br/></td></tr>
<tr class="separator:a605bec54cb2bac4ce873dc7b2783cd5d inherit pub_methods_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9848806a322e4a90d0aaf6f1b0407dc8 inherit pub_methods_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a9848806a322e4a90d0aaf6f1b0407dc8">force_fragment_length_distr</a> (double mean, double stddev)</td></tr>
<tr class="separator:a9848806a322e4a90d0aaf6f1b0407dc8 inherit pub_methods_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64a7b36c1880606372d0849842708b0 inherit pub_methods_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#af64a7b36c1880606372d0849842708b0">find_mems_deep</a> (string::const_iterator seq_begin, string::const_iterator seq_end, double &amp;lcp_avg, double &amp;fraction_filtered, int max_mem_length=0, int <a class="el" href="classvg_1_1BaseMapper.html#a6de91c39c73a95b014b1773495985a09">min_mem_length</a>=1, int reseed_length=0, bool use_lcp_reseed_heuristic=false, bool use_diff_based_fast_reseed=false, bool include_parent_in_sub_mem_count=false, bool record_max_lcp=false, int reseed_below_count=0)</td></tr>
<tr class="separator:af64a7b36c1880606372d0849842708b0 inherit pub_methods_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd3272837211543ba461472833734a9 inherit pub_methods_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a4dd3272837211543ba461472833734a9">find_mems_simple</a> (string::const_iterator seq_begin, string::const_iterator seq_end, int max_mem_length=0, int <a class="el" href="classvg_1_1BaseMapper.html#a6de91c39c73a95b014b1773495985a09">min_mem_length</a>=1, int reseed_length=0)</td></tr>
<tr class="separator:a4dd3272837211543ba461472833734a9 inherit pub_methods_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a71951ec7acdbf2c31ae9318ceb035 inherit pub_methods_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#aa7a71951ec7acdbf2c31ae9318ceb035">rescue_high_count_order_length_mems</a> (vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, size_t max_rescue_hit_count)</td></tr>
<tr class="separator:aa7a71951ec7acdbf2c31ae9318ceb035 inherit pub_methods_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4372862ebd4f21da3e9ed105249a5af inherit pub_methods_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#af4372862ebd4f21da3e9ed105249a5af">precollapse_order_length_runs</a> (string::const_iterator seq_begin, vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems)</td></tr>
<tr class="separator:af4372862ebd4f21da3e9ed105249a5af inherit pub_methods_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3103b73da0ef6137ad1d1bd16e35d56 inherit pub_methods_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#ae3103b73da0ef6137ad1d1bd16e35d56">prefilter_redundant_sub_mems</a> (vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, vector&lt; pair&lt; int, vector&lt; size_t &gt;&gt;&gt; &amp;sub_mem_containment_graph)</td></tr>
<tr class="separator:ae3103b73da0ef6137ad1d1bd16e35d56 inherit pub_methods_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvg_1_1AlignerClient"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classvg_1_1AlignerClient')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvg_1_1AlignerClient.html">vg::AlignerClient</a></td></tr>
<tr class="memitem:a0ea937755e15062c023d1b97d61814d4 inherit pub_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a0ea937755e15062c023d1b97d61814d4">set_alignment_scores</a> (int8_t match, int8_t mismatch, int8_t gap_open, int8_t gap_extend, int8_t full_length_bonus, uint32_t xdrop_max_gap_length=default_xdrop_max_gap_length)</td></tr>
<tr class="memdesc:a0ea937755e15062c023d1b97d61814d4 inherit pub_methods_classvg_1_1AlignerClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the aligner scoring parameters and create the stored aligner instances.  <a href="#a0ea937755e15062c023d1b97d61814d4">More...</a><br/></td></tr>
<tr class="separator:a0ea937755e15062c023d1b97d61814d4 inherit pub_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef1e755d0886e16328eb9818ae31fb2 inherit pub_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a2ef1e755d0886e16328eb9818ae31fb2">load_scoring_matrix</a> (std::ifstream &amp;matrix_stream)</td></tr>
<tr class="memdesc:a2ef1e755d0886e16328eb9818ae31fb2 inherit pub_methods_classvg_1_1AlignerClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a scoring amtrix from a file to set scores.  <a href="#a2ef1e755d0886e16328eb9818ae31fb2">More...</a><br/></td></tr>
<tr class="separator:a2ef1e755d0886e16328eb9818ae31fb2 inherit pub_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a9e260c61a4b39d27286957c4f012a26a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a9e260c61a4b39d27286957c4f012a26a">max_branch_trim_length</a> = 1</td></tr>
<tr class="separator:a9e260c61a4b39d27286957c4f012a26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507872f1a20d6b0e34b6f9b8dac2639f"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a507872f1a20d6b0e34b6f9b8dac2639f">max_snarl_cut_size</a> = 5</td></tr>
<tr class="separator:a507872f1a20d6b0e34b6f9b8dac2639f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c0e1fea285f378ef5c7eb23e9baf89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#ad4c0e1fea285f378ef5c7eb23e9baf89">suppress_tail_anchors</a> = false</td></tr>
<tr class="separator:ad4c0e1fea285f378ef5c7eb23e9baf89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136bb7af25fc0b6489c142e6f2871acc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a136bb7af25fc0b6489c142e6f2871acc">band_padding_multiplier</a> = 1.0</td></tr>
<tr class="separator:a136bb7af25fc0b6489c142e6f2871acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d02e5f180a337a4b9eff178fc0b65d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a23d02e5f180a337a4b9eff178fc0b65d">max_expected_dist_approx_error</a> = 8</td></tr>
<tr class="separator:a23d02e5f180a337a4b9eff178fc0b65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29e0a45fcb921023bd6479a15cfef78"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#ad29e0a45fcb921023bd6479a15cfef78">num_alt_alns</a> = 4</td></tr>
<tr class="separator:ad29e0a45fcb921023bd6479a15cfef78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae977e7bbf30ca7634e7422aa76c16e71"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#ae977e7bbf30ca7634e7422aa76c16e71">mem_coverage_min_ratio</a> = 0.5</td></tr>
<tr class="separator:ae977e7bbf30ca7634e7422aa76c16e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac117889984b58f3c0fd3d389a8ee7f26"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#ac117889984b58f3c0fd3d389a8ee7f26">max_suboptimal_path_score_ratio</a> = 2.0</td></tr>
<tr class="separator:ac117889984b58f3c0fd3d389a8ee7f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd259da737785206d02cc2807ab831fa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#acd259da737785206d02cc2807ab831fa">num_mapping_attempts</a> = 48</td></tr>
<tr class="separator:acd259da737785206d02cc2807ab831fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e3e0b047b5d3c195431982f76084c1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a28e3e0b047b5d3c195431982f76084c1">log_likelihood_approx_factor</a> = 1.0</td></tr>
<tr class="separator:a28e3e0b047b5d3c195431982f76084c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac656fb3b81d4cf6d06fb077551b54b7f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#ac656fb3b81d4cf6d06fb077551b54b7f">min_clustering_mem_length</a> = 0</td></tr>
<tr class="separator:ac656fb3b81d4cf6d06fb077551b54b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada39acac8f403bf92632024be4e448e1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#ada39acac8f403bf92632024be4e448e1">max_p_value_memo_size</a> = 500</td></tr>
<tr class="separator:ada39acac8f403bf92632024be4e448e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b608c38afcfea23224165ebb614845"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a93b608c38afcfea23224165ebb614845">band_padding_memo_size</a> = 500</td></tr>
<tr class="separator:a93b608c38afcfea23224165ebb614845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c463a9a1350cd7220abd8575d9e7bd3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a8c463a9a1350cd7220abd8575d9e7bd3">pseudo_length_multiplier</a> = 1.65</td></tr>
<tr class="separator:a8c463a9a1350cd7220abd8575d9e7bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7656b2372ae8450e48a9db512ce309d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#aa7656b2372ae8450e48a9db512ce309d">max_mapping_p_value</a> = 0.00001</td></tr>
<tr class="separator:aa7656b2372ae8450e48a9db512ce309d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90fb9a71fa91ebcf78b94c1f8ae0730"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#ac90fb9a71fa91ebcf78b94c1f8ae0730">unstranded_clustering</a> = true</td></tr>
<tr class="separator:ac90fb9a71fa91ebcf78b94c1f8ae0730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc8310407eabb6cbe419d5765364df7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a1dc8310407eabb6cbe419d5765364df7">max_single_end_mappings_for_rescue</a> = 64</td></tr>
<tr class="separator:a1dc8310407eabb6cbe419d5765364df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f585b42e49cd2e642ab092e54a309a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a87f585b42e49cd2e642ab092e54a309a">max_rescue_attempts</a> = 32</td></tr>
<tr class="separator:a87f585b42e49cd2e642ab092e54a309a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5ee453023a73c3d7c02b929d9ef073"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#aea5ee453023a73c3d7c02b929d9ef073">plausible_rescue_cluster_coverage_diff</a> = 5</td></tr>
<tr class="separator:aea5ee453023a73c3d7c02b929d9ef073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0203a68c7b346ec30bf2854c78bb3434"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a0203a68c7b346ec30bf2854c78bb3434">secondary_rescue_attempts</a> = 4</td></tr>
<tr class="separator:a0203a68c7b346ec30bf2854c78bb3434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ba763f99c22ff9feccb76333cf1039"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#ac5ba763f99c22ff9feccb76333cf1039">secondary_rescue_score_diff</a> = 1.0</td></tr>
<tr class="separator:ac5ba763f99c22ff9feccb76333cf1039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbb94f74824864d7bed5c63cb85687e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#aadbb94f74824864d7bed5c63cb85687e">mapq_scaling_factor</a> = 1.0 / 4.0</td></tr>
<tr class="separator:aadbb94f74824864d7bed5c63cb85687e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaecbb0881e444042662a72907442fc1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#aaaecbb0881e444042662a72907442fc1">use_population_mapqs</a> = false</td></tr>
<tr class="separator:aaaecbb0881e444042662a72907442fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c89cc1e5c4696682c6bc9282de4b034"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a4c89cc1e5c4696682c6bc9282de4b034">force_haplotype_count</a> = 0</td></tr>
<tr class="separator:a4c89cc1e5c4696682c6bc9282de4b034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135abf9221806d613a60edb087509a06"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a135abf9221806d613a60edb087509a06">always_check_population</a> = false</td></tr>
<tr class="separator:a135abf9221806d613a60edb087509a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb100b024b23e3e94a31ea41d0b1ac8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#adfb100b024b23e3e94a31ea41d0b1ac8">population_max_paths</a> = 10</td></tr>
<tr class="separator:adfb100b024b23e3e94a31ea41d0b1ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122b1eaa39c84e9b18a971ebe6566030"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a122b1eaa39c84e9b18a971ebe6566030">top_tracebacks</a> = false</td></tr>
<tr class="separator:a122b1eaa39c84e9b18a971ebe6566030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26993f76e9bbe5c48e0b436cc9c3fda8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a26993f76e9bbe5c48e0b436cc9c3fda8">recombination_penalty</a> = 20.7</td></tr>
<tr class="separator:a26993f76e9bbe5c48e0b436cc9c3fda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad423f9fc1a81bbe31e9c25992de378"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a2ad423f9fc1a81bbe31e9c25992de378">rescue_only_min</a> = 128</td></tr>
<tr class="separator:a2ad423f9fc1a81bbe31e9c25992de378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7c1016549d1f96af13b9c317f239f3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#acd7c1016549d1f96af13b9c317f239f3">rescue_only_anchor_max</a> = 16</td></tr>
<tr class="separator:acd7c1016549d1f96af13b9c317f239f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87f55f358023f5c881494ccc4ed884f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#ae87f55f358023f5c881494ccc4ed884f">order_length_repeat_hit_max</a> = 0</td></tr>
<tr class="separator:ae87f55f358023f5c881494ccc4ed884f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee081b4a0ee6adadb2dff205a24a2c7a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#aee081b4a0ee6adadb2dff205a24a2c7a">secondary_rescue_subopt_diff</a> = 10</td></tr>
<tr class="separator:aee081b4a0ee6adadb2dff205a24a2c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa16d72dd27681fef0f5d99fec8f0ee"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a4aa16d72dd27681fef0f5d99fec8f0ee">min_median_mem_coverage_for_split</a> = 0</td></tr>
<tr class="separator:a4aa16d72dd27681fef0f5d99fec8f0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25f17a8c485548abf5f63517937067f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#ad25f17a8c485548abf5f63517937067f">suppress_cluster_merging</a> = false</td></tr>
<tr class="separator:ad25f17a8c485548abf5f63517937067f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229117ffb8dcad25565d8f65e29ba194"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a229117ffb8dcad25565d8f65e29ba194">alt_anchor_max_length_diff</a> = 5</td></tr>
<tr class="separator:a229117ffb8dcad25565d8f65e29ba194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5bddc4e714e176cfe9c1a9680fa60a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a0b5bddc4e714e176cfe9c1a9680fa60a">dynamic_max_alt_alns</a> = false</td></tr>
<tr class="separator:a0b5bddc4e714e176cfe9c1a9680fa60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f865a27bd34ffce2e2ea1d05fc02b43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a5f865a27bd34ffce2e2ea1d05fc02b43">simplify_topologies</a> = false</td></tr>
<tr class="separator:a5f865a27bd34ffce2e2ea1d05fc02b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0435e272fb95a07554afacfaf9bd34c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a0435e272fb95a07554afacfaf9bd34c5">delay_population_scoring</a> = false</td></tr>
<tr class="separator:a0435e272fb95a07554afacfaf9bd34c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa33d747ce1393304aa96bc5245a4f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#afaa33d747ce1393304aa96bc5245a4f8">use_tvs_clusterer</a> = false</td></tr>
<tr class="separator:afaa33d747ce1393304aa96bc5245a4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87eaae1274e33230fffe9dca05dbbec"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#af87eaae1274e33230fffe9dca05dbbec">reversing_walk_length</a> = 0</td></tr>
<tr class="separator:af87eaae1274e33230fffe9dca05dbbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classvg_1_1BaseMapper"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classvg_1_1BaseMapper')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classvg_1_1BaseMapper.html">vg::BaseMapper</a></td></tr>
<tr class="memitem:a4e17a40bafbd8832d551acb01298403d inherit pub_attribs_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a4e17a40bafbd8832d551acb01298403d">sub_mem_thinning_burn_in</a> = 16</td></tr>
<tr class="separator:a4e17a40bafbd8832d551acb01298403d inherit pub_attribs_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9a00e1d809346bc62f6f2c1e4fbe32 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a8d9a00e1d809346bc62f6f2c1e4fbe32">sub_mem_count_thinning</a> = 4</td></tr>
<tr class="separator:a8d9a00e1d809346bc62f6f2c1e4fbe32 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de91c39c73a95b014b1773495985a09 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a6de91c39c73a95b014b1773495985a09">min_mem_length</a></td></tr>
<tr class="separator:a6de91c39c73a95b014b1773495985a09 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaea877646c1be5aea6200201d28c4cf inherit pub_attribs_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#abaea877646c1be5aea6200201d28c4cf">mem_reseed_length</a></td></tr>
<tr class="separator:abaea877646c1be5aea6200201d28c4cf inherit pub_attribs_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f811924225d6de6f0a26b168ed1df3 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a85f811924225d6de6f0a26b168ed1df3">fast_reseed</a> = true</td></tr>
<tr class="separator:a85f811924225d6de6f0a26b168ed1df3 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ce7cb0903b14c4b4132f504dcdc412 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a74ce7cb0903b14c4b4132f504dcdc412">fast_reseed_length_diff</a> = 0.45</td></tr>
<tr class="separator:a74ce7cb0903b14c4b4132f504dcdc412 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7556c347ea7596624700482dc58c8c inherit pub_attribs_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#acf7556c347ea7596624700482dc58c8c">adaptive_reseed_diff</a> = true</td></tr>
<tr class="separator:acf7556c347ea7596624700482dc58c8c inherit pub_attribs_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653e029302e4442dbabd06a70ec4bbec inherit pub_attribs_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a653e029302e4442dbabd06a70ec4bbec">adaptive_diff_exponent</a> = 0.065</td></tr>
<tr class="separator:a653e029302e4442dbabd06a70ec4bbec inherit pub_attribs_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b8cec81cc68e9d90405c42fbc8ef64 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a29b8cec81cc68e9d90405c42fbc8ef64">hit_max</a> = 0</td></tr>
<tr class="separator:a29b8cec81cc68e9d90405c42fbc8ef64 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1a0a71b2bcc7763690fed623383fb3 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#abf1a0a71b2bcc7763690fed623383fb3">use_approx_sub_mem_count</a> = false</td></tr>
<tr class="separator:abf1a0a71b2bcc7763690fed623383fb3 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa408c8d202885a288f14ff6e2dc60e0 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#afa408c8d202885a288f14ff6e2dc60e0">prefilter_redundant_hits</a> = true</td></tr>
<tr class="separator:afa408c8d202885a288f14ff6e2dc60e0 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12496865e23fd68ba1f579dcb050037 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#ac12496865e23fd68ba1f579dcb050037">max_sub_mem_recursion_depth</a> = 2</td></tr>
<tr class="separator:ac12496865e23fd68ba1f579dcb050037 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20ea9a68bcaca157350595f03b4601c inherit pub_attribs_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#ad20ea9a68bcaca157350595f03b4601c">unpaired_penalty</a> = 17</td></tr>
<tr class="separator:ad20ea9a68bcaca157350595f03b4601c inherit pub_attribs_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf81156cb8c76c2e961b767a782dda59 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#aaf81156cb8c76c2e961b767a782dda59">precollapse_order_length_hits</a> = true</td></tr>
<tr class="separator:aaf81156cb8c76c2e961b767a782dda59 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e6c250a81dc74df57136242174aa54 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#af0e6c250a81dc74df57136242174aa54">recombination_penalty</a> = 20.7</td></tr>
<tr class="separator:af0e6c250a81dc74df57136242174aa54 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ab4a12d44f5b17b5b6caa03ea4cd79 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a34ab4a12d44f5b17b5b6caa03ea4cd79">strip_bonuses</a></td></tr>
<tr class="separator:a34ab4a12d44f5b17b5b6caa03ea4cd79 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7127a75ac293b9b05093134ee8e51cd2 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a7127a75ac293b9b05093134ee8e51cd2">assume_acyclic</a></td></tr>
<tr class="separator:a7127a75ac293b9b05093134ee8e51cd2 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1fe81d11d92332f613d8a29dcadb37 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#ae8af508a4586e2447fdbf2a30a213b39">MappingQualityMethod</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a0b1fe81d11d92332f613d8a29dcadb37">mapping_quality_method</a></td></tr>
<tr class="separator:a0b1fe81d11d92332f613d8a29dcadb37 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467884235c316072a1ed7136faa14be3 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a467884235c316072a1ed7136faa14be3">max_mapping_quality</a></td></tr>
<tr class="separator:a467884235c316072a1ed7136faa14be3 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce344e730fbb7cdc6b6d57b4ca76cf2 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a5ce344e730fbb7cdc6b6d57b4ca76cf2">debug</a> = false</td></tr>
<tr class="memdesc:a5ce344e730fbb7cdc6b6d57b4ca76cf2 inherit pub_attribs_classvg_1_1BaseMapper"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to enable debugging messages to cerr from the mapper, so a user can understand why a read maps the way it does.  <a href="#a5ce344e730fbb7cdc6b6d57b4ca76cf2">More...</a><br/></td></tr>
<tr class="separator:a5ce344e730fbb7cdc6b6d57b4ca76cf2 inherit pub_attribs_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classvg_1_1AlignerClient"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classvg_1_1AlignerClient')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classvg_1_1AlignerClient.html">vg::AlignerClient</a></td></tr>
<tr class="memitem:a25db3953c246e94a7e08ef59fc31b82f inherit pub_attribs_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a25db3953c246e94a7e08ef59fc31b82f">adjust_alignments_for_base_quality</a> = false</td></tr>
<tr class="separator:a25db3953c246e94a7e08ef59fc31b82f inherit pub_attribs_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a50bf42d3a43afc92f7695f66e9744496"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a50bf42d3a43afc92f7695f66e9744496">multipath_map_internal</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, <a class="el" href="namespacevg.html#ae8af508a4586e2447fdbf2a30a213b39">MappingQualityMethod</a> mapq_method, vector&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt; &amp;multipath_alns_out, size_t max_alt_mappings)</td></tr>
<tr class="separator:a50bf42d3a43afc92f7695f66e9744496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6fb4cb7896a6de840b2af5b70a4fed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a6e6fb4cb7896a6de840b2af5b70a4fed">attempt_unpaired_multipath_map_of_pair</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment1, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment2, vector&lt; pair&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;&gt; &amp;multipath_aln_pairs_out, vector&lt; pair&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a>, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&gt; &amp;ambiguous_pair_buffer)</td></tr>
<tr class="separator:a6e6fb4cb7896a6de840b2af5b70a4fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a6a2bccf8123914bcf4e378edcbb61"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a58a6a2bccf8123914bcf4e378edcbb61">attempt_rescue</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;other_aln, bool rescue_forward, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;rescue_multipath_aln)</td></tr>
<tr class="separator:a58a6a2bccf8123914bcf4e378edcbb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e10da35d46a51134c29d96ecb329fdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a0e10da35d46a51134c29d96ecb329fdb">align_to_cluster_graphs</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, <a class="el" href="namespacevg.html#ae8af508a4586e2447fdbf2a30a213b39">MappingQualityMethod</a> mapq_method, vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;cluster_graphs, vector&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt; &amp;multipath_alns_out, size_t <a class="el" href="classvg_1_1MultipathMapper.html#acd259da737785206d02cc2807ab831fa">num_mapping_attempts</a>, vector&lt; size_t &gt; *cluster_idxs=nullptr)</td></tr>
<tr class="separator:a0e10da35d46a51134c29d96ecb329fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e559455e46e8fc3b4e1b6850db1768"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a22e559455e46e8fc3b4e1b6850db1768">align_to_cluster_graph_pairs</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment1, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment2, vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;cluster_graphs1, vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;cluster_graphs2, vector&lt; pair&lt; pair&lt; size_t, size_t &gt;, int64_t &gt;&gt; &amp;cluster_pairs, vector&lt; pair&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;&gt; &amp;multipath_aln_pairs_out, vector&lt; pair&lt; size_t, size_t &gt;&gt; &amp;duplicate_pairs_out)</td></tr>
<tr class="separator:a22e559455e46e8fc3b4e1b6850db1768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd5a0243c79cbb71c9ca2af2f86fcd5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a7dd5a0243c79cbb71c9ca2af2f86fcd5">align_to_cluster_graphs_with_rescue</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment1, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment2, vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;cluster_graphs1, vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;cluster_graphs2, bool block_rescue_from_1, bool block_rescue_from_2, vector&lt; pair&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;&gt; &amp;multipath_aln_pairs_out, vector&lt; pair&lt; pair&lt; size_t, size_t &gt;, int64_t &gt;&gt; &amp;pair_distances, size_t max_alt_mappings)</td></tr>
<tr class="separator:a7dd5a0243c79cbb71c9ca2af2f86fcd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1751c97818eef51d83a0e8f31260822b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a1751c97818eef51d83a0e8f31260822b">attempt_rescue_for_secondaries</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment1, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment2, vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;cluster_graphs1, vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;cluster_graphs2, vector&lt; pair&lt; size_t, size_t &gt;&gt; &amp;duplicate_pairs, vector&lt; pair&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;&gt; &amp;multipath_aln_pairs_out, vector&lt; pair&lt; pair&lt; size_t, size_t &gt;, int64_t &gt;&gt; &amp;cluster_pairs)</td></tr>
<tr class="separator:a1751c97818eef51d83a0e8f31260822b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17aa98cc9509dd4e9cec05610dc629ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a17aa98cc9509dd4e9cec05610dc629ea">attempt_rescue_of_repeat_from_non_repeat</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment1, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment2, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems1, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems2, bool do_repeat_rescue_from_1, bool do_repeat_rescue_from_2, vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a781815d148571276e536c7a7780017be">memcluster_t</a> &gt; &amp;clusters1, vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a781815d148571276e536c7a7780017be">memcluster_t</a> &gt; &amp;clusters2, vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;cluster_graphs1, vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;cluster_graphs2, vector&lt; pair&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;&gt; &amp;multipath_aln_pairs_out, vector&lt; pair&lt; pair&lt; size_t, size_t &gt;, int64_t &gt;&gt; &amp;pair_distances, size_t max_alt_mappings, <a class="el" href="classvg_1_1OrientedDistanceMeasurer.html">OrientedDistanceMeasurer</a> &amp;distance_measurer)</td></tr>
<tr class="separator:a17aa98cc9509dd4e9cec05610dc629ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435fa7c040563791dcae4386cb0128ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a435fa7c040563791dcae4386cb0128ed">merge_rescued_mappings</a> (vector&lt; pair&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;&gt; &amp;multipath_aln_pairs_out, vector&lt; pair&lt; pair&lt; size_t, size_t &gt;, int64_t &gt;&gt; &amp;cluster_pairs, vector&lt; pair&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;&gt; &amp;rescued_multipath_aln_pairs, vector&lt; pair&lt; pair&lt; size_t, size_t &gt;, int64_t &gt;&gt; &amp;rescued_cluster_pairs) const </td></tr>
<tr class="memdesc:a435fa7c040563791dcae4386cb0128ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge the rescued mappings into the output vector and deduplicate pairs.  <a href="#a435fa7c040563791dcae4386cb0128ed">More...</a><br/></td></tr>
<tr class="separator:a435fa7c040563791dcae4386cb0128ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fda5da79bd2dd61ca2d3633a8f25133"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a781815d148571276e536c7a7780017be">memcluster_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a5fda5da79bd2dd61ca2d3633a8f25133">get_clusters</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, <a class="el" href="classvg_1_1OrientedDistanceMeasurer.html">OrientedDistanceMeasurer</a> *distance_measurer=nullptr) const </td></tr>
<tr class="separator:a5fda5da79bd2dd61ca2d3633a8f25133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49fdf1a2efedda808c2d3a7bda5a7f98"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; pair&lt; size_t, <br class="typebreak"/>
size_t &gt;, int64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a49fdf1a2efedda808c2d3a7bda5a7f98">get_cluster_pairs</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment1, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment2, vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;cluster_graphs1, vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;cluster_graphs2, <a class="el" href="classvg_1_1OrientedDistanceMeasurer.html">OrientedDistanceMeasurer</a> *distance_measurer=nullptr)</td></tr>
<tr class="separator:a49fdf1a2efedda808c2d3a7bda5a7f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961427b7963da3d8ba3ae3c075dcb55d"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a961427b7963da3d8ba3ae3c075dcb55d">query_cluster_graphs</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, const vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a781815d148571276e536c7a7780017be">memcluster_t</a> &gt; &amp;clusters)</td></tr>
<tr class="separator:a961427b7963da3d8ba3ae3c075dcb55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5567509cf58d2d8b675e7cba5b8bf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#aaf5567509cf58d2d8b675e7cba5b8bf2">split_multicomponent_alignments</a> (vector&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt; &amp;multipath_alns_out, vector&lt; size_t &gt; *cluster_idxs=nullptr) const </td></tr>
<tr class="separator:aaf5567509cf58d2d8b675e7cba5b8bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e3181768ba99553c33a8a6a0331ebd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a75e3181768ba99553c33a8a6a0331ebd">split_multicomponent_alignments</a> (vector&lt; pair&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;&gt; &amp;multipath_aln_pairs_out, vector&lt; pair&lt; pair&lt; size_t, size_t &gt;, int64_t &gt;&gt; &amp;cluster_pairs) const </td></tr>
<tr class="separator:a75e3181768ba99553c33a8a6a0331ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af687472b369fe14e9b06ca81aa3ff841"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#af687472b369fe14e9b06ca81aa3ff841">multipath_align</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classvg_1_1HashGraph.html">HashGraph</a> *graph, <a class="el" href="classvg_1_1MultipathMapper.html#a781815d148571276e536c7a7780017be">memcluster_t</a> &amp;graph_mems, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln_out) const </td></tr>
<tr class="separator:af687472b369fe14e9b06ca81aa3ff841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38334bfa61a9939db4e4a1cae9bdd1bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a38334bfa61a9939db4e4a1cae9bdd1bb">make_nontrivial_multipath_alignment</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;subgraph, unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;translator, <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;<a class="el" href="classvg_1_1MultipathMapper.html#a82e1a1af4b8ba0170cf7817cd44f1008">snarl_manager</a>, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln_out) const </td></tr>
<tr class="separator:a38334bfa61a9939db4e4a1cae9bdd1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33bea3e28eb96db7e15f374ae9949fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#ad33bea3e28eb96db7e15f374ae9949fa">strip_full_length_bonuses</a> (<a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln) const </td></tr>
<tr class="memdesc:ad33bea3e28eb96db7e15f374ae9949fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the full length bonus from all source or sink subpaths that received it.  <a href="#ad33bea3e28eb96db7e15f374ae9949fa">More...</a><br/></td></tr>
<tr class="separator:ad33bea3e28eb96db7e15f374ae9949fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe95a97bef401ac66fa91e84b33766c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a4fe95a97bef401ac66fa91e84b33766c">compute_raw_mapping_quality_from_scores</a> (const vector&lt; double &gt; &amp;scores, <a class="el" href="namespacevg.html#ae8af508a4586e2447fdbf2a30a213b39">MappingQualityMethod</a> mapq_method) const </td></tr>
<tr class="memdesc:a4fe95a97bef401ac66fa91e84b33766c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a mapping quality from a list of scores, using the selected method.  <a href="#a4fe95a97bef401ac66fa91e84b33766c">More...</a><br/></td></tr>
<tr class="separator:a4fe95a97bef401ac66fa91e84b33766c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0590fa849998ad4f4ef6536a40645d3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a0590fa849998ad4f4ef6536a40645d3a">sort_and_compute_mapping_quality</a> (vector&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt; &amp;multipath_alns, <a class="el" href="namespacevg.html#ae8af508a4586e2447fdbf2a30a213b39">MappingQualityMethod</a> mapq_method, vector&lt; size_t &gt; *cluster_idxs=nullptr) const </td></tr>
<tr class="separator:a0590fa849998ad4f4ef6536a40645d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0dbcb8e10d7675f5b62cac6b3161ba4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#ae0dbcb8e10d7675f5b62cac6b3161ba4">sort_and_compute_mapping_quality</a> (vector&lt; pair&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;&gt; &amp;multipath_aln_pairs, vector&lt; pair&lt; pair&lt; size_t, size_t &gt;, int64_t &gt;&gt; &amp;cluster_pairs, bool allow_population_component, vector&lt; pair&lt; size_t, size_t &gt;&gt; *duplicate_pairs_out=nullptr) const </td></tr>
<tr class="separator:ae0dbcb8e10d7675f5b62cac6b3161ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143b12213214f32022cc89c4f3493ee3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a143b12213214f32022cc89c4f3493ee3">cap_mapping_quality_by_rescue_probability</a> (vector&lt; pair&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;&gt; &amp;multipath_aln_pairs_out, vector&lt; pair&lt; pair&lt; size_t, size_t &gt;, int64_t &gt;&gt; &amp;cluster_pairs, vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;cluster_graphs1, vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;cluster_graphs2, bool from_secondary_rescue) const </td></tr>
<tr class="separator:a143b12213214f32022cc89c4f3493ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13ab2bba48e2d30f8b225a210a599f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#ad13ab2bba48e2d30f8b225a210a599f0">cap_mapping_quality_by_hit_sampling_probability</a> (vector&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt; &amp;multipath_alns_out, vector&lt; size_t &gt; &amp;cluster_idxs, vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;cluster_graphs) const </td></tr>
<tr class="separator:ad13ab2bba48e2d30f8b225a210a599f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b6366f42c3d50ef9d7673e7c3a4381"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a82b6366f42c3d50ef9d7673e7c3a4381">cap_mapping_quality_by_hit_sampling_probability</a> (vector&lt; pair&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;&gt; &amp;multipath_aln_pairs_out, vector&lt; pair&lt; pair&lt; size_t, size_t &gt;, int64_t &gt;&gt; &amp;cluster_pairs, vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;cluster_graphs1, vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;cluster_graphs2, bool did_secondary_rescue) const </td></tr>
<tr class="separator:a82b6366f42c3d50ef9d7673e7c3a4381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c2a2d33793ca4c777b3249554fa4bf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#ab9c2a2d33793ca4c777b3249554fa4bf">prob_equivalent_clusters_hits_missed</a> (const <a class="el" href="classvg_1_1MultipathMapper.html#a781815d148571276e536c7a7780017be">memcluster_t</a> &amp;cluster) const </td></tr>
<tr class="separator:ab9c2a2d33793ca4c777b3249554fa4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff16271d32e6b5d43a9ae3d70a54ffd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#afff16271d32e6b5d43a9ae3d70a54ffd">fragment_length_log_likelihood</a> (int64_t length) const </td></tr>
<tr class="memdesc:afff16271d32e6b5d43a9ae3d70a54ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the log-likelihood of a given fragment length in the trained distribution.  <a href="#afff16271d32e6b5d43a9ae3d70a54ffd">More...</a><br/></td></tr>
<tr class="separator:afff16271d32e6b5d43a9ae3d70a54ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a431478a23ced7402ef5bacc5414d21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a8a431478a23ced7402ef5bacc5414d21">likely_mismapping</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln)</td></tr>
<tr class="memdesc:a8a431478a23ced7402ef5bacc5414d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Would an alignment this good be expected against a graph this big by chance alone.  <a href="#a8a431478a23ced7402ef5bacc5414d21">More...</a><br/></td></tr>
<tr class="separator:a8a431478a23ced7402ef5bacc5414d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4455f8ca97f019d0925a765c18c1313e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a4455f8ca97f019d0925a765c18c1313e">pseudo_length</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln) const </td></tr>
<tr class="memdesc:a4455f8ca97f019d0925a765c18c1313e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A scaling of a score so that it approximately follows the distribution of the longest match in p-value test.  <a href="#a4455f8ca97f019d0925a765c18c1313e">More...</a><br/></td></tr>
<tr class="separator:a4455f8ca97f019d0925a765c18c1313e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6096b620b762f5a73a528fc1088920"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a5e6096b620b762f5a73a528fc1088920">random_match_p_value</a> (size_t match_length, size_t read_length)</td></tr>
<tr class="memdesc:a5e6096b620b762f5a73a528fc1088920"><td class="mdescLeft">&#160;</td><td class="mdescRight">The approximate p-value for a match length of the given size against the current graph.  <a href="#a5e6096b620b762f5a73a528fc1088920">More...</a><br/></td></tr>
<tr class="separator:a5e6096b620b762f5a73a528fc1088920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936b743d3cd63fe8a07e0139f63bbf62"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a936b743d3cd63fe8a07e0139f63bbf62">distance_between</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln_1, const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln_2, bool full_fragment=false, bool forward_strand=false) const </td></tr>
<tr class="separator:a936b743d3cd63fe8a07e0139f63bbf62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa753672aa6739dc7169cf8ff2b7b29c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#afa753672aa6739dc7169cf8ff2b7b29c">are_consistent</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln_1, const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln_2) const </td></tr>
<tr class="memdesc:afa753672aa6739dc7169cf8ff2b7b29c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are two multipath alignments consistently placed based on the learned fragment length distribution?  <a href="#afa753672aa6739dc7169cf8ff2b7b29c">More...</a><br/></td></tr>
<tr class="separator:afa753672aa6739dc7169cf8ff2b7b29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d804e278f901790df7260904215282e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a2d804e278f901790df7260904215282e">is_consistent</a> (int64_t distance) const </td></tr>
<tr class="memdesc:a2d804e278f901790df7260904215282e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this a consistent inter-pair distance based on the learned fragment length distribution?  <a href="#a2d804e278f901790df7260904215282e">More...</a><br/></td></tr>
<tr class="separator:a2d804e278f901790df7260904215282e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5398224011f7ed5f8f200e801b515a6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#ac5398224011f7ed5f8f200e801b515a6">read_coverage_z_score</a> (int64_t coverage, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment) const </td></tr>
<tr class="memdesc:ac5398224011f7ed5f8f200e801b515a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Z-score of the number of matches against an equal length random DNA string.  <a href="#ac5398224011f7ed5f8f200e801b515a6">More...</a><br/></td></tr>
<tr class="separator:ac5398224011f7ed5f8f200e801b515a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae152e4fca517f42655c1747e0abe10d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#ae152e4fca517f42655c1747e0abe10d0">share_terminal_positions</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln_1, const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln_2) const </td></tr>
<tr class="separator:ae152e4fca517f42655c1747e0abe10d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52161f4cd35f9d9ca0980ec34ebd4c8"><td class="memItemLeft" align="right" valign="top">unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classvg_1_1OrientedDistanceMeasurer.html">OrientedDistanceMeasurer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#aa52161f4cd35f9d9ca0980ec34ebd4c8">create_distance_measurer</a> ()</td></tr>
<tr class="memdesc:aa52161f4cd35f9d9ca0980ec34ebd4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a distance measurer to be used for a mapping problem.  <a href="#aa52161f4cd35f9d9ca0980ec34ebd4c8">More...</a><br/></td></tr>
<tr class="separator:aa52161f4cd35f9d9ca0980ec34ebd4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdea9e5e3d5e07cc05e367d572a9b37c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhaplo_1_1haploMath_1_1RRMemo.html">haploMath::RRMemo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#afdea9e5e3d5e07cc05e367d572a9b37c">get_rr_memo</a> (double <a class="el" href="classvg_1_1MultipathMapper.html#a26993f76e9bbe5c48e0b436cc9c3fda8">recombination_penalty</a>, size_t population_size) const </td></tr>
<tr class="memdesc:afdea9e5e3d5e07cc05e367d572a9b37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a thread_local RRMemo with these parameters.  <a href="#afdea9e5e3d5e07cc05e367d572a9b37c">More...</a><br/></td></tr>
<tr class="separator:afdea9e5e3d5e07cc05e367d572a9b37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef2de4240323f32bd2966e4a7f46556"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#acef2de4240323f32bd2966e4a7f46556">establish_strand_consistency</a> (vector&lt; pair&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;&gt; &amp;multipath_aln_pairs, vector&lt; pair&lt; pair&lt; size_t, size_t &gt;, int64_t &gt;&gt; &amp;cluster_pairs)</td></tr>
<tr class="separator:acef2de4240323f32bd2966e4a7f46556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classvg_1_1BaseMapper"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classvg_1_1BaseMapper')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classvg_1_1BaseMapper.html">vg::BaseMapper</a></td></tr>
<tr class="memitem:a77079f609cab775e59ff0750ef9e84d9 inherit pro_methods_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a77079f609cab775e59ff0750ef9e84d9">find_sub_mems</a> (const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, int parent_layer_begin, int parent_layer_end, int mem_idx, string::const_iterator next_mem_end, int <a class="el" href="classvg_1_1BaseMapper.html#a6de91c39c73a95b014b1773495985a09">min_mem_length</a>, vector&lt; pair&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a>, vector&lt; size_t &gt;&gt;&gt; &amp;sub_mems_out)</td></tr>
<tr class="separator:a77079f609cab775e59ff0750ef9e84d9 inherit pro_methods_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81fa3eae0321720511b1f54fa28968bb inherit pro_methods_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a81fa3eae0321720511b1f54fa28968bb">find_sub_mems_fast</a> (const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, int parent_layer_begin, int parent_layer_end, int mem_idx, string::const_iterator leftmost_guaranteed_disjoint_bound, string::const_iterator leftmost_seeding_bound, int min_sub_mem_length, vector&lt; pair&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a>, vector&lt; size_t &gt;&gt;&gt; &amp;sub_mems_out)</td></tr>
<tr class="separator:a81fa3eae0321720511b1f54fa28968bb inherit pro_methods_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3cdacd0ec3e6b27ced793aeb9b561a inherit pro_methods_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a3d3cdacd0ec3e6b27ced793aeb9b561a">fill_nonredundant_sub_mem_nodes</a> (vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;parent_mems, vector&lt; pair&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a>, vector&lt; size_t &gt; &gt; &gt;::iterator sub_mem_records_begin, vector&lt; pair&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a>, vector&lt; size_t &gt; &gt; &gt;::iterator sub_mem_records_end)</td></tr>
<tr class="separator:a3d3cdacd0ec3e6b27ced793aeb9b561a inherit pro_methods_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26dfca3a19af4caf8746f1e28eacf646 inherit pro_methods_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a26dfca3a19af4caf8746f1e28eacf646">first_hit_positions_by_index</a> (<a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;mem, vector&lt; set&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt;&gt; &amp;positions_by_index_out)</td></tr>
<tr class="separator:a26dfca3a19af4caf8746f1e28eacf646 inherit pro_methods_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064f32d036db4774ba8802f0ade9b056 inherit pro_methods_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a064f32d036db4774ba8802f0ade9b056">mem_positions_by_index</a> (<a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;mem, <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> hit_pos, vector&lt; set&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt;&gt; &amp;positions_by_index_out)</td></tr>
<tr class="separator:a064f32d036db4774ba8802f0ade9b056 inherit pro_methods_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301ccfdf585635471e03efde26ff162a inherit pro_methods_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a301ccfdf585635471e03efde26ff162a">pos_char</a> (<a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> pos)</td></tr>
<tr class="separator:a301ccfdf585635471e03efde26ff162a inherit pro_methods_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b162009930636565dbb15614d76619f inherit pro_methods_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">map&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>, char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a9b162009930636565dbb15614d76619f">next_pos_chars</a> (<a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> pos)</td></tr>
<tr class="separator:a9b162009930636565dbb15614d76619f inherit pro_methods_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819df281232ae4d5f689ce8e2981b2a0 inherit pro_methods_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a819df281232ae4d5f689ce8e2981b2a0">positions_bp_from</a> (<a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> pos, int distance, bool rev)</td></tr>
<tr class="separator:a819df281232ae4d5f689ce8e2981b2a0 inherit pro_methods_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc5077e5ea4a236ddf8edcf93288eb9 inherit pro_methods_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a1fc5077e5ea4a236ddf8edcf93288eb9">sequence_positions</a> (const string &amp;seq)</td></tr>
<tr class="separator:a1fc5077e5ea4a236ddf8edcf93288eb9 inherit pro_methods_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f693887391ddeaebf4a4a609e2ab9b3 inherit pro_methods_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a7f693887391ddeaebf4a4a609e2ab9b3">get_adaptive_min_reseed_length</a> (size_t parent_mem_length)</td></tr>
<tr class="separator:a7f693887391ddeaebf4a4a609e2ab9b3 inherit pro_methods_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778c534cca5d7580584bba4131b65adc inherit pro_methods_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a778c534cca5d7580584bba4131b65adc">apply_haplotype_consistency_scores</a> (const vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> * &gt; &amp;alns)</td></tr>
<tr class="separator:a778c534cca5d7580584bba4131b65adc inherit pro_methods_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classvg_1_1AlignerClient"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classvg_1_1AlignerClient')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classvg_1_1AlignerClient.html">vg::AlignerClient</a></td></tr>
<tr class="memitem:ab180631766b1e787e29dd202ad455d90 inherit pro_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#ab180631766b1e787e29dd202ad455d90">AlignerClient</a> (double <a class="el" href="classvg_1_1AlignerClient.html#a65428f092aaa5d894b709e247cf0121a">gc_content_estimate</a>=vg::default_gc_content)</td></tr>
<tr class="separator:ab180631766b1e787e29dd202ad455d90 inherit pro_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e0c82ed9c61de1dfa7c45d62ac1af3 inherit pro_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a74e0c82ed9c61de1dfa7c45d62ac1af3">get_aligner</a> (bool have_qualities=true) const </td></tr>
<tr class="separator:a74e0c82ed9c61de1dfa7c45d62ac1af3 inherit pro_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39bc1b46f1ee4eb34fea4a207b5649e inherit pro_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#ac39bc1b46f1ee4eb34fea4a207b5649e">get_qual_adj_aligner</a> () const </td></tr>
<tr class="separator:ac39bc1b46f1ee4eb34fea4a207b5649e inherit pro_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fe6d0c3f92c5f69baed5790675725f inherit pro_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#af2fe6d0c3f92c5f69baed5790675725f">get_regular_aligner</a> () const </td></tr>
<tr class="separator:af2fe6d0c3f92c5f69baed5790675725f inherit pro_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:aad3de01816bc0be9ac9f6474c15087af"><td class="memItemLeft" align="right" valign="top">static int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#aad3de01816bc0be9ac9f6474c15087af">read_coverage</a> (const <a class="el" href="classvg_1_1MultipathMapper.html#a781815d148571276e536c7a7780017be">memcluster_t</a> &amp;mem_hits)</td></tr>
<tr class="memdesc:aad3de01816bc0be9ac9f6474c15087af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of read bases a cluster of MEM hits covers.  <a href="#aad3de01816bc0be9ac9f6474c15087af">More...</a><br/></td></tr>
<tr class="separator:aad3de01816bc0be9ac9f6474c15087af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a82e1a1af4b8ba0170cf7817cd44f1008"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a82e1a1af4b8ba0170cf7817cd44f1008">snarl_manager</a></td></tr>
<tr class="separator:a82e1a1af4b8ba0170cf7817cd44f1008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c23c9347169a532cac0e21636c2d4bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1DistanceIndex.html">DistanceIndex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a4c23c9347169a532cac0e21636c2d4bb">distance_index</a></td></tr>
<tr class="separator:a4c23c9347169a532cac0e21636c2d4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbf3ba803032d80377c54aa49f1e007"><td class="memItemLeft" align="right" valign="top">vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#abdbf3ba803032d80377c54aa49f1e007">band_padding_memo</a></td></tr>
<tr class="separator:abdbf3ba803032d80377c54aa49f1e007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classvg_1_1BaseMapper"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classvg_1_1BaseMapper')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classvg_1_1BaseMapper.html">vg::BaseMapper</a></td></tr>
<tr class="memitem:a215d1113b92168a450e89133b03569fe inherit pro_attribs_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a215d1113b92168a450e89133b03569fe">xindex</a> = nullptr</td></tr>
<tr class="separator:a215d1113b92168a450e89133b03569fe inherit pro_attribs_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41db0eca93c379087c90b602a6ce751 inherit pro_attribs_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">gcsa::GCSA *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#aa41db0eca93c379087c90b602a6ce751">gcsa</a> = nullptr</td></tr>
<tr class="separator:aa41db0eca93c379087c90b602a6ce751 inherit pro_attribs_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4046b98185c00ff397089435d5b2b8d8 inherit pro_attribs_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">gcsa::LCPArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a4046b98185c00ff397089435d5b2b8d8">lcp</a> = nullptr</td></tr>
<tr class="separator:a4046b98185c00ff397089435d5b2b8d8 inherit pro_attribs_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69ce88df203124121b71bdfdc6f3694 inherit pro_attribs_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhaplo_1_1ScoreProvider.html">haplo::ScoreProvider</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#af69ce88df203124121b71bdfdc6f3694">haplo_score_provider</a> = nullptr</td></tr>
<tr class="separator:af69ce88df203124121b71bdfdc6f3694 inherit pro_attribs_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33465e76a17e2580a6e095f3373239c5 inherit pro_attribs_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a33465e76a17e2580a6e095f3373239c5">haplotype_consistency_exponent</a> = 1</td></tr>
<tr class="separator:a33465e76a17e2580a6e095f3373239c5 inherit pro_attribs_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e37826ea32c98f5ce0f6f4dd2206fd5 inherit pro_attribs_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1FragmentLengthDistribution.html">FragmentLengthDistribution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a8e37826ea32c98f5ce0f6f4dd2206fd5">fragment_length_distr</a></td></tr>
<tr class="separator:a8e37826ea32c98f5ce0f6f4dd2206fd5 inherit pro_attribs_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a5709f5cdf31de90145a1178fa166be44"><td class="memItemLeft" align="right" valign="top">static thread_local <br class="typebreak"/>
unordered_map&lt; pair&lt; double, <br class="typebreak"/>
size_t &gt;, <a class="el" href="structhaplo_1_1haploMath_1_1RRMemo.html">haploMath::RRMemo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#a5709f5cdf31de90145a1178fa166be44">rr_memos</a></td></tr>
<tr class="memdesc:a5709f5cdf31de90145a1178fa166be44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memos used by population model.  <a href="#a5709f5cdf31de90145a1178fa166be44">More...</a><br/></td></tr>
<tr class="separator:a5709f5cdf31de90145a1178fa166be44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e45b752367bcc299b3427d2edd3e54"><td class="memItemLeft" align="right" valign="top">static thread_local <br class="typebreak"/>
unordered_map&lt; pair&lt; size_t, <br class="typebreak"/>
size_t &gt;, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html#aa6e45b752367bcc299b3427d2edd3e54">p_value_memo</a></td></tr>
<tr class="separator:aa6e45b752367bcc299b3427d2edd3e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classvg_1_1BaseMapper"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classvg_1_1BaseMapper')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classvg_1_1BaseMapper.html">vg::BaseMapper</a></td></tr>
<tr class="memitem:a279b5883907a56ada69b41796230b209 inherit pro_static_attribs_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">static thread_local vector<br class="typebreak"/>
&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a279b5883907a56ada69b41796230b209">adaptive_reseed_length_memo</a></td></tr>
<tr class="separator:a279b5883907a56ada69b41796230b209 inherit pro_static_attribs_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classvg_1_1BaseMapper"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classvg_1_1BaseMapper')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classvg_1_1BaseMapper.html">vg::BaseMapper</a></td></tr>
<tr class="memitem:aa08b00e5a349252d013d76651f754f8d inherit pub_static_methods_classvg_1_1BaseMapper"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#aa08b00e5a349252d013d76651f754f8d">estimate_gc_content</a> (const gcsa::GCSA *<a class="el" href="classvg_1_1BaseMapper.html#aa41db0eca93c379087c90b602a6ce751">gcsa</a>)</td></tr>
<tr class="separator:aa08b00e5a349252d013d76651f754f8d inherit pub_static_methods_classvg_1_1BaseMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a5ee49f1e1960e8fa8128b03726aaff61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">vg::MultipathMapper::clustergraph_t</a> =  tuple&lt;<a class="el" href="classvg_1_1HashGraph.html">HashGraph</a>*, <a class="el" href="classvg_1_1MultipathMapper.html#a781815d148571276e536c7a7780017be">memcluster_t</a>, size_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This represents a graph for a cluster, and holds a pointer to the actual extracted graph, a list of assigned MEMs, and the number of bases of read coverage that that MEM cluster provides (which serves as a priority). </p>

</div>
</div>
<a class="anchor" id="a781815d148571276e536c7a7780017be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvg_1_1MultipathMapper.html#a781815d148571276e536c7a7780017be">vg::MultipathMapper::memcluster_t</a> =  vector&lt;pair&lt;const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a>*, <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We often pass around clusters of MEMs and their graph positions. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="acc3f954c49a556ca49b8d571e2bf0f80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::MultipathMapper::MultipathMapper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxg_1_1XG.html">xg::XG</a> *&#160;</td>
          <td class="paramname"><em>xg_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gcsa::GCSA *&#160;</td>
          <td class="paramname"><em>gcsa_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gcsa::LCPArray *&#160;</td>
          <td class="paramname"><em>lcp_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhaplo_1_1ScoreProvider.html">haplo::ScoreProvider</a> *&#160;</td>
          <td class="paramname"><em>haplo_score_provider</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> *&#160;</td>
          <td class="paramname"><em>snarl_manager</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1DistanceIndex.html">DistanceIndex</a> *&#160;</td>
          <td class="paramname"><em>distance_index</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aae4b40b1c3c0668b884ae3247779f188"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::MultipathMapper::~MultipathMapper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a22e559455e46e8fc3b4e1b6850db1768"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathMapper::align_to_cluster_graph_pairs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_graphs1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_graphs2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; pair&lt; size_t, size_t &gt;, int64_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln_pairs_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; size_t, size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>duplicate_pairs_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>After clustering MEMs, extracting graphs, assigning hits to cluster graphs, and determining which cluster graph pairs meet the fragment length distance constraints, perform multipath alignment Produces topologically sorted MultipathAlignments. </p>

</div>
</div>
<a class="anchor" id="a0e10da35d46a51134c29d96ecb329fdb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathMapper::align_to_cluster_graphs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#ae8af508a4586e2447fdbf2a30a213b39">MappingQualityMethod</a>&#160;</td>
          <td class="paramname"><em>mapq_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_graphs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>multipath_alns_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_mapping_attempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; size_t &gt; *&#160;</td>
          <td class="paramname"><em>cluster_idxs</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>After clustering MEMs, extracting graphs, and assigning hits to cluster graphs, perform multipath alignment. Produces topologically sorted MultipathAlignments. </p>

</div>
</div>
<a class="anchor" id="a7dd5a0243c79cbb71c9ca2af2f86fcd5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MultipathMapper::align_to_cluster_graphs_with_rescue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_graphs1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_graphs2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>block_rescue_from_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>block_rescue_from_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln_pairs_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; pair&lt; size_t, size_t &gt;, int64_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>pair_distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_alt_mappings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Align the read ends independently, but also try to form rescue alignments for each from the other. Return true if output obeys pair consistency and false otherwise. Produces topologically sorted MultipathAlignments. </p>

</div>
</div>
<a class="anchor" id="afa753672aa6739dc7169cf8ff2b7b29c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MultipathMapper::are_consistent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are two multipath alignments consistently placed based on the learned fragment length distribution? </p>

</div>
</div>
<a class="anchor" id="a58a6a2bccf8123914bcf4e378edcbb61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MultipathMapper::attempt_rescue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>other_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rescue_forward</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>rescue_multipath_aln</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extracts a section of graph at a distance from the <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> based on the fragment length distribution and attempts to align the other paired read to it. If rescuing forward, assumes the provided <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> is the first read and vice versa if rescuing backward. Rescue constructs a conventional local alignment with gssw and converts the <a class="el" href="structvg_1_1Alignment.html">Alignment</a> to a <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>. The <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> will be stored in the object passed by reference as an argument. </p>

</div>
</div>
<a class="anchor" id="a1751c97818eef51d83a0e8f31260822b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathMapper::attempt_rescue_for_secondaries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_graphs1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_graphs2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; size_t, size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>duplicate_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln_pairs_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; pair&lt; size_t, size_t &gt;, int64_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_pairs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the rescue routine on strong suboptimal clusters to see if we can find a good secondary. Produces topologically sorted MultipathAlignments. </p>

</div>
</div>
<a class="anchor" id="a17aa98cc9509dd4e9cec05610dc629ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathMapper::attempt_rescue_of_repeat_from_non_repeat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_repeat_rescue_from_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_repeat_rescue_from_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a781815d148571276e536c7a7780017be">memcluster_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>clusters1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a781815d148571276e536c7a7780017be">memcluster_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>clusters2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_graphs1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_graphs2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln_pairs_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; pair&lt; size_t, size_t &gt;, int64_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>pair_distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_alt_mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1OrientedDistanceMeasurer.html">OrientedDistanceMeasurer</a> &amp;&#160;</td>
          <td class="paramname"><em>distance_measurer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cluster and extract subgraphs for (possibly) only one end, meant to be a non-repeat, and use them to rescue an alignment for the other end, meant to be a repeat. Produces topologically sorted MultipathAlignments. </p>

</div>
</div>
<a class="anchor" id="a6e6fb4cb7896a6de840b2af5b70a4fed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathMapper::attempt_unpaired_multipath_map_of_pair </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln_pairs_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a>, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ambiguous_pair_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Before the fragment length distribution has been estimated, look for an unambiguous mapping of the reads using the single ended routine. If we find one record the fragment length and report the pair, if we don't find one, add the read pair to a buffer instead of the output vector. </p>

</div>
</div>
<a class="anchor" id="aeedf2b5ed6093154c18ef1c24911e40f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathMapper::calibrate_mismapping_detection </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_simulations</em> = <code>1000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>simulated_read_length</em> = <code>150</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map random sequences against the graph to calibrate a parameterized distribution that detects when mappings are likely to have occurred by chance </p>

</div>
</div>
<a class="anchor" id="ad13ab2bba48e2d30f8b225a210a599f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathMapper::cap_mapping_quality_by_hit_sampling_probability </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>multipath_alns_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_idxs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_graphs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Estimates the probability that the correct cluster was not identified because of sub-sampling MEM hits and caps the mapping quality to this probability (in Phred scale) </p>

</div>
</div>
<a class="anchor" id="a82b6366f42c3d50ef9d7673e7c3a4381"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathMapper::cap_mapping_quality_by_hit_sampling_probability </td>
          <td>(</td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln_pairs_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; pair&lt; size_t, size_t &gt;, int64_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_graphs1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_graphs2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>did_secondary_rescue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Estimates the probability that the correct cluster pair was not identified because of sub-sampling MEM hits and caps the mapping quality to this probability (in Phred scale) </p>

</div>
</div>
<a class="anchor" id="a143b12213214f32022cc89c4f3493ee3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathMapper::cap_mapping_quality_by_rescue_probability </td>
          <td>(</td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln_pairs_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; pair&lt; size_t, size_t &gt;, int64_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_graphs1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_graphs2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_secondary_rescue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Estimates the probability that the correct cluster was not chosen as a cluster to rescue from and caps the mapping quality to the minimum of the current mapping quality and this probability (in Phred scale) </p>

</div>
</div>
<a class="anchor" id="a4fe95a97bef401ac66fa91e84b33766c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vg::MultipathMapper::compute_raw_mapping_quality_from_scores </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#ae8af508a4586e2447fdbf2a30a213b39">MappingQualityMethod</a>&#160;</td>
          <td class="paramname"><em>mapq_method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a mapping quality from a list of scores, using the selected method. </p>

</div>
</div>
<a class="anchor" id="aa52161f4cd35f9d9ca0980ec34ebd4c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classvg_1_1OrientedDistanceMeasurer.html">OrientedDistanceMeasurer</a> &gt; vg::MultipathMapper::create_distance_measurer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a distance measurer to be used for a mapping problem. </p>

</div>
</div>
<a class="anchor" id="a936b743d3cd63fe8a07e0139f63bbf62"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::MultipathMapper::distance_between </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full_fragment</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forward_strand</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the approximate distance between two multipath alignments If either is unmapped, or the distance cannot be obtained, returns numeric_limits&lt;int64_t&gt;::max() </p>

</div>
</div>
<a class="anchor" id="acef2de4240323f32bd2966e4a7f46556"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathMapper::establish_strand_consistency </td>
          <td>(</td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; pair&lt; size_t, size_t &gt;, int64_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_pairs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Detects if each pair can be assigned to a consistent strand of a path, and if not removes them. Also inverts the distances in the cluster pairs vector according to the strand </p>

</div>
</div>
<a class="anchor" id="afff16271d32e6b5d43a9ae3d70a54ffd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::MultipathMapper::fragment_length_log_likelihood </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the log-likelihood of a given fragment length in the trained distribution. </p>

</div>
</div>
<a class="anchor" id="a49fdf1a2efedda808c2d3a7bda5a7f98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; pair&lt; size_t, size_t &gt;, int64_t &gt; &gt; vg::MultipathMapper::get_cluster_pairs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_graphs1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a5ee49f1e1960e8fa8128b03726aaff61">clustergraph_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_graphs2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1OrientedDistanceMeasurer.html">OrientedDistanceMeasurer</a> *&#160;</td>
          <td class="paramname"><em>distance_measurer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the oriented distance clusterer or the TVS clusterer to cluster pairs of clusters. Assumes that the fragment length distribution has been estimated and fixed. </p>

</div>
</div>
<a class="anchor" id="a5fda5da79bd2dd61ca2d3633a8f25133"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a781815d148571276e536c7a7780017be">MultipathMapper::memcluster_t</a> &gt; vg::MultipathMapper::get_clusters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1OrientedDistanceMeasurer.html">OrientedDistanceMeasurer</a> *&#160;</td>
          <td class="paramname"><em>distance_measurer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the oriented distance clusterer or the TVS clusterer to cluster MEMs depending on parameters. If using oriented distance cluster, must alo provide an oriented distance measurer. </p>

</div>
</div>
<a class="anchor" id="afdea9e5e3d5e07cc05e367d572a9b37c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhaplo_1_1haploMath_1_1RRMemo.html">haploMath::RRMemo</a> &amp; vg::MultipathMapper::get_rr_memo </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>recombination_penalty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>population_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a thread_local RRMemo with these parameters. </p>

</div>
</div>
<a class="anchor" id="a373038067171533375512e963f28fa65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathMapper::init_band_padding_memo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Should be called once after construction, or any time the band padding multiplier is changed. </p>

</div>
</div>
<a class="anchor" id="a2d804e278f901790df7260904215282e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MultipathMapper::is_consistent </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>distance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this a consistent inter-pair distance based on the learned fragment length distribution? </p>

</div>
</div>
<a class="anchor" id="a8a431478a23ced7402ef5bacc5414d21"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MultipathMapper::likely_mismapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Would an alignment this good be expected against a graph this big by chance alone. </p>

</div>
</div>
<a class="anchor" id="a38334bfa61a9939db4e4a1cae9bdd1bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathMapper::make_nontrivial_multipath_alignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>translator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl_manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes the sections of an <a class="el" href="structvg_1_1Alignment.html">Alignment</a>'s path within snarls and re-aligns them with multiple traceback to create a multipath alignment with non-trivial topology. Guarantees that the resulting <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> is in topological order. </p>

</div>
</div>
<a class="anchor" id="a435fa7c040563791dcae4386cb0128ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathMapper::merge_rescued_mappings </td>
          <td>(</td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln_pairs_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; pair&lt; size_t, size_t &gt;, int64_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rescued_multipath_aln_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; pair&lt; size_t, size_t &gt;, int64_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rescued_cluster_pairs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge the rescued mappings into the output vector and deduplicate pairs. </p>

</div>
</div>
<a class="anchor" id="af687472b369fe14e9b06ca81aa3ff841"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathMapper::multipath_align </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1HashGraph.html">HashGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1MultipathMapper.html#a781815d148571276e536c7a7780017be">memcluster_t</a> &amp;&#160;</td>
          <td class="paramname"><em>graph_mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a multipath alignment of the read against the indicated graph and add it to the list of multimappings. Does NOT necessarily produce a <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> in topological order. </p>

</div>
</div>
<a class="anchor" id="a422996497786dca48fec812d13ffc81b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathMapper::multipath_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>multipath_alns_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_alt_mappings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map read in alignment to graph and make multipath alignments. </p>

</div>
</div>
<a class="anchor" id="a50bf42d3a43afc92f7695f66e9744496"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathMapper::multipath_map_internal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#ae8af508a4586e2447fdbf2a30a213b39">MappingQualityMethod</a>&#160;</td>
          <td class="paramname"><em>mapq_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>multipath_alns_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_alt_mappings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wrapped internal function that allows some code paths to circumvent the current mapping quality method option. </p>

</div>
</div>
<a class="anchor" id="a27190ea63595c2d7119b27d198848373"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathMapper::multipath_map_paired </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln_pairs_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a>, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ambiguous_pair_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_alt_mappings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map a paired read to the graph and make paired multipath alignments. Assumes reads are on the same strand of the DNA/RNA molecule. If the fragment length distribution is still being estimated and the pair cannot be mapped unambiguously, adds the reads to a buffer for ambiguous pairs and does not output any multipath alignments. </p>

</div>
</div>
<a class="anchor" id="ab9c2a2d33793ca4c777b3249554fa4bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::MultipathMapper::prob_equivalent_clusters_hits_missed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1MultipathMapper.html#a781815d148571276e536c7a7780017be">memcluster_t</a> &amp;&#160;</td>
          <td class="paramname"><em>cluster</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Estimates the probability that a cluster with the same hits would have been missed because of subsampling high-count SMEMs </p>

</div>
</div>
<a class="anchor" id="a4455f8ca97f019d0925a765c18c1313e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MultipathMapper::pseudo_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A scaling of a score so that it approximately follows the distribution of the longest match in p-value test. </p>

</div>
</div>
<a class="anchor" id="a961427b7963da3d8ba3ae3c075dcb55d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::MultipathMapper::query_cluster_graphs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MultipathMapper.html#a781815d148571276e536c7a7780017be">memcluster_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>clusters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extracts a subgraph around each cluster of MEMs that encompasses any graph position reachable (according to the <a class="el" href="classvg_1_1Mapper.html">Mapper</a>'s aligner) with local alignment anchored at the MEMs. If any subgraphs overlap, they are merged into one subgraph. Returns a vector of all the merged cluster subgraphs, their MEMs assigned from the mems vector according to the MEMs' hits, and their read coverages in bp. The caller must delete the <a class="el" href="classvg_1_1VG.html">VG</a> objects produced! </p>

</div>
</div>
<a class="anchor" id="a5e6096b620b762f5a73a528fc1088920"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::MultipathMapper::random_match_p_value </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>match_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>read_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The approximate p-value for a match length of the given size against the current graph. </p>

</div>
</div>
<a class="anchor" id="aad3de01816bc0be9ac9f6474c15087af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::MultipathMapper::read_coverage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1MultipathMapper.html#a781815d148571276e536c7a7780017be">memcluster_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mem_hits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the number of read bases a cluster of MEM hits covers. </p>

</div>
</div>
<a class="anchor" id="ac5398224011f7ed5f8f200e801b515a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::MultipathMapper::read_coverage_z_score </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>coverage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the Z-score of the number of matches against an equal length random DNA string. </p>

</div>
</div>
<a class="anchor" id="a27d289c370da90f69420d260f8298c1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathMapper::reduce_to_single_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>alns_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_alt_mappings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a mapped <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>, reduce it to up to max_alt_mappings + 1 nonoverlapping single path alignments, with mapping qualities accounting for positional uncertainty between them. Even if the read is unmapped, there will always be at least one (possibly score 0) output alignment. </p>

</div>
</div>
<a class="anchor" id="ac0a6f15f0273faa48ff52a59a08855e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathMapper::set_automatic_min_clustering_length </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>random_mem_probability</em> = <code>0.5</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the minimum clustering MEM length to the approximate length that a MEM would have to be to have at most the given probability of occurring in random sequence of the same size as the graph </p>

</div>
</div>
<a class="anchor" id="ae152e4fca517f42655c1747e0abe10d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MultipathMapper::share_terminal_positions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if any of the initial positions of the source Subpaths are shared between the two multipath alignments </p>

</div>
</div>
<a class="anchor" id="a0590fa849998ad4f4ef6536a40645d3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathMapper::sort_and_compute_mapping_quality </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>multipath_alns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#ae8af508a4586e2447fdbf2a30a213b39">MappingQualityMethod</a>&#160;</td>
          <td class="paramname"><em>mapq_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; size_t &gt; *&#160;</td>
          <td class="paramname"><em>cluster_idxs</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sorts mappings by score and store mapping quality of the optimal alignment in the <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> object Optionally also sorts a vector of indexes to keep track of the cluster-of-origin Allows multipath alignments where the best single path alignment is leaving the read unmapped. MultipathAlignments MUST be topologically sorted. </p>
<p>Get all the linearizations we are going to work with, possibly with duplicates. The first alignment will be optimal. </p>

</div>
</div>
<a class="anchor" id="ae0dbcb8e10d7675f5b62cac6b3161ba4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathMapper::sort_and_compute_mapping_quality </td>
          <td>(</td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; pair&lt; size_t, size_t &gt;, int64_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_population_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; size_t, size_t &gt;&gt; *&#160;</td>
          <td class="paramname"><em>duplicate_pairs_out</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sorts mappings by score and store mapping quality of the optimal alignment in the <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> object If there are ties between scores, breaks them by the expected distance between pairs as computed by the OrientedDistanceClusterer::cluster_pairs function (modified cluster_pairs vector) Allows multipath alignments where the best single path alignment is leaving the read unmapped. MultipathAlignments MUST be topologically sorted. </p>

</div>
</div>
<a class="anchor" id="aaf5567509cf58d2d8b675e7cba5b8bf2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathMapper::split_multicomponent_alignments </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>multipath_alns_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; size_t &gt; *&#160;</td>
          <td class="paramname"><em>cluster_idxs</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If there are any MultipathAlignments with multiple connected components, split them up and add them to the return vector. Properly handles MultipathAlignments that are unmapped. Does not depend on or guarantee topological order in the MultipathAlignments. </p>

</div>
</div>
<a class="anchor" id="a75e3181768ba99553c33a8a6a0331ebd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathMapper::split_multicomponent_alignments </td>
          <td>(</td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln_pairs_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; pair&lt; size_t, size_t &gt;, int64_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_pairs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If there are any MultipathAlignments with multiple connected components, split them up and add them to the return vector, also measure the distance between them and add a record to the cluster pairs vector. Properly handles MultipathAlignments that are unmapped. Does not depend on or guarantee topological order in the MultipathAlignments. </p>

</div>
</div>
<a class="anchor" id="ad33bea3e28eb96db7e15f374ae9949fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathMapper::strip_full_length_bonuses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the full length bonus from all source or sink subpaths that received it. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a229117ffb8dcad25565d8f65e29ba194"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MultipathMapper::alt_anchor_max_length_diff = 5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a135abf9221806d613a60edb087509a06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MultipathMapper::always_check_population = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abdbf3ba803032d80377c54aa49f1e007"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;size_t&gt; vg::MultipathMapper::band_padding_memo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a93b608c38afcfea23224165ebb614845"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MultipathMapper::band_padding_memo_size = 500</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a136bb7af25fc0b6489c142e6f2871acc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::MultipathMapper::band_padding_multiplier = 1.0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0435e272fb95a07554afacfaf9bd34c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MultipathMapper::delay_population_scoring = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4c23c9347169a532cac0e21636c2d4bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1DistanceIndex.html">DistanceIndex</a>* vg::MultipathMapper::distance_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0b5bddc4e714e176cfe9c1a9680fa60a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MultipathMapper::dynamic_max_alt_alns = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4c89cc1e5c4696682c6bc9282de4b034"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MultipathMapper::force_haplotype_count = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a28e3e0b047b5d3c195431982f76084c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::MultipathMapper::log_likelihood_approx_factor = 1.0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aadbb94f74824864d7bed5c63cb85687e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::MultipathMapper::mapq_scaling_factor = 1.0 / 4.0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9e260c61a4b39d27286957c4f012a26a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MultipathMapper::max_branch_trim_length = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a23d02e5f180a337a4b9eff178fc0b65d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MultipathMapper::max_expected_dist_approx_error = 8</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa7656b2372ae8450e48a9db512ce309d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::MultipathMapper::max_mapping_p_value = 0.00001</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ada39acac8f403bf92632024be4e448e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MultipathMapper::max_p_value_memo_size = 500</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a87f585b42e49cd2e642ab092e54a309a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MultipathMapper::max_rescue_attempts = 32</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1dc8310407eabb6cbe419d5765364df7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MultipathMapper::max_single_end_mappings_for_rescue = 64</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a507872f1a20d6b0e34b6f9b8dac2639f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::MultipathMapper::max_snarl_cut_size = 5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac117889984b58f3c0fd3d389a8ee7f26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::MultipathMapper::max_suboptimal_path_score_ratio = 2.0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae977e7bbf30ca7634e7422aa76c16e71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::MultipathMapper::mem_coverage_min_ratio = 0.5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac656fb3b81d4cf6d06fb077551b54b7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MultipathMapper::min_clustering_mem_length = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4aa16d72dd27681fef0f5d99fec8f0ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MultipathMapper::min_median_mem_coverage_for_split = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad29e0a45fcb921023bd6479a15cfef78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vg::MultipathMapper::num_alt_alns = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acd259da737785206d02cc2807ab831fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MultipathMapper::num_mapping_attempts = 48</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae87f55f358023f5c881494ccc4ed884f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MultipathMapper::order_length_repeat_hit_max = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa6e45b752367bcc299b3427d2edd3e54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">thread_local unordered_map&lt; pair&lt; size_t, size_t &gt;, double &gt; vg::MultipathMapper::p_value_memo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aea5ee453023a73c3d7c02b929d9ef073"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MultipathMapper::plausible_rescue_cluster_coverage_diff = 5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adfb100b024b23e3e94a31ea41d0b1ac8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MultipathMapper::population_max_paths = 10</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8c463a9a1350cd7220abd8575d9e7bd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::MultipathMapper::pseudo_length_multiplier = 1.65</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a26993f76e9bbe5c48e0b436cc9c3fda8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::MultipathMapper::recombination_penalty = 20.7</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acd7c1016549d1f96af13b9c317f239f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MultipathMapper::rescue_only_anchor_max = 16</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2ad423f9fc1a81bbe31e9c25992de378"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MultipathMapper::rescue_only_min = 128</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af87eaae1274e33230fffe9dca05dbbec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MultipathMapper::reversing_walk_length = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5709f5cdf31de90145a1178fa166be44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">thread_local unordered_map&lt; pair&lt; double, size_t &gt;, <a class="el" href="structhaplo_1_1haploMath_1_1RRMemo.html">haploMath::RRMemo</a> &gt; vg::MultipathMapper::rr_memos</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Memos used by population model. </p>

</div>
</div>
<a class="anchor" id="a0203a68c7b346ec30bf2854c78bb3434"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MultipathMapper::secondary_rescue_attempts = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac5ba763f99c22ff9feccb76333cf1039"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::MultipathMapper::secondary_rescue_score_diff = 1.0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aee081b4a0ee6adadb2dff205a24a2c7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vg::MultipathMapper::secondary_rescue_subopt_diff = 10</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5f865a27bd34ffce2e2ea1d05fc02b43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MultipathMapper::simplify_topologies = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a82e1a1af4b8ba0170cf7817cd44f1008"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a>* vg::MultipathMapper::snarl_manager</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad25f17a8c485548abf5f63517937067f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MultipathMapper::suppress_cluster_merging = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad4c0e1fea285f378ef5c7eb23e9baf89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MultipathMapper::suppress_tail_anchors = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a122b1eaa39c84e9b18a971ebe6566030"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MultipathMapper::top_tracebacks = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac90fb9a71fa91ebcf78b94c1f8ae0730"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MultipathMapper::unstranded_clustering = true</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaaecbb0881e444042662a72907442fc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MultipathMapper::use_population_mapqs = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afaa33d747ce1393304aa96bc5245a4f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MultipathMapper::use_tvs_clusterer = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="multipath__mapper_8hpp.html">multipath_mapper.hpp</a></li>
<li>src/<a class="el" href="multipath__mapper_8cpp.html">multipath_mapper.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
