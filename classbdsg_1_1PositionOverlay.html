<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: bdsg::PositionOverlay Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebdsg.html">bdsg</a></li><li class="navelem"><a class="el" href="classbdsg_1_1PositionOverlay.html">PositionOverlay</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classbdsg_1_1PositionOverlay-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">bdsg::PositionOverlay Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;path_position_overlays.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for bdsg::PositionOverlay:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbdsg_1_1PositionOverlay.png" usemap="#bdsg::PositionOverlay_map" alt=""/>
  <map id="bdsg::PositionOverlay_map" name="bdsg::PositionOverlay_map">
<area href="classhandlegraph_1_1PathPositionHandleGraph.html" alt="handlegraph::PathPositionHandleGraph" shape="rect" coords="0,112,233,136"/>
<area href="classhandlegraph_1_1ExpandingOverlayGraph.html" alt="handlegraph::ExpandingOverlayGraph" shape="rect" coords="243,112,476,136"/>
<area href="classhandlegraph_1_1PathHandleGraph.html" alt="handlegraph::PathHandleGraph" shape="rect" coords="0,56,233,80"/>
<area href="classhandlegraph_1_1HandleGraph.html" alt="handlegraph::HandleGraph" shape="rect" coords="243,56,476,80"/>
<area href="classhandlegraph_1_1HandleGraph.html" alt="handlegraph::HandleGraph" shape="rect" coords="0,0,233,24"/>
<area href="classbdsg_1_1MutablePositionOverlay.html" alt="bdsg::MutablePositionOverlay" shape="rect" coords="121,224,354,248"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1b2e96bb9f6d0199f18d17f6527bd671"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a1b2e96bb9f6d0199f18d17f6527bd671">PositionOverlay</a> (<a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> *<a class="el" href="classbdsg_1_1PositionOverlay.html#a614fb959b379f57b0a554ecda0222e1c">graph</a>)</td></tr>
<tr class="separator:a1b2e96bb9f6d0199f18d17f6527bd671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6193ac0153345513185d4020be7c88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a3b6193ac0153345513185d4020be7c88">PositionOverlay</a> ()</td></tr>
<tr class="separator:a3b6193ac0153345513185d4020be7c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc549ed1e13cd44733c0e0702d378f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a4cc549ed1e13cd44733c0e0702d378f9">~PositionOverlay</a> ()</td></tr>
<tr class="separator:a4cc549ed1e13cd44733c0e0702d378f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9d92c9f7a0b13153169b2b8fc62a90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a6c9d92c9f7a0b13153169b2b8fc62a90">has_node</a> (<a class="el" href="namespacebdsg.html#ac3b5b3c8391e0b96f62c290d510b357f">nid_t</a> node_id) const</td></tr>
<tr class="memdesc:a6c9d92c9f7a0b13153169b2b8fc62a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to check if a node exists by ID.  <a href="#a6c9d92c9f7a0b13153169b2b8fc62a90">More...</a><br /></td></tr>
<tr class="separator:a6c9d92c9f7a0b13153169b2b8fc62a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f56167803b60ddde2ef37c22b5103d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a3f56167803b60ddde2ef37c22b5103d7">get_handle</a> (const <a class="el" href="namespacebdsg.html#ac3b5b3c8391e0b96f62c290d510b357f">nid_t</a> &amp;node_id, bool is_reverse=false) const</td></tr>
<tr class="memdesc:a3f56167803b60ddde2ef37c22b5103d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the handle for the node with the given ID in the given orientation.  <a href="#a3f56167803b60ddde2ef37c22b5103d7">More...</a><br /></td></tr>
<tr class="separator:a3f56167803b60ddde2ef37c22b5103d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d43b4dd0f3a322826712348f8a8952"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebdsg.html#ac3b5b3c8391e0b96f62c290d510b357f">nid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#ab3d43b4dd0f3a322826712348f8a8952">get_id</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:ab3d43b4dd0f3a322826712348f8a8952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID from a handle.  <a href="#ab3d43b4dd0f3a322826712348f8a8952">More...</a><br /></td></tr>
<tr class="separator:ab3d43b4dd0f3a322826712348f8a8952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1f26ec0956c20c640a2c3f77343f70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a5b1f26ec0956c20c640a2c3f77343f70">get_is_reverse</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:a5b1f26ec0956c20c640a2c3f77343f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the orientation of a handle.  <a href="#a5b1f26ec0956c20c640a2c3f77343f70">More...</a><br /></td></tr>
<tr class="separator:a5b1f26ec0956c20c640a2c3f77343f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd377626f62fbdf34f6a0f3b56889e2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#afd377626f62fbdf34f6a0f3b56889e2d">flip</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:afd377626f62fbdf34f6a0f3b56889e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the orientation of a handle (potentially without getting its ID)  <a href="#afd377626f62fbdf34f6a0f3b56889e2d">More...</a><br /></td></tr>
<tr class="separator:afd377626f62fbdf34f6a0f3b56889e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db81b812982ae391c6b29a396ca3b07"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a9db81b812982ae391c6b29a396ca3b07">get_length</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:a9db81b812982ae391c6b29a396ca3b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of a node.  <a href="#a9db81b812982ae391c6b29a396ca3b07">More...</a><br /></td></tr>
<tr class="separator:a9db81b812982ae391c6b29a396ca3b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc072c73f5fcbfd60c7875c2f84b097"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a9bc072c73f5fcbfd60c7875c2f84b097">get_sequence</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:a9bc072c73f5fcbfd60c7875c2f84b097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sequence of a node, presented in the handle's local forward orientation.  <a href="#a9bc072c73f5fcbfd60c7875c2f84b097">More...</a><br /></td></tr>
<tr class="separator:a9bc072c73f5fcbfd60c7875c2f84b097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2383afeee4a38f8cb26a96aca0f987fa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a2383afeee4a38f8cb26a96aca0f987fa">get_degree</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left) const</td></tr>
<tr class="separator:a2383afeee4a38f8cb26a96aca0f987fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad20bda3787c074ace323194ad1d3fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a1ad20bda3787c074ace323194ad1d3fb">has_edge</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right) const</td></tr>
<tr class="separator:a1ad20bda3787c074ace323194ad1d3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3180fba1cd5c058bc2017fe4af1c0fd8"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a3180fba1cd5c058bc2017fe4af1c0fd8">get_base</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, size_t index) const</td></tr>
<tr class="separator:a3180fba1cd5c058bc2017fe4af1c0fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21a77d918d666e3a02d27d76a2d954c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#ae21a77d918d666e3a02d27d76a2d954c">get_subsequence</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, size_t index, size_t size) const</td></tr>
<tr class="separator:ae21a77d918d666e3a02d27d76a2d954c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f6f241dd15b12c478e5bd7bdb85279"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#af9f6f241dd15b12c478e5bd7bdb85279">get_node_count</a> (void) const</td></tr>
<tr class="memdesc:af9f6f241dd15b12c478e5bd7bdb85279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of nodes in the graph.  <a href="#af9f6f241dd15b12c478e5bd7bdb85279">More...</a><br /></td></tr>
<tr class="separator:af9f6f241dd15b12c478e5bd7bdb85279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeacfba2b3c5be0c020dd22563046db8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebdsg.html#ac3b5b3c8391e0b96f62c290d510b357f">nid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#aeacfba2b3c5be0c020dd22563046db8b">min_node_id</a> (void) const</td></tr>
<tr class="separator:aeacfba2b3c5be0c020dd22563046db8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe7e022d34bef36677ae289b3c1ba6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebdsg.html#ac3b5b3c8391e0b96f62c290d510b357f">nid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a5fe7e022d34bef36677ae289b3c1ba6a">max_node_id</a> (void) const</td></tr>
<tr class="separator:a5fe7e022d34bef36677ae289b3c1ba6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd1d0f8d1911d3c678af5442109b61c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a8dd1d0f8d1911d3c678af5442109b61c">get_path_count</a> () const</td></tr>
<tr class="memdesc:a8dd1d0f8d1911d3c678af5442109b61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of paths stored in the graph.  <a href="#a8dd1d0f8d1911d3c678af5442109b61c">More...</a><br /></td></tr>
<tr class="separator:a8dd1d0f8d1911d3c678af5442109b61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696dae46c1949798ed5917dcdc29c584"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a696dae46c1949798ed5917dcdc29c584">has_path</a> (const std::string &amp;path_name) const</td></tr>
<tr class="memdesc:a696dae46c1949798ed5917dcdc29c584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a path name exists and is legal to get a path handle for.  <a href="#a696dae46c1949798ed5917dcdc29c584">More...</a><br /></td></tr>
<tr class="separator:a696dae46c1949798ed5917dcdc29c584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec54aac426696042fb55059f7760bc0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#aec54aac426696042fb55059f7760bc0a">get_path_handle</a> (const std::string &amp;path_name) const</td></tr>
<tr class="separator:aec54aac426696042fb55059f7760bc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96b72b39e341ef1a9df5302b486f9ee"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#ae96b72b39e341ef1a9df5302b486f9ee">get_path_name</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="memdesc:ae96b72b39e341ef1a9df5302b486f9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the name of a path from a handle to it.  <a href="#ae96b72b39e341ef1a9df5302b486f9ee">More...</a><br /></td></tr>
<tr class="separator:ae96b72b39e341ef1a9df5302b486f9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c564072164825ed95d1353a44a29c18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a5c564072164825ed95d1353a44a29c18">get_is_circular</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="memdesc:a5c564072164825ed95d1353a44a29c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up whether a path is circular.  <a href="#a5c564072164825ed95d1353a44a29c18">More...</a><br /></td></tr>
<tr class="separator:a5c564072164825ed95d1353a44a29c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cee56f8035ef1cdfbe5c6d32badc5c4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a4cee56f8035ef1cdfbe5c6d32badc5c4">get_step_count</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="memdesc:a4cee56f8035ef1cdfbe5c6d32badc5c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of node steps in the path.  <a href="#a4cee56f8035ef1cdfbe5c6d32badc5c4">More...</a><br /></td></tr>
<tr class="separator:a4cee56f8035ef1cdfbe5c6d32badc5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c6ac59abb93bfe7b6556699dc7eda9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a85c6ac59abb93bfe7b6556699dc7eda9">get_handle_of_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const</td></tr>
<tr class="memdesc:a85c6ac59abb93bfe7b6556699dc7eda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a node handle (node ID and orientation) from a handle to an step on a path.  <a href="#a85c6ac59abb93bfe7b6556699dc7eda9">More...</a><br /></td></tr>
<tr class="separator:a85c6ac59abb93bfe7b6556699dc7eda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a3418063234b617a9ae83616f688cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a50a3418063234b617a9ae83616f688cf">path_begin</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="separator:a50a3418063234b617a9ae83616f688cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e218aee55970b26f537ab3e85276b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#ac3e218aee55970b26f537ab3e85276b4">path_end</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="separator:ac3e218aee55970b26f537ab3e85276b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393743888658901dcf237491e2640f5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a393743888658901dcf237491e2640f5a">path_back</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="separator:a393743888658901dcf237491e2640f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59640ca46ff0328bd9a658e81fe01cbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a59640ca46ff0328bd9a658e81fe01cbb">path_front_end</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="separator:a59640ca46ff0328bd9a658e81fe01cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1dca5cddaa8c27a6329b02cfc22445"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#aff1dca5cddaa8c27a6329b02cfc22445">has_next_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const</td></tr>
<tr class="memdesc:aff1dca5cddaa8c27a6329b02cfc22445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the step is not the last step in a non-circular path.  <a href="#aff1dca5cddaa8c27a6329b02cfc22445">More...</a><br /></td></tr>
<tr class="separator:aff1dca5cddaa8c27a6329b02cfc22445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f9af3e2077be6222b6240e8b1e6e56"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a49f9af3e2077be6222b6240e8b1e6e56">has_previous_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const</td></tr>
<tr class="memdesc:a49f9af3e2077be6222b6240e8b1e6e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the step is not the first step in a non-circular path.  <a href="#a49f9af3e2077be6222b6240e8b1e6e56">More...</a><br /></td></tr>
<tr class="separator:a49f9af3e2077be6222b6240e8b1e6e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7b092855f4b5f58bf03b50edcbd24e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a8e7b092855f4b5f58bf03b50edcbd24e">get_next_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const</td></tr>
<tr class="separator:a8e7b092855f4b5f58bf03b50edcbd24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe0bd1797d2c09c6a09301e088f9762"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a2fe0bd1797d2c09c6a09301e088f9762">get_previous_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const</td></tr>
<tr class="separator:a2fe0bd1797d2c09c6a09301e088f9762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3827c7a731f24e1d05194203de392a34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a3827c7a731f24e1d05194203de392a34">get_path_handle_of_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const</td></tr>
<tr class="memdesc:a3827c7a731f24e1d05194203de392a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a handle to the path that an step is on.  <a href="#a3827c7a731f24e1d05194203de392a34">More...</a><br /></td></tr>
<tr class="separator:a3827c7a731f24e1d05194203de392a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a70c00c78db2abb392a6e1730b92702"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a7a70c00c78db2abb392a6e1730b92702">get_path_length</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="memdesc:a7a70c00c78db2abb392a6e1730b92702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of a path measured in bases of sequence.  <a href="#a7a70c00c78db2abb392a6e1730b92702">More...</a><br /></td></tr>
<tr class="separator:a7a70c00c78db2abb392a6e1730b92702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f588a816b1ded7ce5cb7b74a987121b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a4f588a816b1ded7ce5cb7b74a987121b">get_position_of_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step) const</td></tr>
<tr class="separator:a4f588a816b1ded7ce5cb7b74a987121b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c16622166f0c6a69354afa666905be9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a1c16622166f0c6a69354afa666905be9">get_step_at_position</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path, const size_t &amp;position) const</td></tr>
<tr class="separator:a1c16622166f0c6a69354afa666905be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ba209e962ff14e787bb53848487473"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a39ba209e962ff14e787bb53848487473">get_underlying_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="separator:a39ba209e962ff14e787bb53848487473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1PathPositionHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1PathPositionHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">handlegraph::PathPositionHandleGraph</a></td></tr>
<tr class="memitem:a2352c6463ffe0b4a279c05a223d8da24 inherit pub_methods_classhandlegraph_1_1PathPositionHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html#a2352c6463ffe0b4a279c05a223d8da24">~PathPositionHandleGraph</a> ()=default</td></tr>
<tr class="separator:a2352c6463ffe0b4a279c05a223d8da24 inherit pub_methods_classhandlegraph_1_1PathPositionHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c30215753a62ebaffcbeffe40009829 inherit pub_methods_classhandlegraph_1_1PathPositionHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html#a5c30215753a62ebaffcbeffe40009829">for_each_step_position_on_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;, const bool &amp;, const size_t &amp;)&gt; &amp;iteratee) const</td></tr>
<tr class="separator:a5c30215753a62ebaffcbeffe40009829 inherit pub_methods_classhandlegraph_1_1PathPositionHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1PathHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1PathHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">handlegraph::PathHandleGraph</a></td></tr>
<tr class="memitem:a49fe5658c5ef27e1d7aba69cd3d7159b inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a49fe5658c5ef27e1d7aba69cd3d7159b">~PathHandleGraph</a> ()=default</td></tr>
<tr class="separator:a49fe5658c5ef27e1d7aba69cd3d7159b inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f1d0595543d760322042770201297c inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:aa3f1d0595543d760322042770201297c inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#aa3f1d0595543d760322042770201297c">for_each_path_handle</a> (const Iteratee &amp;iteratee) const</td></tr>
<tr class="separator:aa3f1d0595543d760322042770201297c inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006a8e3ab9e2783ef7bf80b98b35959c inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a006a8e3ab9e2783ef7bf80b98b35959c inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a006a8e3ab9e2783ef7bf80b98b35959c">for_each_step_on_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const Iteratee &amp;iteratee) const</td></tr>
<tr class="separator:a006a8e3ab9e2783ef7bf80b98b35959c inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015b050f33861cbc8e2a0efaaf771a30 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a015b050f33861cbc8e2a0efaaf771a30">steps_of_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool match_orientation=false) const</td></tr>
<tr class="separator:a015b050f33861cbc8e2a0efaaf771a30 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3f2c04d1e315e485460dcd902467cb inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#aef3f2c04d1e315e485460dcd902467cb">is_empty</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="memdesc:aef3f2c04d1e315e485460dcd902467cb inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given path is empty, and false otherwise.  <a href="classhandlegraph_1_1PathHandleGraph.html#aef3f2c04d1e315e485460dcd902467cb">More...</a><br /></td></tr>
<tr class="separator:aef3f2c04d1e315e485460dcd902467cb inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa071f31a10a02d8231b029d0a7ddef0b inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhandlegraph_1_1PathForEachSocket.html">PathForEachSocket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#aa071f31a10a02d8231b029d0a7ddef0b">scan_path</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path) const</td></tr>
<tr class="separator:aa071f31a10a02d8231b029d0a7ddef0b inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184353db571dd2086d79e4e31f2f97f1 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a184353db571dd2086d79e4e31f2f97f1 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a184353db571dd2086d79e4e31f2f97f1">for_each_step_in_path</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path, const Iteratee &amp;iteratee) const</td></tr>
<tr class="separator:a184353db571dd2086d79e4e31f2f97f1 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1HandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1HandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1HandleGraph.html">handlegraph::HandleGraph</a></td></tr>
<tr class="memitem:a24fb796441c9ad8c870fdb716a82b305 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a24fb796441c9ad8c870fdb716a82b305">~HandleGraph</a> ()=default</td></tr>
<tr class="separator:a24fb796441c9ad8c870fdb716a82b305 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d21f30e62ad0b0c5919b2fe95e6f8aa inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a4d21f30e62ad0b0c5919b2fe95e6f8aa inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a4d21f30e62ad0b0c5919b2fe95e6f8aa">follow_edges</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left, const Iteratee &amp;iteratee) const</td></tr>
<tr class="separator:a4d21f30e62ad0b0c5919b2fe95e6f8aa inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928bdeabd328d357b538e30590164ab4 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a928bdeabd328d357b538e30590164ab4 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a928bdeabd328d357b538e30590164ab4">for_each_handle</a> (const Iteratee &amp;iteratee, bool parallel=false) const</td></tr>
<tr class="separator:a928bdeabd328d357b538e30590164ab4 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6171cdd6036c73623c96656f8b44fe9d inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a6171cdd6036c73623c96656f8b44fe9d">has_edge</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge) const</td></tr>
<tr class="memdesc:a6171cdd6036c73623c96656f8b44fe9d inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient wrapper of has_edge for edge_t argument.  <a href="classhandlegraph_1_1HandleGraph.html#a6171cdd6036c73623c96656f8b44fe9d">More...</a><br /></td></tr>
<tr class="separator:a6171cdd6036c73623c96656f8b44fe9d inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ff62014d7f0f0c01ada8a3d40a278d inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a20ff62014d7f0f0c01ada8a3d40a278d">get_edge_count</a> () const</td></tr>
<tr class="separator:a20ff62014d7f0f0c01ada8a3d40a278d inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c98da99e0d32ebcc9fd31be4b779e29 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a4c98da99e0d32ebcc9fd31be4b779e29">get_total_length</a> () const</td></tr>
<tr class="separator:a4c98da99e0d32ebcc9fd31be4b779e29 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e946bb4ed53f9423072955cdaab6386 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a9e946bb4ed53f9423072955cdaab6386">forward</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:a9e946bb4ed53f9423072955cdaab6386 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the locally forward version of a handle.  <a href="classhandlegraph_1_1HandleGraph.html#a9e946bb4ed53f9423072955cdaab6386">More...</a><br /></td></tr>
<tr class="separator:a9e946bb4ed53f9423072955cdaab6386 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3766f1aca1cbdbf827f2a12aaf2078ec inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a3766f1aca1cbdbf827f2a12aaf2078ec">edge_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right) const</td></tr>
<tr class="separator:a3766f1aca1cbdbf827f2a12aaf2078ec inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af167b0664299cfd4eac610f129fa5fee inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#af167b0664299cfd4eac610f129fa5fee">traverse_edge_handle</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left) const</td></tr>
<tr class="separator:af167b0664299cfd4eac610f129fa5fee inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61570ded026f825d62ea7608a1e92349 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a61570ded026f825d62ea7608a1e92349 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a61570ded026f825d62ea7608a1e92349">for_each_edge</a> (const Iteratee &amp;iteratee, bool parallel=false) const</td></tr>
<tr class="separator:a61570ded026f825d62ea7608a1e92349 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1ExpandingOverlayGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1ExpandingOverlayGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1ExpandingOverlayGraph.html">handlegraph::ExpandingOverlayGraph</a></td></tr>
<tr class="memitem:a9d7cac3cf3b289fe1980d0575e70be72 inherit pub_methods_classhandlegraph_1_1ExpandingOverlayGraph"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1ExpandingOverlayGraph.html#a9d7cac3cf3b289fe1980d0575e70be72">~ExpandingOverlayGraph</a> ()=default</td></tr>
<tr class="separator:a9d7cac3cf3b289fe1980d0575e70be72 inherit pub_methods_classhandlegraph_1_1ExpandingOverlayGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a222ef4b66d5a3ea8fc78f363b704a79d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a222ef4b66d5a3ea8fc78f363b704a79d">index_path_positions</a> ()</td></tr>
<tr class="memdesc:a222ef4b66d5a3ea8fc78f363b704a79d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the index over path positions.  <a href="#a222ef4b66d5a3ea8fc78f363b704a79d">More...</a><br /></td></tr>
<tr class="separator:a222ef4b66d5a3ea8fc78f363b704a79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfb3f2d813860c7e5b2cca6203a8a63"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a3bfb3f2d813860c7e5b2cca6203a8a63">get_graph</a> () const</td></tr>
<tr class="memdesc:a3bfb3f2d813860c7e5b2cca6203a8a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for graph.  <a href="#a3bfb3f2d813860c7e5b2cca6203a8a63">More...</a><br /></td></tr>
<tr class="separator:a3bfb3f2d813860c7e5b2cca6203a8a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classhandlegraph_1_1PathHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classhandlegraph_1_1PathHandleGraph')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">handlegraph::PathHandleGraph</a></td></tr>
<tr class="memitem:a2bbdf56b268001c629cf000f5bd8bb9a inherit pro_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a2bbdf56b268001c629cf000f5bd8bb9a">for_each_step_on_handle_impl</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;)&gt; &amp;iteratee) const =0</td></tr>
<tr class="separator:a2bbdf56b268001c629cf000f5bd8bb9a inherit pro_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a614fb959b379f57b0a554ecda0222e1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a614fb959b379f57b0a554ecda0222e1c">graph</a> = nullptr</td></tr>
<tr class="memdesc:a614fb959b379f57b0a554ecda0222e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The graph we're overlaying.  <a href="#a614fb959b379f57b0a554ecda0222e1c">More...</a><br /></td></tr>
<tr class="separator:a614fb959b379f57b0a554ecda0222e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31aecad86e93899a02e614935d5abfcc"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a31aecad86e93899a02e614935d5abfcc">min_path_offset</a></td></tr>
<tr class="separator:a31aecad86e93899a02e614935d5abfcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0271c53d7270afc3258ddb26013317f"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, map&lt; int64_t, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#aa0271c53d7270afc3258ddb26013317f">step_by_position</a></td></tr>
<tr class="memdesc:aa0271c53d7270afc3258ddb26013317f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of step by position.  <a href="#aa0271c53d7270afc3258ddb26013317f">More...</a><br /></td></tr>
<tr class="separator:aa0271c53d7270afc3258ddb26013317f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f767d5917baa329867d968bb159ae32"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a2f767d5917baa329867d968bb159ae32">offset_by_step</a></td></tr>
<tr class="memdesc:a2f767d5917baa329867d968bb159ae32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of position by step.  <a href="#a2f767d5917baa329867d968bb159ae32">More...</a><br /></td></tr>
<tr class="separator:a2f767d5917baa329867d968bb159ae32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a7f021e753ec9171003304f2d36a72ef3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a7f021e753ec9171003304f2d36a72ef3">follow_edges_impl</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;iteratee) const</td></tr>
<tr class="separator:a7f021e753ec9171003304f2d36a72ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c15f770b5c6e282f2b363f5ad080816"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a8c15f770b5c6e282f2b363f5ad080816">for_each_handle_impl</a> (const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;iteratee, bool parallel=false) const</td></tr>
<tr class="separator:a8c15f770b5c6e282f2b363f5ad080816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176fcb93ad5bb21e72dae72a252cb273"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a176fcb93ad5bb21e72dae72a252cb273">for_each_path_handle_impl</a> (const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; &amp;iteratee) const</td></tr>
<tr class="memdesc:a176fcb93ad5bb21e72dae72a252cb273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a function on each path in the graph.  <a href="#a176fcb93ad5bb21e72dae72a252cb273">More...</a><br /></td></tr>
<tr class="separator:a176fcb93ad5bb21e72dae72a252cb273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5820d785dc3b87a09fc3b841cf7d56"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PositionOverlay.html#a3c5820d785dc3b87a09fc3b841cf7d56">for_each_step_on_handle_impl</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const function&lt; bool(const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;)&gt; &amp;iteratee) const</td></tr>
<tr class="memdesc:a3c5820d785dc3b87a09fc3b841cf7d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the given function for each step of the given handle on a path.  <a href="#a3c5820d785dc3b87a09fc3b841cf7d56">More...</a><br /></td></tr>
<tr class="separator:a3c5820d785dc3b87a09fc3b841cf7d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1b2e96bb9f6d0199f18d17f6527bd671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2e96bb9f6d0199f18d17f6527bd671">&#9670;&nbsp;</a></span>PositionOverlay() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdsg::PositionOverlay::PositionOverlay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b6193ac0153345513185d4020be7c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6193ac0153345513185d4020be7c88">&#9670;&nbsp;</a></span>PositionOverlay() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdsg::PositionOverlay::PositionOverlay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4cc549ed1e13cd44733c0e0702d378f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc549ed1e13cd44733c0e0702d378f9">&#9670;&nbsp;</a></span>~PositionOverlay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdsg::PositionOverlay::~PositionOverlay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afd377626f62fbdf34f6a0f3b56889e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd377626f62fbdf34f6a0f3b56889e2d">&#9670;&nbsp;</a></span>flip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> bdsg::PositionOverlay::flip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invert the orientation of a handle (potentially without getting its ID) </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#aaa3f94ae7e884408ef6e8ca8fd45c7d7">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a7f021e753ec9171003304f2d36a72ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f021e753ec9171003304f2d36a72ef3">&#9670;&nbsp;</a></span>follow_edges_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::PositionOverlay::follow_edges_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>go_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loop over all the handles to next/previous (right/left) nodes. Passes them to a callback which returns false to stop iterating and true to continue. Returns true if we finished and false if we stopped early. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a89bbc118fe1e8e1acb162c14be33e8b5">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a8c15f770b5c6e282f2b363f5ad080816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c15f770b5c6e282f2b363f5ad080816">&#9670;&nbsp;</a></span>for_each_handle_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::PositionOverlay::for_each_handle_impl </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loop over all the nodes in the graph in their local forward orientations, in their internal stored order. Stop if the iteratee returns false. Can be told to run in parallel, in which case stopping after a false return value is on a best-effort basis and iteration order is not defined. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#af48ba081fcb810267dc50e3a3e7ad391">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a176fcb93ad5bb21e72dae72a252cb273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176fcb93ad5bb21e72dae72a252cb273">&#9670;&nbsp;</a></span>for_each_path_handle_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::PositionOverlay::for_each_path_handle_impl </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a function on each path in the graph. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a79f48793555f6be311f6df6603324e7b">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a3c5820d785dc3b87a09fc3b841cf7d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5820d785dc3b87a09fc3b841cf7d56">&#9670;&nbsp;</a></span>for_each_step_on_handle_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::PositionOverlay::for_each_step_on_handle_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls the given function for each step of the given handle on a path. </p>

</div>
</div>
<a id="a3180fba1cd5c058bc2017fe4af1c0fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3180fba1cd5c058bc2017fe4af1c0fd8">&#9670;&nbsp;</a></span>get_base()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char bdsg::PositionOverlay::get_base </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns one base of a handle's sequence, in the orientation of the handle. </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1HandleGraph.html#a64d58c3e26e9e7954dd25c3eff7af521">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a2383afeee4a38f8cb26a96aca0f987fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2383afeee4a38f8cb26a96aca0f987fa">&#9670;&nbsp;</a></span>get_degree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t bdsg::PositionOverlay::get_degree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>go_left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of edges on the right (go_left = false) or left (go_left = true) side of the given handle. The default implementation is O(n) in the number of edges returned, but graph implementations that track this information more efficiently can override this method. </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1HandleGraph.html#ab259e3aba0da47b0ef1c9b5e43c7d209">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a3bfb3f2d813860c7e5b2cca6203a8a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bfb3f2d813860c7e5b2cca6203a8a63">&#9670;&nbsp;</a></span>get_graph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a>* bdsg::PositionOverlay::get_graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for graph. </p>

</div>
</div>
<a id="a3f56167803b60ddde2ef37c22b5103d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f56167803b60ddde2ef37c22b5103d7">&#9670;&nbsp;</a></span>get_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> bdsg::PositionOverlay::get_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacebdsg.html#ac3b5b3c8391e0b96f62c290d510b357f">nid_t</a> &amp;&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up the handle for the node with the given ID in the given orientation. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a6dd9d70931835f5c75518b23a780b744">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a85c6ac59abb93bfe7b6556699dc7eda9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85c6ac59abb93bfe7b6556699dc7eda9">&#9670;&nbsp;</a></span>get_handle_of_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> bdsg::PositionOverlay::get_handle_of_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a node handle (node ID and orientation) from a handle to an step on a path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a339e690ce3e2bb8280dd1f3ea45abe42">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="ab3d43b4dd0f3a322826712348f8a8952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d43b4dd0f3a322826712348f8a8952">&#9670;&nbsp;</a></span>get_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebdsg.html#ac3b5b3c8391e0b96f62c290d510b357f">nid_t</a> bdsg::PositionOverlay::get_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ID from a handle. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#adb7f6e144bf2a59679f7b2eddad934eb">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a5c564072164825ed95d1353a44a29c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c564072164825ed95d1353a44a29c18">&#9670;&nbsp;</a></span>get_is_circular()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::PositionOverlay::get_is_circular </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up whether a path is circular. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a9391c34d9f0c16b21d5bb3bb7ec772e4">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a5b1f26ec0956c20c640a2c3f77343f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1f26ec0956c20c640a2c3f77343f70">&#9670;&nbsp;</a></span>get_is_reverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::PositionOverlay::get_is_reverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the orientation of a handle. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a92773f90eb58f18adb9418a4440223c1">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a9db81b812982ae391c6b29a396ca3b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db81b812982ae391c6b29a396ca3b07">&#9670;&nbsp;</a></span>get_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t bdsg::PositionOverlay::get_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of a node. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a569ff35fb85c725b0b6b6933ed303e49">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a8e7b092855f4b5f58bf03b50edcbd24e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7b092855f4b5f58bf03b50edcbd24e">&#9670;&nbsp;</a></span>get_next_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> bdsg::PositionOverlay::get_next_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a handle to the next step on the path. If the given step is the final step of a non-circular path, returns the past-the-last step that is also returned by path_end. In a circular path, the "last" step will loop around to the "first" (i.e. the one returned by path_begin). Note: to iterate over each step one time, even in a circular path, consider for_each_step_in_path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a209786f5c9e2c0210b383f2022ee221f">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="af9f6f241dd15b12c478e5bd7bdb85279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9f6f241dd15b12c478e5bd7bdb85279">&#9670;&nbsp;</a></span>get_node_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t bdsg::PositionOverlay::get_node_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of nodes in the graph. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a9f95108e6c3f68f404fa93bd3306e4c6">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a8dd1d0f8d1911d3c678af5442109b61c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd1d0f8d1911d3c678af5442109b61c">&#9670;&nbsp;</a></span>get_path_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t bdsg::PositionOverlay::get_path_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of paths stored in the graph. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#acd5df753593ecdfb7aa8c411b98ebad9">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="aec54aac426696042fb55059f7760bc0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec54aac426696042fb55059f7760bc0a">&#9670;&nbsp;</a></span>get_path_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> bdsg::PositionOverlay::get_path_handle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Look up the path handle for the given path name. The path with that name must exist. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a5d6059d716882a80e3982de17011866e">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a3827c7a731f24e1d05194203de392a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3827c7a731f24e1d05194203de392a34">&#9670;&nbsp;</a></span>get_path_handle_of_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> bdsg::PositionOverlay::get_path_handle_of_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a handle to the path that an step is on. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a1d1ca9865da585257709f54769f5d6a9">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a7a70c00c78db2abb392a6e1730b92702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a70c00c78db2abb392a6e1730b92702">&#9670;&nbsp;</a></span>get_path_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t bdsg::PositionOverlay::get_path_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of a path measured in bases of sequence. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html#ab71f007638c65db10efbe198f923413b">handlegraph::PathPositionHandleGraph</a>.</p>

</div>
</div>
<a id="ae96b72b39e341ef1a9df5302b486f9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae96b72b39e341ef1a9df5302b486f9ee">&#9670;&nbsp;</a></span>get_path_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string bdsg::PositionOverlay::get_path_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up the name of a path from a handle to it. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a565f4312a42dfe77ae14c1ee9ed9f2ba">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a4f588a816b1ded7ce5cb7b74a987121b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f588a816b1ded7ce5cb7b74a987121b">&#9670;&nbsp;</a></span>get_position_of_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t bdsg::PositionOverlay::get_position_of_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the position along the path of the beginning of this step measured in bases of sequence. In a circular path, positions start at the step returned by <a class="el" href="classbdsg_1_1PositionOverlay.html#a50a3418063234b617a9ae83616f688cf">path_begin()</a>. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html#a473d58ac35a06551e06ae7f5ad5073be">handlegraph::PathPositionHandleGraph</a>.</p>

</div>
</div>
<a id="a2fe0bd1797d2c09c6a09301e088f9762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe0bd1797d2c09c6a09301e088f9762">&#9670;&nbsp;</a></span>get_previous_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> bdsg::PositionOverlay::get_previous_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a handle to the previous step on the path. If the given step is the first step of a non-circular path, this method has undefined behavior. In a circular path, it will loop around from the "first" step (i.e. the one returned by path_begin) to the "last" step. Note: to iterate over each step one time, even in a circular path, consider for_each_step_in_path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a71040226b29aa5046f4cc04c8c9aa9fb">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a9bc072c73f5fcbfd60c7875c2f84b097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc072c73f5fcbfd60c7875c2f84b097">&#9670;&nbsp;</a></span>get_sequence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string bdsg::PositionOverlay::get_sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the sequence of a node, presented in the handle's local forward orientation. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a8cc2ab8a1292e30ba5e167a823f66d92">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a1c16622166f0c6a69354afa666905be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c16622166f0c6a69354afa666905be9">&#9670;&nbsp;</a></span>get_step_at_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> bdsg::PositionOverlay::get_step_at_position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the step at this position, measured in bases of sequence starting at the step returned by <a class="el" href="classbdsg_1_1PositionOverlay.html#a50a3418063234b617a9ae83616f688cf">path_begin()</a>. If the position is past the end of the path, returns <a class="el" href="classbdsg_1_1PositionOverlay.html#ac3e218aee55970b26f537ab3e85276b4">path_end()</a>. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html#aefbae4c3392c32ec13534a44bcc21136">handlegraph::PathPositionHandleGraph</a>.</p>

</div>
</div>
<a id="a4cee56f8035ef1cdfbe5c6d32badc5c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cee56f8035ef1cdfbe5c6d32badc5c4">&#9670;&nbsp;</a></span>get_step_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t bdsg::PositionOverlay::get_step_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of node steps in the path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#add91075c3490f8dc5acf667f2b26832c">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="ae21a77d918d666e3a02d27d76a2d954c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21a77d918d666e3a02d27d76a2d954c">&#9670;&nbsp;</a></span>get_subsequence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string bdsg::PositionOverlay::get_subsequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a substring of a handle's sequence, in the orientation of the handle. If the indicated substring would extend beyond the end of the handle's sequence, the return value is truncated to the sequence's end. </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1HandleGraph.html#a74c6fcda357516b1160996c63ed40d63">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a39ba209e962ff14e787bb53848487473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ba209e962ff14e787bb53848487473">&#9670;&nbsp;</a></span>get_underlying_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> bdsg::PositionOverlay::get_underlying_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the handle in the underlying graph that corresponds to a handle in the overlay </p>

<p>Implements <a class="el" href="classhandlegraph_1_1ExpandingOverlayGraph.html#aacfa30b0166f91f1aa80f0fd566d2b65">handlegraph::ExpandingOverlayGraph</a>.</p>

</div>
</div>
<a id="a1ad20bda3787c074ace323194ad1d3fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad20bda3787c074ace323194ad1d3fb">&#9670;&nbsp;</a></span>has_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::PositionOverlay::has_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if there is an edge that allows traversal from the left handle to the right handle. By default O(n) in the number of edges on left, but can be overridden with more efficient implementations. </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1HandleGraph.html#a069448fbe58665b9ff531ad0b8c5af57">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="aff1dca5cddaa8c27a6329b02cfc22445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff1dca5cddaa8c27a6329b02cfc22445">&#9670;&nbsp;</a></span>has_next_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::PositionOverlay::has_next_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the step is not the last step in a non-circular path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a81bf54cb4d07a0d47c84862ecebc349d">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a6c9d92c9f7a0b13153169b2b8fc62a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9d92c9f7a0b13153169b2b8fc62a90">&#9670;&nbsp;</a></span>has_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::PositionOverlay::has_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebdsg.html#ac3b5b3c8391e0b96f62c290d510b357f">nid_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to check if a node exists by ID. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a6e58a79001cd7d839ac1f1adaff34dfb">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a696dae46c1949798ed5917dcdc29c584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a696dae46c1949798ed5917dcdc29c584">&#9670;&nbsp;</a></span>has_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::PositionOverlay::has_path </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if a path name exists and is legal to get a path handle for. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#ab7de11c1e994bc104378c4b798013430">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a49f9af3e2077be6222b6240e8b1e6e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f9af3e2077be6222b6240e8b1e6e56">&#9670;&nbsp;</a></span>has_previous_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::PositionOverlay::has_previous_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the step is not the first step in a non-circular path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a93a1ee451e750cb82f1711fd6c3db8cc">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a222ef4b66d5a3ea8fc78f363b704a79d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a222ef4b66d5a3ea8fc78f363b704a79d">&#9670;&nbsp;</a></span>index_path_positions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::PositionOverlay::index_path_positions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the index over path positions. </p>

</div>
</div>
<a id="a5fe7e022d34bef36677ae289b3c1ba6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fe7e022d34bef36677ae289b3c1ba6a">&#9670;&nbsp;</a></span>max_node_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebdsg.html#ac3b5b3c8391e0b96f62c290d510b357f">nid_t</a> bdsg::PositionOverlay::max_node_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the largest ID in the graph, or some larger number if the largest ID is unavailable. Return value is unspecified if the graph is empty. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a5a2e2b1ea6a29b3f4b34a6abcb6dbc50">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="aeacfba2b3c5be0c020dd22563046db8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeacfba2b3c5be0c020dd22563046db8b">&#9670;&nbsp;</a></span>min_node_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebdsg.html#ac3b5b3c8391e0b96f62c290d510b357f">nid_t</a> bdsg::PositionOverlay::min_node_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the smallest ID in the graph, or some smaller number if the smallest ID is unavailable. Return value is unspecified if the graph is empty. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a85c52fe4b5f483504ed142d0ad94a969">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a393743888658901dcf237491e2640f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393743888658901dcf237491e2640f5a">&#9670;&nbsp;</a></span>path_back()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> bdsg::PositionOverlay::path_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a handle to the last step, which will be an arbitrary step in a circular path that we consider "last" based on our construction of the path. If the path is empty then the implementation must return the same value as <a class="el" href="classbdsg_1_1PositionOverlay.html#a59640ca46ff0328bd9a658e81fe01cbb">path_front_end()</a>. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a31bb33a87ad8efd68876fc5ae1deeb09">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a50a3418063234b617a9ae83616f688cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a3418063234b617a9ae83616f688cf">&#9670;&nbsp;</a></span>path_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> bdsg::PositionOverlay::path_begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a handle to the first step, or in a circular path to an arbitrary step considered "first". If the path is empty, returns the past-the-last step returned by path_end. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a815759484087ed92214c2c1c6b9d1a11">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="ac3e218aee55970b26f537ab3e85276b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e218aee55970b26f537ab3e85276b4">&#9670;&nbsp;</a></span>path_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> bdsg::PositionOverlay::path_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a handle to a fictitious position past the end of a path. This position is return by get_next_step for the final step in a path in a non-circular path. Note that get_next_step will <em>NEVER</em> return this value for a circular path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a5c3a5e04838d9e4a0a0ddf574c4de827">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a59640ca46ff0328bd9a658e81fe01cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59640ca46ff0328bd9a658e81fe01cbb">&#9670;&nbsp;</a></span>path_front_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> bdsg::PositionOverlay::path_front_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a handle to a fictitious position before the beginning of a path. This position is return by get_previous_step for the first step in a path in a non-circular path. Note: get_previous_step will <em>NEVER</em> return this value for a circular path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#ad7412bf19084f2b38ffec42517a6a9e9">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a614fb959b379f57b0a554ecda0222e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614fb959b379f57b0a554ecda0222e1c">&#9670;&nbsp;</a></span>graph</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a>* bdsg::PositionOverlay::graph = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The graph we're overlaying. </p>

</div>
</div>
<a id="a31aecad86e93899a02e614935d5abfcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31aecad86e93899a02e614935d5abfcc">&#9670;&nbsp;</a></span>min_path_offset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt;<a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, int64_t&gt; bdsg::PositionOverlay::min_path_offset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The "zero-point" of the offsets TODO: really only needed for the mutable inheritor </p>

</div>
</div>
<a id="a2f767d5917baa329867d968bb159ae32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f767d5917baa329867d968bb159ae32">&#9670;&nbsp;</a></span>offset_by_step</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt;<a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, int64_t&gt; bdsg::PositionOverlay::offset_by_step</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index of position by step. </p>

</div>
</div>
<a id="aa0271c53d7270afc3258ddb26013317f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0271c53d7270afc3258ddb26013317f">&#9670;&nbsp;</a></span>step_by_position</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt;<a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, map&lt;int64_t, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&gt; &gt; bdsg::PositionOverlay::step_by_position</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index of step by position. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>deps/libbdsg/include/bdsg/<a class="el" href="path__position__overlays_8hpp.html">path_position_overlays.hpp</a></li>
<li>deps/libbdsg/src/<a class="el" href="path__position__overlays_8cpp.html">path_position_overlays.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
