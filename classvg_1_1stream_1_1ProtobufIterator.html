<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>vg: vg::stream::ProtobufIterator&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="namespacevg_1_1stream.html">stream</a></li><li class="navelem"><a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">ProtobufIterator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classvg_1_1stream_1_1ProtobufIterator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::stream::ProtobufIterator&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;stream.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae3059225b6ff4b2c2745f357daf985e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html#ae3059225b6ff4b2c2745f357daf985e6">ProtobufIterator</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:ae3059225b6ff4b2c2745f357daf985e6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classvg_1_1Constructor.html">Constructor</a>.  <a href="#ae3059225b6ff4b2c2745f357daf985e6">More...</a><br/></td></tr>
<tr class="separator:ae3059225b6ff4b2c2745f357daf985e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a9f194bc8706318d858b86e8e57d54"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html#af3a9f194bc8706318d858b86e8e57d54">has_next</a> () const </td></tr>
<tr class="memdesc:af3a9f194bc8706318d858b86e8e57d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if dereferencing the iterator will produce a valid value, and false otherwise.  <a href="#af3a9f194bc8706318d858b86e8e57d54">More...</a><br/></td></tr>
<tr class="separator:af3a9f194bc8706318d858b86e8e57d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58032bf7418aaeea21c5cdb95214a116"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html#a58032bf7418aaeea21c5cdb95214a116">get_next</a> ()</td></tr>
<tr class="memdesc:a58032bf7418aaeea21c5cdb95214a116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the iterator to the next message, or the end if this was the last message.  <a href="#a58032bf7418aaeea21c5cdb95214a116">More...</a><br/></td></tr>
<tr class="separator:a58032bf7418aaeea21c5cdb95214a116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343abcf4b771779d505b94a85220dacd"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html#a343abcf4b771779d505b94a85220dacd">operator*</a> () const </td></tr>
<tr class="separator:a343abcf4b771779d505b94a85220dacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4897ff0f2a079e95cc0616df9ae993f3"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html#a4897ff0f2a079e95cc0616df9ae993f3">take</a> ()</td></tr>
<tr class="memdesc:a4897ff0f2a079e95cc0616df9ae993f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the current item, which must exist, and advance the iterator to the next one.  <a href="#a4897ff0f2a079e95cc0616df9ae993f3">More...</a><br/></td></tr>
<tr class="separator:a4897ff0f2a079e95cc0616df9ae993f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826fe0cf95386b65d84ee83c86d98130"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html#a826fe0cf95386b65d84ee83c86d98130">get_item_size</a> () const </td></tr>
<tr class="separator:a826fe0cf95386b65d84ee83c86d98130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa92aed30e3e73510023d7d9c8a8c43"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html#a5fa92aed30e3e73510023d7d9c8a8c43">tell_group</a> () const </td></tr>
<tr class="separator:a5fa92aed30e3e73510023d7d9c8a8c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea008e65851bfa77b627e70418cc606"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html#a7ea008e65851bfa77b627e70418cc606">seek_group</a> (int64_t virtual_offset)</td></tr>
<tr class="separator:a7ea008e65851bfa77b627e70418cc606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ee9b52645c5f9a30dcaf3d2a0762b5"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html#aa1ee9b52645c5f9a30dcaf3d2a0762b5">tell_raw</a> () const </td></tr>
<tr class="separator:aa1ee9b52645c5f9a30dcaf3d2a0762b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6eadec7fc9fa3eec10de230ef2711d0"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html#ac6eadec7fc9fa3eec10de230ef2711d0">tell_item</a> () const </td></tr>
<tr class="separator:ac6eadec7fc9fa3eec10de230ef2711d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75acce13571d7ecd9e89c83a595741f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html#a75acce13571d7ecd9e89c83a595741f9">seek_item_and_stop</a> (int64_t virtual_offset)</td></tr>
<tr class="separator:a75acce13571d7ecd9e89c83a595741f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6699759db236dbb71d604fc4c922012e"><td class="memItemLeft" align="right" valign="top">static std::pair<br class="typebreak"/>
&lt; <a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">ProtobufIterator</a>&lt; T &gt;<br class="typebreak"/>
, <a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">ProtobufIterator</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html#a6699759db236dbb71d604fc4c922012e">range</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:a6699759db236dbb71d604fc4c922012e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns iterators that act like begin() and end() for a stream containing protobuf data.  <a href="#a6699759db236dbb71d604fc4c922012e">More...</a><br/></td></tr>
<tr class="separator:a6699759db236dbb71d604fc4c922012e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ab9cd76e9021808940b2f6789f13ac640"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html#ab9cd76e9021808940b2f6789f13ac640">handle</a> (bool ok)</td></tr>
<tr class="separator:ab9cd76e9021808940b2f6789f13ac640"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a605905cafe2dea49a2995647d6e7196c"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html#a605905cafe2dea49a2995647d6e7196c">value</a></td></tr>
<tr class="separator:a605905cafe2dea49a2995647d6e7196c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a52b48875dc138609f5a16c49a1165a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html#a9a52b48875dc138609f5a16c49a1165a">group_count</a></td></tr>
<tr class="separator:a9a52b48875dc138609f5a16c49a1165a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8251ad8904a0fe67cac48bcbd70c97b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html#ab8251ad8904a0fe67cac48bcbd70c97b">group_idx</a></td></tr>
<tr class="separator:ab8251ad8904a0fe67cac48bcbd70c97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63bf484824efdc96a68c1e2baa6b0c5"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html#af63bf484824efdc96a68c1e2baa6b0c5">group_vo</a></td></tr>
<tr class="separator:af63bf484824efdc96a68c1e2baa6b0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0549ac199aa9111f05f562f4ce67673"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html#ab0549ac199aa9111f05f562f4ce67673">item_vo</a></td></tr>
<tr class="separator:ab0549ac199aa9111f05f562f4ce67673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13abfbcf453c4eb5aa09e868e64f9f33"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html#a13abfbcf453c4eb5aa09e868e64f9f33">item_bytes</a></td></tr>
<tr class="separator:a13abfbcf453c4eb5aa09e868e64f9f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f9b63ff7a280a14e539734d6b8218e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html#a23f9b63ff7a280a14e539734d6b8218e">end_next</a></td></tr>
<tr class="separator:a23f9b63ff7a280a14e539734d6b8218e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85fad60d3d60c28fe13bb468f74e6b22"><td class="memItemLeft" align="right" valign="top">unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classvg_1_1stream_1_1BlockedGzipInputStream.html">BlockedGzipInputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html#a85fad60d3d60c28fe13bb468f74e6b22">bgzip_in</a></td></tr>
<tr class="separator:a85fad60d3d60c28fe13bb468f74e6b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br/>
class vg::stream::ProtobufIterator&lt; T &gt;</h3>

<p>Refactored <a class="el" href="namespacevg_1_1stream.html#a300c797fd37e9fe51c1099be75637c8e">stream::for_each</a> function that follows the unidirectional iterator interface. Also supports seeking and telling at the group level in bgzip files. Cannot be copied, but can be moved. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae3059225b6ff4b2c2745f357daf985e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">vg::stream::ProtobufIterator</a>&lt; T &gt;::<a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">ProtobufIterator</a> </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classvg_1_1Constructor.html">Constructor</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a826fe0cf95386b65d84ee83c86d98130"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">vg::stream::ProtobufIterator</a>&lt; T &gt;::get_item_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>How many serialized, uncompressed bytes did the currently loaded item take. Will be 0 if no current item is available, but can also be 0 for valid, all-default items. </p>

</div>
</div>
<a class="anchor" id="a58032bf7418aaeea21c5cdb95214a116"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">vg::stream::ProtobufIterator</a>&lt; T &gt;::get_next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advance the iterator to the next message, or the end if this was the last message. </p>

</div>
</div>
<a class="anchor" id="ab9cd76e9021808940b2f6789f13ac640"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">vg::stream::ProtobufIterator</a>&lt; T &gt;::handle </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ok</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af3a9f194bc8706318d858b86e8e57d54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">vg::stream::ProtobufIterator</a>&lt; T &gt;::has_next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if dereferencing the iterator will produce a valid value, and false otherwise. </p>

</div>
</div>
<a class="anchor" id="a343abcf4b771779d505b94a85220dacd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">vg::stream::ProtobufIterator</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6699759db236dbb71d604fc4c922012e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::pair&lt;<a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">ProtobufIterator</a>&lt;T&gt;, <a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">ProtobufIterator</a>&lt;T&gt; &gt; <a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">vg::stream::ProtobufIterator</a>&lt; T &gt;::range </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns iterators that act like begin() and end() for a stream containing protobuf data. </p>

</div>
</div>
<a class="anchor" id="a7ea008e65851bfa77b627e70418cc606"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">vg::stream::ProtobufIterator</a>&lt; T &gt;::seek_group </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>virtual_offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Seek to the given virtual offset and start reading the group that is there. The next value produced will be the first value in that group. Return false if seeking is unsupported or the seek fails. </p>

</div>
</div>
<a class="anchor" id="a75acce13571d7ecd9e89c83a595741f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">vg::stream::ProtobufIterator</a>&lt; T &gt;::seek_item_and_stop </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>virtual_offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Seek to the given virtual offset and read a single item from there. The next value produced will be the item that is there, and then the iterator will end (unless the user seeks somewhere else). Return false if seeking is unsupported or the seek fails. Will not work right if EOF is sought. </p>

</div>
</div>
<a class="anchor" id="a4897ff0f2a079e95cc0616df9ae993f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">vg::stream::ProtobufIterator</a>&lt; T &gt;::take </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take the current item, which must exist, and advance the iterator to the next one. </p>

</div>
</div>
<a class="anchor" id="a5fa92aed30e3e73510023d7d9c8a8c43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t <a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">vg::stream::ProtobufIterator</a>&lt; T &gt;::tell_group </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the virtual offset of the group being currently read (i.e. the group to which the current message belongs), to seek back to. You can't seek back to the current message, just to the start of the group. Returns -1 instead if the underlying file doesn't support seek/tell. Returns the past-the-end virtual offset of the file if EOF is reached. </p>

</div>
</div>
<a class="anchor" id="ac6eadec7fc9fa3eec10de230ef2711d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t <a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">vg::stream::ProtobufIterator</a>&lt; T &gt;::tell_item </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the virtual offset of the currently loaded item, or <a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html#aa1ee9b52645c5f9a30dcaf3d2a0762b5">tell_raw()</a> if at end. Returns -1 for an unseekable/untellable stream. </p>

</div>
</div>
<a class="anchor" id="aa1ee9b52645c5f9a30dcaf3d2a0762b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t <a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">vg::stream::ProtobufIterator</a>&lt; T &gt;::tell_raw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the raw virtual offset that the cursor is at in the file, or -1 for an unseekable/untellable stream. Not necessarily at a group boundary, so cannot be used for seeking. Useful for getting the final virtual offset when the cursor hits the end of a file. This is NOT the virtual offset at which the currently loaded item occurs! </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a85fad60d3d60c28fe13bb468f74e6b22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt;<a class="el" href="classvg_1_1stream_1_1BlockedGzipInputStream.html">BlockedGzipInputStream</a>&gt; <a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">vg::stream::ProtobufIterator</a>&lt; T &gt;::bgzip_in</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a23f9b63ff7a280a14e539734d6b8218e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">vg::stream::ProtobufIterator</a>&lt; T &gt;::end_next</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9a52b48875dc138609f5a16c49a1165a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">vg::stream::ProtobufIterator</a>&lt; T &gt;::group_count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab8251ad8904a0fe67cac48bcbd70c97b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">vg::stream::ProtobufIterator</a>&lt; T &gt;::group_idx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af63bf484824efdc96a68c1e2baa6b0c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t <a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">vg::stream::ProtobufIterator</a>&lt; T &gt;::group_vo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a13abfbcf453c4eb5aa09e868e64f9f33"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">vg::stream::ProtobufIterator</a>&lt; T &gt;::item_bytes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab0549ac199aa9111f05f562f4ce67673"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t <a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">vg::stream::ProtobufIterator</a>&lt; T &gt;::item_vo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a605905cafe2dea49a2995647d6e7196c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classvg_1_1stream_1_1ProtobufIterator.html">vg::stream::ProtobufIterator</a>&lt; T &gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="stream_8hpp.html">stream.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Sep 28 2018 16:39:40 for vg by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
